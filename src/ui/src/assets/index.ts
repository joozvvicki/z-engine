export const GAME_DEFS = "\n\ndeclare namespace PIXI {\n\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n */\nexport class EventEmitter<EventTypes extends EventEmitter.ValidEventTypes = string | symbol, Context extends any = any> {\n\tstatic prefixed: string | boolean;\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t */\n\teventNames(): Array<EventEmitter.EventNames<EventTypes>>;\n\t/**\n\t * Return the listeners registered for a given event.\n\t */\n\tlisteners<T extends EventEmitter.EventNames<EventTypes>>(event: T): Array<EventEmitter.EventListener<EventTypes, T>>;\n\t/**\n\t * Return the number of listeners listening to a given event.\n\t */\n\tlistenerCount(event: EventEmitter.EventNames<EventTypes>): number;\n\t/**\n\t * Calls each of the listeners registered for a given event.\n\t */\n\temit<T extends EventEmitter.EventNames<EventTypes>>(event: T, ...args: EventEmitter.EventArgs<EventTypes, T>): boolean;\n\t/**\n\t * Add a listener for a given event.\n\t */\n\ton<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;\n\taddListener<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;\n\t/**\n\t * Add a one-time listener for a given event.\n\t */\n\tonce<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;\n\t/**\n\t * Remove the listeners of a given event.\n\t */\n\tremoveListener<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn?: EventEmitter.EventListener<EventTypes, T>, context?: Context, once?: boolean): this;\n\toff<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn?: EventEmitter.EventListener<EventTypes, T>, context?: Context, once?: boolean): this;\n\t/**\n\t * Remove all listeners, or those of the specified event.\n\t */\n\tremoveAllListeners(event?: EventEmitter.EventNames<EventTypes>): this;\n}\nexport namespace EventEmitter {\n\texport interface ListenerFn<Args extends any[] = any[]> {\n\t\t(...args: Args): void;\n\t}\n\texport interface EventEmitterStatic {\n\t\tnew <EventTypes extends ValidEventTypes = string | symbol, Context = any>(): EventEmitter<EventTypes, Context>;\n\t}\n\t/**\n\t * `object` should be in either of the following forms:\n\t * ```\n\t * interface EventTypes {\n\t *   'event-with-parameters': any[]\n\t *   'event-with-example-handler': (...args: any[]) => void\n\t * }\n\t * ```\n\t */\n\texport type ValidEventTypes = string | symbol | object;\n\texport type EventNames<T extends ValidEventTypes> = T extends string | symbol ? T : keyof T;\n\texport type ArgumentMap<T extends object> = {\n\t\t[K in keyof T]: T[K] extends (...args: any[]) => void ? Parameters<T[K]> : T[K] extends any[] ? T[K] : any[];\n\t};\n\texport type EventListener<T extends ValidEventTypes, K extends EventNames<T>> = T extends string | symbol ? (...args: any[]) => void : (...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K, keyof T>]) => void;\n\texport type EventArgs<T extends ValidEventTypes, K extends EventNames<T>> = Parameters<EventListener<T, K>>;\n\texport const EventEmitter: EventEmitterStatic;\n}\ndeclare type RgbColor = {\n\tr: number;\n\tg: number;\n\tb: number;\n};\ndeclare type HslColor = {\n\th: number;\n\ts: number;\n\tl: number;\n};\ndeclare type HsvColor = {\n\th: number;\n\ts: number;\n\tv: number;\n};\ndeclare type WithAlpha<O> = O & {\n\ta: number;\n};\ndeclare type RgbaColor = WithAlpha<RgbColor>;\ndeclare type HslaColor = WithAlpha<HslColor>;\ndeclare type HsvaColor = WithAlpha<HsvColor>;\n/**\n * Array of RGBA color components, where each component is a number between 0 and 1.\n * The array must contain exactly 4 numbers in the order: red, green, blue, alpha.\n * @example\n * ```ts\n * // Full white (opaque)\n * const white: RgbaArray = [1, 1, 1, 1];\n *\n * // Semi-transparent red\n * const transparentRed: RgbaArray = [1, 0, 0, 0.5];\n * ```\n * @remarks\n * - All components must be between 0 and 1\n * - Array must contain exactly 4 values\n * - Order is [red, green, blue, alpha]\n * @see {@link Color} For the main color utility class\n * @category color\n * @standard\n */\nexport type RgbaArray = [\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber\n];\n/**\n * Valid color formats supported by PixiJS. These types extend from [colord](https://www.npmjs.com/package/colord)\n * with additional PixiJS-specific formats.\n *\n * Common Formats:\n * ```ts\n * // CSS Color Names\n * new Color('red');\n * new Color('blue');\n * new Color('green');\n *\n * // Hex Values\n * new Color(0xff0000);     // RGB integer\n * new Color('#ff0000');    // 6-digit hex\n * new Color('#f00');       // 3-digit hex\n * new Color('#ff0000ff');  // 8-digit hex (with alpha)\n * new Color('#f00f');      // 4-digit hex (with alpha)\n *\n * // RGB/RGBA Objects\n * new Color({ r: 255, g: 0, b: 0 });\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 });\n *\n * // RGB/RGBA Strings\n * new Color('rgb(255, 0, 0)');\n * new Color('rgba(255, 0, 0, 0.5)');\n * new Color('rgb(100% 0% 0%)');\n * new Color('rgba(100% 0% 0% / 50%)');\n *\n * // Arrays (normalized 0-1)\n * new Color([1, 0, 0]);           // RGB\n * new Color([1, 0, 0, 0.5]);      // RGBA\n * new Color(new Float32Array([1, 0, 0, 0.5]));\n *\n * // Arrays (0-255)\n * new Color(new Uint8Array([255, 0, 0]));\n * new Color(new Uint8ClampedArray([255, 0, 0, 128]));\n *\n * // HSL/HSLA\n * new Color({ h: 0, s: 100, l: 50 });\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 });\n * new Color('hsl(0, 100%, 50%)');\n * new Color('hsla(0deg 100% 50% / 50%)');\n *\n * // HSV/HSVA\n * new Color({ h: 0, s: 100, v: 100 });\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 });\n * ```\n * @remarks\n * - All color values are normalized internally to 0-1 range\n * - Alpha is always between 0-1\n * - Invalid colors will throw an error\n * - Original format is preserved when possible\n * @see {@link Color} For the main color utility class\n * @see {@link https://www.w3.org/TR/css-color-4} CSS Color Level 4 Specification\n * @since 7.2.0\n * @category color\n * @standard\n */\nexport type ColorSource = string | number | number[] | Float32Array | Uint8Array | Uint8ClampedArray | HslColor | HslaColor | HsvColor | HsvaColor | RgbColor | RgbaColor | Color | number;\n/**\n * Color utility class for managing colors in various formats. Provides a unified way to work\n * with colors across your PixiJS application.\n *\n * Features:\n * - Accepts multiple color formats (hex, RGB, HSL, etc.)\n * - Automatic format conversion\n * - Color manipulation methods\n * - Component access (r,g,b,a)\n * - Chainable operations\n * @example\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n *\n * // Convert between formats\n * const color = new Color('red');\n * color.toHex();        // \"#ff0000\"\n * color.toRgbString();  // \"rgb(255,0,0,1)\"\n * color.toNumber();     // 0xff0000\n *\n * // Access components\n * color.red;    // 1\n * color.green;  // 0\n * color.blue;   // 0\n * color.alpha;  // 1\n *\n * // Chain operations\n * color\n *   .setAlpha(0.5)\n *   .multiply([0.5, 0.5, 0.5])\n *   .premultiply(0.8);\n * ```\n * @remarks\n * The Color class automatically normalizes all color values internally:\n * - RGB components are stored as floats between 0-1\n * - Alpha is always between 0-1\n * - Color operations clamp values to valid ranges\n * - Original input format is preserved when possible\n * @since 7.2.0\n * @category color\n * @standard\n */\nexport class Color {\n\t/**\n\t * Static shared Color instance used for utility operations. This is a singleton color object\n\t * that can be reused to avoid creating unnecessary Color instances.\n\t * > [!IMPORTANT] You should be careful when using this shared instance, as it is mutable and can be\n\t * > changed by any code that uses it.\n\t * >\n\t * > It is best used for one-off color operations or temporary transformations.\n\t * > For persistent colors, create your own Color instance instead.\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Use shared instance for one-off color operations\n\t * Color.shared.setValue(0xff0000);\n\t * const redHex = Color.shared.toHex();     // \"#ff0000\"\n\t * const redRgb = Color.shared.toRgbArray(); // [1, 0, 0]\n\t *\n\t * // Temporary color transformations\n\t * const colorNumber = Color.shared\n\t *     .setValue('#ff0000')     // Set to red\n\t *     .setAlpha(0.5)          // Make semi-transparent\n\t *     .premultiply(0.8)       // Apply premultiplication\n\t *     .toNumber();            // Convert to number\n\t *\n\t * // Chain multiple operations\n\t * const result = Color.shared\n\t *     .setValue(someColor)\n\t *     .multiply(tintColor)\n\t *     .toPremultiplied(alpha);\n\t * ```\n\t * @remarks\n\t * - This is a shared instance - be careful about multiple code paths using it simultaneously\n\t * - Use for temporary color operations to avoid allocating new Color instances\n\t * - The value is preserved between operations, so reset if needed\n\t * - For persistent colors, create your own Color instance instead\n\t */\n\tstatic readonly shared: Color;\n\t/**\n\t * Temporary Color object for static uses internally.\n\t * As to not conflict with Color.shared.\n\t * @ignore\n\t */\n\tprivate static readonly _temp;\n\t/** Pattern for hex strings */\n\tprivate static readonly HEX_PATTERN;\n\t/** Internal color source, from constructor or set value */\n\tprivate _value;\n\t/** Normalized rgba component, floats from 0-1 */\n\tprivate _components;\n\t/** Cache color as number */\n\tprivate _int;\n\t/** An array of the current Color. Only populated when `toArray` functions are called */\n\tprivate _arrayRgba;\n\tprivate _arrayRgb;\n\t/**\n\t * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n\t */\n\tconstructor(value?: ColorSource);\n\t/**\n\t * Get the red component of the color, normalized between 0 and 1.\n\t * @example\n\t * ```ts\n\t * const color = new Color('red');\n\t * console.log(color.red); // 1\n\t *\n\t * const green = new Color('#00ff00');\n\t * console.log(green.red); // 0\n\t * ```\n\t */\n\tget red(): number;\n\t/**\n\t * Get the green component of the color, normalized between 0 and 1.\n\t * @example\n\t * ```ts\n\t * const color = new Color('lime');\n\t * console.log(color.green); // 1\n\t *\n\t * const red = new Color('#ff0000');\n\t * console.log(red.green); // 0\n\t * ```\n\t */\n\tget green(): number;\n\t/**\n\t * Get the blue component of the color, normalized between 0 and 1.\n\t * @example\n\t * ```ts\n\t * const color = new Color('blue');\n\t * console.log(color.blue); // 1\n\t *\n\t * const yellow = new Color('#ffff00');\n\t * console.log(yellow.blue); // 0\n\t * ```\n\t */\n\tget blue(): number;\n\t/**\n\t * Get the alpha component of the color, normalized between 0 and 1.\n\t * @example\n\t * ```ts\n\t * const color = new Color('red');\n\t * console.log(color.alpha); // 1 (fully opaque)\n\t *\n\t * const transparent = new Color('rgba(255, 0, 0, 0.5)');\n\t * console.log(transparent.alpha); // 0.5 (semi-transparent)\n\t * ```\n\t */\n\tget alpha(): number;\n\t/**\n\t * Sets the color value and returns the instance for chaining.\n\t *\n\t * This is a chainable version of setting the `value` property.\n\t * @param value - The color to set. Accepts various formats:\n\t * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n\t * - RGB/RGBA values (arrays, objects)\n\t * - CSS color names\n\t * - HSL/HSLA values\n\t * - HSV/HSVA values\n\t * @returns The Color instance for chaining\n\t * @example\n\t * ```ts\n\t * // Basic usage\n\t * const color = new Color();\n\t * color.setValue('#ff0000')\n\t *     .setAlpha(0.5)\n\t *     .premultiply(0.8);\n\t *\n\t * // Different formats\n\t * color.setValue(0xff0000);          // Hex number\n\t * color.setValue('#ff0000');         // Hex string\n\t * color.setValue([1, 0, 0]);         // RGB array\n\t * color.setValue([1, 0, 0, 0.5]);    // RGBA array\n\t * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object\n\t *\n\t * // Copy from another color\n\t * const red = new Color('red');\n\t * color.setValue(red);\n\t * ```\n\t * @throws {Error} If the color value is invalid or null\n\t * @see {@link Color.value} For the underlying value property\n\t */\n\tsetValue(value: ColorSource): this;\n\t/**\n\t * The current color source. This property allows getting and setting the color value\n\t * while preserving the original format where possible.\n\t * @remarks\n\t * When setting:\n\t * - Setting to a `Color` instance copies its source and components\n\t * - Setting to other valid sources normalizes and stores the value\n\t * - Setting to `null` throws an Error\n\t * - The color remains unchanged if normalization fails\n\t *\n\t * When getting:\n\t * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}\n\t * - Otherwise returns the original color source\n\t * @example\n\t * ```ts\n\t * // Setting different color formats\n\t * const color = new Color();\n\t *\n\t * color.value = 0xff0000;         // Hex number\n\t * color.value = '#ff0000';        // Hex string\n\t * color.value = [1, 0, 0];        // RGB array\n\t * color.value = [1, 0, 0, 0.5];   // RGBA array\n\t * color.value = { r: 1, g: 0, b: 0 }; // RGB object\n\t *\n\t * // Copying from another color\n\t * const red = new Color('red');\n\t * color.value = red;  // Copies red's components\n\t *\n\t * // Getting the value\n\t * console.log(color.value);  // Returns original format\n\t *\n\t * // After modifications\n\t * color.multiply([0.5, 0.5, 0.5]);\n\t * console.log(color.value);  // Returns null\n\t * ```\n\t * @throws {Error} When attempting to set `null`\n\t */\n\tset value(value: ColorSource | null);\n\tget value(): Exclude<ColorSource, Color> | null;\n\t/**\n\t * Copy a color source internally.\n\t * @param value - Color source\n\t */\n\tprivate _cloneSource;\n\t/**\n\t * Equality check for color sources.\n\t * @param value1 - First color source\n\t * @param value2 - Second color source\n\t * @returns `true` if the color sources are equal, `false` otherwise.\n\t */\n\tprivate _isSourceEqual;\n\t/**\n\t * Convert to a RGBA color object with normalized components (0-1).\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert colors to RGBA objects\n\t * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }\n\t * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }\n\t *\n\t * // With transparency\n\t * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }\n\t * ```\n\t * @returns An RGBA object with normalized components\n\t */\n\ttoRgba(): RgbaColor;\n\t/**\n\t * Convert to a RGB color object with normalized components (0-1).\n\t *\n\t * Alpha component is omitted in the output.\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert colors to RGB objects\n\t * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }\n\t * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }\n\t *\n\t * // Alpha is ignored\n\t * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }\n\t * ```\n\t * @returns An RGB object with normalized components\n\t */\n\ttoRgb(): RgbColor;\n\t/**\n\t * Convert to a CSS-style rgba string representation.\n\t *\n\t * RGB components are scaled to 0-255 range, alpha remains 0-1.\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert colors to RGBA strings\n\t * new Color('white').toRgbaString();     // returns \"rgba(255,255,255,1)\"\n\t * new Color('#ff0000').toRgbaString();   // returns \"rgba(255,0,0,1)\"\n\t *\n\t * // With transparency\n\t * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns \"rgba(255,0,0,0.5)\"\n\t * ```\n\t * @returns A CSS-compatible rgba string\n\t */\n\ttoRgbaString(): string;\n\t/**\n\t * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n\t * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,\n\t * a cached array will be used and returned.\n\t * @returns Array containing RGB components as integers between 0-255\n\t * @example\n\t * ```ts\n\t * // Basic usage\n\t * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n\t * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]\n\t *\n\t * // Using custom output array\n\t * const rgb = new Uint8Array(3);\n\t * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]\n\t *\n\t * // Using different array types\n\t * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]\n\t * new Color('red').toUint8RgbArray([]); // [255, 0, 0]\n\t * ```\n\t * @remarks\n\t * - Output values are always clamped between 0-255\n\t * - Alpha component is not included in output\n\t * - Reuses internal cache array if no output array provided\n\t */\n\ttoUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray = number[]>(out?: T): T;\n\t/**\n\t * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n\t * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n\t * a cached array will be used and returned.\n\t * @returns Array containing RGBA components as floats between 0-1\n\t * @example\n\t * ```ts\n\t * // Basic usage\n\t * new Color('white').toArray();  // returns [1, 1, 1, 1]\n\t * new Color('red').toArray();    // returns [1, 0, 0, 1]\n\t *\n\t * // With alpha\n\t * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]\n\t *\n\t * // Using custom output array\n\t * const rgba = new Float32Array(4);\n\t * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]\n\t * ```\n\t * @remarks\n\t * - Output values are normalized between 0-1\n\t * - Includes alpha component as the fourth value\n\t * - Reuses internal cache array if no output array provided\n\t */\n\ttoArray<T extends number[] | Float32Array = number[]>(out?: T): T;\n\t/**\n\t * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n\t * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n\t * a cached array will be used and returned.\n\t * @returns Array containing RGB components as floats between 0-1\n\t * @example\n\t * ```ts\n\t * // Basic usage\n\t * new Color('white').toRgbArray(); // returns [1, 1, 1]\n\t * new Color('red').toRgbArray();   // returns [1, 0, 0]\n\t *\n\t * // Using custom output array\n\t * const rgb = new Float32Array(3);\n\t * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]\n\t * ```\n\t * @remarks\n\t * - Output values are normalized between 0-1\n\t * - Alpha component is omitted from output\n\t * - Reuses internal cache array if no output array provided\n\t */\n\ttoRgbArray<T extends number[] | Float32Array = number[]>(out?: T): T;\n\t/**\n\t * Convert to a hexadecimal number.\n\t * @returns The color as a 24-bit RGB integer\n\t * @example\n\t * ```ts\n\t * // Basic usage\n\t * new Color('white').toNumber(); // returns 0xffffff\n\t * new Color('red').toNumber();   // returns 0xff0000\n\t *\n\t * // Store as hex\n\t * const color = new Color('blue');\n\t * const hex = color.toNumber(); // 0x0000ff\n\t * ```\n\t */\n\ttoNumber(): number;\n\t/**\n\t * Convert to a BGR number.\n\t *\n\t * Useful for platforms that expect colors in BGR format.\n\t * @returns The color as a 24-bit BGR integer\n\t * @example\n\t * ```ts\n\t * // Convert RGB to BGR\n\t * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n\t *\n\t * // Common use case: platform-specific color format\n\t * const color = new Color('orange');\n\t * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels\n\t * ```\n\t * @remarks\n\t * This swaps the red and blue channels compared to the normal RGB format:\n\t * - RGB 0xRRGGBB becomes BGR 0xBBGGRR\n\t */\n\ttoBgrNumber(): number;\n\t/**\n\t * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n\t *\n\t * Useful for platforms that expect colors in little endian byte order.\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert RGB color to little endian format\n\t * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n\t *\n\t * // Common use cases:\n\t * const color = new Color('orange');\n\t * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems\n\t *\n\t * // Multiple conversions\n\t * const colors = {\n\t *     normal: 0xffcc99,\n\t *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff\n\t *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99\n\t * };\n\t * ```\n\t * @remarks\n\t * - Swaps R and B channels in the color value\n\t * - RGB 0xRRGGBB becomes 0xBBGGRR\n\t * - Useful for systems that use little endian byte order\n\t * - Can be used to convert back and forth between formats\n\t * @returns The color as a number in little endian format (BBGGRR)\n\t * @see {@link Color.toBgrNumber} For BGR format without byte swapping\n\t */\n\ttoLittleEndianNumber(): number;\n\t/**\n\t * Multiply with another color.\n\t *\n\t * This action is destructive and modifies the original color.\n\t * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:\n\t * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n\t * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])\n\t * - Color objects ({ r: 1, g: 0, b: 0 })\n\t * - CSS color names ('red', 'blue')\n\t * @returns this - The Color instance for chaining\n\t * @example\n\t * ```ts\n\t * // Basic multiplication\n\t * const color = new Color('#ff0000');\n\t * color.multiply(0x808080); // 50% darker red\n\t *\n\t * // With transparency\n\t * color.multiply([1, 1, 1, 0.5]); // 50% transparent\n\t *\n\t * // Chain operations\n\t * color\n\t *     .multiply('#808080')\n\t *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });\n\t * ```\n\t * @remarks\n\t * - Multiplies each RGB component and alpha separately\n\t * - Values are clamped between 0-1\n\t * - Original color format is lost (value becomes null)\n\t * - Operation cannot be undone\n\t */\n\tmultiply(value: ColorSource): this;\n\t/**\n\t * Converts color to a premultiplied alpha format.\n\t *\n\t * This action is destructive and modifies the original color.\n\t * @param alpha - The alpha value to multiply by (0-1)\n\t * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n\t * @returns {Color} The Color instance for chaining\n\t * @example\n\t * ```ts\n\t * // Basic premultiplication\n\t * const color = new Color('red');\n\t * color.premultiply(0.5); // 50% transparent red with premultiplied RGB\n\t *\n\t * // Alpha only (RGB unchanged)\n\t * color.premultiply(0.5, false); // 50% transparent, original RGB\n\t *\n\t * // Chain with other operations\n\t * color\n\t *     .multiply(0x808080)\n\t *     .premultiply(0.5)\n\t *     .toNumber();\n\t * ```\n\t * @remarks\n\t * - RGB channels are multiplied by alpha when applyToRGB is true\n\t * - Alpha is always set to the provided value\n\t * - Values are clamped between 0-1\n\t * - Original color format is lost (value becomes null)\n\t * - Operation cannot be undone\n\t */\n\tpremultiply(alpha: number, applyToRGB?: boolean): this;\n\t/**\n\t * Returns the color as a 32-bit premultiplied alpha integer.\n\t *\n\t * Format: 0xAARRGGBB\n\t * @param {number} alpha - The alpha value to multiply by (0-1)\n\t * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n\t * @returns {number} The premultiplied color as a 32-bit integer\n\t * @example\n\t * ```ts\n\t * // Convert to premultiplied format\n\t * const color = new Color('red');\n\t *\n\t * // Full opacity (0xFFRRGGBB)\n\t * color.toPremultiplied(1.0); // 0xFFFF0000\n\t *\n\t * // 50% transparency with premultiplied RGB\n\t * color.toPremultiplied(0.5); // 0x7F7F0000\n\t *\n\t * // 50% transparency without RGB premultiplication\n\t * color.toPremultiplied(0.5, false); // 0x7FFF0000\n\t * ```\n\t * @remarks\n\t * - Returns full opacity (0xFF000000) when alpha is 1.0\n\t * - Returns 0 when alpha is 0.0 and applyToRGB is true\n\t * - RGB values are rounded during premultiplication\n\t */\n\ttoPremultiplied(alpha: number, applyToRGB?: boolean): number;\n\t/**\n\t * Convert to a hexadecimal string (6 characters).\n\t * @returns A CSS-compatible hex color string (e.g., \"#ff0000\")\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Basic colors\n\t * new Color('red').toHex();    // returns \"#ff0000\"\n\t * new Color('white').toHex();  // returns \"#ffffff\"\n\t * new Color('black').toHex();  // returns \"#000000\"\n\t *\n\t * // From different formats\n\t * new Color(0xff0000).toHex(); // returns \"#ff0000\"\n\t * new Color([1, 0, 0]).toHex(); // returns \"#ff0000\"\n\t * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns \"#ff0000\"\n\t * ```\n\t * @remarks\n\t * - Always returns a 6-character hex string\n\t * - Includes leading \"#\" character\n\t * - Alpha channel is ignored\n\t * - Values are rounded to nearest hex value\n\t */\n\ttoHex(): string;\n\t/**\n\t * Convert to a hexadecimal string with alpha (8 characters).\n\t * @returns A CSS-compatible hex color string with alpha (e.g., \"#ff0000ff\")\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Fully opaque colors\n\t * new Color('red').toHexa();   // returns \"#ff0000ff\"\n\t * new Color('white').toHexa(); // returns \"#ffffffff\"\n\t *\n\t * // With transparency\n\t * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns \"#ff00007f\"\n\t * new Color([1, 0, 0, 0]).toHexa(); // returns \"#ff000000\"\n\t * ```\n\t * @remarks\n\t * - Returns an 8-character hex string\n\t * - Includes leading \"#\" character\n\t * - Alpha is encoded in last two characters\n\t * - Values are rounded to nearest hex value\n\t */\n\ttoHexa(): string;\n\t/**\n\t * Set alpha (transparency) value while preserving color components.\n\t *\n\t * Provides a chainable interface for setting alpha.\n\t * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)\n\t * @returns The Color instance for chaining\n\t * @example\n\t * ```ts\n\t * // Basic alpha setting\n\t * const color = new Color('red');\n\t * color.setAlpha(0.5);  // 50% transparent red\n\t *\n\t * // Chain with other operations\n\t * color\n\t *     .setValue('#ff0000')\n\t *     .setAlpha(0.8)    // 80% opaque\n\t *     .premultiply(0.5); // Further modify alpha\n\t *\n\t * // Reset to fully opaque\n\t * color.setAlpha(1);\n\t * ```\n\t * @remarks\n\t * - Alpha value is clamped between 0-1\n\t * - Can be chained with other color operations\n\t */\n\tsetAlpha(alpha: number): this;\n\t/**\n\t * Normalize the input value into rgba\n\t * @param value - Input value\n\t */\n\tprivate _normalize;\n\t/** Refresh the internal color rgb number */\n\tprivate _refreshInt;\n\t/**\n\t * Clamps values to a range. Will override original values\n\t * @param value - Value(s) to clamp\n\t * @param min - Minimum value\n\t * @param max - Maximum value\n\t */\n\tprivate _clamp;\n\t/**\n\t * Check if a value can be interpreted as a valid color format.\n\t * Supports all color formats that can be used with the Color class.\n\t * @param value - Value to check\n\t * @returns True if the value can be used as a color\n\t * @example\n\t * ```ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // CSS colors and hex values\n\t * Color.isColorLike('red');          // true\n\t * Color.isColorLike('#ff0000');      // true\n\t * Color.isColorLike(0xff0000);       // true\n\t *\n\t * // Arrays (RGB/RGBA)\n\t * Color.isColorLike([1, 0, 0]);      // true\n\t * Color.isColorLike([1, 0, 0, 0.5]); // true\n\t *\n\t * // TypedArrays\n\t * Color.isColorLike(new Float32Array([1, 0, 0]));          // true\n\t * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true\n\t * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true\n\t *\n\t * // Object formats\n\t * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)\n\t * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)\n\t * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)\n\t * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)\n\t * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)\n\t * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)\n\t *\n\t * // Color instances\n\t * Color.isColorLike(new Color('red')); // true\n\t *\n\t * // Invalid values\n\t * Color.isColorLike(null);           // false\n\t * Color.isColorLike(undefined);      // false\n\t * Color.isColorLike({});             // false\n\t * Color.isColorLike([]);             // false\n\t * Color.isColorLike('not-a-color');  // false\n\t * ```\n\t * @remarks\n\t * Checks for the following formats:\n\t * - Numbers (0x000000 to 0xffffff)\n\t * - CSS color strings\n\t * - RGB/RGBA arrays and objects\n\t * - HSL/HSLA objects\n\t * - HSV/HSVA objects\n\t * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)\n\t * - Color instances\n\t * @see {@link ColorSource} For supported color format types\n\t * @see {@link Color.setValue} For setting color values\n\t * @category utility\n\t */\n\tstatic isColorLike(value: unknown): value is ColorSource;\n}\n/**\n * Common interface for points. Both Point and ObservablePoint implement it.\n * Provides a standard way to represent 2D coordinates.\n *\n * Many PixiJS methods accept PointData for transformations,\n * making it easy to work with different point types interchangeably.\n * @example\n * ```ts\n * // Create an object implementing PointData\n * const point: PointData = { x: 100, y: 200 };\n *\n * // Use with matrix transformations\n * const matrix = new Matrix();\n * matrix.translate(50, 50).apply(point);\n *\n * // Mix with other point types\n * const observablePoint = new ObservablePoint(() => {}, null, 0, 0);\n * const regularPoint = new Point(0, 0);\n * // All are PointData compatible\n * ```\n * @remarks\n * - Basic x,y coordinate interface\n * - Used by Point and ObservablePoint\n * @see {@link Point} For standard point implementation\n * @see {@link ObservablePoint} For observable point implementation\n * @category maths\n * @standard\n */\nexport interface PointData {\n\t/** X coordinate */\n\tx: number;\n\t/** Y coordinate */\n\ty: number;\n}\n/**\n * Common interface for points with manipulation methods.\n *\n * Extends PointData to add operations for copying, comparison and setting values.\n * @example\n * ```ts\n * // Basic point manipulation\n * const point: PointLike = new Point(10, 20);\n * point.set(30, 40);\n *\n * // Copy between points\n * const other = new Point();\n * point.copyTo(other);\n *\n * // Compare points\n * const same = point.equals(other); // true\n * ```\n * @see {@link PointData} For basic x,y interface\n * @see {@link Point} For standard implementation\n * @see {@link ObservablePoint} For observable implementation\n * @category maths\n * @standard\n */\nexport interface PointLike extends PointData {\n\t/**\n\t * Copies x and y from the given point\n\t * @param {PointData} p - The point to copy from\n\t * @returns {this} Returns itself.\n\t * @example\n\t * ```ts\n\t * const point1: PointLike = new Point(10, 20);\n\t * const point2: PointLike = new Point(30, 40);\n\t * point1.copyFrom(point2);\n\t * console.log(point1.x, point1.y); // 30, 40\n\t * ```\n\t */\n\tcopyFrom: (p: PointData) => this;\n\t/**\n\t * Copies x and y into the given point\n\t * @param {PointLike} p - The point to copy.\n\t * @returns {PointLike} Given point with values updated\n\t * @example\n\t * ```ts\n\t * const point1: PointLike = new Point(10, 20);\n\t * const point2: PointLike = new Point(0, 0);\n\t * point1.copyTo(point2);\n\t * console.log(point2.x, point2.y); // 10, 20\n\t * ```\n\t */\n\tcopyTo: <T extends PointLike>(p: T) => T;\n\t/**\n\t * Returns true if the given point is equal to this point\n\t * @param {PointData} p - The point to check\n\t * @returns {boolean} Whether the given point equal to this point\n\t * @example\n\t * ```ts\n\t * const point1: PointLike = new Point(10, 20);\n\t * const point2: PointLike = new Point(10, 20);\n\t * const point3: PointLike = new Point(30, 40);\n\t * console.log(point1.equals(point2)); // true\n\t * console.log(point1.equals(point3)); // false\n\t * ```\n\t */\n\tequals: (p: PointData) => boolean;\n\t/**\n\t * Sets the point to a new x and y position.\n\t * If y is omitted, both x and y will be set to x.\n\t * @param {number} [x=0] - position of the point on the x axis\n\t * @param {number} [y=x] - position of the point on the y axis\n\t * @example\n\t * ```ts\n\t * const point: PointLike = new Point(10, 20);\n\t * point.set(30, 40);\n\t * console.log(point.x, point.y); // 30, 40\n\t * point.set(50); // Sets both x and y to 50\n\t * console.log(point.x, point.y); // 50, 50\n\t * ```\n\t */\n\tset: (x?: number, y?: number) => void;\n}\nexport interface Point extends PixiMixins.Point {\n}\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @example\n * ```ts\n * // Basic point creation\n * const point = new Point(100, 200);\n *\n * // Using with transformations\n * const matrix = new Matrix();\n * matrix.translate(50, 50).apply(point);\n *\n * // Point arithmetic\n * const start = new Point(0, 0);\n * const end = new Point(100, 100);\n * const middle = new Point(\n *     (start.x + end.x) / 2,\n *     (start.y + end.y) / 2\n * );\n * ```\n * @see {@link PointData} For basic x,y interface\n * @see {@link PointLike} For point manipulation interface\n * @see {@link ObservablePoint} For observable version\n * @category maths\n * @standard\n */\nexport class Point implements PointLike {\n\t/**\n\t * Position of the point on the x axis\n\t * @example\n\t * ```ts\n\t * // Set x position\n\t * const point = new Point();\n\t * point.x = 100;\n\t *\n\t * // Use in calculations\n\t * const width = rightPoint.x - leftPoint.x;\n\t * ```\n\t */\n\tx: number;\n\t/**\n\t * Position of the point on the y axis\n\t * @example\n\t * ```ts\n\t * // Set y position\n\t * const point = new Point();\n\t * point.y = 200;\n\t *\n\t * // Use in calculations\n\t * const height = bottomPoint.y - topPoint.y;\n\t * ```\n\t */\n\ty: number;\n\t/**\n\t * Creates a new `Point`\n\t * @param {number} [x=0] - position of the point on the x axis\n\t * @param {number} [y=0] - position of the point on the y axis\n\t */\n\tconstructor(x?: number, y?: number);\n\t/**\n\t * Creates a clone of this point, which is a new instance with the same `x` and `y` values.\n\t * @example\n\t * ```ts\n\t * // Basic point cloning\n\t * const original = new Point(100, 200);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.set(300, 400);\n\t *\n\t * // Verify independence\n\t * console.log(original); // Point(100, 200)\n\t * console.log(modified); // Point(300, 400)\n\t * ```\n\t * @remarks\n\t * - Creates new Point instance\n\t * - Deep copies x and y values\n\t * - Independent from original\n\t * - Useful for preserving values\n\t * @returns A clone of this point\n\t * @see {@link Point.copyFrom} For copying into existing point\n\t * @see {@link Point.copyTo} For copying to existing point\n\t */\n\tclone(): Point;\n\t/**\n\t * Copies x and y from the given point into this point.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Point(100, 200);\n\t * const target = new Point();\n\t * target.copyFrom(source);\n\t *\n\t * // Copy and chain operations\n\t * const point = new Point()\n\t *     .copyFrom(source)\n\t *     .set(x + 50, y + 50);\n\t *\n\t * // Copy from any PointData\n\t * const data = { x: 10, y: 20 };\n\t * point.copyFrom(data);\n\t * ```\n\t * @param p - The point to copy from\n\t * @returns The point instance itself\n\t * @see {@link Point.copyTo} For copying to another point\n\t * @see {@link Point.clone} For creating new point copy\n\t */\n\tcopyFrom(p: PointData): this;\n\t/**\n\t * Copies this point's x and y into the given point.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Point(100, 200);\n\t * const target = new Point();\n\t * source.copyTo(target);\n\t * ```\n\t * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n\t * @returns The point (`p`) with values updated\n\t * @see {@link Point.copyFrom} For copying from another point\n\t * @see {@link Point.clone} For creating new point copy\n\t */\n\tcopyTo<T extends PointLike>(p: T): T;\n\t/**\n\t * Checks if another point is equal to this point.\n\t *\n\t * Compares x and y values using strict equality.\n\t * @example\n\t * ```ts\n\t * // Basic equality check\n\t * const p1 = new Point(100, 200);\n\t * const p2 = new Point(100, 200);\n\t * console.log(p1.equals(p2)); // true\n\t *\n\t * // Compare with PointData\n\t * const data = { x: 100, y: 200 };\n\t * console.log(p1.equals(data)); // true\n\t *\n\t * // Check different points\n\t * const p3 = new Point(200, 300);\n\t * console.log(p1.equals(p3)); // false\n\t * ```\n\t * @param p - The point to check\n\t * @returns `true` if both `x` and `y` are equal\n\t * @see {@link Point.copyFrom} For making points equal\n\t * @see {@link PointData} For point data interface\n\t */\n\tequals(p: PointData): boolean;\n\t/**\n\t * Sets the point to a new x and y position.\n\t *\n\t * If y is omitted, both x and y will be set to x.\n\t * @example\n\t * ```ts\n\t * // Basic position setting\n\t * const point = new Point();\n\t * point.set(100, 200);\n\t *\n\t * // Set both x and y to same value\n\t * point.set(50); // x=50, y=50\n\t *\n\t * // Chain with other operations\n\t * point\n\t *     .set(10, 20)\n\t *     .copyTo(otherPoint);\n\t * ```\n\t * @param x - Position on the x axis\n\t * @param y - Position on the y axis, defaults to x\n\t * @returns The point instance itself\n\t * @see {@link Point.copyFrom} For copying from another point\n\t * @see {@link Point.equals} For comparing positions\n\t */\n\tset(x?: number, y?: number): this;\n\ttoString(): string;\n\t/**\n\t * A static Point object with `x` and `y` values of `0`.\n\t *\n\t * This shared instance is reset to zero values when accessed.\n\t *\n\t * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.\n\t * @example\n\t * ```ts\n\t * // Use for temporary calculations\n\t * const tempPoint = Point.shared;\n\t * tempPoint.set(100, 200);\n\t * matrix.apply(tempPoint);\n\t *\n\t * // Will be reset to (0,0) on next access\n\t * const fresh = Point.shared; // x=0, y=0\n\t * ```\n\t * @readonly\n\t * @returns A fresh zeroed point for temporary use\n\t * @see {@link Point.constructor} For creating new points\n\t * @see {@link PointData} For basic point interface\n\t */\n\tstatic get shared(): Point;\n}\n/**\n * The data structure that contains the position, scale, pivot, skew and rotation of an object.\n * This is used by the {@link Matrix} class to decompose the matrix into its components.\n * @category maths\n * @advanced\n */\nexport interface TransformableObject {\n\t/** The position of the object */\n\tposition: PointData;\n\t/** The scale of the object */\n\tscale: PointData;\n\t/** The pivot of the object */\n\tpivot: PointData;\n\t/** The skew of the object */\n\tskew: PointData;\n\t/** The rotation of the object */\n\trotation: number;\n}\n/**\n * A fast matrix for 2D transformations.\n * Represents a 3x3 transformation matrix:\n *\n * ```js\n * | a  c  tx |\n * | b  d  ty |\n * | 0  0  1  |\n * ```\n * @example\n * ```ts\n * // Create identity matrix\n * const matrix = new Matrix();\n *\n * // Create matrix with custom values\n * const transform = new Matrix(2, 0, 0, 2, 100, 100); // Scale 2x, translate 100,100\n *\n * // Transform a point\n * const point = { x: 10, y: 20 };\n * const transformed = transform.apply(point);\n *\n * // Chain transformations\n * matrix\n *     .translate(100, 50)\n *     .rotate(Math.PI / 4)\n *     .scale(2, 2);\n * ```\n * @remarks\n * - Used for transform hierarchies\n * - Supports scale, rotation, position\n * - Can be concatenated with append/prepend\n * - Efficient for batched transformations\n * @category maths\n * @standard\n */\nexport class Matrix {\n\t/**\n\t * Scale on the x axis.\n\t * @default 1\n\t */\n\ta: number;\n\t/**\n\t * Shear on the y axis.\n\t * @default 0\n\t */\n\tb: number;\n\t/**\n\t * Shear on the x axis.\n\t * @default 0\n\t */\n\tc: number;\n\t/**\n\t * Scale on the y axis.\n\t * @default 1\n\t */\n\td: number;\n\t/**\n\t * Translation on the x axis.\n\t * @default 0\n\t */\n\ttx: number;\n\t/**\n\t * Translation on the y axis.\n\t * @default 0\n\t */\n\tty: number;\n\t/**\n\t * Array representation of the matrix.\n\t * Only populated when `toArray()` is called.\n\t * @default null\n\t * @see {@link Matrix.toArray} For filling this array\n\t */\n\tarray: Float32Array | null;\n\t/**\n\t * @param a - x scale\n\t * @param b - y skew\n\t * @param c - x skew\n\t * @param d - y scale\n\t * @param tx - x translation\n\t * @param ty - y translation\n\t */\n\tconstructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);\n\t/**\n\t * Creates a Matrix object based on the given array.\n\t * Populates matrix components from a flat array in column-major order.\n\t *\n\t * > [!NOTE] Array mapping order:\n\t * > ```\n\t * > array[0] = a  (x scale)\n\t * > array[1] = b  (y skew)\n\t * > array[2] = tx (x translation)\n\t * > array[3] = c  (x skew)\n\t * > array[4] = d  (y scale)\n\t * > array[5] = ty (y translation)\n\t * > ```\n\t * @example\n\t * ```ts\n\t * // Create matrix from array\n\t * const matrix = new Matrix();\n\t * matrix.fromArray([\n\t *     2, 0,  100,  // a, b, tx\n\t *     0, 2,  100   // c, d, ty\n\t * ]);\n\t *\n\t * // Create matrix from typed array\n\t * const float32Array = new Float32Array([\n\t *     1, 0, 0,     // Scale x1, no skew\n\t *     0, 1, 0      // No skew, scale x1\n\t * ]);\n\t * matrix.fromArray(float32Array);\n\t * ```\n\t * @param array - The array to populate the matrix from\n\t * @see {@link Matrix.toArray} For converting matrix to array\n\t * @see {@link Matrix.set} For setting values directly\n\t */\n\tfromArray(array: number[]): void;\n\t/**\n\t * Sets the matrix properties directly.\n\t * All matrix components can be set in one call.\n\t * @example\n\t * ```ts\n\t * // Set to identity matrix\n\t * matrix.set(1, 0, 0, 1, 0, 0);\n\t *\n\t * // Set to scale matrix\n\t * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x\n\t *\n\t * // Set to translation matrix\n\t * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50\n\t * ```\n\t * @param a - Scale on x axis\n\t * @param b - Shear on y axis\n\t * @param c - Shear on x axis\n\t * @param d - Scale on y axis\n\t * @param tx - Translation on x axis\n\t * @param ty - Translation on y axis\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.identity} For resetting to identity\n\t * @see {@link Matrix.fromArray} For setting from array\n\t */\n\tset(a: number, b: number, c: number, d: number, tx: number, ty: number): this;\n\t/**\n\t * Creates an array from the current Matrix object.\n\t *\n\t * > [!NOTE] The array format is:\n\t * > ```\n\t * > Non-transposed:\n\t * > [a, c, tx,\n\t * > b, d, ty,\n\t * > 0, 0, 1]\n\t * >\n\t * > Transposed:\n\t * > [a, b, 0,\n\t * > c, d, 0,\n\t * > tx,ty,1]\n\t * > ```\n\t * @example\n\t * ```ts\n\t * // Basic array conversion\n\t * const matrix = new Matrix(2, 0, 0, 2, 100, 100);\n\t * const array = matrix.toArray();\n\t *\n\t * // Using existing array\n\t * const float32Array = new Float32Array(9);\n\t * matrix.toArray(false, float32Array);\n\t *\n\t * // Get transposed array\n\t * const transposed = matrix.toArray(true);\n\t * ```\n\t * @param transpose - Whether to transpose the matrix\n\t * @param out - Optional Float32Array to store the result\n\t * @returns The array containing the matrix values\n\t * @see {@link Matrix.fromArray} For creating matrix from array\n\t * @see {@link Matrix.array} For cached array storage\n\t */\n\ttoArray(transpose?: boolean, out?: Float32Array): Float32Array;\n\t/**\n\t * Get a new position with the current transformation applied.\n\t *\n\t * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n\t * @example\n\t * ```ts\n\t * // Basic point transformation\n\t * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n\t * const point = new Point(10, 20);\n\t * const transformed = matrix.apply(point);\n\t *\n\t * // Reuse existing point\n\t * const output = new Point();\n\t * matrix.apply(point, output);\n\t * ```\n\t * @param pos - The origin point to transform\n\t * @param newPos - Optional point to store the result\n\t * @returns The transformed point\n\t * @see {@link Matrix.applyInverse} For inverse transformation\n\t * @see {@link Point} For point operations\n\t */\n\tapply<P extends PointData = Point>(pos: PointData, newPos?: P): P;\n\t/**\n\t * Get a new position with the inverse of the current transformation applied.\n\t *\n\t * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n\t * @example\n\t * ```ts\n\t * // Basic inverse transformation\n\t * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n\t * const worldPoint = new Point(150, 100);\n\t * const localPoint = matrix.applyInverse(worldPoint);\n\t *\n\t * // Reuse existing point\n\t * const output = new Point();\n\t * matrix.applyInverse(worldPoint, output);\n\t *\n\t * // Convert mouse position to local space\n\t * const mousePoint = new Point(mouseX, mouseY);\n\t * const localMouse = matrix.applyInverse(mousePoint);\n\t * ```\n\t * @param pos - The origin point to inverse-transform\n\t * @param newPos - Optional point to store the result\n\t * @returns The inverse-transformed point\n\t * @see {@link Matrix.apply} For forward transformation\n\t * @see {@link Matrix.invert} For getting inverse matrix\n\t */\n\tapplyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P;\n\t/**\n\t * Translates the matrix on the x and y axes.\n\t * Adds to the position values while preserving scale, rotation and skew.\n\t * @example\n\t * ```ts\n\t * // Basic translation\n\t * const matrix = new Matrix();\n\t * matrix.translate(100, 50); // Move right 100, down 50\n\t *\n\t * // Chain with other transformations\n\t * matrix\n\t *     .scale(2, 2)\n\t *     .translate(100, 0)\n\t *     .rotate(Math.PI / 4);\n\t * ```\n\t * @param x - How much to translate on the x axis\n\t * @param y - How much to translate on the y axis\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.set} For setting position directly\n\t * @see {@link Matrix.setTransform} For complete transform setup\n\t */\n\ttranslate(x: number, y: number): this;\n\t/**\n\t * Applies a scale transformation to the matrix.\n\t * Multiplies the scale values with existing matrix components.\n\t * @example\n\t * ```ts\n\t * // Basic scaling\n\t * const matrix = new Matrix();\n\t * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically\n\t *\n\t * // Chain with other transformations\n\t * matrix\n\t *     .translate(100, 100)\n\t *     .scale(2, 2)     // Scales after translation\n\t *     .rotate(Math.PI / 4);\n\t * ```\n\t * @param x - The amount to scale horizontally\n\t * @param y - The amount to scale vertically\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.setTransform} For setting scale directly\n\t * @see {@link Matrix.append} For combining transformations\n\t */\n\tscale(x: number, y: number): this;\n\t/**\n\t * Applies a rotation transformation to the matrix.\n\t *\n\t * Rotates around the origin (0,0) by the given angle in radians.\n\t * @example\n\t * ```ts\n\t * // Basic rotation\n\t * const matrix = new Matrix();\n\t * matrix.rotate(Math.PI / 4); // Rotate 45 degrees\n\t *\n\t * // Chain with other transformations\n\t * matrix\n\t *     .translate(100, 100) // Move to rotation center\n\t *     .rotate(Math.PI)     // Rotate 180 degrees\n\t *     .scale(2, 2);        // Scale after rotation\n\t *\n\t * // Common angles\n\t * matrix.rotate(Math.PI / 2);  // 90 degrees\n\t * matrix.rotate(Math.PI);      // 180 degrees\n\t * matrix.rotate(Math.PI * 2);  // 360 degrees\n\t * ```\n\t * @remarks\n\t * - Rotates around origin point (0,0)\n\t * - Affects position if translation was set\n\t * - Uses counter-clockwise rotation\n\t * - Order of operations matters when chaining\n\t * @param angle - The angle in radians\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.setTransform} For setting rotation directly\n\t * @see {@link Matrix.append} For combining transformations\n\t */\n\trotate(angle: number): this;\n\t/**\n\t * Appends the given Matrix to this Matrix.\n\t * Combines two matrices by multiplying them together: this = this * matrix\n\t * @example\n\t * ```ts\n\t * // Basic matrix combination\n\t * const matrix = new Matrix();\n\t * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);\n\t * matrix.append(other);\n\t * ```\n\t * @remarks\n\t * - Order matters: A.append(B) !== B.append(A)\n\t * - Modifies current matrix\n\t * - Preserves transformation order\n\t * - Commonly used for combining transforms\n\t * @param matrix - The matrix to append\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.prepend} For prepending transformations\n\t * @see {@link Matrix.appendFrom} For appending two external matrices\n\t */\n\tappend(matrix: Matrix): this;\n\t/**\n\t * Appends two matrices and sets the result to this matrix.\n\t * Performs matrix multiplication: this = A * B\n\t * @example\n\t * ```ts\n\t * // Basic matrix multiplication\n\t * const result = new Matrix();\n\t * const matrixA = new Matrix().scale(2, 2);\n\t * const matrixB = new Matrix().rotate(Math.PI / 4);\n\t * result.appendFrom(matrixA, matrixB);\n\t * ```\n\t * @remarks\n\t * - Order matters: A * B !== B * A\n\t * - Creates a new transformation from two others\n\t * - More efficient than append() for multiple operations\n\t * - Does not modify input matrices\n\t * @param a - The first matrix to multiply\n\t * @param b - The second matrix to multiply\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.append} For single matrix combination\n\t * @see {@link Matrix.prepend} For reverse order multiplication\n\t */\n\tappendFrom(a: Matrix, b: Matrix): this;\n\t/**\n\t * Sets the matrix based on all the available properties.\n\t * Combines position, scale, rotation, skew and pivot in a single operation.\n\t * @example\n\t * ```ts\n\t * // Basic transform setup\n\t * const matrix = new Matrix();\n\t * matrix.setTransform(\n\t *     100, 100,    // position\n\t *     0, 0,        // pivot\n\t *     2, 2,        // scale\n\t *     Math.PI / 4, // rotation (45 degrees)\n\t *     0, 0         // skew\n\t * );\n\t * ```\n\t * @remarks\n\t * - Updates all matrix components at once\n\t * - More efficient than separate transform calls\n\t * - Uses radians for rotation and skew\n\t * - Pivot affects rotation center\n\t * @param x - Position on the x axis\n\t * @param y - Position on the y axis\n\t * @param pivotX - Pivot on the x axis\n\t * @param pivotY - Pivot on the y axis\n\t * @param scaleX - Scale on the x axis\n\t * @param scaleY - Scale on the y axis\n\t * @param rotation - Rotation in radians\n\t * @param skewX - Skew on the x axis\n\t * @param skewY - Skew on the y axis\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.decompose} For extracting transform properties\n\t * @see {@link TransformableObject} For transform data structure\n\t */\n\tsetTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number, scaleY: number, rotation: number, skewX: number, skewY: number): this;\n\t/**\n\t * Prepends the given Matrix to this Matrix.\n\t * Combines two matrices by multiplying them together: this = matrix * this\n\t * @example\n\t * ```ts\n\t * // Basic matrix prepend\n\t * const matrix = new Matrix().scale(2, 2);\n\t * const other = new Matrix().translate(100, 0);\n\t * matrix.prepend(other); // Translation happens before scaling\n\t * ```\n\t * @remarks\n\t * - Order matters: A.prepend(B) !== B.prepend(A)\n\t * - Modifies current matrix\n\t * - Reverses transformation order compared to append()\n\t * @param matrix - The matrix to prepend\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.append} For appending transformations\n\t * @see {@link Matrix.appendFrom} For combining external matrices\n\t */\n\tprepend(matrix: Matrix): this;\n\t/**\n\t * Decomposes the matrix into its individual transform components.\n\t * Extracts position, scale, rotation and skew values from the matrix.\n\t * @example\n\t * ```ts\n\t * // Basic decomposition\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4)\n\t *     .scale(2, 2);\n\t *\n\t * const transform = {\n\t *     position: new Point(),\n\t *     scale: new Point(),\n\t *     pivot: new Point(),\n\t *     skew: new Point(),\n\t *     rotation: 0\n\t * };\n\t *\n\t * matrix.decompose(transform);\n\t * console.log(transform.position); // Point(100, 100)\n\t * console.log(transform.rotation); // ~0.785 (PI/4)\n\t * console.log(transform.scale); // Point(2, 2)\n\t * ```\n\t * @remarks\n\t * - Handles combined transformations\n\t * - Accounts for pivot points\n\t * - Chooses between rotation/skew based on transform type\n\t * - Uses radians for rotation and skew\n\t * @param transform - The transform object to store the decomposed values\n\t * @returns The transform with the newly applied properties\n\t * @see {@link Matrix.setTransform} For composing from components\n\t * @see {@link TransformableObject} For transform structure\n\t */\n\tdecompose(transform: TransformableObject): TransformableObject;\n\t/**\n\t * Inverts this matrix.\n\t * Creates the matrix that when multiplied with this matrix results in an identity matrix.\n\t * @example\n\t * ```ts\n\t * // Basic matrix inversion\n\t * const matrix = new Matrix()\n\t *     .translate(100, 50)\n\t *     .scale(2, 2);\n\t *\n\t * matrix.invert(); // Now transforms in opposite direction\n\t *\n\t * // Verify inversion\n\t * const point = new Point(50, 50);\n\t * const transformed = matrix.apply(point);\n\t * const original = matrix.invert().apply(transformed);\n\t * // original  point\n\t * ```\n\t * @remarks\n\t * - Modifies the current matrix\n\t * - Useful for reversing transformations\n\t * - Cannot invert matrices with zero determinant\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.identity} For resetting to identity\n\t * @see {@link Matrix.applyInverse} For inverse transformations\n\t */\n\tinvert(): this;\n\t/**\n\t * Checks if this matrix is an identity matrix.\n\t *\n\t * An identity matrix has no transformations applied (default state).\n\t * @example\n\t * ```ts\n\t * // Check if matrix is identity\n\t * const matrix = new Matrix();\n\t * console.log(matrix.isIdentity()); // true\n\t *\n\t * // Check after transformations\n\t * matrix.translate(100, 0);\n\t * console.log(matrix.isIdentity()); // false\n\t *\n\t * // Reset and verify\n\t * matrix.identity();\n\t * console.log(matrix.isIdentity()); // true\n\t * ```\n\t * @remarks\n\t * - Verifies a = 1, d = 1 (no scale)\n\t * - Verifies b = 0, c = 0 (no skew)\n\t * - Verifies tx = 0, ty = 0 (no translation)\n\t * @returns True if matrix has no transformations\n\t * @see {@link Matrix.identity} For resetting to identity\n\t * @see {@link Matrix.IDENTITY} For constant identity matrix\n\t */\n\tisIdentity(): boolean;\n\t/**\n\t * Resets this Matrix to an identity (default) matrix.\n\t * Sets all components to their default values: scale=1, no skew, no translation.\n\t * @example\n\t * ```ts\n\t * // Reset transformed matrix\n\t * const matrix = new Matrix()\n\t *     .scale(2, 2)\n\t *     .rotate(Math.PI / 4);\n\t * matrix.identity(); // Back to default state\n\t *\n\t * // Chain after reset\n\t * matrix\n\t *     .identity()\n\t *     .translate(100, 100)\n\t *     .scale(2, 2);\n\t *\n\t * // Compare with identity constant\n\t * const isDefault = matrix.equals(Matrix.IDENTITY);\n\t * ```\n\t * @remarks\n\t * - Sets a=1, d=1 (default scale)\n\t * - Sets b=0, c=0 (no skew)\n\t * - Sets tx=0, ty=0 (no translation)\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.IDENTITY} For constant identity matrix\n\t * @see {@link Matrix.isIdentity} For checking identity state\n\t */\n\tidentity(): this;\n\t/**\n\t * Creates a new Matrix object with the same values as this one.\n\t * @returns A copy of this matrix. Good for chaining method calls.\n\t */\n\tclone(): Matrix;\n\t/**\n\t * Creates a new Matrix object with the same values as this one.\n\t * @param matrix\n\t * @example\n\t * ```ts\n\t * // Basic matrix cloning\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4);\n\t * const copy = matrix.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = matrix.clone()\n\t *     .scale(2, 2);\n\t *\n\t * // Compare matrices\n\t * console.log(matrix.equals(copy));     // true\n\t * console.log(matrix.equals(modified)); // false\n\t * ```\n\t * @returns A copy of this matrix. Good for chaining method calls.\n\t * @see {@link Matrix.copyTo} For copying to existing matrix\n\t * @see {@link Matrix.copyFrom} For copying from another matrix\n\t */\n\tcopyTo(matrix: Matrix): Matrix;\n\t/**\n\t * Changes the values of the matrix to be the same as the ones in given matrix.\n\t * @example\n\t * ```ts\n\t * // Basic matrix copying\n\t * const source = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4);\n\t * const target = new Matrix();\n\t * target.copyFrom(source);\n\t * ```\n\t * @param matrix - The matrix to copy from\n\t * @returns This matrix. Good for chaining method calls.\n\t * @see {@link Matrix.clone} For creating new matrix copy\n\t * @see {@link Matrix.copyTo} For copying to another matrix\n\t */\n\tcopyFrom(matrix: Matrix): this;\n\t/**\n\t * Checks if this matrix equals another matrix.\n\t * Compares all components for exact equality.\n\t * @example\n\t * ```ts\n\t * // Basic equality check\n\t * const m1 = new Matrix();\n\t * const m2 = new Matrix();\n\t * console.log(m1.equals(m2)); // true\n\t *\n\t * // Compare transformed matrices\n\t * const transform = new Matrix()\n\t *     .translate(100, 100)\n\t * const clone = new Matrix()\n\t *     .scale(2, 2);\n\t * console.log(transform.equals(clone)); // false\n\t * ```\n\t * @param matrix - The matrix to compare to\n\t * @returns True if matrices are identical\n\t * @see {@link Matrix.copyFrom} For copying matrix values\n\t * @see {@link Matrix.isIdentity} For identity comparison\n\t */\n\tequals(matrix: Matrix): boolean;\n\ttoString(): string;\n\t/**\n\t * A default (identity) matrix with no transformations applied.\n\t *\n\t * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.\n\t * @example\n\t * ```ts\n\t * // Get identity matrix reference\n\t * const identity = Matrix.IDENTITY;\n\t * console.log(identity.isIdentity()); // true\n\t *\n\t * // Compare with identity\n\t * const matrix = new Matrix();\n\t * console.log(matrix.equals(Matrix.IDENTITY)); // true\n\t *\n\t * // Create new matrix instead of modifying IDENTITY\n\t * const transform = new Matrix()\n\t *     .copyFrom(Matrix.IDENTITY)\n\t *     .translate(100, 100);\n\t * ```\n\t * @readonly\n\t * @returns A read-only identity matrix\n\t * @see {@link Matrix.shared} For temporary calculations\n\t * @see {@link Matrix.identity} For resetting matrices\n\t */\n\tstatic get IDENTITY(): Readonly<Matrix>;\n\t/**\n\t * A static Matrix that can be used to avoid creating new objects.\n\t * Will always ensure the matrix is reset to identity when requested.\n\t *\n\t * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.\n\t * @example\n\t * ```ts\n\t * // Use for temporary calculations\n\t * const tempMatrix = Matrix.shared;\n\t * tempMatrix.translate(100, 100).rotate(Math.PI / 4);\n\t * const point = tempMatrix.apply({ x: 10, y: 20 });\n\t *\n\t * // Will be reset to identity on next access\n\t * const fresh = Matrix.shared; // Back to identity\n\t * ```\n\t * @remarks\n\t * - Always returns identity matrix\n\t * - Safe to modify temporarily\n\t * - Not safe to store references\n\t * - Useful for one-off calculations\n\t * @readonly\n\t * @returns A fresh identity matrix for temporary use\n\t * @see {@link Matrix.IDENTITY} For immutable identity matrix\n\t * @see {@link Matrix.identity} For resetting matrices\n\t */\n\tstatic get shared(): Matrix;\n}\nexport interface ObservablePoint extends PixiMixins.ObservablePoint {\n}\n/**\n * Observer used to listen for observable point changes.\n * Provides callback mechanism for point value updates.\n * @example\n * ```ts\n * // Basic observer implementation\n * const observer: Observer<ObservablePoint> = {\n *     _onUpdate: (point) => {\n *         console.log(`Point updated to (${point.x}, ${point.y})`);\n *     }\n * };\n *\n * // Create observable point with observer\n * const point = new ObservablePoint(observer, 100, 100);\n *\n * // Observer will be notified on changes\n * point.x = 200; // Logs: Point updated to (200, 100)\n * ```\n * @remarks\n * - Used internally by ObservablePoint\n * - Triggered on x/y changes\n * - Can track multiple points\n * - Useful for change detection\n * @typeParam T - The type of point being observed\n * @see {@link ObservablePoint} The observable point class\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport interface Observer<T> {\n\t/**\n\t * Callback to call when the point has updated.\n\t * Triggered whenever x or y coordinates change.\n\t * @param point - The point that was updated\n\t */\n\t_onUpdate: (point?: T) => void;\n}\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system.\n * Triggers a callback when its position changes.\n *\n * The x and y properties represent the position on the horizontal and vertical axes, respectively.\n * @example\n * ```ts\n * // Basic observable point usage\n * const point = new ObservablePoint(\n *     { _onUpdate: (p) => console.log(`Updated to (${p.x}, ${p.y})`) },\n *     100, 100\n * );\n *\n * // Update triggers callback\n * point.x = 200; // Logs: Updated to (200, 100)\n * point.y = 300; // Logs: Updated to (200, 300)\n *\n * // Set both coordinates\n * point.set(50, 50); // Logs: Updated to (50, 50)\n * ```\n * @see {@link Point} For non-observable version\n * @see {@link Observer} For observer interface\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport class ObservablePoint implements PointLike {\n\t/** @ignore */\n\t_x: number;\n\t/** @ignore */\n\t_y: number;\n\t/** This object used to call the `onUpdate` callback when the point changes. */\n\tprivate readonly _observer;\n\t/**\n\t * Creates a new `ObservablePoint`\n\t * @param observer - Observer to pass to listen for change events.\n\t * @param {number} [x=0] - position of the point on the x axis\n\t * @param {number} [y=0] - position of the point on the y axis\n\t */\n\tconstructor(observer: Observer<ObservablePoint>, x?: number, y?: number);\n\t/**\n\t * Creates a clone of this point.\n\t * @example\n\t * ```ts\n\t * // Basic cloning\n\t * const point = new ObservablePoint(observer, 100, 200);\n\t * const copy = point.clone();\n\t *\n\t * // Clone with new observer\n\t * const newObserver = {\n\t *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)\n\t * };\n\t * const watched = point.clone(newObserver);\n\t *\n\t * // Verify independence\n\t * watched.set(300, 400); // Only triggers new observer\n\t * ```\n\t * @param observer - Optional observer to pass to the new observable point\n\t * @returns A copy of this observable point\n\t * @see {@link ObservablePoint.copyFrom} For copying into existing point\n\t * @see {@link Observer} For observer interface details\n\t */\n\tclone(observer?: Observer<ObservablePoint>): ObservablePoint;\n\t/**\n\t * Sets the point to a new x and y position.\n\t *\n\t * If y is omitted, both x and y will be set to x.\n\t * @example\n\t * ```ts\n\t * // Basic position setting\n\t * const point = new ObservablePoint(observer);\n\t * point.set(100, 200);\n\t *\n\t * // Set both x and y to same value\n\t * point.set(50); // x=50, y=50\n\t * ```\n\t * @param x - Position on the x axis\n\t * @param y - Position on the y axis, defaults to x\n\t * @returns The point instance itself\n\t * @see {@link ObservablePoint.copyFrom} For copying from another point\n\t * @see {@link ObservablePoint.equals} For comparing positions\n\t */\n\tset(x?: number, y?: number): this;\n\t/**\n\t * Copies x and y from the given point into this point.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new ObservablePoint(observer, 100, 200);\n\t * const target = new ObservablePoint();\n\t * target.copyFrom(source);\n\t *\n\t * // Copy and chain operations\n\t * const point = new ObservablePoint()\n\t *     .copyFrom(source)\n\t *     .set(x + 50, y + 50);\n\t *\n\t * // Copy from any PointData\n\t * const data = { x: 10, y: 20 };\n\t * point.copyFrom(data);\n\t * ```\n\t * @param p - The point to copy from\n\t * @returns The point instance itself\n\t * @see {@link ObservablePoint.copyTo} For copying to another point\n\t * @see {@link ObservablePoint.clone} For creating new point copy\n\t */\n\tcopyFrom(p: PointData): this;\n\t/**\n\t * Copies this point's x and y into the given point.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new ObservablePoint(100, 200);\n\t * const target = new ObservablePoint();\n\t * source.copyTo(target);\n\t * ```\n\t * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n\t * @returns The point (`p`) with values updated\n\t * @see {@link ObservablePoint.copyFrom} For copying from another point\n\t * @see {@link ObservablePoint.clone} For creating new point copy\n\t */\n\tcopyTo<T extends PointLike>(p: T): T;\n\t/**\n\t * Checks if another point is equal to this point.\n\t *\n\t * Compares x and y values using strict equality.\n\t * @example\n\t * ```ts\n\t * // Basic equality check\n\t * const p1 = new ObservablePoint(100, 200);\n\t * const p2 = new ObservablePoint(100, 200);\n\t * console.log(p1.equals(p2)); // true\n\t *\n\t * // Compare with PointData\n\t * const data = { x: 100, y: 200 };\n\t * console.log(p1.equals(data)); // true\n\t *\n\t * // Check different points\n\t * const p3 = new ObservablePoint(200, 300);\n\t * console.log(p1.equals(p3)); // false\n\t * ```\n\t * @param p - The point to check\n\t * @returns `true` if both `x` and `y` are equal\n\t * @see {@link ObservablePoint.copyFrom} For making points equal\n\t * @see {@link PointData} For point data interface\n\t */\n\tequals(p: PointData): boolean;\n\ttoString(): string;\n\t/**\n\t * Position of the observable point on the x axis.\n\t * Triggers observer callback when value changes.\n\t * @example\n\t * ```ts\n\t * // Basic x position\n\t * const point = new ObservablePoint(observer);\n\t * point.x = 100; // Triggers observer\n\t *\n\t * // Use in calculations\n\t * const width = rightPoint.x - leftPoint.x;\n\t * ```\n\t * @default 0\n\t */\n\tget x(): number;\n\tset x(value: number);\n\t/**\n\t * Position of the observable point on the y axis.\n\t * Triggers observer callback when value changes.\n\t * @example\n\t * ```ts\n\t * // Basic y position\n\t * const point = new ObservablePoint(observer);\n\t * point.y = 200; // Triggers observer\n\t *\n\t * // Use in calculations\n\t * const height = bottomPoint.y - topPoint.y;\n\t * ```\n\t * @default 0\n\t */\n\tget y(): number;\n\tset y(value: number);\n}\n/**\n * Collection of valid extension types.\n * @category extensions\n * @advanced\n */\nexport enum ExtensionType {\n\t/** extensions that are registered as Application plugins */\n\tApplication = \"application\",\n\t/** extensions that are registered as WebGL render pipes */\n\tWebGLPipes = \"webgl-pipes\",\n\t/** extensions that are registered as WebGL render pipes adaptors */\n\tWebGLPipesAdaptor = \"webgl-pipes-adaptor\",\n\t/** extensions that are registered as WebGL render systems */\n\tWebGLSystem = \"webgl-system\",\n\t/** extensions that are registered as WebGPU render pipes */\n\tWebGPUPipes = \"webgpu-pipes\",\n\t/** extensions that are registered as WebGPU render pipes adaptors */\n\tWebGPUPipesAdaptor = \"webgpu-pipes-adaptor\",\n\t/** extensions that are registered as WebGPU render systems */\n\tWebGPUSystem = \"webgpu-system\",\n\t/** extensions that are registered as Canvas render pipes */\n\tCanvasSystem = \"canvas-system\",\n\t/** extensions that are registered as Canvas render pipes adaptors */\n\tCanvasPipesAdaptor = \"canvas-pipes-adaptor\",\n\t/** extensions that are registered as Canvas render systems */\n\tCanvasPipes = \"canvas-pipes\",\n\t/** extensions that combine the other Asset extensions */\n\tAsset = \"asset\",\n\t/** extensions that are used to load assets through Assets */\n\tLoadParser = \"load-parser\",\n\t/** extensions that are used to resolve asset urls through Assets */\n\tResolveParser = \"resolve-parser\",\n\t/** extensions that are used to handle how urls are cached by Assets */\n\tCacheParser = \"cache-parser\",\n\t/** extensions that are used to add/remove available resources from Assets */\n\tDetectionParser = \"detection-parser\",\n\t/** extensions that are registered with the MaskEffectManager */\n\tMaskEffect = \"mask-effect\",\n\t/** A type of extension for creating a new advanced blend mode */\n\tBlendMode = \"blend-mode\",\n\t/** A type of extension that will be used to auto detect a resource type */\n\tTextureSource = \"texture-source\",\n\t/** A type of extension that will be used to auto detect an environment */\n\tEnvironment = \"environment\",\n\t/** A type of extension for building and triangulating custom shapes used in graphics. */\n\tShapeBuilder = \"shape-builder\",\n\t/** A type of extension for creating custom batchers used in rendering. */\n\tBatcher = \"batcher\"\n}\n/**\n * The metadata for an extension.\n * @category extensions\n * @ignore\n */\nexport interface ExtensionMetadataDetails {\n\t/** The extension type, can be multiple types */\n\ttype: ExtensionType | ExtensionType[];\n\t/** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n\tname?: string;\n\t/** Optional, used for sorting the plugins in a particular order */\n\tpriority?: number;\n}\n/**\n * The metadata for an extension.\n * @category extensions\n * @advanced\n */\nexport type ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @category extensions\n * @advanced\n */\ninterface ExtensionFormat {\n\t/** The extension type, can be multiple types */\n\ttype: ExtensionType | ExtensionType[];\n\t/** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n\tname?: string;\n\t/** Optional, used for sorting the plugins in a particular order */\n\tpriority?: number;\n\t/** Reference to the plugin object/class */\n\tref: any;\n}\n/**\n * Extension format that is used internally for registrations.\n * @category extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat {\n\t/** The extension type, always expressed as multiple, even if a single */\n\ttype: ExtensionType[];\n}\n/**\n * The function that is called when an extension is added or removed.\n * @category extensions\n * @ignore\n */\nexport type ExtensionHandler = (extension: StrictExtensionFormat) => void;\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @category extensions\n */\nexport const normalizeExtensionPriority: (ext: ExtensionFormat | any, defaultPriority: number) => number;\n/**\n * Global registration system for all PixiJS extensions. Provides a centralized way to add, remove,\n * and manage functionality across the engine.\n *\n * Features:\n * - Register custom extensions and plugins\n * - Handle multiple extension types\n * - Priority-based ordering\n * @example\n * ```ts\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // Register a simple object extension\n * extensions.add({\n *   extension: {\n *       type: ExtensionType.LoadParser,\n *       name: 'my-loader',\n *       priority: 100, // Optional priority for ordering\n *   },\n *   // add load parser functions\n * });\n *\n * // Register a class-based extension\n * class MyRendererPlugin {\n *     static extension = {\n *         type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n *         name: 'myRendererPlugin'\n *     };\n *\n *    // add renderer plugin methods\n * }\n * extensions.add(MyRendererPlugin);\n *\n * // Remove extensions\n * extensions.remove(MyRendererPlugin);\n * ```\n * @remarks\n * - Extensions must have a type from {@link ExtensionType}\n * - Can be registered before or after their handlers\n * - Supports priority-based ordering\n * - Automatically normalizes extension formats\n * @see {@link ExtensionType} For all available extension types\n * @see {@link ExtensionFormat} For extension registration format\n * @see {@link Application} For application plugin system\n * @see {@link LoaderParser} For asset loading extensions\n * @category extensions\n * @standard\n * @class\n */\nexport const extensions: {\n\t/** @ignore */\n\t_addHandlers: Partial<Record<ExtensionType, ExtensionHandler>>;\n\t/** @ignore */\n\t_removeHandlers: Partial<Record<ExtensionType, ExtensionHandler>>;\n\t/** @ignore */\n\t_queue: Partial<Record<ExtensionType, StrictExtensionFormat[]>>;\n\t/**\n\t * Remove extensions from PixiJS.\n\t * @param extensions - Extensions to be removed. Can be:\n\t * - Extension class with static `extension` property\n\t * - Extension format object with `type` and `ref`\n\t * - Multiple extensions as separate arguments\n\t * @returns {extensions} this for chaining\n\t * @example\n\t * ```ts\n\t * // Remove a single extension\n\t * extensions.remove(MyRendererPlugin);\n\t *\n\t * // Remove multiple extensions\n\t * extensions.remove(\n\t *     MyRendererPlugin,\n\t *     MySystemPlugin\n\t * );\n\t * ```\n\t * @see {@link ExtensionType} For available extension types\n\t * @see {@link ExtensionFormat} For extension format details\n\t */\n\tremove(...extensions: Array<ExtensionFormat | any>): any;\n\t/**\n\t * Register new extensions with PixiJS. Extensions can be registered in multiple formats:\n\t * - As a class with a static `extension` property\n\t * - As an extension format object\n\t * - As multiple extensions passed as separate arguments\n\t * @param extensions - Extensions to add to PixiJS. Each can be:\n\t * - A class with static `extension` property\n\t * - An extension format object with `type` and `ref`\n\t * - Multiple extensions as separate arguments\n\t * @returns This extensions instance for chaining\n\t * @example\n\t * ```ts\n\t * // Register a simple extension\n\t * extensions.add(MyRendererPlugin);\n\t *\n\t * // Register multiple extensions\n\t * extensions.add(\n\t *     MyRendererPlugin,\n\t *     MySystemPlugin,\n\t * });\n\t * ```\n\t * @see {@link ExtensionType} For available extension types\n\t * @see {@link ExtensionFormat} For extension format details\n\t * @see {@link extensions.remove} For removing registered extensions\n\t */\n\tadd(...extensions: Array<ExtensionFormat | any>): any;\n\t/**\n\t * Internal method to handle extensions by name.\n\t * @param type - The extension type.\n\t * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n\t * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n\t * @returns this for chaining.\n\t * @internal\n\t * @ignore\n\t */\n\thandle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler): any;\n\t/**\n\t * Handle a type, but using a map by `name` property.\n\t * @param type - Type of extension to handle.\n\t * @param map - The object map of named extensions.\n\t * @returns this for chaining.\n\t * @ignore\n\t */\n\thandleByMap(type: ExtensionType, map: Record<string, any>): any;\n\t/**\n\t * Handle a type, but using a list of extensions with a `name` property.\n\t * @param type - Type of extension to handle.\n\t * @param map - The array of named extensions.\n\t * @param defaultPriority - Fallback priority if none is defined.\n\t * @returns this for chaining.\n\t * @ignore\n\t */\n\thandleByNamedList(type: ExtensionType, map: {\n\t\tname: string;\n\t\tvalue: any;\n\t}[], defaultPriority?: number): any;\n\t/**\n\t * Handle a type, but using a list of extensions.\n\t * @param type - Type of extension to handle.\n\t * @param list - The list of extensions.\n\t * @param defaultPriority - The default priority to use if none is specified.\n\t * @returns this for chaining.\n\t * @ignore\n\t */\n\thandleByList(type: ExtensionType, list: any[], defaultPriority?: number): any;\n\t/**\n\t * Mixin the source object(s) properties into the target class's prototype.\n\t * Copies all property descriptors from source objects to the target's prototype.\n\t * @param Target - The target class to mix properties into\n\t * @param sources - One or more source objects containing properties to mix in\n\t * @example\n\t * ```ts\n\t * // Create a mixin with shared properties\n\t * const moveable = {\n\t *     x: 0,\n\t *     y: 0,\n\t *     move(x: number, y: number) {\n\t *         this.x += x;\n\t *         this.y += y;\n\t *     }\n\t * };\n\t *\n\t * // Create a mixin with computed properties\n\t * const scalable = {\n\t *     scale: 1,\n\t *     get scaled() {\n\t *         return this.scale > 1;\n\t *     }\n\t * };\n\t *\n\t * // Apply mixins to a class\n\t * extensions.mixin(Sprite, moveable, scalable);\n\t *\n\t * // Use mixed-in properties\n\t * const sprite = new Sprite();\n\t * sprite.move(10, 20);\n\t * console.log(sprite.x, sprite.y); // 10, 20\n\t * ```\n\t * @remarks\n\t * - Copies all properties including getters/setters\n\t * - Does not modify source objects\n\t * - Preserves property descriptors\n\t * @see {@link Object.defineProperties} For details on property descriptors\n\t * @see {@link Object.getOwnPropertyDescriptors} For details on property copying\n\t */\n\tmixin(Target: any, ...sources: Parameters<typeof Object.getOwnPropertyDescriptors>[0][]): void;\n};\n/**\n * Interface for HTMLImageElement.\n * @category environment\n * @advanced\n */\nexport interface ImageLike extends EventTarget {\n\t/** Whether or not the image has completely loaded. */\n\treadonly complete: boolean;\n\t/** The Cross-Origin Resource Sharing (CORS) setting to use when retrieving the image. */\n\tcrossOrigin: string | null;\n\t/** The URL of the image which is currently presented in the <img> element it represents. */\n\treadonly currentSrc: string;\n\t/** The width. */\n\twidth: number;\n\t/** The height. */\n\theight: number;\n\t/** The address or URL of the a media resource that is to be considered. */\n\tsrc: string;\n\t/** Returns a Promise that resolves once the image is decoded. */\n\tdecode(): Promise<void>;\n\t/** Removes the image from the DOM and cleans up resources. */\n\tremove(): void;\n\tonload: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n\tonerror: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n}\n/**\n * Common interface for CanvasRenderingContext2D, OffscreenCanvasRenderingContext2D, and other custom canvas 2D context.\n * @category environment\n * @advanced\n */\nexport interface ICanvasRenderingContext2D extends CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, Omit<CanvasTextDrawingStyles, \"letterSpacing\">, CanvasPath {\n\t/** creates a pattern using the specified image and repetition. */\n\tcreatePattern(image: CanvasImageSource | ICanvas | ImageLike, repetition: string | null): CanvasPattern | null;\n\t/** provides different ways to draw an image onto the canvas */\n\tdrawImage(image: CanvasImageSource | ICanvas | ImageLike, dx: number, dy: number): void;\n\tdrawImage(image: CanvasImageSource | ICanvas | ImageLike, dx: number, dy: number, dw: number, dh: number): void;\n\tdrawImage(image: CanvasImageSource | ICanvas | ImageLike, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;\n\t/** sets the horizontal spacing behavior between text characters. */\n\tletterSpacing?: string;\n\t/** sets the horizontal spacing behavior between text characters. */\n\ttextLetterSpacing?: string;\n}\n/**\n * The context identifiers for the canvas.\n * These identifiers are used to specify the type of rendering context to create.\n * @category environment\n * @advanced\n */\nexport type ContextIds = \"2d\" | \"bitmaprenderer\" | \"webgl\" | \"experimental-webgl\" | \"webgl2\" | \"experimental-webgl2\" | \"webgpu\";\n/**\n * The predefined color spaces for the canvas.\n * @category environment\n * @advanced\n */\ntype PredefinedColorSpace$1 = \"srgb\" | \"display-p3\";\n/**\n * The rendering context for the canvas.\n * @category environment\n * @advanced\n */\ntype RenderingContext$1 = ICanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext;\n/**\n * The context 2D settings for creating a rendering context.\n * @category environment\n * @advanced\n */\nexport interface ICanvasRenderingContext2DSettings {\n\talpha?: boolean;\n\tcolorSpace?: PredefinedColorSpace$1;\n\tdesynchronized?: boolean;\n\twillReadFrequently?: boolean;\n}\n/**\n * The context settings for creating a rendering context.\n * @category environment\n * @advanced\n */\nexport type ContextSettings = ICanvasRenderingContext2DSettings | ImageBitmapRenderingContextSettings | WebGLContextAttributes;\n/**\n * The parent node of the canvas.\n * @category environment\n * @advanced\n */\nexport interface ICanvasParentNode {\n\t/** Adds a node to the end of the list of children of the parent node. */\n\tappendChild(element: HTMLElement): void;\n\t/** Removes a child node from the parent node. */\n\tremoveChild(element: HTMLElement): void;\n\tremoveChild(element: ICanvas): void;\n}\n/**\n * Represents the style properties of a canvas element.\n * @category environment\n * @advanced\n */\nexport interface ICanvasStyle {\n\twidth?: string;\n\theight?: string;\n\tcursor?: string;\n\ttouchAction?: string;\n\tmsTouchAction?: string;\n\tmsContentZooming?: string;\n}\n/**\n * Represents a rectangle in the canvas.\n * @category environment\n * @advanced\n */\nexport interface ICanvasRect {\n\t/** The x-coordinate of the rectangle's top-left corner. */\n\tx: number;\n\t/** The y-coordinate of the rectangle's top-left corner. */\n\ty: number;\n\t/** The width of the rectangle. */\n\twidth: number;\n\t/** The height of the rectangle. */\n\theight: number;\n}\n/**\n * WebGL context events.\n * @category environment\n * @advanced\n */\nexport interface WebGLContextEventMap {\n\t\"webglcontextlost\": WebGLContextEvent;\n\t\"webglcontextrestore\": WebGLContextEvent;\n}\n/**\n * Common interface for HTMLCanvasElement, OffscreenCanvas, and other custom canvas classes.\n * @extends PixiMixins.ICanvas\n * @extends Partial<EventTarget>\n * @category environment\n * @advanced\n */\nexport interface ICanvas extends PixiMixins.ICanvas, Partial<EventTarget> {\n\t/** Width of the canvas. */\n\twidth: number;\n\t/** Height of the canvas. */\n\theight: number;\n\t/**\n\t * Get rendering context of the canvas.\n\t * @param {ContextIds} contextId - The identifier of the type of context to create.\n\t * @param {ContextSettings} options - The options for creating context.\n\t * @returns {RenderingContext | null} The created context, or null if contextId is not supported.\n\t */\n\tgetContext(contextId: \"2d\", options?: ICanvasRenderingContext2DSettings): ICanvasRenderingContext2D | null;\n\tgetContext(contextId: \"bitmaprenderer\", options?: ImageBitmapRenderingContextSettings): ImageBitmapRenderingContext | null;\n\tgetContext(contextId: \"webgl\" | \"experimental-webgl\", options?: WebGLContextAttributes): WebGLRenderingContext | null;\n\tgetContext(contextId: \"webgl2\" | \"experimental-webgl2\", options?: WebGLContextAttributes): WebGL2RenderingContext | null;\n\tgetContext(contextId: \"webgpu\"): GPUCanvasContext | null;\n\tgetContext(contextId: ContextIds, options?: ContextSettings): RenderingContext$1 | null;\n\t/**\n\t * Get the content of the canvas as data URL.\n\t * @param {string} [type] - A string indicating the image format. The default type is `image/png`;\n\t *      that type is also used if the given type isn't supported.\n\t * @param {string} [quality] - A number between 0 and 1 indicating the image quality to be used when\n\t *      creating images using file formats that support lossy compression (such as `image/jpeg` or `image/webp`).\n\t *      A user agent will use its default quality value if this option is not specified, or if the number\n\t *      is outside the allowed range.\n\t * @returns {string} A string containing the requested data URL.\n\t */\n\ttoDataURL?(type?: string, quality?: number): string;\n\t/**\n\t * Creates a Blob from the content of the canvas.\n\t * @param {(blob: Blob | null) => void} callback - A callback function with the resulting `Blob` object\n\t *      as a single argument. `null` may be passed if the image cannot be created for any reason.\n\t * @param {string} [type] - A string indicating the image format. The default type is `image/png`;\n\t *      that type is also used if the given type isn't supported.\n\t * @param {string} [quality] - A number between 0 and 1 indicating the image quality to be used when\n\t *      creating images using file formats that support lossy compression (such as `image/jpeg` or `image/webp`).\n\t *      A user agent will use its default quality value if this option is not specified, or if the number\n\t *      is outside the allowed range.\n\t * @returns {void}\n\t */\n\ttoBlob?(callback: (blob: Blob | null) => void, type?: string, quality?: number): void;\n\t/**\n\t * Get the content of the canvas as Blob.\n\t * @param {object} [options] - The options for creating Blob.\n\t * @param {string} [options.type] - A string indicating the image format. The default type is `image/png`;\n\t *      that type is also used if the given type isn't supported.\n\t * @param {string} [options.quality] - A number between 0 and 1 indicating the image quality to be used when\n\t *      creating images using file formats that support lossy compression (such as `image/jpeg` or `image/webp`).\n\t *      A user agent will use its default quality value if this option is not specified, or if the number\n\t *      is outside the allowed range.\n\t * @returns {Promise<Blob>} A `Promise` returning a Blob object representing the image contained in the canvas.\n\t */\n\tconvertToBlob?(options?: {\n\t\ttype?: string;\n\t\tquality?: number;\n\t}): Promise<Blob>;\n\t/**\n\t * Adds the listener for the specified event.\n\t * @param {string} type - The type of event to listen for.\n\t * @param {EventListenerOrEventListenerObject} listener - The callback to invoke when the event is fired.\n\t * @param {boolean | AddEventListenerOptions} options - The options for adding event listener.\n\t * @returns {void}\n\t */\n\taddEventListener?: {\n\t\t(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n\t\t<K extends keyof WebGLContextEventMap>(type: K, listener: (this: ICanvas, ev: WebGLContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n\t};\n\t/**\n\t * Removes the listener for the specified event.\n\t * @param {string} type - The type of event to listen for.\n\t * @param {EventListenerOrEventListenerObject} listener - The callback to invoke when the event is fired.\n\t * @param {boolean | EventListenerOptions} options - The options for removing event listener.\n\t * @returns {void}\n\t */\n\tremoveEventListener?: {\n\t\t(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n\t\t<K extends keyof WebGLContextEventMap>(type: K, listener: (this: ICanvas, ev: WebGLContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n\t};\n\t/**\n\t * Dispatches a event.\n\t * @param {Event} event - The Event object to dispatch. Its Event.target property will be set to the current EventTarget.\n\t * @returns {boolean} Returns false if event is cancelable, and at least one of the event handlers which received event\n\t *                    called Event.preventDefault(). Otherwise true.\n\t */\n\tdispatchEvent(event: Event): boolean;\n\t/** Parent node of the canvas. */\n\treadonly parentNode?: ICanvasParentNode | null;\n\t/** Style of the canvas. */\n\treadonly style?: ICanvasStyle;\n\t/**\n\t * Get the position and the size of the canvas.\n\t * @returns The smallest rectangle which contains the entire canvas.\n\t */\n\tgetBoundingClientRect?(): ICanvasRect;\n}\ndeclare function earcut(vertices: ArrayLike<number>, holes?: ArrayLike<number>, dimensions?: number): number[];\n/**\n * A polygon triangulation library\n * @see {@link https://github.com/mapbox/earcut}\n * @param {number[]} vertices - A flat array of vertex coordinates\n * @param {number[]} [holes] - An array of hole indices\n * @param {number} [dimensions=2] - The number of coordinates per vertex in the input array\n * @returns {number[]} Triangulated polygon\n * @category utils\n * @advanced\n */\ndeclare const earcut$1: typeof earcut;\n/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @category rendering\n * @internal\n */\nexport class SystemRunner {\n\titems: any[];\n\tprivate _name;\n\t/**\n\t * @param name - The function name that will be executed on the listeners added to this Runner.\n\t */\n\tconstructor(name: string);\n\t/**\n\t * Dispatch/Broadcast Runner to all listeners added to the queue.\n\t * @param {...any} params - (optional) parameters to pass to each listener\n\t */\n\temit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown, a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this;\n\t/**\n\t * Add a listener to the Runner\n\t *\n\t * Runners do not need to have scope or functions passed to them.\n\t * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n\t * as the name provided to the Runner when it was created.\n\t *\n\t * Eg A listener passed to this Runner will require a 'complete' function.\n\t *\n\t * ```ts\n\t * import { Runner } from 'pixi.js';\n\t *\n\t * const complete = new Runner('complete');\n\t * ```\n\t *\n\t * The scope used will be the object itself.\n\t * @param {any} item - The object that will be listening.\n\t */\n\tadd(item: unknown): this;\n\t/**\n\t * Remove a single listener from the dispatch queue.\n\t * @param {any} item - The listener that you would like to remove.\n\t */\n\tremove(item: unknown): this;\n\t/**\n\t * Check to see if the listener is already in the Runner\n\t * @param {any} item - The listener that you would like to check.\n\t */\n\tcontains(item: unknown): boolean;\n\t/** Remove all listeners from the Runner */\n\tremoveAll(): this;\n\t/** Remove all references, don't use after this. */\n\tdestroy(): void;\n\t/**\n\t * `true` if there are no this Runner contains no listeners\n\t * @readonly\n\t */\n\tget empty(): boolean;\n\t/**\n\t * The name of the runner.\n\t * @readonly\n\t */\n\tget name(): string;\n}\n/**\n * A simple axis-aligned bounding box (AABB) data structure used to define rectangular boundaries.\n * Provides a clearer alternative to array-based bounds representation [minX, minY, maxX, maxY].\n * @example\n * ```ts\n * // Create bounds data\n * const bounds: BoundsData = {\n *     minX: 0,\n *     minY: 0,\n *     maxX: 100,\n *     maxY: 100\n * };\n *\n * // Calculate dimensions\n * const width = bounds.maxX - bounds.minX;\n * const height = bounds.maxY - bounds.minY;\n *\n * // Check if point is inside\n * const isInside = (x: number, y: number) =>\n *     x >= bounds.minX && x <= bounds.maxX &&\n *     y >= bounds.minY && y <= bounds.maxY;\n * ```\n * @see {@link Bounds} For full bounds implementation\n * @see {@link Container#getBounds} For getting bounds\n * @category rendering\n * @standard\n */\nexport interface BoundsData {\n\t/** The minimum X coordinate of the bounds */\n\tminX: number;\n\t/** The minimum Y coordinate of the bounds */\n\tminY: number;\n\t/** The maximum X coordinate of the bounds */\n\tmaxX: number;\n\t/** The maximum Y coordinate of the bounds */\n\tmaxY: number;\n}\n/**\n * A representation of an axis-aligned bounding box (AABB) used for efficient collision detection and culling.\n * Stores minimum and maximum coordinates to define a rectangular boundary.\n * @example\n * ```ts\n * // Create bounds\n * const bounds = new Bounds();\n *\n * // Add a rectangular frame\n * bounds.addFrame(0, 0, 100, 100);\n * console.log(bounds.width, bounds.height); // 100, 100\n *\n * // Transform bounds\n * const matrix = new Matrix()\n *     .translate(50, 50)\n *     .rotate(Math.PI / 4);\n * bounds.applyMatrix(matrix);\n *\n * // Check point intersection\n * if (bounds.containsPoint(75, 75)) {\n *     console.log('Point is inside bounds!');\n * }\n * ```\n * @category rendering\n * @standard\n */\nexport class Bounds {\n\t/**\n\t * The minimum X coordinate of the bounds.\n\t * Represents the leftmost edge of the bounding box.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * // Set left edge\n\t * bounds.minX = 100;\n\t * ```\n\t * @default Infinity\n\t */\n\tminX: number;\n\t/**\n\t * The minimum Y coordinate of the bounds.\n\t * Represents the topmost edge of the bounding box.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * // Set top edge\n\t * bounds.minY = 100;\n\t * ```\n\t * @default Infinity\n\t */\n\tminY: number;\n\t/**\n\t * The maximum X coordinate of the bounds.\n\t * Represents the rightmost edge of the bounding box.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * // Set right edge\n\t * bounds.maxX = 200;\n\t * // Get width\n\t * const width = bounds.maxX - bounds.minX;\n\t * ```\n\t * @default -Infinity\n\t */\n\tmaxX: number;\n\t/**\n\t * The maximum Y coordinate of the bounds.\n\t * Represents the bottommost edge of the bounding box.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * // Set bottom edge\n\t * bounds.maxY = 200;\n\t * // Get height\n\t * const height = bounds.maxY - bounds.minY;\n\t * ```\n\t * @default -Infinity\n\t */\n\tmaxY: number;\n\t/**\n\t * The transformation matrix applied to this bounds object.\n\t * Used when calculating bounds with transforms.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t *\n\t * // Apply translation matrix\n\t * bounds.matrix = new Matrix()\n\t *     .translate(100, 100);\n\t *\n\t * // Combine transformations\n\t * bounds.matrix = new Matrix()\n\t *     .translate(50, 50)\n\t *     .rotate(Math.PI / 4)\n\t *     .scale(2, 2);\n\t *\n\t * // Use in bounds calculations\n\t * bounds.addFrame(0, 0, 100, 100); // Uses current matrix\n\t * bounds.addFrame(0, 0, 100, 100, customMatrix); // Override matrix\n\t * ```\n\t * @advanced\n\t */\n\tmatrix: Matrix;\n\tprivate _rectangle;\n\t/**\n\t * Creates a new Bounds object.\n\t * @param minX - The minimum X coordinate of the bounds.\n\t * @param minY - The minimum Y coordinate of the bounds.\n\t * @param maxX - The maximum X coordinate of the bounds.\n\t * @param maxY - The maximum Y coordinate of the bounds.\n\t */\n\tconstructor(minX?: number, minY?: number, maxX?: number, maxY?: number);\n\t/**\n\t * Checks if bounds are empty, meaning either width or height is zero or negative.\n\t * Empty bounds occur when min values exceed max values on either axis.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t *\n\t * // Check if newly created bounds are empty\n\t * console.log(bounds.isEmpty()); // true, default bounds are empty\n\t *\n\t * // Add frame and check again\n\t * bounds.addFrame(0, 0, 100, 100);\n\t * console.log(bounds.isEmpty()); // false, bounds now have area\n\t *\n\t * // Clear bounds\n\t * bounds.clear();\n\t * console.log(bounds.isEmpty()); // true, bounds are empty again\n\t * ```\n\t * @returns True if bounds are empty (have no area)\n\t * @see {@link Bounds#clear} For resetting bounds\n\t * @see {@link Bounds#isValid} For checking validity\n\t */\n\tisEmpty(): boolean;\n\t/**\n\t * The bounding rectangle representation of these bounds.\n\t * Lazily creates and updates a Rectangle instance based on the current bounds.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Get rectangle representation\n\t * const rect = bounds.rectangle;\n\t * console.log(rect.x, rect.y, rect.width, rect.height);\n\t *\n\t * // Use for hit testing\n\t * if (bounds.rectangle.contains(mouseX, mouseY)) {\n\t *     console.log('Mouse is inside bounds!');\n\t * }\n\t * ```\n\t * @see {@link Rectangle} For rectangle methods\n\t * @see {@link Bounds.isEmpty} For bounds validation\n\t */\n\tget rectangle(): Rectangle;\n\t/**\n\t * Clears the bounds and resets all coordinates to their default values.\n\t * Resets the transformation matrix back to identity.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * console.log(bounds.isEmpty()); // false\n\t * // Clear the bounds\n\t * bounds.clear();\n\t * console.log(bounds.isEmpty()); // true\n\t * ```\n\t * @returns This bounds object for chaining\n\t */\n\tclear(): this;\n\t/**\n\t * Sets the bounds directly using coordinate values.\n\t * Provides a way to set all bounds values at once.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * bounds.set(0, 0, 100, 100);\n\t * ```\n\t * @param x0 - Left X coordinate of frame\n\t * @param y0 - Top Y coordinate of frame\n\t * @param x1 - Right X coordinate of frame\n\t * @param y1 - Bottom Y coordinate of frame\n\t * @see {@link Bounds#addFrame} For matrix-aware bounds setting\n\t * @see {@link Bounds#clear} For resetting bounds\n\t */\n\tset(x0: number, y0: number, x1: number, y1: number): void;\n\t/**\n\t * Adds a rectangular frame to the bounds, optionally transformed by a matrix.\n\t * Updates the bounds to encompass the new frame coordinates.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * bounds.addFrame(0, 0, 100, 100);\n\t *\n\t * // Add transformed frame\n\t * const matrix = new Matrix()\n\t *     .translate(50, 50)\n\t *     .rotate(Math.PI / 4);\n\t * bounds.addFrame(0, 0, 100, 100, matrix);\n\t * ```\n\t * @param x0 - Left X coordinate of frame\n\t * @param y0 - Top Y coordinate of frame\n\t * @param x1 - Right X coordinate of frame\n\t * @param y1 - Bottom Y coordinate of frame\n\t * @param matrix - Optional transformation matrix\n\t * @see {@link Bounds#addRect} For adding Rectangle objects\n\t * @see {@link Bounds#addBounds} For adding other Bounds\n\t */\n\taddFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void;\n\t/**\n\t * Adds a rectangle to the bounds, optionally transformed by a matrix.\n\t * Updates the bounds to encompass the given rectangle.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * // Add simple rectangle\n\t * const rect = new Rectangle(0, 0, 100, 100);\n\t * bounds.addRect(rect);\n\t *\n\t * // Add transformed rectangle\n\t * const matrix = new Matrix()\n\t *     .translate(50, 50)\n\t *     .rotate(Math.PI / 4);\n\t * bounds.addRect(rect, matrix);\n\t * ```\n\t * @param rect - The rectangle to be added\n\t * @param matrix - Optional transformation matrix\n\t * @see {@link Bounds#addFrame} For adding raw coordinates\n\t * @see {@link Bounds#addBounds} For adding other bounds\n\t */\n\taddRect(rect: Rectangle, matrix?: Matrix): void;\n\t/**\n\t * Adds another bounds object to this one, optionally transformed by a matrix.\n\t * Expands the bounds to include the given bounds' area.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t *\n\t * // Add child bounds\n\t * const childBounds = sprite.getBounds();\n\t * bounds.addBounds(childBounds);\n\t *\n\t * // Add transformed bounds\n\t * const matrix = new Matrix()\n\t *     .scale(2, 2);\n\t * bounds.addBounds(childBounds, matrix);\n\t * ```\n\t * @param bounds - The bounds to be added\n\t * @param matrix - Optional transformation matrix\n\t * @see {@link Bounds#addFrame} For adding raw coordinates\n\t * @see {@link Bounds#addRect} For adding rectangles\n\t */\n\taddBounds(bounds: BoundsData, matrix?: Matrix): void;\n\t/**\n\t * Adds other Bounds as a mask, creating an intersection of the two bounds.\n\t * Only keeps the overlapping region between current bounds and mask bounds.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Create mask bounds\n\t * const mask = new Bounds();\n\t * mask.addFrame(50, 50, 150, 150);\n\t * // Apply mask - results in bounds of (50,50,100,100)\n\t * bounds.addBoundsMask(mask);\n\t * ```\n\t * @param mask - The Bounds to use as a mask\n\t * @see {@link Bounds#addBounds} For union operation\n\t * @see {@link Bounds#fit} For fitting to rectangle\n\t */\n\taddBoundsMask(mask: Bounds): void;\n\t/**\n\t * Applies a transformation matrix to the bounds, updating its coordinates.\n\t * Transforms all corners of the bounds using the given matrix.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Apply translation\n\t * const translateMatrix = new Matrix()\n\t *     .translate(50, 50);\n\t * bounds.applyMatrix(translateMatrix);\n\t * ```\n\t * @param matrix - The matrix to apply to the bounds\n\t * @see {@link Matrix} For matrix operations\n\t * @see {@link Bounds#addFrame} For adding transformed frames\n\t */\n\tapplyMatrix(matrix: Matrix): void;\n\t/**\n\t * Resizes the bounds object to fit within the given rectangle.\n\t * Clips the bounds if they extend beyond the rectangle's edges.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 200, 200);\n\t * // Fit within viewport\n\t * const viewport = new Rectangle(50, 50, 100, 100);\n\t * bounds.fit(viewport);\n\t * // bounds are now (50, 50, 150, 150)\n\t * ```\n\t * @param rect - The rectangle to fit within\n\t * @returns This bounds object for chaining\n\t * @see {@link Bounds#addBoundsMask} For intersection\n\t * @see {@link Bounds#pad} For expanding bounds\n\t */\n\tfit(rect: Rectangle): this;\n\t/**\n\t * Resizes the bounds object to include the given bounds.\n\t * Similar to fit() but works with raw coordinate values instead of a Rectangle.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 200, 200);\n\t * // Fit to specific coordinates\n\t * bounds.fitBounds(50, 150, 50, 150);\n\t * // bounds are now (50, 50, 150, 150)\n\t * ```\n\t * @param left - The left value of the bounds\n\t * @param right - The right value of the bounds\n\t * @param top - The top value of the bounds\n\t * @param bottom - The bottom value of the bounds\n\t * @returns This bounds object for chaining\n\t * @see {@link Bounds#fit} For fitting to Rectangle\n\t * @see {@link Bounds#addBoundsMask} For intersection\n\t */\n\tfitBounds(left: number, right: number, top: number, bottom: number): this;\n\t/**\n\t * Pads bounds object, making it grow in all directions.\n\t * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Add equal padding\n\t * bounds.pad(10);\n\t * // bounds are now (-10, -10, 110, 110)\n\t *\n\t * // Add different padding for x and y\n\t * bounds.pad(20, 10);\n\t * // bounds are now (-30, -20, 130, 120)\n\t * ```\n\t * @param paddingX - The horizontal padding amount\n\t * @param paddingY - The vertical padding amount\n\t * @returns This bounds object for chaining\n\t * @see {@link Bounds#fit} For constraining bounds\n\t * @see {@link Bounds#scale} For uniform scaling\n\t */\n\tpad(paddingX: number, paddingY?: number): this;\n\t/**\n\t * Ceils the bounds by rounding up max values and rounding down min values.\n\t * Useful for pixel-perfect calculations and avoiding fractional pixels.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * bounds.set(10.2, 10.9, 50.1, 50.8);\n\t *\n\t * // Round to whole pixels\n\t * bounds.ceil();\n\t * // bounds are now (10, 10, 51, 51)\n\t * ```\n\t * @returns This bounds object for chaining\n\t * @see {@link Bounds#scale} For size adjustments\n\t * @see {@link Bounds#fit} For constraining bounds\n\t */\n\tceil(): this;\n\t/**\n\t * Creates a new Bounds instance with the same values.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Create a copy\n\t * const copy = bounds.clone();\n\t *\n\t * // Original and copy are independent\n\t * bounds.pad(10);\n\t * console.log(copy.width === bounds.width); // false\n\t * ```\n\t * @returns A new Bounds instance with the same values\n\t * @see {@link Bounds#copyFrom} For reusing existing bounds\n\t */\n\tclone(): Bounds;\n\t/**\n\t * Scales the bounds by the given values, adjusting all edges proportionally.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Scale uniformly\n\t * bounds.scale(2);\n\t * // bounds are now (0, 0, 200, 200)\n\t *\n\t * // Scale non-uniformly\n\t * bounds.scale(0.5, 2);\n\t * // bounds are now (0, 0, 100, 400)\n\t * ```\n\t * @param x - The X value to scale by\n\t * @param y - The Y value to scale by (defaults to x)\n\t * @returns This bounds object for chaining\n\t * @see {@link Bounds#pad} For adding padding\n\t * @see {@link Bounds#fit} For constraining size\n\t */\n\tscale(x: number, y?: number): this;\n\t/**\n\t * The x position of the bounds in local space.\n\t * Setting this value will move the bounds while maintaining its width.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get x position\n\t * console.log(bounds.x); // 0\n\t *\n\t * // Move bounds horizontally\n\t * bounds.x = 50;\n\t * console.log(bounds.minX, bounds.maxX); // 50, 150\n\t *\n\t * // Width stays the same\n\t * console.log(bounds.width); // Still 100\n\t * ```\n\t */\n\tget x(): number;\n\tset x(value: number);\n\t/**\n\t * The y position of the bounds in local space.\n\t * Setting this value will move the bounds while maintaining its height.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get y position\n\t * console.log(bounds.y); // 0\n\t *\n\t * // Move bounds vertically\n\t * bounds.y = 50;\n\t * console.log(bounds.minY, bounds.maxY); // 50, 150\n\t *\n\t * // Height stays the same\n\t * console.log(bounds.height); // Still 100\n\t * ```\n\t */\n\tget y(): number;\n\tset y(value: number);\n\t/**\n\t * The width value of the bounds.\n\t * Represents the distance between minX and maxX coordinates.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get width\n\t * console.log(bounds.width); // 100\n\t * // Resize width\n\t * bounds.width = 200;\n\t * console.log(bounds.maxX - bounds.minX); // 200\n\t * ```\n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height value of the bounds.\n\t * Represents the distance between minY and maxY coordinates.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get height\n\t * console.log(bounds.height); // 100\n\t * // Resize height\n\t * bounds.height = 150;\n\t * console.log(bounds.maxY - bounds.minY); // 150\n\t * ```\n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * The left edge coordinate of the bounds.\n\t * Alias for minX.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(50, 0, 150, 100);\n\t * console.log(bounds.left); // 50\n\t * console.log(bounds.left === bounds.minX); // true\n\t * ```\n\t * @readonly\n\t */\n\tget left(): number;\n\t/**\n\t * The right edge coordinate of the bounds.\n\t * Alias for maxX.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * console.log(bounds.right); // 100\n\t * console.log(bounds.right === bounds.maxX); // true\n\t * ```\n\t * @readonly\n\t */\n\tget right(): number;\n\t/**\n\t * The top edge coordinate of the bounds.\n\t * Alias for minY.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 25, 100, 125);\n\t * console.log(bounds.top); // 25\n\t * console.log(bounds.top === bounds.minY); // true\n\t * ```\n\t * @readonly\n\t */\n\tget top(): number;\n\t/**\n\t * The bottom edge coordinate of the bounds.\n\t * Alias for maxY.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 200);\n\t * console.log(bounds.bottom); // 200\n\t * console.log(bounds.bottom === bounds.maxY); // true\n\t * ```\n\t * @readonly\n\t */\n\tget bottom(): number;\n\t/**\n\t * Whether the bounds has positive width and height.\n\t * Checks if both dimensions are greater than zero.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Check if bounds are positive\n\t * console.log(bounds.isPositive); // true\n\t *\n\t * // Negative bounds\n\t * bounds.maxX = bounds.minX;\n\t * console.log(bounds.isPositive); // false, width is 0\n\t * ```\n\t * @readonly\n\t * @see {@link Bounds#isEmpty} For checking empty state\n\t * @see {@link Bounds#isValid} For checking validity\n\t */\n\tget isPositive(): boolean;\n\t/**\n\t * Whether the bounds has valid coordinates.\n\t * Checks if the bounds has been initialized with real values.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t * console.log(bounds.isValid); // false, default state\n\t *\n\t * // Set valid bounds\n\t * bounds.addFrame(0, 0, 100, 100);\n\t * console.log(bounds.isValid); // true\n\t * ```\n\t * @readonly\n\t * @see {@link Bounds#isEmpty} For checking empty state\n\t * @see {@link Bounds#isPositive} For checking dimensions\n\t */\n\tget isValid(): boolean;\n\t/**\n\t * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.\n\t * Used for efficiently updating bounds from raw vertex data.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds();\n\t *\n\t * // Add vertices from geometry\n\t * const vertices = new Float32Array([\n\t *     0, 0,    // Vertex 1\n\t *     100, 0,  // Vertex 2\n\t *     100, 100 // Vertex 3\n\t * ]);\n\t * bounds.addVertexData(vertices, 0, 6);\n\t *\n\t * // Add transformed vertices\n\t * const matrix = new Matrix()\n\t *     .translate(50, 50)\n\t *     .rotate(Math.PI / 4);\n\t * bounds.addVertexData(vertices, 0, 6, matrix);\n\t *\n\t * // Add subset of vertices\n\t * bounds.addVertexData(vertices, 2, 4); // Only second vertex\n\t * ```\n\t * @param vertexData - The array of vertices to add\n\t * @param beginOffset - Starting index in the vertex array\n\t * @param endOffset - Ending index in the vertex array (excluded)\n\t * @param matrix - Optional transformation matrix\n\t * @see {@link Bounds#addFrame} For adding rectangular frames\n\t * @see {@link Matrix} For transformation details\n\t */\n\taddVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void;\n\t/**\n\t * Checks if a point is contained within the bounds.\n\t * Returns true if the point's coordinates fall within the bounds' area.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Basic point check\n\t * console.log(bounds.containsPoint(50, 50)); // true\n\t * console.log(bounds.containsPoint(150, 150)); // false\n\t *\n\t * // Check edges\n\t * console.log(bounds.containsPoint(0, 0));   // true, includes edges\n\t * console.log(bounds.containsPoint(100, 100)); // true, includes edges\n\t * ```\n\t * @param x - x coordinate to check\n\t * @param y - y coordinate to check\n\t * @returns True if the point is inside the bounds\n\t * @see {@link Bounds#isPositive} For valid bounds check\n\t * @see {@link Bounds#rectangle} For Rectangle representation\n\t */\n\tcontainsPoint(x: number, y: number): boolean;\n\t/**\n\t * Returns a string representation of the bounds.\n\t * Useful for debugging and logging bounds information.\n\t * @example\n\t * ```ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * console.log(bounds.toString()); // \"[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]\"\n\t * ```\n\t * @returns A string describing the bounds\n\t * @see {@link Bounds#copyFrom} For copying bounds\n\t * @see {@link Bounds#clone} For creating a new instance\n\t */\n\ttoString(): string;\n\t/**\n\t * Copies the bounds from another bounds object.\n\t * Useful for reusing bounds objects and avoiding allocations.\n\t * @example\n\t * ```ts\n\t * const sourceBounds = new Bounds(0, 0, 100, 100);\n\t * // Copy bounds\n\t * const targetBounds = new Bounds();\n\t * targetBounds.copyFrom(sourceBounds);\n\t * ```\n\t * @param bounds - The bounds to copy from\n\t * @returns This bounds object for chaining\n\t * @see {@link Bounds#clone} For creating new instances\n\t */\n\tcopyFrom(bounds: Bounds): this;\n}\n/**\n * Two Pi.\n * @type {number}\n * @category maths\n * @standard\n */\nexport const PI_2: number;\n/**\n * Conversion factor for converting radians to degrees.\n * @type {number} RAD_TO_DEG\n * @category maths\n * @standard\n */\nexport const RAD_TO_DEG: number;\n/**\n * Conversion factor for converting degrees to radians.\n * @type {number}\n * @category maths\n * @standard\n */\nexport const DEG_TO_RAD: number;\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @category maths\n * @advanced\n */\nexport type SHAPE_PRIMITIVE = \"polygon\" | \"rectangle\" | \"circle\" | \"ellipse\" | \"triangle\" | \"roundedRectangle\";\n/**\n * A basic interface that defines common properties and methods for all Pixi shape primitives.\n * Provides a standard API for shape manipulation, hit testing, and bounds calculation.\n * @example\n * ```ts\n * // Implement basic shape\n * class CustomShape implements ShapePrimitive {\n *     public readonly type = 'custom';\n *     public x = 0;\n *     public y = 0;\n *\n *     // Implement required methods\n *     public contains(x: number, y: number): boolean {\n *         // Custom hit testing logic\n *         return true;\n *     }\n *\n *     public getBounds(out?: Rectangle): Rectangle {\n *         // Custom bounds calculation\n *         return out || new Rectangle();\n *     }\n *\n *     // ... implement other required methods\n * }\n * // Use in a container\n * container.hitArea = new CustomShape();\n * ```\n * @see {@link Rectangle} For rectangular shape implementation\n * @see {@link Circle} For circular shape implementation\n * @see {@link Polygon} For polygon shape implementation\n * @category maths\n * @advanced\n */\nexport interface ShapePrimitive {\n\t/** The type of the object, mainly used to avoid `instanceof` checks */\n\treadonly type: SHAPE_PRIMITIVE | (string & {});\n\t/** Checks whether the x and y coordinates passed to this function are contained within this ShapePrimitive. */\n\tcontains(x: number, y: number): boolean;\n\t/** Checks whether the x and y coordinates passed to this function are contained within the stroke of this shape */\n\tstrokeContains(x: number, y: number, strokeWidth: number, alignment?: number): boolean;\n\t/** Creates a clone of this ShapePrimitive instance. */\n\tclone(): ShapePrimitive;\n\t/** Copies the properties from another ShapePrimitive to this ShapePrimitive. */\n\tcopyFrom(source: ShapePrimitive): void;\n\t/** Copies the properties from this ShapePrimitive to another ShapePrimitive. */\n\tcopyTo(destination: ShapePrimitive): void;\n\t/** Returns the framing rectangle of the ShapePrimitive as a Rectangle object. */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/** The X coordinate of the shape */\n\treadonly x: number;\n\t/** The Y coordinate of the shape */\n\treadonly y: number;\n}\nexport interface Rectangle extends PixiMixins.Rectangle {\n}\n/**\n * The `Rectangle` object represents a rectangular area defined by its position and dimensions.\n * Used for hit testing, bounds calculation, and general geometric operations.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new Rectangle(100, 100, 200, 150);\n *\n * // Use as container bounds\n * container.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n *\n * // Manipulate dimensions\n * rect.width *= 2;\n * rect.height += 50;\n * ```\n * @remarks\n * - Position defined by top-left corner (x,y)\n * - Dimensions defined by width and height\n * - Supports point and rectangle containment\n * - Common in UI and layout calculations\n * @see {@link Circle} For circular shapes\n * @see {@link Polygon} For complex shapes\n * @see {@link RoundedRectangle} For rounded corners\n * @category maths\n * @standard\n */\nexport class Rectangle implements ShapePrimitive {\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * ```ts\n\t * // Check shape type\n\t * const shape = new Rectangle(0, 0, 100, 100);\n\t * console.log(shape.type); // 'rectangle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'rectangle') {\n\t *     console.log(shape.width, shape.height);\n\t * }\n\t * ```\n\t * @readonly\n\t * @default 'rectangle'\n\t * @see {@link SHAPE_PRIMITIVE} For all shape types\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * The X coordinate of the upper-left corner of the rectangle\n\t * @example\n\t * ```ts\n\t * // Basic x position\n\t * const rect = new Rectangle();\n\t * rect.x = 100;\n\t * ```\n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the upper-left corner of the rectangle\n\t * @example\n\t * ```ts\n\t * // Basic y position\n\t * const rect = new Rectangle();\n\t * rect.y = 100;\n\t * ```\n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The overall width of this rectangle\n\t * @example\n\t * ```ts\n\t * // Basic width setting\n\t * const rect = new Rectangle();\n\t * rect.width = 200;\n\t * ```\n\t * @default 0\n\t */\n\twidth: number;\n\t/**\n\t * The overall height of this rectangle\n\t * @example\n\t * ```ts\n\t * // Basic height setting\n\t * const rect = new Rectangle();\n\t * rect.height = 150;\n\t * ```\n\t * @default 0\n\t */\n\theight: number;\n\t/**\n\t * @param x - The X coordinate of the upper-left corner of the rectangle\n\t * @param y - The Y coordinate of the upper-left corner of the rectangle\n\t * @param width - The overall width of the rectangle\n\t * @param height - The overall height of the rectangle\n\t */\n\tconstructor(x?: string | number, y?: string | number, width?: string | number, height?: string | number);\n\t/**\n\t * Returns the left edge (x-coordinate) of the rectangle.\n\t * @example\n\t * ```ts\n\t * // Get left edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.left); // 100\n\t *\n\t * // Use in alignment calculations\n\t * sprite.x = rect.left + padding;\n\t *\n\t * // Compare positions\n\t * if (point.x > rect.left) {\n\t *     console.log('Point is right of rectangle');\n\t * }\n\t * ```\n\t * @readonly\n\t * @returns The x-coordinate of the left edge\n\t * @see {@link Rectangle.right} For right edge position\n\t * @see {@link Rectangle.x} For direct x-coordinate access\n\t */\n\tget left(): number;\n\t/**\n\t * Returns the right edge (x + width) of the rectangle.\n\t * @example\n\t * ```ts\n\t * // Get right edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.right); // 300\n\t *\n\t * // Align to right edge\n\t * sprite.x = rect.right - sprite.width;\n\t *\n\t * // Check boundaries\n\t * if (point.x < rect.right) {\n\t *     console.log('Point is inside right bound');\n\t * }\n\t * ```\n\t * @readonly\n\t * @returns The x-coordinate of the right edge\n\t * @see {@link Rectangle.left} For left edge position\n\t * @see {@link Rectangle.width} For width value\n\t */\n\tget right(): number;\n\t/**\n\t * Returns the top edge (y-coordinate) of the rectangle.\n\t * @example\n\t * ```ts\n\t * // Get top edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.top); // 100\n\t *\n\t * // Position above rectangle\n\t * sprite.y = rect.top - sprite.height;\n\t *\n\t * // Check vertical position\n\t * if (point.y > rect.top) {\n\t *     console.log('Point is below top edge');\n\t * }\n\t * ```\n\t * @readonly\n\t * @returns The y-coordinate of the top edge\n\t * @see {@link Rectangle.bottom} For bottom edge position\n\t * @see {@link Rectangle.y} For direct y-coordinate access\n\t */\n\tget top(): number;\n\t/**\n\t * Returns the bottom edge (y + height) of the rectangle.\n\t * @example\n\t * ```ts\n\t * // Get bottom edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.bottom); // 250\n\t *\n\t * // Stack below rectangle\n\t * sprite.y = rect.bottom + margin;\n\t *\n\t * // Check vertical bounds\n\t * if (point.y < rect.bottom) {\n\t *     console.log('Point is above bottom edge');\n\t * }\n\t * ```\n\t * @readonly\n\t * @returns The y-coordinate of the bottom edge\n\t * @see {@link Rectangle.top} For top edge position\n\t * @see {@link Rectangle.height} For height value\n\t */\n\tget bottom(): number;\n\t/**\n\t * Determines whether the Rectangle is empty (has no area).\n\t * @example\n\t * ```ts\n\t * // Check zero dimensions\n\t * const rect = new Rectangle(100, 100, 0, 50);\n\t * console.log(rect.isEmpty()); // true\n\t * ```\n\t * @returns True if the rectangle has no area\n\t * @see {@link Rectangle.width} For width value\n\t * @see {@link Rectangle.height} For height value\n\t */\n\tisEmpty(): boolean;\n\t/**\n\t * A constant empty rectangle. This is a new object every time the property is accessed.\n\t * @example\n\t * ```ts\n\t * // Get fresh empty rectangle\n\t * const empty = Rectangle.EMPTY;\n\t * console.log(empty.isEmpty()); // true\n\t * ```\n\t * @returns A new empty rectangle instance\n\t * @see {@link Rectangle.isEmpty} For empty state testing\n\t */\n\tstatic get EMPTY(): Rectangle;\n\t/**\n\t * Creates a clone of this Rectangle\n\t * @example\n\t * ```ts\n\t * // Basic cloning\n\t * const original = new Rectangle(100, 100, 200, 150);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.width *= 2;\n\t * modified.height += 50;\n\t *\n\t * // Verify independence\n\t * console.log(original.width);  // 200\n\t * console.log(modified.width);  // 400\n\t * ```\n\t * @returns A copy of the rectangle\n\t * @see {@link Rectangle.copyFrom} For copying into existing rectangle\n\t * @see {@link Rectangle.copyTo} For copying to another rectangle\n\t */\n\tclone(): Rectangle;\n\t/**\n\t * Converts a Bounds object to a Rectangle object.\n\t * @example\n\t * ```ts\n\t * // Convert bounds to rectangle\n\t * const bounds = container.getBounds();\n\t * const rect = new Rectangle().copyFromBounds(bounds);\n\t * ```\n\t * @param bounds - The bounds to copy and convert to a rectangle\n\t * @returns Returns itself\n\t * @see {@link Bounds} For bounds object structure\n\t * @see {@link Rectangle.getBounds} For getting rectangle bounds\n\t */\n\tcopyFromBounds(bounds: Bounds): this;\n\t/**\n\t * Copies another rectangle to this one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Rectangle(100, 100, 200, 150);\n\t * const target = new Rectangle();\n\t * target.copyFrom(source);\n\t *\n\t * // Chain with other operations\n\t * const rect = new Rectangle()\n\t *     .copyFrom(source)\n\t *     .pad(10);\n\t * ```\n\t * @param rectangle - The rectangle to copy from\n\t * @returns Returns itself\n\t * @see {@link Rectangle.copyTo} For copying to another rectangle\n\t * @see {@link Rectangle.clone} For creating new rectangle copy\n\t */\n\tcopyFrom(rectangle: Rectangle): Rectangle;\n\t/**\n\t * Copies this rectangle to another one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Rectangle(100, 100, 200, 150);\n\t * const target = new Rectangle();\n\t * source.copyTo(target);\n\t *\n\t * // Chain with other operations\n\t * const result = source\n\t *     .copyTo(new Rectangle())\n\t *     .getBounds();\n\t * ```\n\t * @param rectangle - The rectangle to copy to\n\t * @returns Returns given parameter\n\t * @see {@link Rectangle.copyFrom} For copying from another rectangle\n\t * @see {@link Rectangle.clone} For creating new rectangle copy\n\t */\n\tcopyTo(rectangle: Rectangle): Rectangle;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this Rectangle\n\t * @example\n\t * ```ts\n\t * // Basic containment check\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * const isInside = rect.contains(150, 125); // true\n\t * // Check edge cases\n\t * console.log(rect.contains(100, 100)); // true (on edge)\n\t * console.log(rect.contains(300, 250)); // false (outside)\n\t * ```\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Rectangle\n\t * @see {@link Rectangle.containsRect} For rectangle containment\n\t * @see {@link Rectangle.strokeContains} For checking stroke intersection\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n\t * @example\n\t * ```ts\n\t * // Basic stroke check\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n\t * ```\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this rectangle's stroke\n\t * @see {@link Rectangle.contains} For checking fill containment\n\t * @see {@link Rectangle.getBounds} For getting stroke bounds\n\t */\n\tstrokeContains(x: number, y: number, strokeWidth: number, alignment?: number): boolean;\n\t/**\n\t * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n\t * Returns true only if the area of the intersection is >0, this means that Rectangles\n\t * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n\t * (width or height equal to zero) can't intersect any other rectangle.\n\t * @param {Rectangle} other - The Rectangle to intersect with `this`.\n\t * @param {Matrix} transform - The transformation matrix of `other`.\n\t * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n\t */\n\t/**\n\t * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n\t *\n\t * Returns true only if the area of the intersection is greater than 0.\n\t * This means that rectangles sharing only a side are not considered intersecting.\n\t * @example\n\t * ```ts\n\t * // Basic intersection check\n\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t * const rect2 = new Rectangle(50, 50, 100, 100);\n\t * console.log(rect1.intersects(rect2)); // true\n\t *\n\t * // With transformation matrix\n\t * const matrix = new Matrix();\n\t * matrix.rotate(Math.PI / 4); // 45 degrees\n\t * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation\n\t *\n\t * // Edge cases\n\t * const zeroWidth = new Rectangle(0, 0, 0, 100);\n\t * console.log(rect1.intersects(zeroWidth)); // false (no area)\n\t * ```\n\t * @remarks\n\t * - Returns true only if intersection area is > 0\n\t * - Rectangles sharing only a side are not intersecting\n\t * - Zero-area rectangles cannot intersect anything\n\t * - Supports optional transformation matrix\n\t * @param other - The Rectangle to intersect with `this`\n\t * @param transform - Optional transformation matrix of `other`\n\t * @returns True if the transformed `other` Rectangle intersects with `this`\n\t * @see {@link Rectangle.containsRect} For containment testing\n\t * @see {@link Rectangle.contains} For point testing\n\t */\n\tintersects(other: Rectangle, transform?: Matrix): boolean;\n\t/**\n\t * Pads the rectangle making it grow in all directions.\n\t *\n\t * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n\t * @example\n\t * ```ts\n\t * // Basic padding\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * rect.pad(10); // Adds 10px padding on all sides\n\t *\n\t * // Different horizontal and vertical padding\n\t * const uiRect = new Rectangle(0, 0, 100, 50);\n\t * uiRect.pad(20, 10); // 20px horizontal, 10px vertical\n\t * ```\n\t * @remarks\n\t * - Adjusts x/y by subtracting padding\n\t * - Increases width/height by padding * 2\n\t * - Common in UI layout calculations\n\t * - Chainable with other methods\n\t * @param paddingX - The horizontal padding amount\n\t * @param paddingY - The vertical padding amount\n\t * @returns Returns itself\n\t * @see {@link Rectangle.enlarge} For growing to include another rectangle\n\t * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n\t */\n\tpad(paddingX?: number, paddingY?: number): this;\n\t/**\n\t * Fits this rectangle around the passed one.\n\t * @example\n\t * ```ts\n\t * // Basic fitting\n\t * const container = new Rectangle(0, 0, 100, 100);\n\t * const content = new Rectangle(25, 25, 200, 200);\n\t * content.fit(container); // Clips to container bounds\n\t * ```\n\t * @param rectangle - The rectangle to fit around\n\t * @returns Returns itself\n\t * @see {@link Rectangle.enlarge} For growing to include another rectangle\n\t * @see {@link Rectangle.pad} For adding padding around the rectangle\n\t */\n\tfit(rectangle: Rectangle): this;\n\t/**\n\t * Enlarges rectangle so that its corners lie on a grid defined by resolution.\n\t * @example\n\t * ```ts\n\t * // Basic grid alignment\n\t * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);\n\t * rect.ceil(); // Aligns to whole pixels\n\t *\n\t * // Custom resolution grid\n\t * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);\n\t * uiRect.ceil(0.5); // Aligns to half pixels\n\t *\n\t * // Use with precision value\n\t * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);\n\t * preciseRect.ceil(1, 0.01); // Handles small decimal variations\n\t * ```\n\t * @param resolution - The grid size to align to (1 = whole pixels)\n\t * @param eps - Small number to prevent floating point errors\n\t * @returns Returns itself\n\t * @see {@link Rectangle.fit} For constraining to bounds\n\t * @see {@link Rectangle.enlarge} For growing dimensions\n\t */\n\tceil(resolution?: number, eps?: number): this;\n\t/**\n\t * Scales the rectangle's dimensions and position by the specified factors.\n\t * @example\n\t * ```ts\n\t * const rect = new Rectangle(50, 50, 100, 100);\n\t *\n\t * // Scale uniformly\n\t * rect.scale(0.5, 0.5);\n\t * // rect is now: x=25, y=25, width=50, height=50\n\t *\n\t * // non-uniformly\n\t * rect.scale(0.5, 1);\n\t * // rect is now: x=25, y=50, width=50, height=100\n\t * ```\n\t * @param x - The factor by which to scale the horizontal properties (x, width).\n\t * @param y - The factor by which to scale the vertical properties (y, height).\n\t * @returns Returns itself\n\t */\n\tscale(x: number, y?: number): this;\n\t/**\n\t * Enlarges this rectangle to include the passed rectangle.\n\t * @example\n\t * ```ts\n\t * // Basic enlargement\n\t * const rect = new Rectangle(50, 50, 100, 100);\n\t * const other = new Rectangle(0, 0, 200, 75);\n\t * rect.enlarge(other);\n\t * // rect is now: x=0, y=0, width=200, height=150\n\t *\n\t * // Use for bounding box calculation\n\t * const bounds = new Rectangle();\n\t * objects.forEach((obj) => {\n\t *     bounds.enlarge(obj.getBounds());\n\t * });\n\t * ```\n\t * @param rectangle - The rectangle to include\n\t * @returns Returns itself\n\t * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n\t * @see {@link Rectangle.pad} For adding padding around the rectangle\n\t */\n\tenlarge(rectangle: Rectangle): this;\n\t/**\n\t * Returns the framing rectangle of the rectangle as a Rectangle object\n\t * @example\n\t * ```ts\n\t * // Basic bounds retrieval\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * const bounds = rect.getBounds();\n\t *\n\t * // Reuse existing rectangle\n\t * const out = new Rectangle();\n\t * rect.getBounds(out);\n\t * ```\n\t * @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t * @see {@link Rectangle.copyFrom} For direct copying\n\t * @see {@link Rectangle.clone} For creating new copy\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Determines whether another Rectangle is fully contained within this Rectangle.\n\t *\n\t * Rectangles that occupy the same space are considered to be containing each other.\n\t *\n\t * Rectangles without area (width or height equal to zero) can't contain anything,\n\t * not even other arealess rectangles.\n\t * @example\n\t * ```ts\n\t * // Check if one rectangle contains another\n\t * const container = new Rectangle(0, 0, 100, 100);\n\t * const inner = new Rectangle(25, 25, 50, 50);\n\t *\n\t * console.log(container.containsRect(inner)); // true\n\t *\n\t * // Check overlapping rectangles\n\t * const partial = new Rectangle(75, 75, 50, 50);\n\t * console.log(container.containsRect(partial)); // false\n\t *\n\t * // Zero-area rectangles\n\t * const empty = new Rectangle(0, 0, 0, 100);\n\t * console.log(container.containsRect(empty)); // false\n\t * ```\n\t * @param other - The Rectangle to check for containment\n\t * @returns True if other is fully contained within this Rectangle\n\t * @see {@link Rectangle.contains} For point containment\n\t * @see {@link Rectangle.intersects} For overlap testing\n\t */\n\tcontainsRect(other: Rectangle): boolean;\n\t/**\n\t * Sets the position and dimensions of the rectangle.\n\t * @example\n\t * ```ts\n\t * // Basic usage\n\t * const rect = new Rectangle();\n\t * rect.set(100, 100, 200, 150);\n\t *\n\t * // Chain with other operations\n\t * const bounds = new Rectangle()\n\t *     .set(0, 0, 100, 100)\n\t *     .pad(10);\n\t * ```\n\t * @param x - The X coordinate of the upper-left corner of the rectangle\n\t * @param y - The Y coordinate of the upper-left corner of the rectangle\n\t * @param width - The overall width of the rectangle\n\t * @param height - The overall height of the rectangle\n\t * @returns Returns itself for method chaining\n\t * @see {@link Rectangle.copyFrom} For copying from another rectangle\n\t * @see {@link Rectangle.clone} For creating a new copy\n\t */\n\tset(x: number, y: number, width: number, height: number): this;\n\ttoString(): string;\n}\n/**\n * Base options for destroying display objects.\n * Controls how deep the destruction process should go through the display tree.\n * @example\n * ```ts\n * // Basic destruction - only this container\n * container.destroy({ children: false });\n *\n * // Deep destruction - container and all children\n * container.destroy({ children: true });\n *\n * // Cleanup pattern\n * function cleanupScene(scene: Container) {\n *     // Remove from parent first\n *     scene.parent?.removeChild(scene);\n *     // Then destroy with all children\n *     scene.destroy({ children: true });\n * }\n * ```\n * @see {@link Container#destroy} For destruction method\n * @see {@link DestroyOptions} For all destroy options\n * @category scene\n * @standard\n */\nexport interface BaseDestroyOptions {\n\t/**\n\t * Whether to destroy children recursively.\n\t * When true, runs destroy() on all children in the display tree.\n\t * @default false\n\t * @example\n\t * ```js\n\t * container.destroy({ children: true });\n\t * ```\n\t */\n\tchildren?: boolean;\n}\n/**\n * Options when destroying textures through `.destroy()` calls.\n * Controls how thoroughly textures and their sources are cleaned up.\n * @example\n * ```ts\n * // Basic texture cleanup\n * sprite.destroy({\n *     texture: true\n * });\n *\n * // Complete texture cleanup\n * sprite.destroy({\n *     texture: true,\n *     textureSource: true\n * });\n * ```\n * @see {@link Container#destroy} For general destruction\n * @see {@link Texture#destroy} For texture cleanup\n * @category scene\n * @standard\n */\nexport interface TextureDestroyOptions {\n\t/**\n\t * Whether to destroy the texture for the display object.\n\t * @default false\n\t * @example\n\t * ```js\n\t * texturedObject.destroy({ texture: true });\n\t * ```\n\t */\n\ttexture?: boolean;\n\t/**\n\t * Whether to destroy the underlying texture source.\n\t * Use carefully with shared texture sources.\n\t * @default false\n\t * @example\n\t * ```js\n\t * texturedObject.destroy({ textureSource: true });\n\t * ```\n\t */\n\ttextureSource?: boolean;\n}\n/**\n * Options when destroying a graphics context.\n * Controls the cleanup of graphics-specific resources.\n * @example\n * ```ts\n * // Basic context cleanup\n * graphics.destroy({\n *     context: true\n * });\n *\n * // Full graphics cleanup\n * graphics.destroy({\n *     context: true,\n *     texture: true,\n *     textureSource: true\n * });\n * ```\n * @see {@link Graphics#destroy} For graphics destruction\n * @see {@link DestroyOptions} For all destroy options\n * @category scene\n * @standard\n */\nexport interface ContextDestroyOptions {\n\t/**\n\t * Whether to destroy the graphics context associated with the graphics object.\n\t * @default false\n\t * @example\n\t * ```js\n\t * graphics.destroy({ context: true });\n\t * ```\n\t */\n\tcontext?: boolean;\n}\n/**\n * Options when destroying a text object. Controls whether associated text styles\n * should be cleaned up along with the text object itself.\n * ```ts\n * // Basic text cleanup\n * text.destroy({ style: false }); // Keep style for reuse\n * text.destroy({ style: true }); // Destroy style as well\n * ```\n * @category text\n * @standard\n */\nexport interface TextDestroyOptions {\n\t/**\n\t * Whether to destroy the text style object along with the text.\n\t * Use carefully with shared styles.\n\t * @default false\n\t */\n\tstyle?: boolean;\n}\n/**\n * A utility type that allows a type to be either the specified type or a boolean.\n * This is useful for options that can be either a specific value or a boolean flag.\n * @category utils\n * @advanced\n */\nexport type TypeOrBool<T> = T | boolean;\n/**\n * Options for destroying a container and its resources.\n * Combines all destroy options into a single configuration object.\n * @example\n * ```ts\n * // Destroy the container and all its children, including textures and styles\n * container.destroy({\n *     children: true,\n *     texture: true,\n *     textureSource: true,\n *     context: true,\n *     style: true\n * });\n * ```\n * @category scene\n * @standard\n */\nexport type DestroyOptions = TypeOrBool<BaseDestroyOptions & ContextDestroyOptions & TextureDestroyOptions & TextDestroyOptions>;\n/**\n * Constants used by the renderer for clearing the screen or render textures.\n * @category rendering\n * @advanced\n */\nexport enum CLEAR {\n\t/** No clear operation. */\n\tNONE = 0,\n\t/** Clear the color buffer. */\n\tCOLOR = 16384,\n\t/** Clear the stencil buffer. */\n\tSTENCIL = 1024,\n\t/** Clear the depth buffer. */\n\tDEPTH = 256,\n\t/** Clear the color and depth buffers. */\n\tCOLOR_DEPTH = 16640,\n\t/** Clear the color and stencil buffers. */\n\tCOLOR_STENCIL = 17408,\n\t/** Clear the depth and stencil buffers. */\n\tDEPTH_STENCIL = 1280,\n\t/** Clear the color, depth, and stencil buffers. */\n\tALL = 17664\n}\n/**\n * Used for clearing render textures. true is the same as `ALL` false is the same as `NONE`\n * @category rendering\n * @advanced\n */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n/**\n * A system is a generic interface for a renderer system.\n * It is used to define the methods that a system should implement.\n * @category rendering\n * @advanced\n */\nexport interface System<INIT_OPTIONS = null, DESTROY_OPTIONS = RendererDestroyOptions> {\n\tinit?: (options: INIT_OPTIONS) => void;\n\t/** Generic destroy methods to be overridden by the subclass */\n\tdestroy?: (options?: DESTROY_OPTIONS) => void;\n}\n/**\n * The constructor for a System.\n * It is used to create instances of systems that can be added to a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SystemConstructor {\n\tnew (renderer: Renderer): System;\n}\n/**\n * Options for the background system.\n * @category rendering\n * @advanced\n */\nexport interface BackgroundSystemOptions {\n\t/**\n\t * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n\t * @default 'black'\n\t */\n\tbackgroundColor: ColorSource;\n\t/** Alias for `backgroundColor` */\n\tbackground?: ColorSource;\n\t/**\n\t * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n\t * This value determines whether the canvas is initialized with alpha transparency support.\n\t * Note: This cannot be changed after initialization. If set to `1`, the canvas will remain opaque,\n\t * even if a transparent background color is set later.\n\t * @default 1\n\t */\n\tbackgroundAlpha?: number;\n\t/**\n\t * Whether to clear the canvas before new render passes.\n\t * @default true\n\t */\n\tclearBeforeRender?: boolean;\n}\n/**\n * The background system manages the background color and alpha of the main view.\n * @category rendering\n * @advanced\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"background\";\n\t\treadonly priority: 0;\n\t};\n\t/** default options used by the system */\n\tstatic defaultOptions: BackgroundSystemOptions;\n\t/**\n\t * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n\t * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n\t * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n\t * to clear the canvas every frame. Disable this by setting this to false. For example, if\n\t * your game has a canvas filling background image you often don't need this set.\n\t */\n\tclearBeforeRender: boolean;\n\tprivate readonly _backgroundColor;\n\tconstructor();\n\t/**\n\t * initiates the background system\n\t * @param options - the options for the background colors\n\t */\n\tinit(options: BackgroundSystemOptions): void;\n\t/** The background color to fill if not transparent */\n\tget color(): Color;\n\tset color(value: ColorSource);\n\t/** The background color alpha. Setting this to 0 will make the canvas transparent. */\n\tget alpha(): number;\n\tset alpha(value: number);\n\t/** The background color as an [R, G, B, A] array. */\n\tget colorRgba(): RgbaArray;\n\t/**\n\t * destroys the background system\n\t * @internal\n\t */\n\tdestroy(): void;\n}\n/**\n * Various GL texture/resources formats.\n * @category rendering\n * @advanced\n */\nexport enum GL_FORMATS {\n\tRGBA = 6408,\n\tRGB = 6407,\n\tRG = 33319,\n\tRED = 6403,\n\tRGBA_INTEGER = 36249,\n\tRGB_INTEGER = 36248,\n\tRG_INTEGER = 33320,\n\tRED_INTEGER = 36244,\n\tALPHA = 6406,\n\tLUMINANCE = 6409,\n\tLUMINANCE_ALPHA = 6410,\n\tDEPTH_COMPONENT = 6402,\n\tDEPTH_STENCIL = 34041\n}\n/**\n * Various GL target types.\n * @category rendering\n * @advanced\n */\nexport enum GL_TARGETS {\n\tTEXTURE_2D = 3553,\n\tTEXTURE_CUBE_MAP = 34067,\n\tTEXTURE_2D_ARRAY = 35866,\n\tTEXTURE_CUBE_MAP_POSITIVE_X = 34069,\n\tTEXTURE_CUBE_MAP_NEGATIVE_X = 34070,\n\tTEXTURE_CUBE_MAP_POSITIVE_Y = 34071,\n\tTEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,\n\tTEXTURE_CUBE_MAP_POSITIVE_Z = 34073,\n\tTEXTURE_CUBE_MAP_NEGATIVE_Z = 34074\n}\n/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n * @category rendering\n * @advanced\n */\nexport enum GL_WRAP_MODES {\n\t/**\n\t * The textures uvs are clamped\n\t * @default 33071\n\t */\n\tCLAMP = 33071,\n\t/**\n\t * The texture uvs tile and repeat\n\t * @default 10497\n\t */\n\tREPEAT = 10497,\n\t/**\n\t * The texture uvs tile and repeat with mirroring\n\t * @default 33648\n\t */\n\tMIRRORED_REPEAT = 33648\n}\n/** @internal */\nexport enum GL_TYPES {\n\t/**\n\t * 8 bits per channel for gl.RGBA\n\t * @default 5121\n\t */\n\tUNSIGNED_BYTE = 5121,\n\t/** @default 5123 */\n\tUNSIGNED_SHORT = 5123,\n\t/**\n\t * 5 red bits, 6 green bits, 5 blue bits.\n\t * @default 33635\n\t */\n\tUNSIGNED_SHORT_5_6_5 = 33635,\n\t/**\n\t * 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits.\n\t * @default 32819\n\t */\n\tUNSIGNED_SHORT_4_4_4_4 = 32819,\n\t/**\n\t * 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.\n\t * @default 32820\n\t */\n\tUNSIGNED_SHORT_5_5_5_1 = 32820,\n\t/** @default 5125 */\n\tUNSIGNED_INT = 5125,\n\t/** @default 35899 */\n\tUNSIGNED_INT_10F_11F_11F_REV = 35899,\n\t/** @default 33640 */\n\tUNSIGNED_INT_2_10_10_10_REV = 33640,\n\t/** @default 34042 */\n\tUNSIGNED_INT_24_8 = 34042,\n\t/** @default 35902 */\n\tUNSIGNED_INT_5_9_9_9_REV = 35902,\n\t/** @default 5120 */\n\tBYTE = 5120,\n\t/** @default 5122 */\n\tSHORT = 5122,\n\t/** @default 5124 */\n\tINT = 5124,\n\t/** @default 5126 */\n\tFLOAT = 5126,\n\t/** @default 36269 */\n\tFLOAT_32_UNSIGNED_INT_24_8_REV = 36269,\n\t/** @default 36193 */\n\tHALF_FLOAT = 36193\n}\n/**\n * Internal texture for WebGL context\n * @category rendering\n * @ignore\n */\nexport class GlTexture implements GPUData {\n\ttarget: GL_TARGETS;\n\t/** The WebGL texture. */\n\ttexture: WebGLTexture;\n\t/** Width of texture that was used in texImage2D. */\n\twidth: number;\n\t/** Height of texture that was used in texImage2D. */\n\theight: number;\n\t/** Whether mip levels has to be generated. */\n\tmipmap: boolean;\n\t/** Type copied from texture source. */\n\ttype: number;\n\t/** Type copied from texture source. */\n\tinternalFormat: number;\n\t/** Type of sampler corresponding to this texture. See {@link SAMPLER_TYPES} */\n\tsamplerType: number;\n\tformat: GL_FORMATS;\n\tconstructor(texture: WebGLTexture);\n\tdestroy(): void;\n}\n/**\n * an interface that allows a resource to be bound to the gpu in a bind group\n * @category rendering\n * @advanced\n */\nexport interface BindResource {\n\t/**\n\t * The type of resource this is\n\t * @ignore\n\t */\n\t_resourceType: string;\n\t/**\n\t * Unique id for this resource this can change and is used to link the gpu\n\t * @ignore\n\t */\n\t_resourceId: number;\n\t_touched: number;\n\t/**\n\t * a boolean that indicates if the resource has been destroyed.\n\t * If true, the resource should not be used and any bind groups\n\t * that will release any references to this resource.\n\t * @ignore\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * event dispatch whenever the underlying resource needs to change\n\t * this could be a texture or buffer that has been resized.\n\t * This is important as it allows the renderer to know that it needs to rebind the resource\n\t */\n\ton?(event: \"change\", listenerFunction: (resource: BindResource) => void, listener: BindGroup): void;\n\t/** todo */\n\toff?(event: \"change\", listenerFunction: (resource: BindResource) => void, listener: BindGroup): void;\n}\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @category rendering\n * @advanced\n */\nexport class BindGroup {\n\t/** The resources that are bound together for use by a shader. */\n\tresources: Record<string, BindResource>;\n\t/**\n\t * a key used internally to match it up to a WebGPU Bindgroup\n\t * @internal\n\t */\n\t_key: string;\n\tprivate _dirty;\n\t/**\n\t * Create a new instance eof the Bind Group.\n\t * @param resources - The resources that are bound together for use by a shader.\n\t */\n\tconstructor(resources?: Record<string, BindResource>);\n\t/**\n\t * Updates the key if its flagged as dirty. This is used internally to\n\t * match this bind group to a WebGPU BindGroup.\n\t * @internal\n\t */\n\t_updateKey(): void;\n\t/**\n\t * Set a resource at a given index. this function will\n\t * ensure that listeners will be removed from the current resource\n\t * and added to the new resource.\n\t * @param resource - The resource to set.\n\t * @param index - The index to set the resource at.\n\t */\n\tsetResource(resource: BindResource, index: number): void;\n\t/**\n\t * Returns the resource at the current specified index.\n\t * @param index - The index of the resource to get.\n\t * @returns - The resource at the specified index.\n\t */\n\tgetResource(index: number): BindResource;\n\t/**\n\t * Used internally to 'touch' each resource, to ensure that the GC\n\t * knows that all resources in this bind group are still being used.\n\t * @param now - The current time in milliseconds.\n\t * @param tick - The current tick.\n\t * @internal\n\t */\n\t_touch(now: number, tick: number): void;\n\t/** Destroys this bind group and removes all listeners. */\n\tdestroy(): void;\n\tprotected onResourceChange(resource: BindResource): void;\n}\n/**\n * Data about the pixels of a texture.\n * This includes the pixel data as a Uint8ClampedArray, and the width and height of the texture.\n * @category rendering\n * @advanced\n */\nexport type GetPixelsOutput = {\n\tpixels: Uint8ClampedArray;\n\twidth: number;\n\theight: number;\n};\n/** @internal */\nexport interface CanvasGenerator {\n\tgenerateCanvas(texture: Texture): ICanvas;\n\tgetPixels(texture: Texture): GetPixelsOutput;\n}\n/**\n * Specifies the alpha composition mode for textures.\n *\n * - `no-premultiply-alpha`: Does not premultiply alpha.\n * - `premultiply-alpha-on-upload`: Premultiplies alpha on texture upload.\n * - `premultiplied-alpha`: Assumes the texture is already in premultiplied alpha format.\n * @category rendering\n * @advanced\n */\nexport type ALPHA_MODES = \"no-premultiply-alpha\" | \"premultiply-alpha-on-upload\" | \"premultiplied-alpha\";\n/**\n * The texture formats that are supported by pixi.\n *\n * These formats are used to specify the format of textures in WebGPU and WebGL.\n * They include various uncompressed, compressed, and depth/stencil formats.\n * @category rendering\n * @advanced\n */\nexport type TEXTURE_FORMATS = \"r8unorm\" | \"r8snorm\" | \"r8uint\" | \"r8sint\" | \"r16uint\" | \"r16sint\" | \"r16float\" | \"rg8unorm\" | \"rg8snorm\" | \"rg8uint\" | \"rg8sint\" | \"r32uint\" | \"r32sint\" | \"r32float\" | \"rg16uint\" | \"rg16sint\" | \"rg16float\" | \"rgba8unorm\" | \"rgba8unorm-srgb\" | \"rgba8snorm\" | \"rgba8uint\" | \"rgba8sint\" | \"bgra8unorm\" | \"bgra8unorm-srgb\" | \"rgb9e5ufloat\" | \"rgb10a2unorm\" | \"rg11b10ufloat\" | \"rg32uint\" | \"rg32sint\" | \"rg32float\" | \"rgba16uint\" | \"rgba16sint\" | \"rgba16float\" | \"rgba32uint\" | \"rgba32sint\" | \"rgba32float\" | \"stencil8\" | \"depth16unorm\" | \"depth24plus\" | \"depth24plus-stencil8\" | \"depth32float\" | \"depth32float-stencil8\" | \"bc1-rgba-unorm\" | \"bc1-rgba-unorm-srgb\" | \"bc2-rgba-unorm\" | \"bc2-rgba-unorm-srgb\" | \"bc3-rgba-unorm\" | \"bc3-rgba-unorm-srgb\" | \"bc4-r-unorm\" | \"bc4-r-snorm\" | \"bc5-rg-unorm\" | \"bc5-rg-snorm\" | \"bc6h-rgb-ufloat\" | \"bc6h-rgb-float\" | \"bc7-rgba-unorm\" | \"bc7-rgba-unorm-srgb\" | \"etc2-rgb8unorm\" | \"etc2-rgb8unorm-srgb\" | \"etc2-rgb8a1unorm\" | \"etc2-rgb8a1unorm-srgb\" | \"etc2-rgba8unorm\" | \"etc2-rgba8unorm-srgb\" | \"eac-r11unorm\" | \"eac-r11snorm\" | \"eac-rg11unorm\" | \"eac-rg11snorm\" | \"astc-4x4-unorm\" | \"astc-4x4-unorm-srgb\" | \"astc-5x4-unorm\" | \"astc-5x4-unorm-srgb\" | \"astc-5x5-unorm\" | \"astc-5x5-unorm-srgb\" | \"astc-6x5-unorm\" | \"astc-6x5-unorm-srgb\" | \"astc-6x6-unorm\" | \"astc-6x6-unorm-srgb\" | \"astc-8x5-unorm\" | \"astc-8x5-unorm-srgb\" | \"astc-8x6-unorm\" | \"astc-8x6-unorm-srgb\" | \"astc-8x8-unorm\" | \"astc-8x8-unorm-srgb\" | \"astc-10x5-unorm\" | \"astc-10x5-unorm-srgb\" | \"astc-10x6-unorm\" | \"astc-10x6-unorm-srgb\" | \"astc-10x8-unorm\" | \"astc-10x8-unorm-srgb\" | \"astc-10x10-unorm\" | \"astc-10x10-unorm-srgb\" | \"astc-12x10-unorm\" | \"astc-12x10-unorm-srgb\" | \"astc-12x12-unorm\" | \"astc-12x12-unorm-srgb\";\n/**\n * The texture dimensions that are supported by pixi.\n *\n * - `1d` is a one-dimensional texture, which is typically used for linear data.\n * - `2d` is a two-dimensional texture, which is commonly used for images and textures.\n * - `3d` is a three-dimensional texture, which is used for volumetric data or 3D textures.\n * @category rendering\n * @advanced\n */\nexport type TEXTURE_DIMENSIONS = \"1d\" | \"2d\" | \"3d\";\n/**\n * The wrap modes that are supported by pixi.\n *\n * The wrap mode affects the default wrapping mode of future operations.\n * - `clamp-to-edge` is the default mode, which clamps the texture coordinates to the edge of the texture.\n * - `repeat` allows the texture to repeat in both u and v directions.\n * - `mirror-repeat` allows the texture to repeat in both u and v directions, but mirrors the texture on every other repeat.\n * @category rendering\n * @standard\n */\nexport type WRAP_MODE = \"clamp-to-edge\" | \"repeat\" | \"mirror-repeat\";\n/** @internal */\nexport enum DEPRECATED_WRAP_MODES {\n\tCLAMP = \"clamp-to-edge\",\n\tREPEAT = \"repeat\",\n\tMIRRORED_REPEAT = \"mirror-repeat\"\n}\n/**\n * The wrap modes that are supported by pixi.\n * @deprecated since 8.0.0\n * @category rendering\n * @see WRAP_MODE\n * @advanced\n */\nexport const WRAP_MODES: typeof DEPRECATED_WRAP_MODES;\n/**\n * The scale modes that are supported by pixi.\n *\n * The scale mode affects the default scaling mode of future operations.\n * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.\n *\n * - `nearest` is a pixelating scaling mode, which does not interpolate pixels.\n * - `linear` is a smooth scaling mode, which interpolates pixels for smoother results.\n * @category rendering\n * @standard\n */\nexport type SCALE_MODE = \"nearest\" | \"linear\";\n/** @internal */\nexport enum DEPRECATED_SCALE_MODES {\n\tNEAREST = \"nearest\",\n\tLINEAR = \"linear\"\n}\n/**\n * The scale modes that are supported by pixi.\n * @deprecated since 8.0.0\n * @category rendering\n * @see SCALE_MODE\n * @advanced\n */\nexport const SCALE_MODES: typeof DEPRECATED_SCALE_MODES;\n/**\n * The compare function types used for comparing values in various operations.\n * @category rendering\n * @advanced\n */\nexport type COMPARE_FUNCTION = \"never\" | \"less\" | \"equal\" | \"less-equal\" | \"greater\" | \"not-equal\" | \"greater-equal\" | \"always\";\n/**\n * The options for the texture style.\n * @category rendering\n * @advanced\n */\nexport interface TextureStyleOptions extends Partial<TextureStyle> {\n\t/** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n\taddressMode?: WRAP_MODE;\n\t/** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n\taddressModeU?: WRAP_MODE;\n\t/** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n\taddressModeV?: WRAP_MODE;\n\t/** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n\taddressModeW?: WRAP_MODE;\n\t/** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n\tscaleMode?: SCALE_MODE;\n\t/** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n\tmagFilter?: SCALE_MODE;\n\t/** specifies the sampling behavior when the sample footprint is larger than one texel. */\n\tminFilter?: SCALE_MODE;\n\t/** specifies behavior for sampling between mipmap levels. */\n\tmipmapFilter?: SCALE_MODE;\n\t/** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n\tlodMinClamp?: number;\n\t/** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n\tlodMaxClamp?: number;\n\t/**\n\t * When provided the sampler will be a comparison sampler with the specified\n\t * {@link COMPARE_FUNCTION}.\n\t * Note: Comparison samplers may use filtering, but the sampling results will be\n\t * implementation-dependent and may differ from the normal filtering rules.\n\t */\n\tcompare?: COMPARE_FUNCTION;\n\t/**\n\t * Specifies the maximum anisotropy value clamp used by the sampler.\n\t * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n\t * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n\t * be clamped to the maximum value that the platform supports.\n\t *\n\t * setting this to anything higher than 1 will set scale modes to 'linear'\n\t */\n\tmaxAnisotropy?: number;\n}\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @category rendering\n * @advanced\n */\nexport class TextureStyle extends EventEmitter<{\n\tchange: TextureStyle;\n\tdestroy: TextureStyle;\n}> implements BindResource {\n\t/** @internal */\n\t_resourceType: string;\n\t/** @internal */\n\t_touched: number;\n\tprivate _sharedResourceId;\n\t/** default options for the style */\n\tstatic readonly defaultOptions: TextureStyleOptions;\n\t/** */\n\taddressModeU?: WRAP_MODE;\n\t/** */\n\taddressModeV?: WRAP_MODE;\n\t/** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n\taddressModeW?: WRAP_MODE;\n\t/** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n\tmagFilter?: SCALE_MODE;\n\t/** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n\tminFilter?: SCALE_MODE;\n\t/** Specifies behavior for sampling between mipmap levels. */\n\tmipmapFilter?: SCALE_MODE;\n\t/** */\n\tlodMinClamp?: number;\n\t/** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n\tlodMaxClamp?: number;\n\t/**\n\t * When provided the sampler will be a comparison sampler with the specified\n\t * {@link COMPARE_FUNCTION}.\n\t * Note: Comparison samplers may use filtering, but the sampling results will be\n\t * implementation-dependent and may differ from the normal filtering rules.\n\t */\n\tcompare?: COMPARE_FUNCTION;\n\t/**\n\t * Specifies the maximum anisotropy value clamp used by the sampler.\n\t * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n\t * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n\t * be clamped to the maximum value that the platform supports.\n\t * @internal\n\t */\n\t_maxAnisotropy?: number;\n\t/**\n\t * Has the style been destroyed?\n\t * @readonly\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * @param options - options for the style\n\t */\n\tconstructor(options?: TextureStyleOptions);\n\tset addressMode(value: WRAP_MODE);\n\t/** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n\tget addressMode(): WRAP_MODE;\n\tset wrapMode(value: WRAP_MODE);\n\tget wrapMode(): WRAP_MODE;\n\tset scaleMode(value: SCALE_MODE);\n\t/** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n\tget scaleMode(): SCALE_MODE;\n\t/** Specifies the maximum anisotropy value clamp used by the sampler. */\n\tset maxAnisotropy(value: number);\n\tget maxAnisotropy(): number;\n\tget _resourceId(): number;\n\tupdate(): void;\n\tprivate _generateResourceId;\n\t/** Destroys the style */\n\tdestroy(): void;\n}\n/**\n * Options for the {@link GCManagedHash}.\n * @internal\n */\nexport interface GCManagedHashOptions<T extends GCable & {\n\tuid: number;\n} & Pick<EventEmitter, \"once\" | \"off\">> {\n\trenderer: Renderer;\n\ttype: GCData[\"type\"];\n\tonUnload?: (item: T, ...args: any[]) => void;\n\tpriority?: number;\n\tname: string;\n}\n/**\n * A hash for managing renderable and resource resources with GC integration.\n * @internal\n */\nexport class GCManagedHash<T extends GCable & {\n\tuid: number;\n} & Pick<EventEmitter, \"once\" | \"off\">> {\n\titems: Record<number, T>;\n\tprivate _renderer;\n\tprivate _onUnload?;\n\treadonly name: string;\n\tconstructor(options: GCManagedHashOptions<T>);\n\t/**\n\t * Add an item to the hash. No-op if already added.\n\t * @param item\n\t * @returns true if the item was added, false if it was already in the hash\n\t */\n\tadd(item: T): boolean;\n\tremove(item: T, ...args: unknown[]): void;\n\tremoveAll(...args: unknown[]): void;\n\tdestroy(...args: unknown[]): void;\n}\n/**\n * The different topology types supported by the renderer used to describe how the geometry should be renderer\n * @category rendering\n * @advanced\n */\nexport type Topology = \"point-list\" | \"line-list\" | \"line-strip\" | \"triangle-list\" | \"triangle-strip\";\n/**\n * @deprecated since 8.0.0\n * @category rendering\n * @advanced\n */\nexport const DRAW_MODES: {\n\tPOINTS: string;\n\tLINES: string;\n\tLINE_STRIP: string;\n\tTRIANGLES: string;\n\tTRIANGLE_STRIP: string;\n};\n/**\n * The different types of vertex formats supported by the renderer\n * @category rendering\n * @advanced\n */\nexport type VertexFormat = \"uint8x2\" | \"uint8x4\" | \"sint8x2\" | \"sint8x4\" | \"unorm8x2\" | \"unorm8x4\" | \"snorm8x2\" | \"snorm8x4\" | \"uint16x2\" | \"uint16x4\" | \"sint16x2\" | \"sint16x4\" | \"unorm16x2\" | \"unorm16x4\" | \"snorm16x2\" | \"snorm16x4\" | \"float16x2\" | \"float16x4\" | \"float32\" | \"float32x2\" | \"float32x3\" | \"float32x4\" | \"uint32\" | \"uint32x2\" | \"uint32x3\" | \"uint32x4\" | \"sint32\" | \"sint32x2\" | \"sint32x3\" | \"sint32x4\";\n/**\n * The WebGL rendering context type used by the PixiJS WebGL renderer.\n * This is typically a `WebGL2RenderingContext`, which is the default for PixiJS.\n * It is used to ensure that the renderer operates with the correct context type.\n * @category rendering\n * @advanced\n */\nexport type GlRenderingContext = WebGL2RenderingContext;\n/**\n * Constants for various buffer types in Pixi\n * @category rendering\n * @advanced\n */\nexport enum BUFFER_TYPE {\n\t/** buffer type for using as an index buffer */\n\tELEMENT_ARRAY_BUFFER = 34963,\n\t/** buffer type for using attribute data */\n\tARRAY_BUFFER = 34962,\n\t/** the buffer type is for uniform buffer objects */\n\tUNIFORM_BUFFER = 35345\n}\n/** @internal */\nexport class GlBuffer implements GPUData {\n\tbuffer: WebGLBuffer;\n\tupdateID: number;\n\tbyteLength: number;\n\ttype: number;\n\t_lastBindBaseLocation: number;\n\t_lastBindCallId: number;\n\tconstructor(buffer: WebGLBuffer, type: BUFFER_TYPE);\n\tdestroy(): void;\n}\n/** @internal */\nexport class GpuBufferData implements GPUData {\n\tgpuBuffer: GPUBuffer;\n\tconstructor(gpuBuffer: GPUBuffer);\n\tdestroy(): void;\n}\n/**\n * System plugin to the renderer to manage buffers.\n * @category rendering\n * @advanced\n */\nexport class GpuBufferSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"buffer\";\n\t};\n\tprotected CONTEXT_UID: number;\n\tprivate readonly _renderer;\n\tprivate readonly _managedBuffers;\n\tprivate _gpu;\n\tconstructor(renderer: WebGPURenderer);\n\tprotected contextChange(gpu: GPU$1): void;\n\tgetGPUBuffer(buffer: Buffer$1): GPUBuffer;\n\tupdateBuffer(buffer: Buffer$1): GPUBuffer;\n\t/** dispose all WebGL resources of all managed buffers */\n\tdestroyAll(): void;\n\tprotected onBufferUnload(buffer: Buffer$1): void;\n\tcreateGPUBuffer(buffer: Buffer$1): GPUBuffer;\n\tprotected onBufferChange(buffer: Buffer$1): void;\n\tdestroy(): void;\n}\n/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @category rendering\n * @advanced\n */\nexport enum BufferUsage {\n\t/**\n\t * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n\t * May only be combined with COPY_DST.\n\t */\n\tMAP_READ = 1,\n\t/**\n\t * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n\t * May only be combined with COPY_SRC.\n\t */\n\tMAP_WRITE = 2,\n\t/**\n\t * The buffer can be used as the source of a copy operation.\n\t * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n\t */\n\tCOPY_SRC = 4,\n\t/**\n\t * The buffer can be used as the destination of a copy or write operation.\n\t * (Examples: as the destination argument of a copyBufferToBuffer() or\n\t * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n\t */\n\tCOPY_DST = 8,\n\t/** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n\tINDEX = 16,\n\t/** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n\tVERTEX = 32,\n\t/**\n\t * The buffer can be used as a uniform buffer.\n\t * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n\t */\n\tUNIFORM = 64,\n\t/**\n\t * The buffer can be used as a storage buffer.\n\t * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n\t */\n\tSTORAGE = 128,\n\t/**\n\t * The buffer can be used as to store indirect command arguments.\n\t * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n\t */\n\tINDIRECT = 256,\n\t/**\n\t * The buffer can be used to capture query results.\n\t * (Example: as the destination argument of a resolveQuerySet() call.)\n\t */\n\tQUERY_RESOLVE = 512,\n\t/** the buffer will not be updated frequently */\n\tSTATIC = 1024\n}\n/**\n * All the various typed arrays that exist in js\n * @category rendering\n * @advanced\n */\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n/**\n * Options for creating a buffer\n *\n * This interface defines the options that can be passed to the Buffer constructor.\n * It includes the data to initialize the buffer with, the size of the buffer,\n * the usage of the buffer, a label for debugging, and whether the buffer should shrink to fit\n * when the data becomes smaller.\n * @category rendering\n * @advanced\n */\nexport interface BufferOptions {\n\t/**\n\t * the data to initialize the buffer with, this can be a typed array,\n\t * or a regular number array. If it is a number array, it will be converted to a Float32Array\n\t */\n\tdata?: TypedArray | number[];\n\t/** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n\tsize?: number;\n\t/** the usage of the buffer, see {@link BufferUsage} */\n\tusage: number;\n\t/** a label for the buffer, this is useful for debugging */\n\tlabel?: string;\n\t/**\n\t * should the GPU buffer be shrunk when the data becomes smaller?\n\t * changing this will cause the buffer to be destroyed and a new one created on the GPU\n\t * this can be expensive, especially if the buffer is already big enough!\n\t * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n\t * if you are constantly setting data that is changing size often.\n\t * @default true\n\t */\n\tshrinkToFit?: boolean;\n}\n/** @internal */\nexport interface BufferDescriptor {\n\tlabel?: string;\n\tsize: GPUSize64;\n\tusage: BufferUsage;\n\tmappedAtCreation?: boolean;\n}\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @category rendering\n * @advanced\n */\ndeclare class Buffer$1 extends EventEmitter<{\n\tchange: BindResource;\n\tupdate: Buffer$1;\n\tdestroy: Buffer$1;\n\tunload: Buffer$1;\n}> implements BindResource, GPUDataOwner, GCable {\n\t/**\n\t * emits when the underlying buffer has changed shape (i.e. resized)\n\t * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n\t * @event change\n\t */\n\t/**\n\t * emits when the underlying buffer data has been updated. letting the renderer know\n\t * that it needs to update the buffer on the GPU\n\t * @event update\n\t */\n\t/**\n\t * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n\t * @event destroy\n\t */\n\t/** @internal */\n\t_gpuData: Record<number, GlBuffer | GpuBufferData>;\n\t/** @internal */\n\t_gcData?: GCData;\n\t/** @internal */\n\t_gcLastUsed: number;\n\t/** If set to true, the buffer will be garbage collected automatically when it is not used. */\n\tautoGarbageCollect: boolean;\n\t/** a unique id for this uniform group used through the renderer */\n\treadonly uid: number;\n\t/**\n\t * a resource type, used to identify how to handle it when its in a bind group / shader resource\n\t * @internal\n\t */\n\treadonly _resourceType = \"buffer\";\n\t/**\n\t * the resource id used internally by the renderer to build bind group keys\n\t * @internal\n\t */\n\t_resourceId: number;\n\t/**\n\t * used internally to know if a uniform group was used in the last render pass\n\t * @internal\n\t */\n\t_touched: number;\n\t/**\n\t * a description of the buffer and how it should be set up on the GPU\n\t * @internal\n\t */\n\treadonly descriptor: BufferDescriptor;\n\t/** @internal */\n\t_updateID: number;\n\t/** @internal */\n\t_updateSize: number;\n\tprivate _data;\n\tprivate _dataInt32;\n\t/**\n\t * should the GPU buffer be shrunk when the data becomes smaller?\n\t * changing this will cause the buffer to be destroyed and a new one created on the GPU\n\t * this can be expensive, especially if the buffer is already big enough!\n\t * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n\t * if you are constantly setting data that is changing size often.\n\t * @default true\n\t */\n\tshrinkToFit: boolean;\n\t/**\n\t * Has the buffer been destroyed?\n\t * @readonly\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * Creates a new Buffer with the given options\n\t * @param options - the options for the buffer\n\t */\n\tconstructor(options: BufferOptions);\n\t/** the data in the buffer */\n\tget data(): TypedArray;\n\tset data(value: TypedArray);\n\tget dataInt32(): Int32Array;\n\t/** whether the buffer is static or not */\n\tget static(): boolean;\n\tset static(value: boolean);\n\t/**\n\t * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n\t * If you only want to update a subset of the buffer, you can pass in the size of the data.\n\t * @param value - the data to set\n\t * @param size - the size of the data in bytes\n\t * @param syncGPU - should the buffer be updated on the GPU immediately?\n\t */\n\tsetDataWithSize(value: TypedArray, size: number, syncGPU: boolean): void;\n\t/**\n\t * updates the buffer on the GPU to reflect the data in the buffer.\n\t * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n\t * you can pass in the size of the buffer to update.\n\t * @param sizeInBytes - the new size of the buffer in bytes\n\t */\n\tupdate(sizeInBytes?: number): void;\n\t/** Unloads the buffer from the GPU */\n\tunload(): void;\n\t/** Destroys the buffer */\n\tdestroy(): void;\n}\n/** @internal */\nexport interface GlUniformData {\n\tname: string;\n\tindex: number;\n\ttype: string;\n\tsize: number;\n\tisArray: boolean;\n\tvalue: any;\n}\n/** @internal */\nexport interface GlUniformBlockData {\n\tindex: number;\n\tname: string;\n\tsize: number;\n\tvalue?: TypedArray;\n}\n/**\n * The options for the gl program\n * @category rendering\n * @advanced\n */\nexport interface GlProgramOptions {\n\t/** The fragment glsl shader source. */\n\tfragment: string;\n\t/** The vertex glsl shader source. */\n\tvertex: string;\n\t/** the name of the program, defaults to 'pixi-program' */\n\tname?: string;\n\t/** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n\tpreferredVertexPrecision?: string;\n\t/** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n\tpreferredFragmentPrecision?: string;\n\ttransformFeedbackVaryings?: {\n\t\tnames: string[];\n\t\tbufferMode: \"separate\" | \"interleaved\";\n\t};\n}\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlProgram {\n\t/** The default options used by the program. */\n\tstatic defaultOptions: Partial<GlProgramOptions>;\n\t/** the fragment glsl shader source. */\n\treadonly fragment?: string;\n\t/** the vertex glsl shader source */\n\treadonly vertex?: string;\n\t/**\n\t * attribute data extracted from the program once created this happens when the program is used for the first time\n\t * @internal\n\t */\n\t_attributeData: Record<string, ExtractedAttributeData>;\n\t/**\n\t * uniform data extracted from the program once created this happens when the program is used for the first time\n\t * @internal\n\t */\n\t_uniformData: Record<string, GlUniformData>;\n\t/**\n\t * uniform data extracted from the program once created this happens when the program is used for the first time\n\t * @internal\n\t */\n\t_uniformBlockData: Record<string, GlUniformBlockData>;\n\t/** details on how to use this program with transform feedback */\n\ttransformFeedbackVaryings?: {\n\t\tnames: string[];\n\t\tbufferMode: \"separate\" | \"interleaved\";\n\t};\n\t/**\n\t * the key that identifies the program via its source vertex + fragment\n\t * @internal\n\t */\n\treadonly _key: number;\n\t/**\n\t * A cache key used to identify the program instance.\n\t * @internal\n\t */\n\t_cacheKey: string;\n\t/**\n\t * Creates a shiny new GlProgram. Used by WebGL renderer.\n\t * @param options - The options for the program.\n\t */\n\tconstructor(options: GlProgramOptions);\n\t/** destroys the program */\n\tdestroy(): void;\n\t/**\n\t * Helper function that creates a program for a given source.\n\t * It will check the program cache if the program has already been created.\n\t * If it has that one will be returned, if not a new one will be created and cached.\n\t * @param options - The options for the program.\n\t * @returns A program using the same source\n\t */\n\tstatic from(options: GlProgramOptions): GlProgram;\n}\n/**\n * Stores GPU-specific data for a Geometry instance in WebGL context.\n *\n * This class manages Vertex Array Object (VAO) caching for geometries,\n * allowing efficient reuse of VAOs across different shader programs.\n * Each geometry can have multiple VAOs cached, one for each unique\n * shader program signature it's used with.\n * @internal\n */\nexport class GlGeometryGpuData implements GPUData {\n\tvaoCache: Record<string, WebGLVertexArrayObject>;\n\tconstructor();\n\tdestroy(): void;\n}\n/**\n * System plugin to the renderer to manage geometry.\n * @category rendering\n * @advanced\n */\nexport class GlGeometrySystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"geometry\";\n\t};\n\t/**\n\t * `true` if we has `*_vertex_array_object` extension.\n\t * @readonly\n\t */\n\thasVao: boolean;\n\t/**\n\t * `true` if has `ANGLE_instanced_arrays` extension.\n\t * @readonly\n\t */\n\thasInstance: boolean;\n\tprotected gl: GlRenderingContext;\n\tprotected _activeGeometry: Geometry;\n\t/** @internal */\n\t_activeVao: WebGLVertexArrayObject;\n\t/** @internal */\n\t_managedGeometries: GCManagedHash<Geometry>;\n\t/** Renderer that owns this {@link GeometrySystem}. */\n\tprivate _renderer;\n\t/** @param renderer - The renderer this System works for. */\n\tconstructor(renderer: WebGLRenderer);\n\t/** Sets up the renderer context and necessary buffers. */\n\tprotected contextChange(): void;\n\t/**\n\t * Binds geometry so that is can be drawn. Creating a Vao if required\n\t * @param geometry - Instance of geometry to bind.\n\t * @param program - Instance of program to use vao for.\n\t */\n\tbind(geometry?: Geometry, program?: GlProgram): void;\n\t/** Reset and unbind any active VAO and geometry. */\n\tresetState(): void;\n\t/** Update buffers of the currently bound geometry. */\n\tupdateBuffers(): void;\n\t/**\n\t * Check compatibility between a geometry and a program\n\t * @param geometry - Geometry instance.\n\t * @param program - Program instance.\n\t */\n\tprotected checkCompatibility(geometry: Geometry, program: GlProgram): void;\n\t/**\n\t * Takes a geometry and program and generates a unique signature for them.\n\t * @param geometry - To get signature from.\n\t * @param program - To test geometry against.\n\t * @returns - Unique signature of the geometry and program\n\t */\n\tprotected getSignature(geometry: Geometry, program: GlProgram): string;\n\tprotected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject;\n\t/**\n\t * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n\t * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n\t * attribute locations.\n\t * @param geometry - Instance of geometry to to generate Vao for.\n\t * @param program\n\t * @param _incRefCount - Increment refCount of all geometry buffers.\n\t */\n\tprotected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount?: boolean): WebGLVertexArrayObject;\n\tprotected onGeometryUnload(geometry: Geometry, contextLost?: boolean): void;\n\t/**\n\t * Dispose all WebGL resources of all managed geometries.\n\t * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n\t */\n\tdestroyAll(contextLost?: boolean): void;\n\t/**\n\t * Activate vertex array object.\n\t * @param geometry - Geometry instance.\n\t * @param program - Shader program instance.\n\t */\n\tprotected activateVao(geometry: Geometry, program: GlProgram): void;\n\t/**\n\t * Draws the currently bound geometry.\n\t * @param topology - The type primitive to render.\n\t * @param size - The number of elements to be rendered. If not specified, all vertices after the\n\t *  starting vertex will be drawn.\n\t * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n\t *  drawing will start from the first vertex.\n\t * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n\t *  all instances will be drawn.\n\t * @returns This instance of the geometry system.\n\t */\n\tdraw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this;\n\t/** Unbind/reset everything. */\n\tprotected unbind(): void;\n\tdestroy(): void;\n}\n/**\n * The index buffer array type used in geometries.\n * @category rendering\n * @advanced\n */\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n/**\n * The attribute data for a geometries attributes\n * @category rendering\n * @advanced\n */\nexport interface Attribute {\n\t/** the buffer that this attributes data belongs to */\n\tbuffer: Buffer$1;\n\t/** the format of the attribute */\n\tformat?: VertexFormat;\n\t/** the stride of the data in the buffer - in bytes*/\n\tstride?: number;\n\t/** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n\toffset?: number;\n\t/** is this an instanced buffer? (defaults to false) */\n\tinstance?: boolean;\n\t/** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n\tsize?: number;\n\t/**\n\t * the starting vertex in the geometry to start drawing from. If not specified,\n\t *  drawing will start from the first vertex.\n\t */\n\tstart?: number;\n\t/**\n\t * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n\t * issue a warning if one of the attributes has divisor set.\n\t */\n\tdivisor?: number;\n}\n/**\n * The attribute option used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOption = Omit<Attribute, \"buffer\"> & {\n\tbuffer: Buffer$1 | TypedArray | number[];\n} | Buffer$1 | TypedArray | number[];\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOptions = Record<string, AttributeOption>;\n/**\n * the interface that describes the structure of the geometry\n * @category rendering\n * @advanced\n */\nexport interface GeometryDescriptor {\n\t/** an optional label to easily identify the geometry */\n\tlabel?: string;\n\t/** the attributes that make up the geometry */\n\tattributes?: AttributeOptions;\n\t/** optional index buffer for this geometry */\n\tindexBuffer?: Buffer$1 | TypedArray | number[];\n\t/** the topology of the geometry, defaults to 'triangle-list' */\n\ttopology?: Topology;\n\tinstanceCount?: number;\n}\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @category rendering\n * @advanced\n */\nexport class Geometry extends EventEmitter<{\n\tupdate: Geometry;\n\tdestroy: Geometry;\n\tunload: Geometry;\n}> implements GPUDataOwner, GCable {\n\t/** @internal */\n\t_gpuData: Record<number, GlGeometryGpuData>;\n\t/** @internal */\n\t_gcData?: GCData;\n\t/** If set to true, the resource will be garbage collected automatically when it is not used. */\n\tautoGarbageCollect: boolean;\n\t/** @internal */\n\t_gcLastUsed: number;\n\t/** The topology of the geometry. */\n\ttopology: Topology;\n\t/** The unique id of the geometry. */\n\treadonly uid: number;\n\t/** A record of the attributes of the geometry. */\n\treadonly attributes: Record<string, Attribute>;\n\t/** The buffers that the attributes use */\n\treadonly buffers: Buffer$1[];\n\t/** The index buffer of the geometry */\n\tindexBuffer: Buffer$1;\n\t/**\n\t * the layout key will be generated by WebGPU all geometries that have the same structure\n\t * will have the same layout key. This is used to cache the pipeline layout\n\t * @internal\n\t */\n\t_layoutKey: number;\n\t/** the instance count of the geometry to draw */\n\tinstanceCount: number;\n\tprivate readonly _bounds;\n\tprivate _boundsDirty;\n\t/**\n\t * Create a new instance of a geometry\n\t * @param options - The options for the geometry.\n\t */\n\tconstructor(options?: GeometryDescriptor);\n\tprotected onBufferUpdate(): void;\n\t/**\n\t * Returns the requested attribute.\n\t * @param id - The name of the attribute required\n\t * @returns - The attribute requested.\n\t */\n\tgetAttribute(id: string): Attribute;\n\t/**\n\t * Returns the index buffer\n\t * @returns - The index buffer.\n\t */\n\tgetIndex(): Buffer$1;\n\t/**\n\t * Returns the requested buffer.\n\t * @param id - The name of the buffer required.\n\t * @returns - The buffer requested.\n\t */\n\tgetBuffer(id: string): Buffer$1;\n\t/**\n\t * Used to figure out how many vertices there are in this geometry\n\t * @returns the number of vertices in the geometry\n\t */\n\tgetSize(): number;\n\t/**\n\t * Adds an attribute to the geometry.\n\t * @param name - The name of the attribute to add.\n\t * @param attributeOption - The attribute option to add.\n\t */\n\taddAttribute(name: string, attributeOption: AttributeOption): void;\n\t/**\n\t * Adds an index buffer to the geometry.\n\t * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n\t */\n\taddIndex(indexBuffer: Buffer$1 | TypedArray | number[]): void;\n\t/** Returns the bounds of the geometry. */\n\tget bounds(): Bounds;\n\t/** Unloads the geometry from the GPU. */\n\tunload(): void;\n\t/**\n\t * destroys the geometry.\n\t * @param destroyBuffers - destroy the buffers associated with this geometry\n\t */\n\tdestroy(destroyBuffers?: boolean): void;\n}\n/**\n * This interface represents the extracted attribute data from a WebGL program.\n * It extends the `Attribute` interface but omits the `buffer` property.\n * It includes an optional `location` property that indicates where the shader location is for this attribute.\n * @category rendering\n * @advanced\n */\nexport interface ExtractedAttributeData extends Omit<Attribute, \"buffer\"> {\n\t/** set where the shader location is for this attribute */\n\tlocation?: number;\n}\n/**\n * returns the attribute data from the program\n * @private\n * @param {WebGLProgram} [program] - the WebGL program\n * @param {WebGLRenderingContext} [gl] - the WebGL context\n * @param sortAttributes\n * @returns {object} the attribute data for this program\n */\nexport function extractAttributesFromGlProgram(program: WebGLProgram, gl: WebGLRenderingContextBase, sortAttributes?: boolean): Record<string, ExtractedAttributeData>;\n/**\n * Defines the structure of the extracted WGSL structs and groups.\n * @category rendering\n * @advanced\n */\nexport interface StructsAndGroups {\n\tgroups: {\n\t\tgroup: number;\n\t\tbinding: number;\n\t\tname: string;\n\t\tisUniform: boolean;\n\t\ttype: string;\n\t}[];\n\tstructs: {\n\t\tname: string;\n\t\tmembers: Record<string, string>;\n\t}[];\n}\n/**\n * @param wgsl\n * @internal\n */\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups;\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @category rendering\n * @advanced\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @category rendering\n * @advanced\n */\nexport type ProgramLayout = Record<string, number>[];\n/**\n * the program source\n * @category rendering\n * @advanced\n */\nexport interface ProgramSource {\n\t/** The wgsl source code of the shader. */\n\tsource: string;\n\t/** The main function to run in this shader */\n\tentryPoint?: string;\n}\n/**\n * The options for the gpu program\n * @category rendering\n * @advanced\n */\nexport interface GpuProgramOptions {\n\t/**\n\t * the name of the program, this is added to the label of the GPU Program created\n\t * under the hood. Makes it much easier to debug!\n\t */\n\tname?: string;\n\t/** The fragment glsl shader source. */\n\tfragment?: ProgramSource;\n\t/** The vertex glsl shader source. */\n\tvertex?: ProgramSource;\n\t/** The layout of the program. If not provided, it will be generated from the shader sources. */\n\tlayout?: ProgramLayout;\n\t/** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n\tgpuLayout?: ProgramPipelineLayoutDescription;\n}\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @category rendering\n * @advanced\n */\nexport class GpuProgram {\n\t/** The fragment glsl shader source. */\n\treadonly fragment?: ProgramSource;\n\t/** The vertex glsl shader source */\n\treadonly vertex?: ProgramSource;\n\t/**\n\t * Mapping of uniform names to group indexes for organizing shader program uniforms.\n\t * Automatically generated from shader sources if not provided.\n\t * @example\n\t * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n\t * [\n\t *   { \"u_time\": 0 },\n\t *   { \"u_resolution\": 1 }\n\t * ]\n\t */\n\treadonly layout: ProgramLayout;\n\t/**\n\t * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n\t * Generated from shader sources if not explicitly provided.\n\t * @example\n\t * // Assuming a shader program that requires two bind groups:\n\t * [\n\t *   // First bind group layout entries\n\t *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n\t *   // Second bind group layout entries\n\t *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n\t *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n\t * ]\n\t */\n\treadonly gpuLayout: ProgramPipelineLayoutDescription;\n\t/** @internal */\n\t_layoutKey: number;\n\t/** @internal */\n\t_cacheKey: string;\n\t/** @internal */\n\t_attributeLocationsKey: number;\n\t/** the structs and groups extracted from the shader sources */\n\treadonly structsAndGroups: StructsAndGroups;\n\t/**\n\t * the name of the program, this is added to the label of the GPU Program created under the hood.\n\t * Makes it much easier to debug!\n\t */\n\treadonly name: string;\n\tprivate _attributeData;\n\t/** if true, the program will automatically assign global uniforms to group[0] */\n\tautoAssignGlobalUniforms: boolean;\n\t/** if true, the program will automatically assign local uniforms to group[1] */\n\tautoAssignLocalUniforms: boolean;\n\t/**\n\t * Create a new GpuProgram\n\t * @param options - The options for the gpu program\n\t */\n\tconstructor(options: GpuProgramOptions);\n\tprivate _generateProgramKey;\n\tget attributeData(): Record<string, ExtractedAttributeData>;\n\t/** destroys the program */\n\tdestroy(): void;\n\t/**\n\t * Helper function that creates a program for a given source.\n\t * It will check the program cache if the program has already been created.\n\t * If it has that one will be returned, if not a new one will be created and cached.\n\t * @param options - The options for the program.\n\t * @returns A program using the same source\n\t */\n\tstatic from(options: GpuProgramOptions): GpuProgram;\n}\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @category rendering\n * @advanced\n */\nexport class BindGroupSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"bindGroup\";\n\t};\n\tprivate readonly _renderer;\n\tprivate _hash;\n\tprivate _gpu;\n\tconstructor(renderer: WebGPURenderer);\n\tprotected contextChange(gpu: GPU$1): void;\n\tgetBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup;\n\tprivate _createBindGroup;\n\tdestroy(): void;\n}\n/**\n * The system that handles color masking for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuColorMaskSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"colorMask\";\n\t};\n\tprivate readonly _renderer;\n\tprivate _colorMaskCache;\n\tconstructor(renderer: WebGPURenderer);\n\tsetMask(colorMask: number): void;\n\tdestroy(): void;\n}\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @category rendering\n * @advanced\n */\nexport type ShaderGroups = Record<number, BindGroup>;\ninterface ShaderBase {\n\t/** The WebGL program used by the WebGL renderer. */\n\tglProgram?: GlProgram;\n\t/** The WebGPU program used by the WebGPU renderer. */\n\tgpuProgram?: GpuProgram;\n\t/**\n\t * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n\t * 0b00 - not compatible with either\n\t * 0b01 - compatible with WebGL\n\t * 0b10 - compatible with WebGPU\n\t * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n\t */\n\tcompatibleRenderers?: number;\n}\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GlShaderWith extends ShaderBase {\n\t/** The WebGL program used by the WebGL renderer. */\n\tglProgram: GlProgram;\n}\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GpuShaderWith extends ShaderBase {\n\t/** The WebGPU program used by the WebGPU renderer. */\n\tgpuProgram: GpuProgram;\n}\n/**\n * A descriptor for a shader with groups.\n * This is used to define a shader that uses {@link BindGroup}'s.\n * @category rendering\n * @advanced\n */\nexport interface ShaderWithGroupsDescriptor {\n\t/** A record of {@link BindGroup}'s used by the shader. */\n\tgroups: ShaderGroups;\n\t/** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n\tgroupMap?: Record<string, Record<string, any>>;\n}\ninterface ShaderWithResourcesDescriptor {\n\t/**\n\t * A key value of uniform resources used by the shader.\n\t * Under the hood pixi will look at the provided shaders and figure out where\n\t * the resources are mapped. Its up to you to make sure the resource key\n\t * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n\t */\n\tresources?: Record<string, any>;\n}\n/**\n * A descriptor for a shader\n * @category rendering\n * @advanced\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n/**\n * A descriptor for a shader with groups.\n * @category rendering\n * @advanced\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @category rendering\n * @advanced\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\n/**\n * A shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {\n}\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\ntype GlShaderFromWith = {\n\tgpu?: GpuProgramOptions;\n\tgl: GlProgramOptions;\n};\ntype GpuShaderFromWith = {\n\tgpu: GpuProgramOptions;\n\tgl?: GlProgramOptions;\n};\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, \"glProgram\" | \"gpuProgram\">;\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithResources, \"glProgram\" | \"gpuProgram\">;\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @category rendering\n * @advanced\n */\nexport class Shader extends EventEmitter<{\n\t\"destroy\": Shader;\n}> {\n\t/** A unique identifier for the shader */\n\treadonly uid: number;\n\t/** An instance of the GPU program used by the WebGPU renderer */\n\tgpuProgram: GpuProgram;\n\t/** An instance of the GL program used by the WebGL renderer */\n\tglProgram: GlProgram;\n\t/**\n\t * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n\t * 0b00 - not compatible with either\n\t * 0b01 - compatible with WebGL\n\t * 0b10 - compatible with WebGPU\n\t * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n\t */\n\treadonly compatibleRenderers: number;\n\t/** */\n\tgroups: Record<number, BindGroup>;\n\t/** A record of the resources used by the shader. */\n\tresources: Record<string, any>;\n\t/**\n\t * A record of the uniform groups and resources used by the shader.\n\t * This is used by WebGL renderer to sync uniform data.\n\t * @internal\n\t */\n\t_uniformBindMap: Record<number, Record<number, string>>;\n\tprivate readonly _ownedBindGroups;\n\t/** @internal */\n\t_destroyed: boolean;\n\t/**\n\t * Fired after rendering finishes.\n\t * @event Shader#destroy\n\t */\n\t/**\n\t * There are two ways to create a shader.\n\t * one is to pass in resources which is a record of uniform groups and resources.\n\t * another is to pass in groups which is a record of {@link BindGroup}s.\n\t * this second method is really to make use of shared {@link BindGroup}s.\n\t * For most cases you will want to use resources as they are easier to work with.\n\t * USe Groups if you want to share {@link BindGroup}s between shaders.\n\t * you cannot mix and match - either use resources or groups.\n\t * @param options - The options for the shader\n\t */\n\tconstructor(options: ShaderWithResources);\n\tconstructor(options: ShaderWithGroups);\n\t/**\n\t * Sometimes a resource group will be provided later (for example global uniforms)\n\t * In such cases, this method can be used to let the shader know about the group.\n\t * @param name - the name of the resource group\n\t * @param groupIndex - the index of the group (should match the webGPU shader group location)\n\t * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n\t */\n\taddResource(name: string, groupIndex: number, bindIndex: number): void;\n\tprivate _buildResourceAccessor;\n\t/**\n\t * Use to destroy the shader when its not longer needed.\n\t * It will destroy the resources and remove listeners.\n\t * @param destroyPrograms - if the programs should be destroyed as well.\n\t * Make sure its not being used by other shaders!\n\t */\n\tdestroy(destroyPrograms?: boolean): void;\n\t/**\n\t * A short hand function to create a shader based of a vertex and fragment shader.\n\t * @param options\n\t * @returns A shiny new PixiJS shader!\n\t */\n\tstatic from(options: ShaderFromGroups): Shader;\n\tstatic from(options: ShaderFromResources): Shader;\n}\n/**\n * Various blend modes supported by Pixi\n * @category filters\n * @standard\n */\nexport type BLEND_MODES = \"inherit\" | \"normal\" | \"add\" | \"multiply\" | \"screen\" | \"darken\" | \"lighten\" | \"erase\" | \"color-dodge\" | \"color-burn\" | \"linear-burn\" | \"linear-dodge\" | \"linear-light\" | \"hard-light\" | \"soft-light\" | \"pin-light\" | \"difference\" | \"exclusion\" | \"overlay\" | \"saturation\" | \"color\" | \"luminosity\" | \"normal-npm\" | \"add-npm\" | \"screen-npm\" | \"none\" | \"subtract\" | \"divide\" | \"vivid-light\" | \"hard-mix\" | \"negation\" | \"min\" | \"max\";\n/**\n * The map of blend modes supported by Pixi\n * @category rendering\n * @advanced\n */\nexport const BLEND_TO_NPM: {\n\tnormal: string;\n\tadd: string;\n\tscreen: string;\n};\n/**\n * The stencil operation to perform when using the stencil buffer\n * @category rendering\n * @advanced\n */\nexport enum STENCIL_MODES {\n\tDISABLED = 0,\n\tRENDERING_MASK_ADD = 1,\n\tMASK_ACTIVE = 2,\n\tINVERSE_MASK_ACTIVE = 3,\n\tRENDERING_MASK_REMOVE = 4,\n\tNONE = 5\n}\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @category rendering\n * @advanced\n */\nexport type CULL_MODES = \"none\" | \"back\" | \"front\";\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State {\n\t/**\n\t * The data is a unique number based on the states settings.\n\t * This lets us quickly compare states with a single number rather than looking\n\t * at all the individual settings.\n\t */\n\tdata: number;\n\t/** @internal */\n\t_blendModeId: number;\n\tprivate _blendMode;\n\tprivate _polygonOffset;\n\tconstructor();\n\t/**\n\t * Activates blending of the computed fragment color values.\n\t * @default true\n\t */\n\tget blend(): boolean;\n\tset blend(value: boolean);\n\t/**\n\t * Activates adding an offset to depth values of polygon's fragments\n\t * @default false\n\t */\n\tget offsets(): boolean;\n\tset offsets(value: boolean);\n\t/** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n\tset cullMode(value: CULL_MODES);\n\tget cullMode(): CULL_MODES;\n\t/**\n\t * Activates culling of polygons.\n\t * @default false\n\t */\n\tget culling(): boolean;\n\tset culling(value: boolean);\n\t/**\n\t * Activates depth comparisons and updates to the depth buffer.\n\t * @default false\n\t */\n\tget depthTest(): boolean;\n\tset depthTest(value: boolean);\n\t/**\n\t * Enables or disables writing to the depth buffer.\n\t * @default true\n\t */\n\tget depthMask(): boolean;\n\tset depthMask(value: boolean);\n\t/**\n\t * Specifies whether or not front or back-facing polygons can be culled.\n\t * @default false\n\t */\n\tget clockwiseFrontFace(): boolean;\n\tset clockwiseFrontFace(value: boolean);\n\t/**\n\t * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n\t * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n\t * @default 'normal'\n\t */\n\tget blendMode(): BLEND_MODES;\n\tset blendMode(value: BLEND_MODES);\n\t/**\n\t * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n\t * @default 0\n\t */\n\tget polygonOffset(): number;\n\tset polygonOffset(value: number);\n\ttoString(): string;\n\t/**\n\t * A quickly getting an instance of a State that is configured for 2d rendering.\n\t * @returns a new State with values set for 2d rendering\n\t */\n\tstatic for2d(): State;\n\tstatic default2d: State;\n}\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTarget {\n\tcontexts: GPUCanvasContext[];\n\tmsaaTextures: TextureSource[];\n\tmsaa: boolean;\n\tmsaaSamples: number;\n\tcolorTargetCount: number;\n\twidth: number;\n\theight: number;\n\tdescriptor: GPURenderPassDescriptor;\n}\n/**\n * The system that handles encoding commands for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuEncoderSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"encoder\";\n\t\treadonly priority: 1;\n\t};\n\tcommandEncoder: GPUCommandEncoder;\n\trenderPassEncoder: GPURenderPassEncoder;\n\tcommandFinished: Promise<void>;\n\tprivate _resolveCommandFinished;\n\tprivate _gpu;\n\tprivate _boundBindGroup;\n\tprivate _boundVertexBuffer;\n\tprivate _boundIndexBuffer;\n\tprivate _boundPipeline;\n\tprivate readonly _renderer;\n\tconstructor(renderer: WebGPURenderer);\n\trenderStart(): void;\n\tbeginRenderPass(gpuRenderTarget: GpuRenderTarget): void;\n\tendRenderPass(): void;\n\tsetViewport(viewport: Rectangle): void;\n\tsetPipelineFromGeometryProgramAndState(geometry: Geometry, program: GpuProgram, state: any, topology?: Topology): void;\n\tsetPipeline(pipeline: GPURenderPipeline): void;\n\tprivate _setVertexBuffer;\n\tprivate _setIndexBuffer;\n\tresetBindGroup(index: number): void;\n\tsetBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram): void;\n\tsetGeometry(geometry: Geometry, program: GpuProgram): void;\n\tprivate _setShaderBindGroups;\n\tprivate _syncBindGroup;\n\tdraw(options: {\n\t\tgeometry: Geometry;\n\t\tshader: Shader;\n\t\tstate?: State;\n\t\ttopology?: Topology;\n\t\tsize?: number;\n\t\tstart?: number;\n\t\tinstanceCount?: number;\n\t\tskipSync?: boolean;\n\t}): void;\n\tfinishRenderPass(): void;\n\tpostrender(): void;\n\trestoreRenderPass(): void;\n\tprivate _clearCache;\n\tdestroy(): void;\n\tprotected contextChange(gpu: GPU$1): void;\n}\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the WebGPU Device rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGPURenderer();\n * await renderer.init(); // GPU limits are populated after this call\n *\n * console.log(renderer.limits.maxTextures);\n * console.log(renderer.limits.maxBatchableTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GpuLimitsSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"limits\";\n\t};\n\t/** The maximum number of textures that can be used by a shader */\n\tmaxTextures: number;\n\t/** The maximum number of batchable textures */\n\tmaxBatchableTextures: number;\n\tprivate readonly _renderer;\n\tconstructor(renderer: WebGPURenderer);\n\tcontextChange(): void;\n\tdestroy(): void;\n}\n/**\n * Options for creating a render target.\n * @category rendering\n * @advanced\n */\nexport interface RenderTargetOptions {\n\t/** the width of the RenderTarget */\n\twidth?: number;\n\t/** the height of the RenderTarget */\n\theight?: number;\n\t/** the resolution of the RenderTarget */\n\tresolution?: number;\n\t/** an array of textures, or a number indicating how many color textures there should be */\n\tcolorTextures?: BindableTexture[] | number;\n\t/** should this render target have a stencil buffer? */\n\tstencil?: boolean;\n\t/** should this render target have a depth buffer? */\n\tdepth?: boolean;\n\t/** a depth stencil texture that the depth and stencil outputs will be written to */\n\tdepthStencilTexture?: BindableTexture | boolean;\n\t/** should this render target be antialiased? */\n\tantialias?: boolean;\n\t/** is this a root element, true if this is gl context owners render target */\n\tisRoot?: boolean;\n}\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @category rendering\n * @advanced\n */\nexport class RenderTarget {\n\t/** The default options for a render target */\n\tstatic defaultOptions: RenderTargetOptions;\n\t/** unique id for this render target */\n\treadonly uid: number;\n\t/**\n\t * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n\t * write to multiple if required! (eg deferred lighting)\n\t */\n\tcolorTextures: TextureSource[];\n\t/** the stencil and depth buffer will right to this texture in WebGPU */\n\tdepthStencilTexture: TextureSource;\n\t/** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n\tstencil: boolean;\n\t/** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n\tdepth: boolean;\n\tdirtyId: number;\n\tisRoot: boolean;\n\tprivate readonly _size;\n\t/** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n\tprivate readonly _managedColorTextures;\n\t/**\n\t * @param [descriptor] - Options for creating a render target.\n\t */\n\tconstructor(descriptor?: RenderTargetOptions);\n\tget size(): [\n\t\tnumber,\n\t\tnumber\n\t];\n\tget width(): number;\n\tget height(): number;\n\tget pixelWidth(): number;\n\tget pixelHeight(): number;\n\tget resolution(): number;\n\tget colorTexture(): TextureSource;\n\tprotected onSourceResize(source: TextureSource): void;\n\t/**\n\t * This will ensure a depthStencil texture is created for this render target.\n\t * Most likely called by the mask system to make sure we have stencil buffer added.\n\t * @internal\n\t */\n\tensureDepthStencilTexture(): void;\n\tresize(width: number, height: number, resolution?: number, skipColorTexture?: boolean): void;\n\tdestroy(): void;\n}\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GpuStencilSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"stencil\";\n\t};\n\tprivate readonly _renderer;\n\tprivate _renderTargetStencilState;\n\tprivate _activeRenderTarget;\n\tconstructor(renderer: WebGPURenderer);\n\tprotected onRenderTargetChange(renderTarget: RenderTarget): void;\n\tsetStencilMode(stencilMode: STENCIL_MODES, stencilReference: number): void;\n\tdestroy(): void;\n}\n/** @internal */\nexport const UNIFORM_TYPES_VALUES: readonly [\n\t\"f32\",\n\t\"i32\",\n\t\"vec2<f32>\",\n\t\"vec3<f32>\",\n\t\"vec4<f32>\",\n\t\"mat2x2<f32>\",\n\t\"mat3x3<f32>\",\n\t\"mat4x4<f32>\",\n\t\"mat3x2<f32>\",\n\t\"mat4x2<f32>\",\n\t\"mat2x3<f32>\",\n\t\"mat4x3<f32>\",\n\t\"mat2x4<f32>\",\n\t\"mat3x4<f32>\",\n\t\"vec2<i32>\",\n\t\"vec3<i32>\",\n\t\"vec4<i32>\"\n];\n/**\n * useful for checking if a type is supported - a map of supported types with a true value.\n * @internal\n */\nexport const UNIFORM_TYPES_MAP: Record<UNIFORM_TYPES, boolean>;\n/** @internal */\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\ntype OPTIONAL_SPACE = \" \" | \"\";\n/** @internal */\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n/** @internal */\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n/**\n * This is the type of the uniform structures that are used in the UniformGroup.\n * @category rendering\n * @advanced\n */\nexport interface UniformData {\n\t/** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n\tvalue: unknown;\n\ttype: UNIFORM_TYPES;\n\t/** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n\tsize?: number;\n\tname?: string;\n}\n/** @internal */\nexport interface UboElement {\n\tdata: UniformData;\n\toffset: number;\n\tsize: number;\n}\n/** @internal */\nexport interface UboLayout {\n\tuboElements: UboElement[];\n\t/** float32 size // TODO change to bytes */\n\tsize: number;\n}\n/** @internal */\nexport type UniformsSyncCallback = (...args: any[]) => void;\ntype FLOPS<T = UniformData> = T extends {\n\tvalue: infer V;\n} ? V : never;\n/**\n * Extracts the value type from a uniform data object.\n * @internal\n */\nexport type ExtractUniformObject<T = Record<string, UniformData>> = {\n\t[K in keyof T]: FLOPS<T[K]>;\n};\n/**\n * Uniform group options\n * @category rendering\n * @advanced\n */\nexport type UniformGroupOptions = {\n\t/**\n\t * if true the UniformGroup is handled as an Uniform buffer object.\n\t * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n\t * So don't set to true if you want to use WebGPU :D\n\t */\n\tubo?: boolean;\n\t/** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n\tisStatic?: boolean;\n};\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```ts\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n * ```\n * @category rendering\n * @advanced\n */\nexport class UniformGroup<UNIFORMS extends {\n\t[key: string]: UniformData;\n} = any> implements BindResource {\n\t/** The default options used by the uniform group. */\n\tstatic defaultOptions: UniformGroupOptions;\n\t/**\n\t * used internally to know if a uniform group was used in the last render pass\n\t * @internal\n\t */\n\t_touched: number;\n\t/** a unique id for this uniform group used through the renderer */\n\treadonly uid: number;\n\t/**\n\t * a resource type, used to identify how to handle it when its in a bind group / shader resource\n\t * @internal\n\t */\n\t_resourceType: string;\n\t/**\n\t * the resource id used internally by the renderer to build bind group keys\n\t * @internal\n\t */\n\t_resourceId: number;\n\t/** the structures of the uniform group */\n\tuniformStructures: UNIFORMS;\n\t/** the uniforms as an easily accessible map of properties */\n\tuniforms: ExtractUniformObject<UNIFORMS>;\n\t/** true if it should be used as a uniform buffer object */\n\tubo: boolean;\n\t/** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n\tbuffer?: Buffer$1;\n\t/**\n\t * if true, then you are responsible for when the data is uploaded to the GPU.\n\t * otherwise, the data is reuploaded each frame.\n\t */\n\tisStatic: boolean;\n\t/** used ito identify if this is a uniform group */\n\treadonly isUniformGroup = true;\n\t/**\n\t * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n\t * @internal\n\t */\n\t_dirtyId: number;\n\t/**\n\t * a signature string generated for internal use\n\t * @internal\n\t */\n\treadonly _signature: number;\n\treadonly destroyed = false;\n\t/**\n\t * Create a new Uniform group\n\t * @param uniformStructures - The structures of the uniform group\n\t * @param options - The optional parameters of this uniform group\n\t */\n\tconstructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions);\n\t/** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n\tupdate(): void;\n}\n/** @internal */\nexport interface UboAdaptor {\n\tcreateUboElements: (uniformData: UniformData[]) => UboLayout;\n\tgenerateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @category rendering\n * @advanced\n */\nexport class UboSystem implements System {\n\t/** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n\tprivate _syncFunctionHash;\n\tprivate readonly _adaptor;\n\tconstructor(adaptor: UboAdaptor);\n\t/**\n\t * Overridable function by `pixi.js/unsafe-eval` to silence\n\t * throwing an error if platform doesn't support unsafe-evals.\n\t * @private\n\t */\n\tprivate _systemCheck;\n\tensureUniformGroup(uniformGroup: UniformGroup): void;\n\tgetUniformGroupData(uniformGroup: UniformGroup): {\n\t\tlayout: UboLayout;\n\t\tsyncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void;\n\t};\n\tprivate _initUniformGroup;\n\tprivate _generateUboSync;\n\tsyncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean;\n\tupdateUniformGroup(uniformGroup: UniformGroup): boolean;\n\tdestroy(): void;\n}\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @category rendering\n * @advanced\n */\nexport class GpuUboSystem extends UboSystem {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"ubo\";\n\t};\n\tconstructor();\n}\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @category rendering\n * @advanced\n */\nexport class BufferResource extends EventEmitter<{\n\tchange: BindResource;\n}> implements BindResource {\n\t/**\n\t * emits when the underlying buffer has changed shape (i.e. resized)\n\t * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n\t * @event change\n\t */\n\t/** a unique id for this uniform group used through the renderer */\n\treadonly uid: number;\n\t/**\n\t * a resource type, used to identify how to handle it when its in a bind group / shader resource\n\t * @internal\n\t */\n\treadonly _resourceType = \"bufferResource\";\n\t/**\n\t * used internally to know if a uniform group was used in the last render pass\n\t * @internal\n\t */\n\t_touched: number;\n\t/**\n\t * the resource id used internally by the renderer to build bind group keys\n\t * @internal\n\t */\n\t_resourceId: number;\n\t/** the underlying buffer that this resource is using */\n\tbuffer: Buffer$1;\n\t/** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n\treadonly offset: number;\n\t/** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n\treadonly size: number;\n\t/**\n\t * A cheeky hint to the GL renderer to let it know this is a BufferResource\n\t * @internal\n\t */\n\treadonly _bufferResource = true;\n\t/**\n\t * Has the Buffer resource been destroyed?\n\t * @readonly\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * Create a new Buffer Resource.\n\t * @param options - The options for the buffer resource\n\t * @param options.buffer - The underlying buffer that this resource is using\n\t * @param options.offset - The offset of the buffer this resource is using.\n\t * If not provided, then it will use the offset of the buffer.\n\t * @param options.size - The size of the buffer this resource is using.\n\t * If not provided, then it will use the size of the buffer.\n\t */\n\tconstructor({ buffer, offset, size }: {\n\t\tbuffer: Buffer$1;\n\t\toffset?: number;\n\t\tsize?: number;\n\t});\n\tprotected onBufferChange(): void;\n\t/**\n\t * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n\t * if you want to destroy it as well, or code will explode\n\t * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n\t */\n\tdestroy(destroyBuffer?: boolean): void;\n}\n/** @internal */\nexport class GpuUniformBatchPipe {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUPipes\n\t\t];\n\t\treadonly name: \"uniformBatch\";\n\t};\n\tprivate _renderer;\n\tprivate _bindGroupHash;\n\tprivate readonly _batchBuffer;\n\tprivate _buffers;\n\tprivate _bindGroups;\n\tprivate _bufferResources;\n\tconstructor(renderer: WebGPURenderer);\n\trenderEnd(): void;\n\tprivate _resetBindGroups;\n\tgetUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup;\n\tgetUboResource(group: UniformGroup<any>): BufferResource;\n\tgetArrayBindGroup(data: Float32Array): BindGroup;\n\tgetArrayBufferResource(data: Float32Array): BufferResource;\n\tprivate _getBufferResource;\n\tprivate _getBindGroup;\n\tprivate _uploadBindGroups;\n\tdestroy(): void;\n}\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @category rendering\n * @advanced\n */\nexport class PipelineSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"pipeline\";\n\t};\n\tprivate readonly _renderer;\n\tprotected CONTEXT_UID: number;\n\tprivate _moduleCache;\n\tprivate _bufferLayoutsCache;\n\tprivate readonly _bindingNamesCache;\n\tprivate _pipeCache;\n\tprivate readonly _pipeStateCaches;\n\tprivate _gpu;\n\tprivate _stencilState;\n\tprivate _stencilMode;\n\tprivate _colorMask;\n\tprivate _multisampleCount;\n\tprivate _colorTargetCount;\n\tprivate _depthStencilAttachment;\n\tconstructor(renderer: WebGPURenderer);\n\tprotected contextChange(gpu: GPU$1): void;\n\tsetMultisampleCount(multisampleCount: number): void;\n\tsetRenderTarget(renderTarget: GpuRenderTarget): void;\n\tsetColorMask(colorMask: number): void;\n\tsetStencilMode(stencilMode: STENCIL_MODES): void;\n\tsetPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void;\n\tgetPipeline(geometry: Geometry, program: GpuProgram, state: State, topology?: Topology): GPURenderPipeline;\n\tprivate _createPipeline;\n\tprivate _getModule;\n\tprivate _createModule;\n\tprivate _generateBufferKey;\n\tprivate _generateAttributeLocationsKey;\n\t/**\n\t * Returns a hash of buffer names mapped to bind locations.\n\t * This is used to bind the correct buffer to the correct location in the shader.\n\t * @param geometry - The geometry where to get the buffer names\n\t * @param program - The program where to get the buffer names\n\t * @returns An object of buffer names mapped to the bind location.\n\t */\n\tgetBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>;\n\tprivate _createVertexBufferLayouts;\n\tprivate _updatePipeHash;\n\tdestroy(): void;\n}\n/**\n * Represents a render target.\n * @category rendering\n * @ignore\n */\nexport class GlRenderTarget {\n\twidth: number;\n\theight: number;\n\tmsaa: boolean;\n\tframebuffer: WebGLFramebuffer;\n\tresolveTargetFramebuffer: WebGLFramebuffer;\n\tmsaaRenderBuffer: WebGLRenderbuffer[];\n\tdepthStencilRenderBuffer: WebGLRenderbuffer;\n}\n/**\n * A render surface is a texture, canvas, or render target\n * @category rendering\n * @see environment.ICanvas\n * @see Texture\n * @see RenderTarget\n * @advanced\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> {\n\tinit(\n\t/** the renderer */\n\trenderer: Renderer, \n\t/** the render target system */\n\trenderTargetSystem: RenderTargetSystem<RENDER_TARGET>): void;\n\t/** A function copies the contents of a render surface to a texture */\n\tcopyToTexture(\n\t/** the render surface to copy from  */\n\tsourceRenderSurfaceTexture: RenderTarget, \n\t/** the texture to copy to */\n\tdestinationTexture: Texture, \n\t/** the origin of the copy */\n\toriginSrc: {\n\t\tx: number;\n\t\ty: number;\n\t}, \n\t/** the size of the copy */\n\tsize: {\n\t\twidth: number;\n\t\theight: number;\n\t}, \n\t/** the destination origin (top left to paste from!) */\n\toriginDest?: {\n\t\tx: number;\n\t\ty: number;\n\t}): Texture;\n\t/** starts a render pass on the render target */\n\tstartRenderPass(\n\t/** the render target to start the render pass on */\n\trenderTarget: RenderTarget, clear: CLEAR_OR_BOOL, \n\t/** the color to clear to */\n\tclearColor?: RgbaArray, \n\t/** the viewport to use */\n\tviewport?: Rectangle): void;\n\t/** clears the current render target to the specified color */\n\tclear(\n\t/** the render target to clear */\n\trenderTarget: RenderTarget, \n\t/** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n\tclear: CLEAR_OR_BOOL, \n\t/** the color to clear to   */\n\tclearColor?: RgbaArray, \n\t/** the viewport to use */\n\tviewport?: Rectangle): void;\n\t/** finishes the current render pass */\n\tfinishRenderPass(renderTarget: RenderTarget): void;\n\t/** called after the render pass is finished */\n\tpostrender?(renderTarget: RenderTarget): void;\n\t/** called before the render main pass is started */\n\tprerender?(renderTarget: RenderTarget): void;\n\t/**\n\t * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n\t * Its different type of object depending on the renderer.\n\t */\n\tinitGpuRenderTarget(\n\t/** the render target to initialize */\n\trenderTarget: RenderTarget): RENDER_TARGET;\n\t/** called when a render target is resized */\n\tresizeGpuRenderTarget(\n\t/** the render target to resize */\n\trenderTarget: RenderTarget): void;\n\t/** destroys the gpu render target */\n\tdestroyGpuRenderTarget(\n\t/** the render target to destroy */\n\tgpuRenderTarget: RENDER_TARGET): void;\n}\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System {\n\t/** When rendering of a scene begins, this is where the root render surface is stored */\n\trootRenderTarget: RenderTarget;\n\t/** This is the root viewport for the render pass*/\n\trootViewPort: Rectangle;\n\t/** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n\trenderingToScreen: boolean;\n\t/** the current active render target */\n\trenderTarget: RenderTarget;\n\t/** the current active render surface that the render target is created from */\n\trenderSurface: RenderSurface;\n\t/** the current viewport that the gpu is using */\n\treadonly viewport: Rectangle;\n\t/**\n\t * a runner that lets systems know if the active render target has changed.\n\t * Eg the Stencil System needs to know so it can manage the stencil buffer\n\t */\n\treadonly onRenderTargetChange: SystemRunner;\n\t/** the projection matrix that is used by the shaders based on the active render target and the viewport */\n\treadonly projectionMatrix: Matrix;\n\t/** the default clear color for render targets */\n\treadonly defaultClearColor: RgbaArray;\n\t/** a reference to the adaptor that interfaces with WebGL / WebGP */\n\treadonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n\t/**\n\t * a hash that stores the render target for a given render surface. When you pass in a texture source,\n\t * a render target is created for it. This map stores and makes it easy to retrieve the render target\n\t */\n\tprivate readonly _renderSurfaceToRenderTargetHash;\n\t/** A hash that stores a gpu render target for a given render target. */\n\tprivate _gpuRenderTargetHash;\n\t/**\n\t * A stack that stores the render target and frame that is currently being rendered to.\n\t * When push is called, the current render target is stored in this stack.\n\t * When pop is called, the previous render target is restored.\n\t */\n\tprivate readonly _renderTargetStack;\n\t/** A reference to the renderer */\n\tprivate readonly _renderer;\n\tconstructor(renderer: Renderer);\n\t/** called when dev wants to finish a render pass */\n\tfinishRenderPass(): void;\n\t/**\n\t * called when the renderer starts to render a scene.\n\t * @param options\n\t * @param options.target - the render target to render to\n\t * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n\t * @param options.clearColor - the color to clear to\n\t * @param options.frame - the frame to render to\n\t */\n\trenderStart({ target, clear, clearColor, frame }: {\n\t\ttarget: RenderSurface;\n\t\tclear: CLEAR_OR_BOOL;\n\t\tclearColor: RgbaArray;\n\t\tframe?: Rectangle;\n\t}): void;\n\tpostrender(): void;\n\t/**\n\t * Binding a render surface! This is the main function of the render target system.\n\t * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n\t * Once bound all draw calls will be rendered to the render surface.\n\t *\n\t * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n\t * @param renderSurface - the render surface to bind\n\t * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n\t * @param clearColor - the color to clear to\n\t * @param frame - the frame to render to\n\t * @returns the render target that was bound\n\t */\n\tbind(renderSurface: RenderSurface, clear?: CLEAR_OR_BOOL, clearColor?: RgbaArray, frame?: Rectangle): RenderTarget;\n\tclear(target?: RenderSurface, clear?: CLEAR_OR_BOOL, clearColor?: RgbaArray): void;\n\tprotected contextChange(): void;\n\t/**\n\t * Push a render surface to the renderer. This will bind the render surface to the renderer,\n\t * @param renderSurface - the render surface to push\n\t * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n\t * @param clearColor - the color to clear to\n\t * @param frame - the frame to use when rendering to the render surface\n\t */\n\tpush(renderSurface: RenderSurface, clear?: CLEAR | boolean, clearColor?: RgbaArray, frame?: Rectangle): RenderTarget;\n\t/** Pops the current render target from the renderer and restores the previous render target. */\n\tpop(): void;\n\t/**\n\t * Gets the render target from the provide render surface. Eg if its a texture,\n\t * it will return the render target for the texture.\n\t * If its a render target, it will return the same render target.\n\t * @param renderSurface - the render surface to get the render target for\n\t * @returns the render target for the render surface\n\t */\n\tgetRenderTarget(renderSurface: RenderSurface): RenderTarget;\n\t/**\n\t * Copies a render surface to another texture.\n\t *\n\t * NOTE:\n\t * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n\t *\n\t * The following is not valid:\n\t * @example\n\t * const canvas = document.createElement('canvas')\n\t * canvas.width = 200;\n\t * canvas.height = 200;\n\t *\n\t * const ctx = canvas2.getContext('2d')!\n\t * ctx.fillStyle = 'red'\n\t * ctx.fillRect(0, 0, 200, 200);\n\t *\n\t * const texture = RenderTexture.create({\n\t *   width: 200,\n\t *   height: 200,\n\t * })\n\t * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n\t *\n\t * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n\t *\n\t * The best way to copy a canvas is to create a texture from it. Then render with that.\n\t *\n\t * Parsing in a RenderTarget canvas context (with a 2d context)\n\t * @param sourceRenderSurfaceTexture - the render surface to copy from\n\t * @param destinationTexture - the texture to copy to\n\t * @param originSrc - the origin of the copy\n\t * @param originSrc.x - the x origin of the copy\n\t * @param originSrc.y - the y origin of the copy\n\t * @param size - the size of the copy\n\t * @param size.width - the width of the copy\n\t * @param size.height - the height of the copy\n\t * @param originDest - the destination origin (top left to paste from!)\n\t * @param originDest.x - the x origin of the paste\n\t * @param originDest.y - the y origin of the paste\n\t */\n\tcopyToTexture(sourceRenderSurfaceTexture: RenderTarget, destinationTexture: Texture, originSrc: {\n\t\tx: number;\n\t\ty: number;\n\t}, size: {\n\t\twidth: number;\n\t\theight: number;\n\t}, originDest: {\n\t\tx: number;\n\t\ty: number;\n\t}): Texture<TextureSource<any>>;\n\t/**\n\t * ensures that we have a depth stencil buffer available to render to\n\t * This is used by the mask system to make sure we have a stencil buffer.\n\t */\n\tensureDepthStencil(): void;\n\t/** nukes the render target system */\n\tdestroy(): void;\n\tprivate _initRenderTarget;\n\tgetGpuRenderTarget(renderTarget: RenderTarget): RENDER_TARGET;\n\tresetState(): void;\n}\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget> {\n\tprivate _renderTargetSystem;\n\tprivate _renderer;\n\tinit(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void;\n\tcopyToTexture(sourceRenderSurfaceTexture: RenderTarget, destinationTexture: Texture, originSrc: {\n\t\tx: number;\n\t\ty: number;\n\t}, size: {\n\t\twidth: number;\n\t\theight: number;\n\t}, originDest: {\n\t\tx: number;\n\t\ty: number;\n\t}): Texture<TextureSource<any>>;\n\tstartRenderPass(renderTarget: RenderTarget, clear?: CLEAR_OR_BOOL, clearColor?: RgbaArray, viewport?: Rectangle): void;\n\tfinishRenderPass(): void;\n\t/**\n\t * returns the gpu texture for the first color texture in the render target\n\t * mainly used by the filter manager to get copy the texture for blending\n\t * @param renderTarget\n\t * @returns a gpu texture\n\t */\n\tprivate _getGpuColorTexture;\n\tgetDescriptor(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearValue: RgbaArray): GPURenderPassDescriptor;\n\tclear(renderTarget: RenderTarget, clear?: CLEAR_OR_BOOL, clearColor?: RgbaArray, viewport?: Rectangle): void;\n\tinitGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget;\n\tdestroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget): void;\n\tensureDepthStencilTexture(renderTarget: RenderTarget): void;\n\tresizeGpuRenderTarget(renderTarget: RenderTarget): void;\n}\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"renderTarget\";\n\t};\n\tadaptor: GpuRenderTargetAdaptor;\n\tconstructor(renderer: WebGPURenderer);\n}\n/**\n * Data structure for GPU program layout.\n * Contains bind group layouts and pipeline layout.\n * @category rendering\n * @advanced\n */\nexport interface GPUProgramData {\n\tbindGroups: GPUBindGroupLayout[];\n\tpipeline: GPUPipelineLayout;\n}\n/**\n * A system that manages the rendering of GpuPrograms.\n * @category rendering\n * @advanced\n */\nexport class GpuShaderSystem {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"shader\";\n\t};\n\tprivate _gpu;\n\tprivate readonly _gpuProgramData;\n\tprotected contextChange(gpu: GPU$1): void;\n\tgetProgramData(program: GpuProgram): GPUProgramData;\n\tprivate _createGPUProgramData;\n\tdestroy(): void;\n}\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @category rendering\n * @advanced\n */\nexport class GpuStateSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"state\";\n\t};\n\t/**\n\t * State ID\n\t * @readonly\n\t */\n\tstateId: number;\n\t/**\n\t * Polygon offset\n\t * @readonly\n\t */\n\tpolygonOffset: number;\n\t/**\n\t * Blend mode\n\t * @default 'none'\n\t * @readonly\n\t */\n\tblendMode: BLEND_MODES;\n\t/** Whether current blend equation is different */\n\tprotected _blendEq: boolean;\n\t/**\n\t * GL context\n\t * @type {WebGLRenderingContext}\n\t * @readonly\n\t */\n\tprotected gpu: GPU$1;\n\t/**\n\t * Default WebGL State\n\t * @readonly\n\t */\n\tprotected defaultState: State;\n\tconstructor();\n\tprotected contextChange(gpu: GPU$1): void;\n\t/**\n\t * Gets the blend mode data for the current state\n\t * @param state - The state to get the blend mode from\n\t * @param count - The number of color targets to create\n\t */\n\tgetColorTargets(state: State, count: number): GPUColorTargetState[];\n\tdestroy(): void;\n}\n/**\n * An effect that can be applied to a container. This is used to create effects such as filters/masks etc.\n * @category rendering\n * @advanced\n */\nexport interface Effect {\n\tpipe: string;\n\tpriority: number;\n\taddBounds?(bounds: Bounds, skipUpdateTransform?: boolean): void;\n\taddLocalBounds?(bounds: Bounds, localRoot: Container): void;\n\tcontainsPoint?(point: PointData, hitTestFn: (container: Container, point: Point) => boolean): boolean;\n\tdestroy(): void;\n}\n/**\n * The constructor for an Effect.\n * It is used to create instances of effects that can be applied to containers.\n * @param options - The options for the effect.\n * @returns A new instance of the effect.\n * @category rendering\n * @advanced\n */\nexport interface EffectConstructor {\n\tnew (options?: any): Effect;\n\ttest?(options: any): boolean;\n}\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @category utils\n * @advanced\n */\nexport class ViewableBuffer {\n\t/** The size of the buffer in bytes. */\n\tsize: number;\n\t/** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n\trawBinaryData: ArrayBuffer;\n\t/** View on the raw binary data as a `Uint32Array`. */\n\tuint32View: Uint32Array;\n\t/** View on the raw binary data as a `Float32Array`. */\n\tfloat32View: Float32Array;\n\t/** View on the raw binary data as a `Uint16Array`. */\n\tuint16View: Uint16Array;\n\tprivate _int8View;\n\tprivate _uint8View;\n\tprivate _int16View;\n\tprivate _int32View;\n\tprivate _float64Array;\n\tprivate _bigUint64Array;\n\t/**\n\t * @param length - The size of the buffer in bytes.\n\t */\n\tconstructor(length: number);\n\t/**\n\t * @param arrayBuffer - The source array buffer.\n\t */\n\tconstructor(arrayBuffer: ArrayBuffer);\n\t/** View on the raw binary data as a `Int8Array`. */\n\tget int8View(): Int8Array;\n\t/** View on the raw binary data as a `Uint8Array`. */\n\tget uint8View(): Uint8Array;\n\t/**  View on the raw binary data as a `Int16Array`. */\n\tget int16View(): Int16Array;\n\t/** View on the raw binary data as a `Int32Array`. */\n\tget int32View(): Int32Array;\n\t/** View on the raw binary data as a `Float64Array`. */\n\tget float64View(): Float64Array;\n\t/** View on the raw binary data as a `BigUint64Array`. */\n\tget bigUint64View(): BigUint64Array;\n\t/**\n\t * Returns the view of the given type.\n\t * @param type - One of `int8`, `uint8`, `int16`,\n\t *    `uint16`, `int32`, `uint32`, and `float32`.\n\t * @returns - typed array of given type\n\t */\n\tview(type: string): TypedArray;\n\t/** Destroys all buffer references. Do not use after calling this. */\n\tdestroy(): void;\n\t/**\n\t * Returns the size of the given type in bytes.\n\t * @param type - One of `int8`, `uint8`, `int16`,\n\t *   `uint16`, `int32`, `uint32`, and `float32`.\n\t * @returns - size of the type in bytes\n\t */\n\tstatic sizeOf(type: string): number;\n}\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @category rendering\n * @advanced\n */\nexport class BatchTextureArray {\n\t/** Inside textures array. */\n\ttextures: TextureSource[];\n\t/** Respective locations for textures. */\n\tids: Record<number, number>;\n\t/** Number of filled elements. */\n\tcount: number;\n\tconstructor();\n\t/** Clear the textures and their locations. */\n\tclear(): void;\n}\n/**\n * An instruction that can be executed by the renderer\n * @category rendering\n * @advanced\n */\nexport interface Instruction {\n\t/** a the id of the render pipe that can run this instruction */\n\trenderPipeId: string;\n\t/** the name of the instruction */\n\taction?: string;\n\t/** true if this instruction can be compiled into a WebGPU bundle */\n\tcanBundle: boolean;\n}\n/**\n * The action types for a batch.\n * @category rendering\n * @advanced\n */\nexport type BatchAction = \"startBatch\" | \"renderBatch\";\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @category rendering\n * @advanced\n */\nexport class Batch implements Instruction {\n\trenderPipeId: string;\n\taction: BatchAction;\n\tstart: number;\n\tsize: number;\n\ttextures: BatchTextureArray;\n\tblendMode: BLEND_MODES;\n\ttopology: Topology;\n\tcanBundle: boolean;\n\t/**\n\t * breaking rules slightly here in the name of performance..\n\t * storing references to these bindgroups here is just faster for access!\n\t * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n\t */\n\tgpuBindGroup: GPUBindGroup;\n\t/**\n\t * breaking rules slightly here in the name of performance..\n\t * storing references to these bindgroups here is just faster for access!\n\t * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n\t */\n\tbindGroup: BindGroup;\n\tbatcher: Batcher;\n\tdestroy(): void;\n}\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @category rendering\n * @advanced\n */\nexport interface BatchableElement {\n\t/**\n\t * The name of the batcher to use. Must be registered.\n\t * @type {string}\n\t */\n\tbatcherName: string;\n\t/**\n\t * The texture to be used for rendering.\n\t * @type {Texture}\n\t */\n\ttexture: Texture;\n\t/**\n\t * The blend mode to be applied.\n\t * @type {BLEND_MODES}\n\t */\n\tblendMode: BLEND_MODES;\n\t/**\n\t * The size of the index data.\n\t * @type {number}\n\t */\n\tindexSize: number;\n\t/**\n\t * The size of the attribute data.\n\t * @type {number}\n\t */\n\tattributeSize: number;\n\t/**\n\t * The topology to be used for rendering.\n\t * @type {Topology}\n\t */\n\ttopology: Topology;\n\t/**\n\t * Whether the element should be packed as a quad for better performance.\n\t * @type {boolean}\n\t */\n\tpackAsQuad: boolean;\n\t/**\n\t * The texture ID, stored for efficient updating.\n\t * @type {number}\n\t * @private\n\t */\n\t_textureId: number;\n\t/**\n\t * The starting position in the attribute buffer.\n\t * @type {number}\n\t * @private\n\t */\n\t_attributeStart: number;\n\t/**\n\t * The starting position in the index buffer.\n\t * @type {number}\n\t * @private\n\t */\n\t_indexStart: number;\n\t/**\n\t * Reference to the batcher.\n\t * @type {Batcher}\n\t * @private\n\t */\n\t_batcher: Batcher;\n\t/**\n\t * Reference to the batch.\n\t * @type {Batch}\n\t * @private\n\t */\n\t_batch: Batch;\n}\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableQuadElement extends BatchableElement {\n\t/**\n\t * Indicates that this element should be packed as a quad.\n\t * @type {true}\n\t */\n\tpackAsQuad: true;\n\t/**\n\t * The size of the attribute data for this quad element.\n\t * @type {4}\n\t */\n\tattributeSize: 4;\n\t/**\n\t * The size of the index data for this quad element.\n\t * @type {6}\n\t */\n\tindexSize: 6;\n\t/**\n\t * The bounds data for this quad element.\n\t * @type {BoundsData}\n\t */\n\tbounds: BoundsData;\n}\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableMeshElement extends BatchableElement {\n\t/**\n\t * The UV coordinates of the mesh.\n\t * @type {number[] | Float32Array}\n\t */\n\tuvs: number[] | Float32Array;\n\t/**\n\t * The vertex positions of the mesh.\n\t * @type {number[] | Float32Array}\n\t */\n\tpositions: number[] | Float32Array;\n\t/**\n\t * The indices of the mesh.\n\t * @type {number[] | Uint16Array | Uint32Array}\n\t */\n\tindices: number[] | Uint16Array | Uint32Array;\n\t/**\n\t * The offset in the index buffer.\n\t * @type {number}\n\t */\n\tindexOffset: number;\n\t/**\n\t * The offset in the attribute buffer.\n\t * @type {number}\n\t */\n\tattributeOffset: number;\n\t/**\n\t * Indicates that this element should not be packed as a quad.\n\t * @type {false}\n\t */\n\tpackAsQuad: false;\n}\n/**\n * The options for the batcher.\n * @category rendering\n * @advanced\n */\nexport interface BatcherOptions {\n\t/** The maximum number of textures per batch. */\n\tmaxTextures: number;\n\t/** The initial size of the attribute buffer. */\n\tattributesInitialSize?: number;\n\t/** The initial size of the index buffer. */\n\tindicesInitialSize?: number;\n}\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @category rendering\n * @advanced\n */\nexport abstract class Batcher {\n\tstatic defaultOptions: Partial<BatcherOptions>;\n\t/** unique id for this batcher */\n\treadonly uid: number;\n\t/** The buffer containing attribute data for all elements in the batch. */\n\tattributeBuffer: ViewableBuffer;\n\t/** The buffer containing index data for all elements in the batch. */\n\tindexBuffer: IndexBufferArray;\n\t/** The current size of the attribute data in the batch. */\n\tattributeSize: number;\n\t/** The current size of the index data in the batch. */\n\tindexSize: number;\n\t/** The total number of elements currently in the batch. */\n\telementSize: number;\n\t/** The starting index of elements in the current batch. */\n\telementStart: number;\n\t/** Indicates whether the batch data has been modified and needs updating. */\n\tdirty: boolean;\n\t/** The current index of the batch being processed. */\n\tbatchIndex: number;\n\t/** An array of all batches created during the current rendering process. */\n\tbatches: Batch[];\n\tprivate _elements;\n\tprivate _batchIndexStart;\n\tprivate _batchIndexSize;\n\t/** The maximum number of textures per batch. */\n\treadonly maxTextures: number;\n\t/** The name of the batcher. Must be implemented by subclasses. */\n\tabstract name: string;\n\t/** The vertex size of the batcher. Must be implemented by subclasses. */\n\tprotected abstract vertexSize: number;\n\t/** The geometry used by this batcher. Must be implemented by subclasses. */\n\tabstract geometry: Geometry;\n\t/**\n\t * The shader used by this batcher. Must be implemented by subclasses.\n\t * this can be shared by multiple batchers of the same type.\n\t */\n\tabstract shader: Shader;\n\t/**\n\t * Packs the attributes of a BatchableMeshElement into the provided views.\n\t * Must be implemented by subclasses.\n\t * @param element - The BatchableMeshElement to pack.\n\t * @param float32View - The Float32Array view to pack into.\n\t * @param uint32View - The Uint32Array view to pack into.\n\t * @param index - The starting index in the views.\n\t * @param textureId - The texture ID to use.\n\t */\n\tabstract packAttributes(element: BatchableMeshElement, float32View: Float32Array, uint32View: Uint32Array, index: number, textureId: number): void;\n\t/**\n\t * Packs the attributes of a BatchableQuadElement into the provided views.\n\t * Must be implemented by subclasses.\n\t * @param element - The BatchableQuadElement to pack.\n\t * @param float32View - The Float32Array view to pack into.\n\t * @param uint32View - The Uint32Array view to pack into.\n\t * @param index - The starting index in the views.\n\t * @param textureId - The texture ID to use.\n\t */\n\tabstract packQuadAttributes(element: BatchableQuadElement, float32View: Float32Array, uint32View: Uint32Array, index: number, textureId: number): void;\n\tconstructor(options: BatcherOptions);\n\tbegin(): void;\n\tadd(batchableObject: BatchableElement): void;\n\tcheckAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean;\n\tupdateElement(batchableObject: BatchableElement): void;\n\t/**\n\t * breaks the batcher. This happens when a batch gets too big,\n\t * or we need to switch to a different type of rendering (a filter for example)\n\t * @param instructionSet\n\t */\n\tbreak(instructionSet: InstructionSet): void;\n\tprivate _finishBatch;\n\tfinish(instructionSet: InstructionSet): void;\n\t/**\n\t * Resizes the attribute buffer to the given size (1 = 1 float32)\n\t * @param size - the size in vertices to ensure (not bytes!)\n\t */\n\tensureAttributeBuffer(size: number): void;\n\t/**\n\t * Resizes the index buffer to the given size (1 = 1 float32)\n\t * @param size - the size in vertices to ensure (not bytes!)\n\t */\n\tensureIndexBuffer(size: number): void;\n\tprivate _resizeAttributeBuffer;\n\tprivate _resizeIndexBuffer;\n\tpackQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number): void;\n\tpackIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number): void;\n\t/**\n\t * Destroys the batch and its resources.\n\t * @param options - destruction options\n\t * @param options.shader - whether to destroy the associated shader\n\t */\n\tdestroy(options?: {\n\t\tshader?: boolean;\n\t}): void;\n}\n/**\n * An interface for a pipe that can be used to build instructions for the renderer.\n * InstructionPipes are specifically  used to manage the state of the renderer.\n * For example, the BlendModePipe is used to set the blend mode of the renderer.\n * @category rendering\n * @advanced\n */\nexport interface InstructionPipe<INSTRUCTION extends Instruction> {\n\t/**\n\t * called just before we execute the draw calls , this is where the pipes have an opportunity to\n\t * upload data to the GPU. This is only called if data changes.\n\t * @param instructionSet - the instruction set currently being built\n\t */\n\tupload?: (instructionSet: InstructionSet) => void;\n\t/**\n\t * this is where the actual instruction is executed - eg make the draw call\n\t * activate a filter. Any instructions that have the same renderPipeId have their\n\t * execute method called\n\t * @param instruction - the instruction to execute\n\t */\n\texecute?: (instruction: INSTRUCTION) => void;\n\tbuildReset?: (instructionSet: InstructionSet) => void;\n\tbuildStart?: (instructionSet: InstructionSet) => void;\n\tbuildEnd?: (instructionSet: InstructionSet) => void;\n\t/** Called just after the render ends giving the RenderPipes a chance to do any cleanup */\n\trenderEnd?: () => void;\n\t/** Called just before the render starts giving the RenderPipes a chance to do any setup */\n\trenderStart?: () => void;\n\t/**\n\t * Used by the effect pipes push and pop effects to the renderer. A push effect allows\n\t * the renderer to change its state to support the effect. A pop effect allows the renderer\n\t * to return to its previous state. An example of this would be the filter effect.\n\t * @param effect - the effect to push\n\t * @param targetContainer - the container that the effect is being applied to\n\t * @param instructionSet - the instruction set currently being built\n\t */\n\tpush?: (effect: Effect, targetContainer: Container, instructionSet: InstructionSet) => void;\n\t/**\n\t * Used by effect pipes to pop effects from the renderer.\n\t * @param effect - the effect to pop\n\t * @param targetContainer - the container that the effect is being applied to\n\t * @param instructionSet - the instruction set currently being built\n\t */\n\tpop?: (effect: Effect, targetContainer: Container, instructionSet: InstructionSet) => void;\n}\n/**\n * An interface for a pipe that can be used to build instructions for the renderer.\n * RenderPipes are specifically used to render Renderables like a Mesh.\n * @category rendering\n * @advanced\n */\nexport interface RenderPipe<RENDERABLE = Renderable> {\n\t/**\n\t * This is where the renderable is added to the instruction set. This is called once per renderable.\n\t * For instance, a MeshRenderPipe could be used to enqueue a 'draw mesh' command\n\t * to the rendering instruction set, catering to the rendering of mesh geometry.\n\t * In more complex scenarios, such as the SpritePipe, this seamlessly coordinates\n\t * with a batchPipe to efficiently batch and add batch instructions to the instructions set\n\t *\n\t * Add is called when the instructions set is being built.\n\t * @param renderable - the renderable that needs to be rendered\n\t * @param instructionSet - the instruction set currently being built\n\t */\n\taddRenderable: (renderable: RENDERABLE, instructionSet: InstructionSet) => void;\n\t/**\n\t * Called whenever a renderable has been been updated, eg its position has changed.\n\t * This is only called in the render loop if the instructions set is being reused\n\t * from the last frame. Otherwise addRenderable is called.\n\t * @param renderable - the renderable that needs to be rendered\n\t */\n\tupdateRenderable: (renderable: RENDERABLE) => void;\n\t/**\n\t * Called whenever a renderable is destroyed, often the pipes keep a webGL / webGPU specific representation\n\t * of the renderable that needs to be tidied up when the renderable is destroyed.\n\t * @param renderable - the renderable that needs to be rendered\n\t */\n\tdestroyRenderable?: (renderable: RENDERABLE) => void;\n\t/**\n\t * This function is called when the renderer is determining if it can use the same instruction set again to\n\t * improve performance. If this function returns true, the renderer will rebuild the whole instruction set\n\t * for the scene. This is only called if the scene has not its changed its structure .\n\t * @param renderable\n\t * @returns {boolean}\n\t */\n\tvalidateRenderable: (renderable: RENDERABLE) => boolean;\n}\n/**\n * An interface for a pipe that can be used to build instructions for the renderer.\n * BatchPipes are specifically used to build and render Batches.\n * @category rendering\n * @advanced\n */\nexport interface BatchPipe {\n\t/**\n\t * Add a add a batchable object to the batch.\n\t * @param renderable - a batchable object that can be added to the batch\n\t * @param instructionSet - the instruction set currently being built\n\t */\n\taddToBatch: (renderable: BatchableElement, instructionSet: InstructionSet) => void;\n\t/**\n\t * Forces the batch to break. This can happen if for example you need to render everything and then\n\t * change the render target.\n\t * @param instructionSet - the instruction set currently being built\n\t */\n\tbreak: (instructionSet: InstructionSet) => void;\n}\n/**\n * A helpful type that can be used to create a new RenderPipe, BatchPipe or InstructionPipe\n * @category rendering\n * @advanced\n */\nexport interface PipeConstructor {\n\tnew (renderer: Renderer, adaptor?: any): RenderPipe | BatchPipe | InstructionPipe<any>;\n}\n/**\n * A function that takes a renderer and does the custom rendering logic.\n * This is the function that will be called each frame.\n * @param renderer - The current renderer\n * @example\n * ```js\n * import { RenderContainer } from 'pixi.js';\n *\n * // create a new render container\n * const renderContainer = new RenderContainer((renderer) => {\n *     // custom render logic here\n *     renderer.clear({\n *         clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * });\n * ```\n * @category scene\n * @advanced\n */\nexport type RenderFunction = (renderer: Renderer) => void;\n/**\n * Options for the {@link RenderContainer} constructor.\n * @category scene\n * @advanced\n * @noInheritDoc\n */\nexport interface RenderContainerOptions extends ContainerOptions {\n\t/** the optional custom render function if you want to inject the function via the constructor */\n\trender?: RenderFunction;\n\t/** how to know if the custom render logic contains a point or not, used for interaction */\n\tcontainsPoint?: (point: Point) => boolean;\n\t/** how to add the bounds of this object when measuring */\n\taddBounds?: (bounds: BoundsData) => void;\n}\n/**\n * A container that allows for custom rendering logic. Its essentially calls the render function each frame\n * and allows for custom rendering logic - the render could be a WebGL renderer or WebGPU render or even a canvas render.\n * Its up to you to define the logic.\n *\n * This can be used in two ways, either by extending the class and overriding the render method,\n * or by passing a custom render function\n * @example\n * ```js\n * import { RenderContainer } from 'pixi.js';\n *\n * // extend the class\n * class MyRenderContainer extends RenderContainer\n * {\n *    render(renderer)\n *    {\n *      renderer.clear({\n *         clearColor: 'green', // clear the screen to green when rendering this item\n *      });\n *   }\n * }\n *\n * // override the render method\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * ```\n * @category scene\n * @advanced\n */\nexport class RenderContainer extends ViewContainer implements Instruction {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/** @internal */\n\tbatched: boolean;\n\t/**\n\t * Adds the bounds of this text to the bounds object.\n\t * @param bounds - The output bounds object.\n\t */\n\taddBounds: (bounds: Bounds) => void;\n\t/**\n\t * @param options - The options for the container.\n\t */\n\tconstructor(options: RenderContainerOptions | RenderFunction);\n\t/** @private */\n\tprotected updateBounds(): void;\n\t/**\n\t * An overridable function that can be used to render the object using the current renderer.\n\t * @param _renderer - The current renderer\n\t */\n\trender(_renderer: Renderer): void;\n}\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @category rendering\n * @internal\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer> {\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"customRender\";\n\t};\n\tprivate _renderer;\n\tconstructor(renderer: Renderer);\n\tupdateRenderable(): void;\n\tdestroyRenderable(): void;\n\tvalidateRenderable(): boolean;\n\taddRenderable(container: RenderContainer, instructionSet: InstructionSet): void;\n\texecute(container: RenderContainer): void;\n\tdestroy(): void;\n}\n/**\n * This class represents a geometry used for batching in the rendering system.\n * It defines the structure of vertex attributes and index buffers for batched rendering.\n * @category rendering\n * @advanced\n */\nexport class BatchGeometry extends Geometry {\n\tconstructor();\n}\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @category rendering\n * @advanced\n */\nexport class DefaultShader extends Shader {\n\t/** @internal */\n\tmaxTextures?: number;\n\tconstructor(maxTextures: number);\n}\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchElements {\n\t/**\n\t * The color of the element that will be multiplied with the texture color.\n\t * This is typically represented as a 32-bit integer in RGBA format.\n\t */\n\tcolor: number;\n\t/**\n\t * Determines whether the element should be rounded to the nearest pixel.\n\t * - 0: No rounding (default)\n\t * - 1: Round to nearest pixel\n\t * This can help with visual consistency, especially for pixel art styles.\n\t */\n\troundPixels: 0 | 1;\n\t/**\n\t * The transform matrix of the element.\n\t * This matrix represents the position, scale, rotation, and skew of the element.\n\t */\n\ttransform: Matrix;\n}\n/**\n * Represents a batchable quad element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {\n}\n/**\n * Represents a batchable mesh element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {\n}\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @category rendering\n * @advanced\n */\nexport class DefaultBatcher extends Batcher {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.Batcher\n\t\t];\n\t\treadonly name: \"default\";\n\t};\n\tgeometry: BatchGeometry;\n\tshader: DefaultShader;\n\tname: \"default\";\n\t/** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n\tvertexSize: number;\n\tconstructor(options: BatcherOptions);\n\t/**\n\t * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n\t * @param element - The DefaultBatchableMeshElement to pack.\n\t * @param float32View - The Float32Array view to pack into.\n\t * @param uint32View - The Uint32Array view to pack into.\n\t * @param index - The starting index in the views.\n\t * @param textureId - The texture ID to use.\n\t */\n\tpackAttributes(element: DefaultBatchableMeshElement, float32View: Float32Array, uint32View: Uint32Array, index: number, textureId: number): void;\n\t/**\n\t * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n\t * @param element - The DefaultBatchableQuadElement to pack.\n\t * @param float32View - The Float32Array view to pack into.\n\t * @param uint32View - The Uint32Array view to pack into.\n\t * @param index - The starting index in the views.\n\t * @param textureId - The texture ID to use.\n\t */\n\tpackQuadAttributes(element: DefaultBatchableQuadElement, float32View: Float32Array, uint32View: Uint32Array, index: number, textureId: number): void;\n\t/**\n\t * Updates the maximum number of textures that can be used in the shader.\n\t * @param maxTextures - The maximum number of textures that can be used in the shader.\n\t * @internal\n\t */\n\t_updateMaxTextures(maxTextures: number): void;\n\tdestroy(): void;\n}\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement, GPUData {\n\tbatcherName: string;\n\ttopology: Topology;\n\treadonly attributeSize = 4;\n\treadonly indexSize = 6;\n\treadonly packAsQuad = true;\n\ttransform: Matrix;\n\trenderable: Container;\n\ttexture: Texture;\n\tbounds: BoundsData;\n\troundPixels: 0 | 1;\n\t_indexStart: number;\n\t_textureId: number;\n\t_attributeStart: number;\n\t_batcher: Batcher;\n\t_batch: Batch;\n\tget blendMode(): BLEND_MODES;\n\tget color(): number;\n\treset(): void;\n\tdestroy(): void;\n}\n/**\n * Options for caching a container as a texture.\n * @category rendering\n * @advanced\n */\nexport interface CacheAsTextureOptions {\n\t/**\n\t * If true, the texture will be antialiased. This smooths out the edges of the texture.\n\t * @default false\n\t */\n\tantialias?: boolean;\n\t/**\n\t * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n\t * By default the resolution is 1 which is the same as the rendererers resolution.\n\t */\n\tresolution?: number;\n\t/**\n\t * Scale Mode to use for the cached texture\n\t * @type {SCALE_MODE}\n\t * @default 'linear'\n\t * @example\n\t * ```ts\n\t * const container = new Container();\n\t * container.cacheAsTexture({ scaleMode: 'nearest' });\n\t * ```\n\t * @see {@link SCALE_MODE}\n\t */\n\tscaleMode?: SCALE_MODE;\n}\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @category rendering\n * @advanced\n */\nexport class RenderGroup implements Instruction {\n\trenderPipeId: string;\n\troot: Container;\n\tcanBundle: boolean;\n\trenderGroupParent: RenderGroup;\n\trenderGroupChildren: RenderGroup[];\n\tworldTransform: Matrix;\n\tworldColorAlpha: number;\n\tworldColor: number;\n\tworldAlpha: number;\n\treadonly childrenToUpdate: Record<number, {\n\t\tlist: Container[];\n\t\tindex: number;\n\t}>;\n\tupdateTick: number;\n\tgcTick: number;\n\treadonly childrenRenderablesToUpdate: {\n\t\tlist: Container[];\n\t\tindex: number;\n\t};\n\tstructureDidChange: boolean;\n\tinstructionSet: InstructionSet;\n\tprivate readonly _onRenderContainers;\n\t/**\n\t * Indicates if the cached texture needs to be updated.\n\t * @default true\n\t */\n\ttextureNeedsUpdate: boolean;\n\t/**\n\t * Indicates if the container should be cached as a texture.\n\t * @default false\n\t */\n\tisCachedAsTexture: boolean;\n\t/**\n\t * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n\t * It can only be accessed after a render pass.\n\t * @type {Texture | undefined}\n\t */\n\ttexture?: Texture;\n\t/**\n\t * The bounds of the cached texture.\n\t * @type {Bounds | undefined}\n\t * @ignore\n\t */\n\t_textureBounds?: Bounds;\n\t/**\n\t * The options for caching the container as a texture.\n\t * @type {CacheAsTextureOptions}\n\t */\n\ttextureOptions: CacheAsTextureOptions;\n\t/**\n\t *  holds a reference to the batchable render sprite\n\t *  @ignore\n\t */\n\t_batchableRenderGroup: BatchableSprite;\n\t/**\n\t * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n\t * This is used to properly transform coordinates when rendering into cached textures.\n\t * @type {RenderGroup | null}\n\t * @ignore\n\t */\n\t_parentCacheAsTextureRenderGroup: RenderGroup;\n\tprivate _inverseWorldTransform;\n\tprivate _textureOffsetInverseTransform;\n\tprivate _inverseParentTextureTransform;\n\tprivate _matrixDirty;\n\tinit(root: Container): void;\n\tenableCacheAsTexture(options?: CacheAsTextureOptions): void;\n\tdisableCacheAsTexture(): void;\n\tupdateCacheTexture(): void;\n\treset(): void;\n\tget localTransform(): Matrix;\n\taddRenderGroupChild(renderGroupChild: RenderGroup): void;\n\tprivate _removeRenderGroupChild;\n\taddChild(child: Container): void;\n\tremoveChild(child: Container): void;\n\tremoveChildren(children: Container[]): void;\n\tonChildUpdate(child: Container): void;\n\tupdateRenderable(renderable: ViewContainer): void;\n\tonChildViewUpdate(child: Container): void;\n\tget isRenderable(): boolean;\n\t/**\n\t * adding a container to the onRender list will make sure the user function\n\t * passed in to the user defined 'onRender` callBack\n\t * @param container - the container to add to the onRender list\n\t */\n\taddOnRender(container: Container): void;\n\tremoveOnRender(container: Container): void;\n\trunOnRender(renderer: Renderer): void;\n\tdestroy(): void;\n\tgetChildren(out?: Container[]): Container[];\n\tprivate _getChildren;\n\tinvalidateMatrices(): void;\n\t/**\n\t * Returns the inverse of the world transform matrix.\n\t * @returns {Matrix} The inverse of the world transform matrix.\n\t */\n\tget inverseWorldTransform(): Matrix;\n\t/**\n\t * Returns the inverse of the texture offset transform matrix.\n\t * @returns {Matrix} The inverse of the texture offset transform matrix.\n\t */\n\tget textureOffsetInverseTransform(): Matrix;\n\t/**\n\t * Returns the inverse of the parent texture transform matrix.\n\t * This is used to properly transform coordinates when rendering into cached textures.\n\t * @returns {Matrix} The inverse of the parent texture transform matrix.\n\t */\n\tget inverseParentTextureTransform(): Matrix;\n\t/**\n\t * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n\t * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n\t * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n\t * or null if no parent is cached as texture.\n\t */\n\tget cacheToLocalTransform(): Matrix;\n}\n/**\n * The RenderGroupPipe is a render pipe for rendering RenderGroups.\n * @internal\n */\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup> {\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"renderGroup\";\n\t};\n\tprivate _renderer;\n\tconstructor(renderer: Renderer);\n\taddRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void;\n\texecute(renderGroup: RenderGroup): void;\n\tdestroy(): void;\n\tprivate _addRenderableDirect;\n\tprivate _addRenderableCacheAsTexture;\n\tprivate _executeCacheAsTexture;\n\tprivate _executeDirect;\n}\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"renderGroup\";\n\t};\n\tprivate readonly _renderer;\n\tconstructor(renderer: Renderer);\n\tprotected render({ container, transform }: {\n\t\tcontainer: Container;\n\t\ttransform: Matrix;\n\t}): void;\n\tdestroy(): void;\n\tprivate _updateCachedRenderGroups;\n\tprivate _updateRenderGroups;\n\tprivate _updateRenderables;\n\t/**\n\t * @param renderGroup\n\t * @param renderPipes\n\t * @deprecated since 8.3.0\n\t */\n\tprivate _buildInstructions;\n}\n/**\n * Defines a size with a width and a height.\n * @category maths\n * @standard\n */\nexport interface Size {\n\t/** The width. */\n\twidth: number;\n\t/** The height. */\n\theight: number;\n}\n/**\n * A utility type that makes all properties of T optional except for the specified keys K.\n * @category utils\n * @internal\n */\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n/** @ignore */\nexport interface MeasureMixinConstructor {\n\t/**\n\t * The width of the display object, in pixels.\n\t * @example\n\t * ```ts\n\t * new Container({ width: 100});\n\t * ```\n\t * @default 0\n\t */\n\twidth?: number;\n\t/**\n\t * The height of the display object, in pixels.\n\t * @example\n\t * ```ts\n\t * new Container({ height: 100});\n\t * ```\n\t * @default 0\n\t */\n\theight?: number;\n}\n/**\n * The MeasureMixin interface provides methods for measuring and manipulating the size and bounds of a display object.\n * It includes methods to get and set the size of the object, retrieve its local bounds,\n * and calculate its global bounds.\n * @category scene\n * @advanced\n */\nexport interface MeasureMixin extends Required<MeasureMixinConstructor> {\n\tgetSize(out?: Size): Size;\n\tsetSize(width: number, height?: number): void;\n\tsetSize(value: Optional<Size, \"height\">): void;\n\t/**\n\t * Retrieves the local bounds of the container as a Bounds object.\n\t * Uses cached values when possible for better performance.\n\t * @example\n\t * ```ts\n\t * // Basic bounds check\n\t * const bounds = container.getLocalBounds();\n\t * console.log(`Width: ${bounds.width}, Height: ${bounds.height}`);\n\t * // subsequent calls will reuse the cached bounds\n\t * const cachedBounds = container.getLocalBounds();\n\t * console.log(bounds === cachedBounds); // true\n\t * ```\n\t * @returns The bounding area\n\t * @see {@link Container#getBounds} For world space bounds\n\t * @see {@link Bounds} For bounds properties\n\t */\n\tgetLocalBounds(): Bounds;\n\t/**\n\t * Calculates and returns the (world) bounds of the display object as a Rectangle.\n\t * Takes into account transforms and child bounds.\n\t * @example\n\t * ```ts\n\t * // Basic bounds calculation\n\t * const bounds = sprite.getBounds();\n\t * console.log(`World bounds: ${bounds.x}, ${bounds.y}, ${bounds.width}, ${bounds.height}`);\n\t *\n\t * // Reuse bounds object for performance\n\t * const recycleBounds = new Bounds();\n\t * sprite.getBounds(false, recycleBounds);\n\t *\n\t * // Skip update for performance\n\t * const fastBounds = sprite.getBounds(true);\n\t * ```\n\t * @remarks\n\t * - Includes transform calculations\n\t * - Updates scene graph by default\n\t * - Can reuse bounds objects\n\t * - Common in hit testing\n\t * @param {boolean} skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n\t *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n\t *  nice performance boost.\n\t * @param {Bounds} bounds - Optional bounds to store the result of the bounds calculation\n\t * @returns The minimum axis-aligned rectangle in world space that fits around this object\n\t * @see {@link Container#getLocalBounds} For untransformed bounds\n\t * @see {@link Bounds} For bounds properties\n\t */\n\tgetBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n\t/** @private */\n\t_localBoundsCacheData: LocalBoundsCacheData;\n\t/** @private */\n\t_localBoundsCacheId: number;\n\t/** @private */\n\t_setWidth(width: number, localWidth: number): void;\n\t/** @private */\n\t_setHeight(height: number, localHeight: number): void;\n}\ninterface LocalBoundsCacheData {\n\tdata: number[];\n\tindex: number;\n\tdidChange: boolean;\n\tlocalBounds: Bounds;\n}\n/** @internal */\nexport const measureMixin: Partial<Container>;\n/**\n * Options for configuring a Sprite instance. Defines the texture, anchor point, and rendering behavior.\n * @example\n * ```ts\n * // Create a basic sprite with texture\n * const sprite = new Sprite({\n *     texture: Texture.from('sprite.png')\n * });\n *\n * // Create a centered sprite with rounded position\n * const centeredSprite = new Sprite({\n *     texture: Texture.from('centered.png'),\n *     anchor: 0.5,        // Center point\n *     roundPixels: true,  // Crisp rendering\n *     x: 100,            // Position from ViewContainerOptions\n *     y: 100\n * });\n *\n * // Create a sprite with specific anchor points\n * const anchoredSprite = new Sprite({\n *     texture: Texture.from('corner.png'),\n *     anchor: {\n *         x: 1,  // Right-aligned\n *         y: 0   // Top-aligned\n *     }\n * });\n * ```\n * @extends ViewContainerOptions\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface SpriteOptions extends PixiMixins.SpriteOptions, ViewContainerOptions {\n\t/**\n\t * The texture to use for the sprite. If not provided, uses Texture.EMPTY\n\t * @default Texture.EMPTY\n\t * @example\n\t * ```ts\n\t * // Create a sprite with a texture\n\t * const sprite = new Sprite({\n\t *     texture: Texture.from('path/to/image.png')\n\t * });\n\t * // Update the texture later\n\t * sprite.texture = Texture.from('path/to/another-image.png');\n\t * ```\n\t */\n\ttexture?: Texture;\n\t/**\n\t * The anchor point of the sprite (0-1 range).\n\t * Controls the origin point for rotation, scaling, and positioning.\n\t * Can be a number for uniform anchor or a PointData for separate x/y values.\n\t * @default 0\n\t * @example\n\t * ```ts\n\t * // Centered anchor\n\t * anchor: 0.5\n\t * // Separate x/y anchor\n\t * anchor: { x: 0.5, y: 0.5 }\n\t * // Right-aligned anchor\n\t * anchor: { x: 1, y: 0 }\n\t * ```\n\t */\n\tanchor?: PointData | number;\n\t/**\n\t * Whether or not to round the x/y position to whole pixels.\n\t * Useful for crisp pixel art style rendering.\n\t * @default false\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite({\n\t *     texture: Texture.from('sprite.png'),\n\t *     roundPixels: true // Ensures crisp rendering\n\t * });\n\t * ```\n\t */\n\troundPixels?: boolean;\n}\nexport interface Sprite extends PixiMixins.Sprite, ViewContainer<BatchableSprite> {\n}\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n * Sprites can display images, handle input events, and be transformed in various ways.\n * @example\n * ```ts\n * // Create a sprite directly from an image path\n * const sprite = Sprite.from('assets/image.png');\n * sprite.position.set(100, 100);\n * app.stage.addChild(sprite);\n *\n * // Create from a spritesheet (more efficient)\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n *\n * // Create with specific options\n * const configuredSprite = new Sprite({\n *     texture: Texture.from('sprite.png'),\n *     anchor: 0.5,           // Center anchor point\n *     position: { x: 100, y: 100 },\n *     scale: { x: 2, y: 2 }, // Double size\n *     rotation: Math.PI / 4   // 45 degrees\n * });\n *\n * // Animate sprite properties\n * app.ticker.add(() => {\n *     sprite.rotation += 0.1;      // Rotate\n *     sprite.scale.x = Math.sin(performance.now() / 1000) + 1; // Pulse scale\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link SpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class Sprite extends ViewContainer<BatchableSprite> {\n\t/**\n\t * Creates a new sprite based on a source texture, image, video, or canvas element.\n\t * This is a convenience method that automatically creates and manages textures.\n\t * @example\n\t * ```ts\n\t * // Create from path or URL\n\t * const sprite = Sprite.from('assets/image.png');\n\t *\n\t * // Create from existing texture\n\t * const sprite = Sprite.from(texture);\n\t *\n\t * // Create from canvas\n\t * const canvas = document.createElement('canvas');\n\t * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n\t * ```\n\t * @param source - The source to create the sprite from. Can be a path to an image, a texture,\n\t * or any valid texture source (canvas, video, etc.)\n\t * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n\t * @returns A new sprite based on the source\n\t * @see {@link Texture.from} For texture creation details\n\t * @see {@link Assets} For asset loading and management\n\t */\n\tstatic from(source: Texture | TextureSourceLike, skipCache?: boolean): Sprite;\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/** @internal */\n\tbatched: boolean;\n\t/** @internal */\n\treadonly _anchor: ObservablePoint;\n\t/** @internal */\n\t_texture: Texture;\n\tprivate readonly _visualBounds;\n\tprivate _width;\n\tprivate _height;\n\t/**\n\t * @param options - The options for creating the sprite.\n\t */\n\tconstructor(options?: SpriteOptions | Texture);\n\tset texture(value: Texture);\n\t/**\n\t * The texture that is displayed by the sprite. When changed, automatically updates\n\t * the sprite dimensions and manages texture event listeners.\n\t * @example\n\t * ```ts\n\t * // Create sprite with texture\n\t * const sprite = new Sprite({\n\t *     texture: Texture.from('sprite.png')\n\t * });\n\t *\n\t * // Update texture\n\t * sprite.texture = Texture.from('newSprite.png');\n\t *\n\t * // Use texture from spritesheet\n\t * const sheet = await Assets.load('spritesheet.json');\n\t * sprite.texture = sheet.textures['frame1.png'];\n\t *\n\t * // Reset to empty texture\n\t * sprite.texture = Texture.EMPTY;\n\t * ```\n\t * @see {@link Texture} For texture creation and management\n\t * @see {@link Assets} For asset loading\n\t */\n\tget texture(): Texture;\n\t/**\n\t * The bounds of the sprite, taking into account the texture's trim area.\n\t * @example\n\t * ```ts\n\t * const texture = new Texture({\n\t *     source: new TextureSource({ width: 300, height: 300 }),\n\t *     frame: new Rectangle(196, 66, 58, 56),\n\t *     trim: new Rectangle(4, 4, 58, 56),\n\t *     orig: new Rectangle(0, 0, 64, 64),\n\t *     rotate: 2,\n\t * });\n\t * const sprite = new Sprite(texture);\n\t * const visualBounds = sprite.visualBounds;\n\t * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n\t */\n\tget visualBounds(): BoundsData;\n\t/**\n\t * @deprecated\n\t * @ignore\n\t */\n\tget sourceBounds(): BoundsData;\n\t/** @private */\n\tprotected updateBounds(): void;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * sprite.destroy();\n\t * sprite.destroy(true);\n\t * sprite.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n\t * and passed to the constructor.\n\t *\n\t * - The default is `(0,0)`, this means the sprite's origin is the top left.\n\t * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n\t * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n\t *\n\t * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n\t * @example\n\t * ```ts\n\t * // Center the anchor point\n\t * sprite.anchor = 0.5; // Sets both x and y to 0.5\n\t * sprite.position.set(400, 300); // Sprite will be centered at this position\n\t *\n\t * // Set specific x/y anchor points\n\t * sprite.anchor = {\n\t *     x: 1, // Right edge\n\t *     y: 0  // Top edge\n\t * };\n\t *\n\t * // Using individual coordinates\n\t * sprite.anchor.set(0.5, 1); // Center-bottom\n\t *\n\t * // For rotation around center\n\t * sprite.anchor.set(0.5);\n\t * sprite.rotation = Math.PI / 4; // 45 degrees around center\n\t *\n\t * // For scaling from center\n\t * sprite.anchor.set(0.5);\n\t * sprite.scale.set(2); // Scales from center point\n\t * ```\n\t */\n\tget anchor(): ObservablePoint;\n\tset anchor(value: PointData | number);\n\t/**\n\t * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n\t * @example\n\t * ```ts\n\t * // Set width directly\n\t * sprite.width = 200;\n\t * console.log(sprite.scale.x); // Scale adjusted to match width\n\t *\n\t * // Set width while preserving aspect ratio\n\t * const ratio = sprite.height / sprite.width;\n\t * sprite.width = 300;\n\t * sprite.height = 300 * ratio;\n\t *\n\t * // For better performance when setting both width and height\n\t * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n\t *\n\t * // Reset to original texture size\n\t * sprite.width = sprite.texture.orig.width;\n\t * ```\n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n\t * @example\n\t * ```ts\n\t * // Set height directly\n\t * sprite.height = 150;\n\t * console.log(sprite.scale.y); // Scale adjusted to match height\n\t *\n\t * // Set height while preserving aspect ratio\n\t * const ratio = sprite.width / sprite.height;\n\t * sprite.height = 200;\n\t * sprite.width = 200 * ratio;\n\t *\n\t * // For better performance when setting both width and height\n\t * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n\t *\n\t * // Reset to original texture size\n\t * sprite.height = sprite.texture.orig.height;\n\t * ```\n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n\t * This is faster than getting width and height separately as it only calculates the bounds once.\n\t * @example\n\t * ```ts\n\t * // Basic size retrieval\n\t * const sprite = new Sprite(Texture.from('sprite.png'));\n\t * const size = sprite.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * sprite.getSize(reuseSize);\n\t * ```\n\t * @param out - Optional object to store the size in, to avoid allocating a new object\n\t * @returns The size of the Sprite\n\t * @see {@link Sprite#width} For getting just the width\n\t * @see {@link Sprite#height} For getting just the height\n\t * @see {@link Sprite#setSize} For setting both width and height\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Sets the size of the Sprite to the specified width and height.\n\t * This is faster than setting width and height separately as it only recalculates bounds once.\n\t * @example\n\t * ```ts\n\t * // Basic size setting\n\t * const sprite = new Sprite(Texture.from('sprite.png'));\n\t * sprite.setSize(100, 200); // Width: 100, Height: 200\n\t *\n\t * // Set uniform size\n\t * sprite.setSize(100); // Sets both width and height to 100\n\t *\n\t * // Set size with object\n\t * sprite.setSize({\n\t *     width: 200,\n\t *     height: 300\n\t * });\n\t *\n\t * // Reset to texture size\n\t * sprite.setSize(\n\t *     sprite.texture.orig.width,\n\t *     sprite.texture.orig.height\n\t * );\n\t * ```\n\t * @param value - This can be either a number or a {@link Size} object\n\t * @param height - The height to set. Defaults to the value of `width` if not provided\n\t * @see {@link Sprite#width} For setting width only\n\t * @see {@link Sprite#height} For setting height only\n\t * @see {@link Sprite#texture} For the source dimensions\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n}\n/** @internal */\nexport class SpritePipe implements RenderPipe<Sprite> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"sprite\";\n\t};\n\tprivate _renderer;\n\tconstructor(renderer: Renderer);\n\taddRenderable(sprite: Sprite, instructionSet: InstructionSet): void;\n\tupdateRenderable(sprite: Sprite): void;\n\tvalidateRenderable(sprite: Sprite): boolean;\n\tprivate _updateBatchableSprite;\n\tprivate _getGpuSprite;\n\tprivate _initGPUSprite;\n\tdestroy(): void;\n}\n/**\n * Options for {@link autoDetectRenderer}.\n * @category rendering\n * @advanced\n */\nexport interface AutoDetectOptions extends RendererOptions {\n\t/** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n\tpreference?: \"webgl\" | \"webgpu\";\n\t/** Optional WebGPUOptions to pass only to WebGPU renderer. */\n\twebgpu?: Partial<WebGPUOptions>;\n\t/** Optional WebGLOptions to pass only to the WebGL renderer */\n\twebgl?: Partial<WebGLOptions>;\n}\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @category rendering\n * @standard\n */\nexport function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>;\n/**\n * Interface for creating Application plugins. Any plugin that's usable for Application must implement these methods.\n *\n * To create a plugin:\n * 1. Create a class that implements this interface\n * 2. Add the required static extension property\n * 3. Register the plugin using extensions.add()\n * @example\n * ```ts\n * import { ApplicationPlugin, ExtensionType, extensions } from 'pixi.js';\n *\n * class MyPlugin {\n *    // Required: Declare the extension type\n *    public static extension = ExtensionType.Application;\n *\n *    // Required: Implement init method\n *    public static init(options: Partial<ApplicationOptions>): void {\n *        // Add properties/methods to the Application instance (this)\n *        Object.defineProperty(this, 'myFeature', {\n *            value: () => console.log('My feature!'),\n *        });\n *\n *        // Use options if needed\n *        console.log('Plugin initialized with:', options);\n *    }\n *\n *    // Required: Implement destroy method\n *    public static destroy(): void {\n *        // Clean up any resources\n *        console.log('Plugin destroyed');\n *    }\n * }\n *\n * // Register the plugin\n * extensions.add(MyPlugin);\n *\n * // Usage in application\n * const app = new Application();\n * await app.init();\n * app.myFeature(); // Output: \"My feature!\"\n * ```\n * > [!IMPORTANT]\n * > - Plugins are initialized in the order they are added\n * > - Plugins are destroyed in reverse order\n * > - The `this` context in both methods refers to the Application instance\n * @see {@link ExtensionType} For different types of extensions\n * @see {@link extensions} For the extension registration system\n * @see {@link ApplicationOptions} For available application options\n * @category app\n * @advanced\n */\nexport interface ApplicationPlugin {\n\t/**\n\t * Called when Application is constructed, scoped to Application instance.\n\t * Passes in `options` as the only argument, which are Application `init()` options.\n\t * @param {object} options - Application options.\n\t */\n\tinit(options: Partial<ApplicationOptions>): void;\n\t/** Called when destroying Application, scoped to Application instance. */\n\tdestroy(): void;\n}\n/**\n * Application options supplied to the {@link Application#init} method.\n * These options configure how your PixiJS application behaves.\n * @category app\n * @standard\n * @example\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * // Initialize with common options\n * await app.init({\n *    // Rendering options\n *    width: 800,                    // Canvas width\n *    height: 600,                   // Canvas height\n *    backgroundColor: 0x1099bb,     // Background color\n *    antialias: true,              // Enable antialiasing\n *    resolution: window.devicePixelRatio, // Screen resolution\n *\n *    // Performance options\n *    autoStart: true,              // Auto-starts the render loop\n *    sharedTicker: true,           // Use shared ticker for better performance\n *\n *    // Automatic resize options\n *    resizeTo: window,             // Auto-resize to window\n *    autoDensity: true,           // Adjust for device pixel ratio\n *\n *    // Advanced options\n *    preference: 'webgl',         // Renderer preference ('webgl' or 'webgpu')\n *    powerPreference: 'high-performance' // GPU power preference\n * });\n * ```\n * @see {@link WebGLOptions} For resize-related options\n * @see {@link WebGPUOptions} For resize-related options\n * @see {@link TickerPlugin} For ticker-related options\n * @see {@link ResizePlugin} For resize-related options\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions {\n}\nexport interface Application extends PixiMixins.Application {\n}\n/**\n * Convenience class to create a new PixiJS application.\n *\n * The Application class is the main entry point for creating a PixiJS application. It handles the setup of all core\n * components needed to start rendering and managing your game or interactive experience.\n *\n * Key features:\n * - Automatically creates and manages the renderer\n * - Provides a stage (root container) for your display objects\n * - Handles canvas creation and management\n * - Supports plugins for extending functionality\n *   - {@link ResizePlugin} for automatic resizing\n *   - {@link TickerPlugin} for managing frame updates\n *   - {@link CullerPlugin} for culling off-screen objects\n * @example\n * ```js\n * import { Assets, Application, Sprite } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n *\n * // Initialize with options\n * await app.init({\n *     width: 800,           // Canvas width\n *     height: 600,          // Canvas height\n *     backgroundColor: 0x1099bb, // Background color\n *     antialias: true,     // Enable antialiasing\n *     resolution: 1,       // Resolution / device pixel ratio\n *     preference: 'webgl', // or 'webgpu' // Renderer preference\n * });\n *\n * // Add the canvas to your webpage\n * document.body.appendChild(app.canvas);\n *\n * // Start adding content to your application\n * const texture = await Assets.load('your-image.png');\n * const sprite = new Sprite(texture);\n * app.stage.addChild(sprite);\n * ```\n * > [!IMPORTANT] From PixiJS v8.0.0, the application must be initialized using the async `init()` method\n * > rather than passing options to the constructor.\n * @category app\n * @standard\n * @see {@link ApplicationOptions} For all available initialization options\n * @see {@link Container} For information about the stage container\n * @see {@link Renderer} For details about the rendering system\n */\nexport class Application<R extends Renderer = Renderer> {\n\t/**\n\t * Collection of installed plugins.\n\t * @internal\n\t */\n\tstatic _plugins: ApplicationPlugin[];\n\t/**\n\t * The root display container for your application.\n\t * All visual elements should be added to this container or its children.\n\t * @example\n\t * ```js\n\t * // Create a sprite and add it to the stage\n\t * const sprite = Sprite.from('image.png');\n\t * app.stage.addChild(sprite);\n\t *\n\t * // Create a container for grouping objects\n\t * const container = new Container();\n\t * app.stage.addChild(container);\n\t * ```\n\t */\n\tstage: Container;\n\t/**\n\t * The renderer instance that handles all drawing operations.\n\t *\n\t * Unless specified, it will automatically create a WebGL renderer if available.\n\t * If WebGPU is available and the `preference` is set to `webgpu`, it will create a WebGPU renderer.\n\t * @example\n\t * ```js\n\t * // Create a new application\n\t * const app = new Application();\n\t * await app.init({\n\t *     width: 800,\n\t *     height: 600,\n\t *     preference: 'webgl', // or 'webgpu'\n\t * });\n\t *\n\t * // Access renderer properties\n\t * console.log(app.renderer.width, app.renderer.height);\n\t * ```\n\t */\n\trenderer: R;\n\t/** Create new Application instance */\n\tconstructor();\n\t/** @deprecated since 8.0.0 */\n\tconstructor(options?: Partial<ApplicationOptions>);\n\t/**\n\t * Initializes the PixiJS application with the specified options.\n\t *\n\t * This method must be called after creating a new Application instance.\n\t * @param options - Configuration options for the application and renderer\n\t * @returns A promise that resolves when initialization is complete\n\t * @example\n\t * ```js\n\t * const app = new Application();\n\t *\n\t * // Initialize with custom options\n\t * await app.init({\n\t *     width: 800,\n\t *     height: 600,\n\t *     backgroundColor: 0x1099bb,\n\t *     preference: 'webgl', // or 'webgpu'\n\t * });\n\t * ```\n\t */\n\tinit(options?: Partial<ApplicationOptions>): Promise<void>;\n\t/**\n\t * Renders the current stage to the screen.\n\t *\n\t * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call\n\t * this method directly as rendering is handled automatically.\n\t *\n\t * Only use this method if you've disabled the {@link TickerPlugin} or need custom\n\t * render timing control.\n\t * @example\n\t * ```js\n\t * // Example 1: Default setup (TickerPlugin handles rendering)\n\t * const app = new Application();\n\t * await app.init();\n\t * // No need to call render() - TickerPlugin handles it\n\t *\n\t * // Example 2: Custom rendering loop (if TickerPlugin is disabled)\n\t * const app = new Application();\n\t * await app.init({ autoStart: false }); // Disable automatic rendering\n\t *\n\t * function animate() {\n\t *     app.render();\n\t *     requestAnimationFrame(animate);\n\t * }\n\t * animate();\n\t * ```\n\t */\n\trender(): void;\n\t/**\n\t * Reference to the renderer's canvas element. This is the HTML element\n\t * that displays your application's graphics.\n\t * @readonly\n\t * @type {HTMLCanvasElement}\n\t * @example\n\t * ```js\n\t * // Create a new application\n\t * const app = new Application();\n\t * // Initialize the application\n\t * await app.init({...});\n\t * // Add canvas to the page\n\t * document.body.appendChild(app.canvas);\n\t *\n\t * // Access the canvas directly\n\t * console.log(app.canvas); // HTMLCanvasElement\n\t * ```\n\t */\n\tget canvas(): R[\"canvas\"];\n\t/**\n\t * Reference to the renderer's canvas element.\n\t * @type {HTMLCanvasElement}\n\t * @deprecated since 8.0.0\n\t * @see {@link Application#canvas}\n\t */\n\tget view(): R[\"canvas\"];\n\t/**\n\t * Reference to the renderer's screen rectangle. This represents the visible area of your application.\n\t *\n\t * It's commonly used for:\n\t * - Setting filter areas for full-screen effects\n\t * - Defining hit areas for screen-wide interaction\n\t * - Determining the visible bounds of your application\n\t * @readonly\n\t * @example\n\t * ```js\n\t * // Use as filter area for a full-screen effect\n\t * const blurFilter = new BlurFilter();\n\t * sprite.filterArea = app.screen;\n\t *\n\t * // Use as hit area for screen-wide interaction\n\t * const screenSprite = new Sprite();\n\t * screenSprite.hitArea = app.screen;\n\t *\n\t * // Get screen dimensions\n\t * console.log(app.screen.width, app.screen.height);\n\t * ```\n\t * @see {@link Rectangle} For all available properties and methods\n\t */\n\tget screen(): Rectangle;\n\t/**\n\t * Destroys the application and all of its resources.\n\t *\n\t * This method should be called when you want to completely\n\t * clean up the application and free all associated memory.\n\t * @param rendererDestroyOptions - Options for destroying the renderer:\n\t *  - `false` or `undefined`: Preserves the canvas element (default)\n\t *  - `true`: Removes the canvas element\n\t *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal\n\t * @param options - Options for destroying the application:\n\t *  - `false` or `undefined`: Basic cleanup (default)\n\t *  - `true`: Complete cleanup including children\n\t *  - Detailed options object:\n\t *    - `children`: Remove children\n\t *    - `texture`: Destroy textures\n\t *    - `textureSource`: Destroy texture sources\n\t *    - `context`: Destroy WebGL context\n\t * @example\n\t * ```js\n\t * // Basic cleanup\n\t * app.destroy();\n\t *\n\t * // Remove canvas and do complete cleanup\n\t * app.destroy(true, true);\n\t *\n\t * // Remove canvas with explicit options\n\t * app.destroy({ removeView: true }, true);\n\t *\n\t * // Detailed cleanup with specific options\n\t * app.destroy(\n\t *     { removeView: true },\n\t *     {\n\t *         children: true,\n\t *         texture: true,\n\t *         textureSource: true,\n\t *         context: true\n\t *     }\n\t * );\n\t * ```\n\t * > [!WARNING] After calling destroy, the application instance should no longer be used.\n\t * > All properties will be null and further operations will throw errors.\n\t */\n\tdestroy(rendererDestroyOptions?: RendererDestroyOptions, options?: DestroyOptions): void;\n}\ndeclare global {\n\tvar __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n\tvar __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n}\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @category app\n * @internal\n */\nexport class ApplicationInitHook {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tstatic init(): void;\n\tstatic destroy(): void;\n}\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @category rendering\n * @internal\n */\nexport class RendererInitHook implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"initHook\";\n\t\treadonly priority: -10;\n\t};\n\tprivate _renderer;\n\tconstructor(renderer: Renderer);\n\tinit(): void;\n\tdestroy(): void;\n}\n/** @internal */\nexport interface BatcherAdaptor {\n\tstart(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void;\n\tinit?(batchPipe: BatcherPipe): void;\n\texecute(batchPipe: BatcherPipe, batch: Batch): void;\n\tcontextChange?(): void;\n}\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @category rendering\n * @advanced\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"batch\";\n\t};\n\tstate: State;\n\trenderer: Renderer;\n\tprivate readonly _batchersByInstructionSet;\n\tprivate _adaptor;\n\t/** A record of all active batchers, keyed by their names */\n\tprivate _activeBatches;\n\t/** The currently active batcher being used to batch elements */\n\tprivate _activeBatch;\n\tstatic _availableBatchers: Record<string, new () => Batcher>;\n\tstatic getBatcher(name: string): Batcher;\n\tconstructor(renderer: Renderer, adaptor: BatcherAdaptor);\n\tbuildStart(instructionSet: InstructionSet): void;\n\taddToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet): void;\n\tbreak(instructionSet: InstructionSet): void;\n\tbuildEnd(instructionSet: InstructionSet): void;\n\tupload(instructionSet: InstructionSet): void;\n\texecute(batch: Batch): void;\n\tdestroy(): void;\n}\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction {\n\trenderPipeId: \"filter\";\n\taction: \"pushFilter\" | \"popFilter\";\n\tcontainer?: Container;\n\trenderables?: Renderable[];\n\tfilterEffect: FilterEffect;\n}\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"filter\";\n\t};\n\treadonly renderer: Renderer;\n\tprivate _filterStackIndex;\n\tprivate _filterStack;\n\tprivate readonly _filterGlobalUniforms;\n\tprivate readonly _globalFilterBindGroup;\n\tprivate _activeFilterData;\n\tprivate _passthroughFilter;\n\tconstructor(renderer: Renderer);\n\t/**\n\t * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n\t * @readonly\n\t */\n\tget activeBackTexture(): Texture | undefined;\n\t/**\n\t * Pushes a filter instruction onto the filter stack.\n\t * @param instruction - The instruction containing the filter effect and container.\n\t * @internal\n\t */\n\tpush(instruction: FilterInstruction): void;\n\t/**\n\t * Applies filters to a texture.\n\t *\n\t * This method takes a texture and a list of filters, applies the filters to the texture,\n\t * and returns the resulting texture.\n\t * @param {object} params - The parameters for applying filters.\n\t * @param {Texture} params.texture - The texture to apply filters to.\n\t * @param {Filter[]} params.filters - The filters to apply.\n\t * @returns {Texture} The resulting texture after all filters have been applied.\n\t * @example\n\t *\n\t * ```ts\n\t * // Create a texture and a list of filters\n\t * const texture = new Texture(...);\n\t * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n\t *\n\t * // Apply the filters to the texture\n\t * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n\t *\n\t * // Use the resulting texture\n\t * sprite.texture = resultTexture;\n\t * ```\n\t *\n\t * Key Points:\n\t * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n\t * 2. If all filters are disabled or skipped, the original texture is returned.\n\t */\n\tgenerateFilteredTexture({ texture, filters }: {\n\t\ttexture: Texture;\n\t\tfilters: Filter[];\n\t}): Texture;\n\t/** @internal */\n\tpop(): void;\n\t/**\n\t * Copies the last render surface to a texture.\n\t * @param lastRenderSurface - The last render surface to copy from.\n\t * @param bounds - The bounds of the area to copy.\n\t * @param previousBounds - The previous bounds to use for offsetting the copy.\n\t */\n\tgetBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds): Texture<TextureSource<any>>;\n\t/**\n\t * Applies a filter to a texture.\n\t * @param filter - The filter to apply.\n\t * @param input - The input texture.\n\t * @param output - The output render surface.\n\t * @param clear - Whether to clear the output surface before applying the filter.\n\t */\n\tapplyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean): void;\n\t/**\n\t * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n\t *\n\t * Use `outputMatrix * vTextureCoord` in the shader.\n\t * @param outputMatrix - The matrix to output to.\n\t * @param {Sprite} sprite - The sprite to map to.\n\t * @returns The mapped matrix.\n\t */\n\tcalculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix;\n\tdestroy(): void;\n\tprivate _getPassthroughFilter;\n\t/**\n\t * Sets up the bind groups and renders the filter.\n\t * @param filter - The filter to apply\n\t * @param input - The input texture\n\t * @param renderer - The renderer instance\n\t */\n\tprivate _setupBindGroupsAndRender;\n\t/**\n\t * Sets up the filter textures including input texture and back texture if needed.\n\t * @param filterData - The filter data to update\n\t * @param bounds - The bounds for the texture\n\t * @param renderer - The renderer instance\n\t * @param previousFilterData - The previous filter data for back texture calculation\n\t */\n\tprivate _setupFilterTextures;\n\t/**\n\t * Calculates and sets the global frame for the filter.\n\t * @param filterData - The filter data to update\n\t * @param offsetX - The X offset\n\t * @param offsetY - The Y offset\n\t * @param globalResolution - The global resolution\n\t * @param sourceWidth - The source texture width\n\t * @param sourceHeight - The source texture height\n\t */\n\tprivate _calculateGlobalFrame;\n\t/**\n\t * Updates the filter uniforms with the current filter state.\n\t * @param input - The input texture\n\t * @param output - The output render surface\n\t * @param filterData - The current filter data\n\t * @param offsetX - The X offset for positioning\n\t * @param offsetY - The Y offset for positioning\n\t * @param resolution - The current resolution\n\t * @param isFinalTarget - Whether this is the final render target\n\t * @param clear - Whether to clear the output surface\n\t */\n\tprivate _updateFilterUniforms;\n\t/**\n\t * Finds the correct resolution by looking back through the filter stack.\n\t * @param rootResolution - The fallback root resolution to use\n\t * @returns The resolution from the previous filter or root resolution\n\t */\n\tprivate _findFilterResolution;\n\t/**\n\t * Finds the offset from the previous non-skipped filter in the stack.\n\t * @returns The offset coordinates from the previous filter\n\t */\n\tprivate _findPreviousFilterOffset;\n\t/**\n\t * Calculates the filter area bounds based on the instruction type.\n\t * @param instruction - The filter instruction\n\t * @param bounds - The bounds object to populate\n\t */\n\tprivate _calculateFilterArea;\n\tprivate _applyFiltersToTexture;\n\tprivate _calculateFilterBounds;\n\tprivate _popFilterData;\n\tprivate _getPreviousFilterData;\n\tprivate _pushFilterData;\n}\n/**\n * The options to use when creating a new filter.\n * @category filters\n * @advanced\n */\nexport interface FilterOptions {\n\t/** optional blend mode used by the filter when rendering (defaults to 'normal') */\n\tblendMode?: BLEND_MODES;\n\t/**\n\t * the resolution the filter should be rendered at. The lower the resolution, the more performant\n\t * the filter will be, but the lower the quality of the output. (default 1)\n\t * If 'inherit', the resolution of the render target is used.\n\t * Consider lowering this for things like blurs filters\n\t */\n\tresolution?: number | \"inherit\";\n\t/**\n\t * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n\t * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n\t * without clipping occurring. (default 0)\n\t */\n\tpadding?: number;\n\t/**\n\t * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n\t * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n\t * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n\t * but you won't see the difference. (default 'off')\n\t *\n\t * This can be a boolean or [FilterAntialias]{@link FilterAntialias} string.\n\t */\n\tantialias?: FilterAntialias | boolean;\n\t/**\n\t * If this is set to true, the filter system will grab a snap shot of the area being rendered\n\t * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n\t * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n\t * (default false)\n\t *\n\t * If given, the shader should have a uniform named `uBackTexture`, which is where the pixels of the\n\t * area being rendered to can be sampled from.\n\t */\n\tblendRequired?: boolean;\n\t/**\n\t * If this is set to true, the filter system will clip filter texture into viewport\n\t * This is useful for filters that applied to whole texture.\n\t * (default true)\n\t */\n\tclipToViewport?: boolean;\n}\n/**\n * Filter options mixed with shader resources. A filter needs a shader and some resources to work.\n * @category filters\n * @advanced\n * @see {@link FilterOptions}\n */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @category filters\n * @advanced\n */\nexport type FilterAntialias = \"on\" | \"off\" | \"inherit\";\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @category filters\n * @advanced\n * @example\n * import { Filter } from 'pixi.js';\n *\n * const customFilter = new Filter({\n *     glProgram: new GlProgram({\n *         fragment,\n *         vertex,\n *     }),\n *     resources: {\n *         timeUniforms: {\n *             uTime: { value: 0.0, type: 'f32' },\n *         },\n *     },\n * });\n *\n * // Apply the filter\n * sprite.filters = [customFilter];\n *\n * // Update uniform\n * app.ticker.add((ticker) => {\n *     filter.resources.timeUniforms.uniforms.uTime += 0.04 * ticker.deltaTime;\n * });\n */\nexport class Filter extends Shader {\n\t/** The default filter settings */\n\tstatic defaultOptions: FilterOptions;\n\t/**\n\t * The padding of the filter. Some filters require extra space to breath such as a blur.\n\t * Increasing this will add extra width and height to the bounds of the object that the\n\t * filter is applied to.\n\t * @default 0\n\t */\n\tpadding: number;\n\t/**\n\t * should the filter use antialiasing?\n\t * @default inherit\n\t */\n\tantialias: FilterAntialias;\n\t/** If enabled is true the filter is applied, if false it will not. */\n\tenabled: boolean;\n\t/**\n\t * The gpu state the filter requires to render.\n\t * @internal\n\t */\n\t_state: State;\n\t/**\n\t * The resolution of the filter. Setting this to be lower will lower the quality but\n\t * increase the performance of the filter.\n\t * @default 1\n\t */\n\tresolution: number | \"inherit\";\n\t/**\n\t * Whether or not this filter requires the previous render texture for blending.\n\t * @default false\n\t */\n\tblendRequired: boolean;\n\t/**\n\t * Clip texture into viewport or not\n\t * @default true\n\t */\n\tclipToViewport: boolean;\n\t/**\n\t * @param options - The optional parameters of this filter.\n\t */\n\tconstructor(options: FilterWithShader);\n\t/**\n\t * Applies the filter\n\t * @param filterManager - The renderer to retrieve the filter from\n\t * @param input - The input render target.\n\t * @param output - The target to output to.\n\t * @param clearMode - Should the output be cleared before rendering to it\n\t */\n\tapply(filterManager: FilterSystem, input: Texture, output: RenderSurface, clearMode: boolean): void;\n\t/**\n\t * Get the blend mode of the filter.\n\t * @default \"normal\"\n\t */\n\tget blendMode(): BLEND_MODES;\n\t/** Sets the blend mode of the filter. */\n\tset blendMode(value: BLEND_MODES);\n\t/**\n\t * A short hand function to create a filter based of a vertex and fragment shader src.\n\t * @param options\n\t * @returns A shiny new PixiJS filter!\n\t */\n\tstatic from(options: FilterOptions & ShaderFromResources): Filter;\n}\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container.\n * @internal\n */\nexport class FilterEffect implements Effect {\n\t/** read only filters array - to modify, set it again! */\n\tfilters: readonly Filter[];\n\t/**\n\t * If specified, rather than calculating the bounds of the container that the filter\n\t * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n\t * applied to it\n\t */\n\tfilterArea?: Rectangle;\n\t/** the pipe that knows how to handle this effect */\n\tpipe: string;\n\t/** the priority of this effect */\n\tpriority: number;\n\tdestroy(): void;\n}\n/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link PoolItem}.\n * @category utils\n * @advanced\n */\nexport class Pool<T extends PoolItem> {\n\t/** @internal */\n\treadonly _classType: PoolItemConstructor<T>;\n\tprivate readonly _pool;\n\tprivate _count;\n\tprivate _index;\n\t/**\n\t * Constructs a new Pool.\n\t * @param ClassType - The constructor of the items in the pool.\n\t * @param {number} [initialSize] - The initial size of the pool.\n\t */\n\tconstructor(ClassType: PoolItemConstructor<T>, initialSize?: number);\n\t/**\n\t * Prepopulates the pool with a given number of items.\n\t * @param total - The number of items to add to the pool.\n\t */\n\tprepopulate(total: number): void;\n\t/**\n\t * Gets an item from the pool. Calls the item's `init` method if it exists.\n\t * If there are no items left in the pool, a new one will be created.\n\t * @param {unknown} [data] - Optional data to pass to the item's constructor.\n\t * @returns {T} The item from the pool.\n\t */\n\tget(data?: unknown): T;\n\t/**\n\t * Returns an item to the pool. Calls the item's `reset` method if it exists.\n\t * @param {T} item - The item to return to the pool.\n\t */\n\treturn(item: T): void;\n\t/**\n\t * Gets the number of items in the pool.\n\t * @readonly\n\t */\n\tget totalSize(): number;\n\t/**\n\t * Gets the number of items in the pool that are free to use without needing to create more.\n\t * @readonly\n\t */\n\tget totalFree(): number;\n\t/**\n\t * Gets the number of items in the pool that are currently in use.\n\t * @readonly\n\t */\n\tget totalUsed(): number;\n\t/** clears the pool */\n\tclear(): void;\n}\n/**\n * An object that can be stored in a {@link Pool}.\n * @category utils\n * @advanced\n */\nexport type PoolItem = {\n\tinit?: (data?: any) => void;\n\treset?: () => void;\n\tdestroy?: () => void;\n\t[key: string]: any;\n};\n/**\n * The constructor of an object that can be stored in a {@link Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link Pool}.\n * @category utils\n * @advanced\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n/**\n * AlphaMask is an effect that applies a mask to a container using the alpha channel of a sprite.\n * It can be used to create complex masking effects by using a sprite as the mask.\n * The mask can be inverted, and it can render the mask to a texture if the mask is not a sprite.\n * @category rendering\n * @advanced\n */\nexport class AlphaMask implements Effect, PoolItem {\n\tstatic extension: ExtensionMetadata;\n\tpriority: number;\n\tmask: Container;\n\tinverse: boolean;\n\tpipe: string;\n\trenderMaskToTexture: boolean;\n\tconstructor(options?: {\n\t\tmask: Container;\n\t});\n\tinit(mask: Container): void;\n\treset(): void;\n\taddBounds(bounds: Bounds, skipUpdateTransform?: boolean): void;\n\taddLocalBounds(bounds: Bounds, localRoot: Container): void;\n\tcontainsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean;\n\tdestroy(): void;\n\tstatic test(mask: any): boolean;\n}\ntype MaskMode = \"pushMaskBegin\" | \"pushMaskEnd\" | \"popMaskBegin\" | \"popMaskEnd\";\ndeclare class AlphaMaskEffect extends FilterEffect implements PoolItem {\n\tconstructor();\n\tget sprite(): Sprite;\n\tset sprite(value: Sprite);\n\tget inverse(): boolean;\n\tset inverse(value: boolean);\n\tinit: () => void;\n}\n/** @internal */\nexport interface AlphaMaskInstruction extends Instruction {\n\trenderPipeId: \"alphaMask\";\n\taction: MaskMode;\n\tmask: AlphaMask;\n\tinverse: boolean;\n\tmaskedContainer: Container;\n\trenderMask: boolean;\n}\n/** @internal */\nexport interface AlphaMaskData {\n\tfilterEffect: AlphaMaskEffect;\n\tmaskedContainer: Container;\n\tpreviousRenderTarget?: RenderTarget;\n\tfilterTexture?: Texture;\n}\n/** @internal */\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"alphaMask\";\n\t};\n\tprivate _renderer;\n\tprivate _activeMaskStage;\n\tconstructor(renderer: Renderer);\n\tpush(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void;\n\tpop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void;\n\texecute(instruction: AlphaMaskInstruction): void;\n\tdestroy(): void;\n}\n/** @internal */\nexport interface ColorMaskInstruction extends Instruction {\n\trenderPipeId: \"colorMask\";\n\tcolorMask: number;\n}\n/** @internal */\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"colorMask\";\n\t};\n\tprivate readonly _renderer;\n\tprivate _colorStack;\n\tprivate _colorStackIndex;\n\tprivate _currentColor;\n\tconstructor(renderer: Renderer);\n\tbuildStart(): void;\n\tpush(mask: Effect, _container: Container, instructionSet: InstructionSet): void;\n\tpop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void;\n\texecute(instruction: ColorMaskInstruction): void;\n\tdestroy(): void;\n}\n/**\n * A mask that uses the stencil buffer to clip the rendering of a container.\n * This is useful for complex masks that cannot be achieved with simple shapes.\n * It is more performant than using a `Graphics` mask, but requires WebGL support.\n * It is also useful for masking with `Container` objects that have complex shapes.\n * @category rendering\n * @advanced\n */\nexport class StencilMask implements Effect, PoolItem {\n\tstatic extension: ExtensionMetadata;\n\tpriority: number;\n\tmask: Container;\n\tpipe: string;\n\tconstructor(options: {\n\t\tmask: Container;\n\t});\n\tinit(mask: Container): void;\n\treset(): void;\n\taddBounds(bounds: Bounds, skipUpdateTransform: boolean): void;\n\taddLocalBounds(bounds: Bounds, localRoot: Container): void;\n\tcontainsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean;\n\tdestroy(): void;\n\tstatic test(mask: any): boolean;\n}\ntype MaskMode$1 = \"pushMaskBegin\" | \"pushMaskEnd\" | \"popMaskBegin\" | \"popMaskEnd\";\n/** @internal */\nexport interface StencilMaskInstruction extends Instruction {\n\trenderPipeId: \"stencilMask\";\n\taction: MaskMode$1;\n\tinverse: boolean;\n\tmask: StencilMask;\n}\n/** @internal */\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction> {\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"stencilMask\";\n\t};\n\tprivate _renderer;\n\tprivate _maskStackHash;\n\tprivate _maskHash;\n\tconstructor(renderer: Renderer);\n\tpush(mask: Effect, _container: Container, instructionSet: InstructionSet): void;\n\tpop(mask: Effect, _container: Container, instructionSet: InstructionSet): void;\n\texecute(instruction: StencilMaskInstruction): void;\n\tdestroy(): void;\n}\ninterface AdvancedBlendInstruction extends Instruction {\n\trenderPipeId: \"blendMode\";\n\tblendMode: BLEND_MODES;\n\tactiveBlend: Renderable[];\n}\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @category rendering\n * @internal\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"blendMode\";\n\t};\n\tprivate _renderer;\n\tprivate _renderableList?;\n\tprivate _activeBlendMode;\n\tprivate readonly _blendModeStack;\n\tprivate _isAdvanced;\n\tprivate _filterHash;\n\tconstructor(renderer: Renderer);\n\tprerender(): void;\n\t/**\n\t * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n\t * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n\t * @param blendMode - The blend mode to activate.\n\t * @param instructionSet - The instruction set being built.\n\t */\n\tpushBlendMode(renderable: Renderable | RenderGroup, blendMode: BLEND_MODES, instructionSet: InstructionSet): void;\n\t/**\n\t * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n\t * @param instructionSet - The instruction set being built.\n\t */\n\tpopBlendMode(instructionSet: InstructionSet): void;\n\t/**\n\t * Ensure a blend mode switch is added to the instruction set when the mode changes.\n\t * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n\t * rendered within a single filter pass.\n\t * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n\t * @param blendMode - The target blend mode.\n\t * @param instructionSet - The instruction set being built.\n\t */\n\tsetBlendMode(renderable: Renderable | RenderGroup | null, blendMode: BLEND_MODES, instructionSet: InstructionSet): void;\n\tprivate _beginAdvancedBlendMode;\n\tprivate _ensureFilterEffect;\n\tprivate _endAdvancedBlendMode;\n\t/**\n\t * called when the instruction build process is starting this will reset internally to the default blend mode\n\t * @internal\n\t */\n\tbuildStart(): void;\n\t/**\n\t * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n\t * active, we add the final render instructions added to the instruction set\n\t * @param instructionSet - The instruction set we are adding to\n\t * @internal\n\t */\n\tbuildEnd(instructionSet: InstructionSet): void;\n\t/** @internal */\n\tdestroy(): void;\n}\ndeclare const imageTypes: {\n\tpng: string;\n\tjpg: string;\n\twebp: string;\n};\ntype Formats = keyof typeof imageTypes;\n/**\n * Options for creating an image from a renderer.\n * Controls the output format and quality of extracted images.\n * @example\n * ```ts\n * // Extract as PNG (default)\n * const pngImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // Extract as JPEG with quality setting\n * const jpgImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'jpg',\n *     quality: 0.8\n * });\n *\n * // Extract as WebP for better compression\n * const webpImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'webp',\n *     quality: 0.9\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface ImageOptions {\n\t/**\n\t * The format of the extracted image.\n\t * - 'png': Lossless format, best for images with text or sharp edges\n\t * - 'jpg': Lossy format, smaller file size, good for photos\n\t * - 'webp': Modern format with better compression\n\t * @example\n\t * ```ts\n\t * // Extract as PNG\n\t * const pngImage = await renderer.extract.image({\n\t *     target: sprite,\n\t *     format: 'png'\n\t * });\n\t * // Extract as JPEG\n\t * const jpgImage = await renderer.extract.image({\n\t *     target: sprite,\n\t *     format: 'jpg',\n\t * });\n\t * ```\n\t * @default 'png'\n\t */\n\tformat?: Formats;\n\t/**\n\t * The quality of the extracted image, between 0 and 1.\n\t * Only applies to lossy formats (jpg, webp).\n\t * - 1: Maximum quality\n\t * - 0: Maximum compression\n\t * @example\n\t * ```ts\n\t * // Extract as JPEG with 80% quality\n\t * const jpgImage = await renderer.extract.image({\n\t *     target: sprite,\n\t *     format: 'jpg',\n\t *     quality: 0.8\n\t * });\n\t * // Extract as WebP with 90% quality\n\t * const webpImage = await renderer.extract.image({\n\t *     target: sprite,\n\t *     format: 'webp',\n\t *     quality: 0.9\n\t * });\n\t * ```\n\t * @default 1\n\t */\n\tquality?: number;\n}\n/**\n * Options for extracting content from a renderer.\n * These options control how content is extracted and processed from the renderer.\n * @example\n * ```ts\n * // Basic extraction\n * const pixels = renderer.extract.pixels({\n *     target: sprite,\n * });\n *\n * // Extract with custom region and resolution\n * const canvas = renderer.extract.canvas({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n * });\n *\n * // Extract with background color and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface BaseExtractOptions {\n\t/**\n\t * The target to extract. Can be a Container or Texture.\n\t * @example\n\t * ```ts\n\t * // Extract from a sprite\n\t * const sprite = new Sprite(texture);\n\t * renderer.extract.pixels({ target: sprite });\n\t *\n\t * // Extract from a texture directly\n\t * renderer.extract.pixels({ target: texture });\n\t * ```\n\t */\n\ttarget: Container | Texture;\n\t/**\n\t * The region of the target to extract. If not specified, extracts the entire target.\n\t * @example\n\t * ```ts\n\t * // Extract a specific region\n\t * renderer.extract.canvas({\n\t *     target: sprite,\n\t *     frame: new Rectangle(10, 10, 100, 100)\n\t * });\n\t * ```\n\t */\n\tframe?: Rectangle;\n\t/**\n\t * The resolution of the extracted content. Higher values create sharper images.\n\t * @default 1\n\t * @example\n\t * ```ts\n\t * // Extract at 2x resolution for retina displays\n\t * renderer.extract.image({\n\t *     target: sprite,\n\t *     resolution: 2\n\t * });\n\t * ```\n\t */\n\tresolution?: number;\n\t/**\n\t * The color used to clear the extracted content before rendering.\n\t * Can be a hex number, string, or array of numbers.\n\t * @example\n\t * ```ts\n\t * // Clear with red background\n\t * renderer.extract.canvas({\n\t *     target: sprite,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Clear with semi-transparent black\n\t * renderer.extract.canvas({\n\t *     target: sprite,\n\t *     clearColor: [0, 0, 0, 0.5]\n\t * });\n\t * ```\n\t */\n\tclearColor?: ColorSource;\n\t/**\n\t * Whether to enable anti-aliasing during extraction.\n\t * Improves quality but may affect performance.\n\t * @default false\n\t * @example\n\t * ```ts\n\t * // Enable anti-aliasing for smoother edges\n\t * renderer.extract.image({\n\t *     target: graphics,\n\t *     antialias: true\n\t * });\n\t * ```\n\t */\n\tantialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * Combines base extraction options with image-specific settings.\n * @example\n * ```ts\n * // Basic PNG extraction\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // High-quality JPEG with custom region\n * const image = await renderer.extract.image({\n *     target: container,\n *     format: 'jpg',\n *     quality: 0.9,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // WebP with background and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     format: 'webp',\n *     quality: 0.8,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - {@link ImageOptions} for image format and quality settings\n *\n * Common use cases:\n * - Capturing game screenshots\n * - Saving rendered content\n * - Creating image thumbnails\n * - Exporting canvas content\n * @see {@link ExtractSystem.image} For the method that uses these options\n * @see {@link ExtractSystem.base64} For base64 encoding\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * Combines base extraction options with download-specific settings.\n * @example\n * ```ts\n * // Basic download with default filename\n * renderer.extract.download({\n *     target: sprite\n * });\n *\n * // Download with custom filename and region\n * renderer.extract.download({\n *     target: container,\n *     filename: 'screenshot.png',\n *     frame: new Rectangle(0, 0, 100, 100)\n * });\n *\n * // Download with high resolution and background\n * renderer.extract.download({\n *     target: stage,\n *     filename: 'hd-capture.png',\n *     resolution: 2,\n *     clearColor: '#ff0000'\n * });\n *\n * // Download with anti-aliasing\n * renderer.extract.download({\n *     target: graphics,\n *     filename: 'smooth.png',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - Additional download-specific options\n *\n * Common use cases:\n * - Saving game screenshots\n * - Exporting rendered content\n * - Creating downloadable assets\n * - Saving canvas state\n * @see {@link ExtractSystem.download} For the method that uses these options\n * @see {@link ExtractSystem.image} For creating images without download\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n\t/**\n\t * The filename to use when downloading the content.\n\t * Should include the desired file extension (e.g., .png).\n\t * @default 'image.png'\n\t * @example\n\t * ```ts\n\t * renderer.extract.download({\n\t *     target: sprite,\n\t *     filename: 'my-screenshot.png'\n\t * });\n\t * ```\n\t */\n\tfilename: string;\n};\n/**\n * Options for extracting content from a renderer. Represents a union of all possible extraction option types.\n * Used by various extraction methods to support different output formats and configurations.\n * @example\n * ```ts\n * // Basic canvas extraction\n * const canvas = renderer.extract.canvas({\n *     target: sprite\n * });\n *\n * // Image extraction with format\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png',\n *     quality: 1\n * });\n *\n * // Download with filename\n * renderer.extract.download({\n *     target: sprite,\n *     filename: 'screenshot.png'\n * });\n *\n * // Advanced extraction with multiple options\n * const image = await renderer.extract.image({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     format: 'webp',\n *     quality: 0.8\n * });\n * ```\n *\n * Supports three types of options:\n * - {@link BaseExtractOptions} - Basic extraction settings\n * - {@link ExtractImageOptions} - Image-specific settings with format and quality\n * - {@link ExtractDownloadOptions} - Download settings with filename\n *\n * Common use cases:\n * - Extracting raw pixels\n * - Creating canvas elements\n * - Generating downloadable images\n * - Taking screenshots\n * - Creating thumbnails\n * @see {@link ExtractSystem.canvas} For canvas extraction\n * @see {@link ExtractSystem.image} For image extraction\n * @see {@link ExtractSystem.download} For downloading content\n * @category rendering\n * @advanced\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * ```ts\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n * ```\n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n * @category rendering\n * @standard\n */\nexport class ExtractSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"extract\";\n\t};\n\t/**\n\t * Default options for image extraction.\n\t * @example\n\t * ```ts\n\t * // Customize default options\n\t * ExtractSystem.defaultImageOptions.format = 'webp';\n\t * ExtractSystem.defaultImageOptions.quality = 0.8;\n\t *\n\t * // Use defaults\n\t * const image = await renderer.extract.image(sprite);\n\t * ```\n\t */\n\tstatic defaultImageOptions: ImageOptions;\n\tprivate _renderer;\n\t/** @param renderer - The renderer this System works for. */\n\tconstructor(renderer: Renderer);\n\tprivate _normalizeOptions;\n\t/**\n\t * Creates an IImage from a display object or texture.\n\t * @param options - Options for creating the image, or the target to extract\n\t * @returns Promise that resolves with the generated IImage\n\t * @example\n\t * ```ts\n\t * // Basic usage with a sprite\n\t * const sprite = new Sprite(texture);\n\t * const image = await renderer.extract.image(sprite);\n\t * document.body.appendChild(image);\n\t *\n\t * // Advanced usage with options\n\t * const image = await renderer.extract.image({\n\t *     target: container,\n\t *     format: 'webp',\n\t *     quality: 0.8,\n\t *     frame: new Rectangle(0, 0, 100, 100),\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000',\n\t *     antialias: true\n\t * });\n\t *\n\t * // Extract directly from a texture\n\t * const texture = Texture.from('myTexture.png');\n\t * const image = await renderer.extract.image(texture);\n\t * ```\n\t * @see {@link ExtractImageOptions} For detailed options\n\t * @see {@link ExtractSystem.base64} For base64 string output\n\t * @see {@link ExtractSystem.canvas} For canvas output\n\t * @see {@link ImageLike} For the image interface\n\t * @category rendering\n\t */\n\timage(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>;\n\t/**\n\t * Converts the target into a base64 encoded string.\n\t *\n\t * This method works by first creating\n\t * a canvas using `Extract.canvas` and then converting it to a base64 string.\n\t * @param options - The options for creating the base64 string, or the target to extract\n\t * @returns Promise that resolves with the base64 encoded string\n\t * @example\n\t * ```ts\n\t * // Basic usage with a sprite\n\t * const sprite = new Sprite(texture);\n\t * const base64 = await renderer.extract.base64(sprite);\n\t * console.log(base64); // data:image/png;base64,...\n\t *\n\t * // Advanced usage with options\n\t * const base64 = await renderer.extract.base64({\n\t *     target: container,\n\t *     format: 'webp',\n\t *     quality: 0.8,\n\t *     frame: new Rectangle(0, 0, 100, 100),\n\t *     resolution: 2\n\t * });\n\t * ```\n\t * @throws Will throw an error if the platform doesn't support any of:\n\t * - ICanvas.toDataURL\n\t * - ICanvas.toBlob\n\t * - ICanvas.convertToBlob\n\t * @see {@link ExtractImageOptions} For detailed options\n\t * @see {@link ExtractSystem.canvas} For canvas output\n\t * @see {@link ExtractSystem.image} For HTMLImage output\n\t * @category rendering\n\t */\n\tbase64(options: ExtractImageOptions | Container | Texture): Promise<string>;\n\t/**\n\t * Creates a Canvas element, renders the target to it and returns it.\n\t * This method is useful for creating static images or when you need direct canvas access.\n\t * @param options - The options for creating the canvas, or the target to extract\n\t * @returns A Canvas element with the texture rendered on\n\t * @example\n\t * ```ts\n\t * // Basic canvas extraction from a sprite\n\t * const sprite = new Sprite(texture);\n\t * const canvas = renderer.extract.canvas(sprite);\n\t * document.body.appendChild(canvas);\n\t *\n\t * // Extract with custom region\n\t * const canvas = renderer.extract.canvas({\n\t *     target: container,\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Extract with high resolution\n\t * const canvas = renderer.extract.canvas({\n\t *     target: sprite,\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Extract directly from a texture\n\t * const texture = Texture.from('myTexture.png');\n\t * const canvas = renderer.extract.canvas(texture);\n\t *\n\t * // Extract with anti-aliasing\n\t * const canvas = renderer.extract.canvas({\n\t *     target: graphics,\n\t *     antialias: true\n\t * });\n\t * ```\n\t * @see {@link ExtractOptions} For detailed options\n\t * @see {@link ExtractSystem.image} For HTMLImage output\n\t * @see {@link ExtractSystem.pixels} For raw pixel data\n\t * @category rendering\n\t */\n\tcanvas(options: ExtractOptions | Container | Texture): ICanvas;\n\t/**\n\t * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n\t * with integer values between 0 and 255 (inclusive).\n\t * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n\t * @param options - The options for extracting the image, or the target to extract\n\t * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n\t * @example\n\t * ```ts\n\t * // Basic pixel extraction\n\t * const sprite = new Sprite(texture);\n\t * const pixels = renderer.extract.pixels(sprite);\n\t * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n\t *\n\t * // Extract with custom region\n\t * const pixels = renderer.extract.pixels({\n\t *     target: sprite,\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Extract with high resolution\n\t * const pixels = renderer.extract.pixels({\n\t *     target: sprite,\n\t *     resolution: 2\n\t * });\n\t * ```\n\t * @see {@link ExtractOptions} For detailed options\n\t * @see {@link ExtractSystem.canvas} For canvas output\n\t * @see {@link ExtractSystem.image} For image output\n\t * @category rendering\n\t */\n\tpixels(options: ExtractOptions | Container | Texture): GetPixelsOutput;\n\t/**\n\t * Creates a texture from a display object or existing texture.\n\t *\n\t * This is useful for creating\n\t * reusable textures from rendered content or making copies of existing textures.\n\t * > [!NOTE] The returned texture should be destroyed when no longer needed\n\t * @param options - The options for creating the texture, or the target to extract\n\t * @returns A new texture containing the extracted content\n\t * @example\n\t * ```ts\n\t * // Basic texture extraction from a sprite\n\t * const sprite = new Sprite(texture);\n\t * const extractedTexture = renderer.extract.texture(sprite);\n\t *\n\t * // Extract with custom region\n\t * const regionTexture = renderer.extract.texture({\n\t *     target: container,\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Extract with high resolution\n\t * const hiResTexture = renderer.extract.texture({\n\t *     target: sprite,\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Create a new sprite from extracted texture\n\t * const newSprite = new Sprite(\n\t *     renderer.extract.texture({\n\t *         target: graphics,\n\t *         antialias: true\n\t *     })\n\t * );\n\t *\n\t * // Clean up when done\n\t * extractedTexture.destroy(true);\n\t * ```\n\t * @see {@link ExtractOptions} For detailed options\n\t * @see {@link Texture} For texture management\n\t * @see {@link GenerateTextureSystem} For texture generation\n\t * @category rendering\n\t */\n\ttexture(options: ExtractOptions | Container | Texture): Texture;\n\t/**\n\t * Extracts and downloads content from the renderer as an image file.\n\t * This is a convenient way to save screenshots or export rendered content.\n\t * > [!NOTE] The download will use PNG format regardless of the filename extension\n\t * @param options - The options for downloading and extracting the image, or the target to extract\n\t * @example\n\t * ```ts\n\t * // Basic download with default filename\n\t * const sprite = new Sprite(texture);\n\t * renderer.extract.download(sprite); // Downloads as 'image.png'\n\t *\n\t * // Download with custom filename\n\t * renderer.extract.download({\n\t *     target: sprite,\n\t *     filename: 'screenshot.png'\n\t * });\n\t *\n\t * // Download with custom region\n\t * renderer.extract.download({\n\t *     target: container,\n\t *     filename: 'region.png',\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Download with high resolution and background\n\t * renderer.extract.download({\n\t *     target: stage,\n\t *     filename: 'hd-screenshot.png',\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Download with anti-aliasing\n\t * renderer.extract.download({\n\t *     target: graphics,\n\t *     filename: 'smooth.png',\n\t *     antialias: true\n\t * });\n\t * ```\n\t * @see {@link ExtractDownloadOptions} For detailed options\n\t * @see {@link ExtractSystem.image} For creating images without download\n\t * @see {@link ExtractSystem.canvas} For canvas output\n\t * @category rendering\n\t */\n\tdownload(options: ExtractDownloadOptions | Container | Texture): void;\n\t/**\n\t * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n\t * The image will be displayed in the browser's console using CSS background images.\n\t * @param options - The options for logging the image, or the target to log\n\t * @param options.width - The width of the logged image preview in the console (in pixels)\n\t * @example\n\t * ```ts\n\t * // Basic usage\n\t * const sprite = new Sprite(texture);\n\t * renderer.extract.log(sprite);\n\t * ```\n\t * @see {@link ExtractSystem.canvas} For getting raw canvas output\n\t * @see {@link ExtractSystem.pixels} For raw pixel data\n\t * @category rendering\n\t * @advanced\n\t */\n\tlog(options: (ExtractOptions & {\n\t\twidth?: number;\n\t}) | Container | Texture): void;\n\tdestroy(): void;\n}\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @category rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipesAdaptor\n\t\t];\n\t\treadonly name: \"batch\";\n\t};\n\tprivate readonly _tempState;\n\t/**\n\t * We only want to sync the a batched shaders uniforms once on first use\n\t * this is a hash of shader uids to a boolean value.  When the shader is first bound\n\t * we set the value to true.  When the shader is bound again we check the value and\n\t * if it is true we know that the uniforms have already been synced and we skip it.\n\t */\n\tprivate _didUploadHash;\n\tinit(batcherPipe: BatcherPipe): void;\n\tcontextChange(): void;\n\tstart(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void;\n\texecute(batchPipe: BatcherPipe, batch: Batch): void;\n}\n/**\n * @param maxIfs\n * @param gl\n * @internal\n */\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number;\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @deprecated Use `Renderer.limits.maxBatchableTextures` instead.\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number;\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateGPULayout(maxTextures: number): GPUBindGroupLayoutEntry[];\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateLayout(maxTextures: number): Record<string, number>;\n/**\n * @param textures\n * @param size\n * @param maxTextures\n * @internal\n */\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number, maxTextures: number): BindGroup;\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @category rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUPipesAdaptor\n\t\t];\n\t\treadonly name: \"batch\";\n\t};\n\tprivate _shader;\n\tprivate _geometry;\n\tstart(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void;\n\texecute(batchPipe: BatcherPipe, batch: Batch): void;\n}\n/**\n * the vertex source code, an obj\n * @internal\n */\nexport type Vertex = {\n\t/** stick uniforms and functions in here all headers will be compiled at the top of the shader */\n\theader?: string;\n\t/** code will be added at the start of the shader */\n\tstart?: string;\n\t/** code will be run here before lighting happens */\n\tmain?: string;\n\t/** code here will to modify anything before it is passed to the fragment shader */\n\tend?: string;\n};\n/** @internal */\nexport type Fragment = {\n\t/** stick uniforms and functions in here all headers will be compiled at the top of the shader */\n\theader?: string;\n\t/** code will be added at the start of the shader */\n\tstart?: string;\n\t/** code will be run here before lighting happens */\n\tmain?: string;\n\t/** code here will to modify anything before it is passed to the fragment shader */\n\tend?: string;\n};\n/**\n * HighShaderBit is a part of a shader.\n * it is used to compile HighShaders.\n *\n * Internally shaders are made up of many of these.\n * You can even write your own and compile them in.\n * @internal\n */\nexport interface HighShaderBit {\n\t/** used to make the shader easier to understand! */\n\tname?: string;\n\t/** the snippets of vertex code */\n\tvertex?: Vertex;\n\t/** the snippets of fragment code */\n\tfragment?: Fragment;\n}\n/**\n * source code to compile a shader. this can be directly used by pixi and should be good to go!\n * It contains the vertex and fragment source code.\n * This is the final output of the HighShader compiler.\n * It is used to create a shader program.\n * @internal\n */\nexport interface HighShaderSource {\n\tfragment: string;\n\tvertex: string;\n}\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGpuProgram({ bits, name }: {\n\tbits: HighShaderBit[];\n\tname: string;\n}): GpuProgram;\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGlProgram({ bits, name }: {\n\tbits: HighShaderBit[];\n\tname: string;\n}): GlProgram;\n/**\n * A high template consists of vertex and fragment source\n * @internal\n */\nexport interface HighShaderTemplate {\n\tname?: string;\n\tfragment: string;\n\tvertex: string;\n}\n/** @internal */\nexport interface CompileHighShaderOptions {\n\ttemplate: HighShaderTemplate;\n\tbits: HighShaderBit[];\n}\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n * @internal\n */\nexport function compileHighShader({ template, bits }: CompileHighShaderOptions): HighShaderSource;\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * It is specifically for WebGL and does not compile inputs and outputs.\n * @param options\n * @param options.template - The HighShader template containing vertex and fragment source.\n * @param options.bits - An array of HighShaderBit objects to be compiled into the shader.\n * @returns A HighShaderSource object containing the compiled vertex and fragment shaders.\n * @internal\n */\nexport function compileHighShaderGl({ template, bits }: CompileHighShaderOptions): HighShaderSource;\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n * @internal\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string): void;\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n * @internal\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>;\n/**\n * @param fragments\n * @param template\n * @param sort\n * @internal\n */\nexport function compileInputs(fragments: any[], template: string, sort?: boolean): string;\n/**\n * @param fragments\n * @param template\n * @internal\n */\nexport function compileOutputs(fragments: any[], template: string): string;\n/**\n * formats a shader so its more pleasant to read\n * @param shader - a glsl shader program source\n * @category utils\n * @advanced\n */\nexport function formatShader(shader: string): string;\n/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n * @internal\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string;\n/** @ignore */\nexport const vertexGPUTemplate = \"\\n    @in aPosition: vec2<f32>;\\n    @in aUV: vec2<f32>;\\n\\n    @out @builtin(position) vPosition: vec4<f32>;\\n    @out vUV : vec2<f32>;\\n    @out vColor : vec4<f32>;\\n\\n    {{header}}\\n\\n    struct VSOutput {\\n        {{struct}}\\n    };\\n\\n    @vertex\\n    fn main( {{in}} ) -> VSOutput {\\n\\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\\n        var modelMatrix = mat3x3<f32>(\\n            1.0, 0.0, 0.0,\\n            0.0, 1.0, 0.0,\\n            0.0, 0.0, 1.0\\n          );\\n        var position = aPosition;\\n        var uv = aUV;\\n\\n        {{start}}\\n\\n        vColor = vec4<f32>(1., 1., 1., 1.);\\n\\n        {{main}}\\n\\n        vUV = uv;\\n\\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\\n\\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\\n\\n        vColor *= globalUniforms.uWorldColorAlpha;\\n\\n        {{end}}\\n\\n        {{return}}\\n    };\\n\";\n/** @ignore */\nexport const fragmentGPUTemplate = \"\\n    @in vUV : vec2<f32>;\\n    @in vColor : vec4<f32>;\\n\\n    {{header}}\\n\\n    @fragment\\n    fn main(\\n        {{in}}\\n      ) -> @location(0) vec4<f32> {\\n\\n        {{start}}\\n\\n        var outColor:vec4<f32>;\\n\\n        {{main}}\\n\\n        var finalColor:vec4<f32> = outColor * vColor;\\n\\n        {{end}}\\n\\n        return finalColor;\\n      };\\n\";\n/** @ignore */\nexport const vertexGlTemplate = \"\\n    in vec2 aPosition;\\n    in vec2 aUV;\\n\\n    out vec4 vColor;\\n    out vec2 vUV;\\n\\n    {{header}}\\n\\n    void main(void){\\n\\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\\n        mat3 modelMatrix = mat3(\\n            1.0, 0.0, 0.0,\\n            0.0, 1.0, 0.0,\\n            0.0, 0.0, 1.0\\n          );\\n        vec2 position = aPosition;\\n        vec2 uv = aUV;\\n\\n        {{start}}\\n\\n        vColor = vec4(1.);\\n\\n        {{main}}\\n\\n        vUV = uv;\\n\\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\\n\\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n\\n        vColor *= uWorldColorAlpha;\\n\\n        {{end}}\\n    }\\n\";\n/** @ignore */\nexport const fragmentGlTemplate = \"\\n\\n    in vec4 vColor;\\n    in vec2 vUV;\\n\\n    out vec4 finalColor;\\n\\n    {{header}}\\n\\n    void main(void) {\\n\\n        {{start}}\\n\\n        vec4 outColor;\\n\\n        {{main}}\\n\\n        finalColor = outColor * vColor;\\n\\n        {{end}}\\n    }\\n\";\n/** @internal */\nexport const colorBit: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/** @internal */\nexport const colorBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit;\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit;\n/** @internal */\nexport const globalUniformsBit: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t};\n};\n/** @internal */\nexport const globalUniformsUBOBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t};\n};\n/** @internal */\nexport const globalUniformsBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t};\n};\n/** @internal */\nexport const localUniformBit: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t\tend: string;\n\t};\n};\n/** @internal */\nexport const localUniformBitGroup2: {\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t\tend: string;\n\t};\n\tname: string;\n};\n/** @internal */\nexport const localUniformBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t\tend: string;\n\t};\n};\n/** @internal */\nexport const roundPixelsBit: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t};\n};\n/** @internal */\nexport const roundPixelsBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t};\n};\n/** @internal */\nexport const textureBit: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n\tfragment: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/** @internal */\nexport const textureBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n\tfragment: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/**\n * The ColorMask effect allows you to apply a color mask to the rendering process.\n * This can be useful for selectively rendering certain colors or for creating\n * effects based on color values.\n * @category rendering\n * @advanced\n */\nexport class ColorMask implements Effect, PoolItem {\n\tstatic extension: ExtensionMetadata;\n\tpriority: number;\n\tmask: number;\n\tpipe: string;\n\tconstructor(options: {\n\t\tmask: number;\n\t});\n\tinit(mask: number): void;\n\tdestroy(): void;\n\tstatic test(mask: any): boolean;\n}\ninterface MaskConversionTest {\n\ttest: (item: any) => boolean;\n\tmaskClass: new (item: any) => Effect & PoolItem;\n}\n/**\n * Represents a mask effect that can be applied to a container.\n * @category rendering\n * @advanced\n */\nexport type MaskEffect = {\n\tmask: unknown;\n} & Effect;\n/**\n * A class that manages the conversion of masks to mask effects.\n * @category rendering\n * @ignore\n */\nexport class MaskEffectManagerClass {\n\t/** @private */\n\treadonly _effectClasses: EffectConstructor[];\n\tprivate readonly _tests;\n\tprivate _initialized;\n\tinit(): void;\n\tadd(test: MaskConversionTest): void;\n\tgetMaskEffect(item: any): MaskEffect;\n\treturnMaskEffect(effect: Effect & PoolItem): void;\n}\n/**\n * A class that manages the conversion of masks to mask effects.\n * @class\n * @category rendering\n * @advanced\n */\nexport const MaskEffectManager: MaskEffectManagerClass;\n/**\n * ScissorMask is an effect that applies a scissor mask to a container.\n * It restricts rendering to the area defined by the mask.\n * The mask is a Container that defines the area to be rendered.\n * The mask must be a Container that is not renderable or measurable.\n * This effect is used to create clipping regions in the rendering process.\n * @category rendering\n * @advanced\n */\nexport class ScissorMask implements Effect {\n\tpriority: number;\n\tmask: Container;\n\tpipe: string;\n\tconstructor(mask: Container);\n\taddBounds(bounds: Bounds, skipUpdateTransform?: boolean): void;\n\taddLocalBounds(bounds: Bounds, localRoot: Container): void;\n\tcontainsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean;\n\treset(): void;\n\tdestroy(): void;\n}\n/**\n * @param mask\n * @param bounds\n * @param skipUpdateTransform\n * @internal\n */\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void;\n/**\n * @param mask\n * @param bounds\n * @param localRoot\n * @internal\n */\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void;\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlBufferSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"buffer\";\n\t};\n\t/** @internal */\n\t_gl: GlRenderingContext;\n\tprotected _managedBuffers: GCManagedHash<Buffer$1>;\n\t/** Cache keeping track of the base bound buffer bases */\n\tprivate _boundBufferBases;\n\tprivate _renderer;\n\tprivate _minBaseLocation;\n\tprivate _maxBindings;\n\tprivate _nextBindBaseIndex;\n\tprivate _bindCallId;\n\t/**\n\t * @param {Renderer} renderer - The renderer this System works for.\n\t */\n\tconstructor(renderer: WebGLRenderer);\n\t/** @ignore */\n\tdestroy(): void;\n\t/** Sets up the renderer context and necessary buffers. */\n\tprotected contextChange(): void;\n\tgetGlBuffer(buffer: Buffer$1): GlBuffer;\n\t/**\n\t * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n\t * @param buffer - the buffer to bind to the renderer\n\t */\n\tbind(buffer: Buffer$1): void;\n\t/**\n\t * Binds an uniform buffer to at the given index.\n\t *\n\t * A cache is used so a buffer will not be bound again if already bound.\n\t * @param glBuffer - the buffer to bind\n\t * @param index - the base index to bind it to.\n\t */\n\tbindBufferBase(glBuffer: GlBuffer, index: number): void;\n\tnextBindBase(hasTransformFeedback: boolean): void;\n\tfreeLocationForBufferBase(glBuffer: GlBuffer): number;\n\tgetLastBindBaseLocation(glBuffer: GlBuffer): number;\n\t/**\n\t * Binds a buffer whilst also binding its range.\n\t * This will make the buffer start from the offset supplied rather than 0 when it is read.\n\t * @param glBuffer - the buffer to bind\n\t * @param index - the base index to bind at, defaults to 0\n\t * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n\t * @param size - the size to bind at (this is blocks of 256).\n\t */\n\tbindBufferRange(glBuffer: GlBuffer, index?: number, offset?: number, size?: number): void;\n\t/**\n\t * Will ensure the data in the buffer is uploaded to the GPU.\n\t * @param {Buffer} buffer - the buffer to update\n\t */\n\tupdateBuffer(buffer: Buffer$1): GlBuffer;\n\t/**\n\t * dispose all WebGL resources of all managed buffers\n\t * @param contextLost\n\t */\n\tdestroyAll(contextLost?: boolean): void;\n\tprotected onBufferUnload(buffer: Buffer$1, contextLost?: boolean): void;\n\t/**\n\t * creates and attaches a GLBuffer object tied to the current context.\n\t * @param buffer\n\t * @protected\n\t */\n\tprotected createGLBuffer(buffer: Buffer$1): GlBuffer;\n\tresetState(): void;\n}\n/**\n * WebGL extensions for compressed textures using the PVRTC format.\n * @category rendering\n * @advanced\n */\ninterface WEBGL_compressed_texture_pvrtc$1 {\n\tCOMPRESSED_RGB_PVRTC_4BPPV1_IMG: number;\n\tCOMPRESSED_RGBA_PVRTC_4BPPV1_IMG: number;\n\tCOMPRESSED_RGB_PVRTC_2BPPV1_IMG: number;\n\tCOMPRESSED_RGBA_PVRTC_2BPPV1_IMG: number;\n}\n/**\n * WebGL extensions for texture compression using the ETC format.\n * @category rendering\n * @advanced\n */\ninterface WEBGL_compressed_texture_etc$1 {\n\tCOMPRESSED_R11_EAC: number;\n\tCOMPRESSED_SIGNED_R11_EAC: number;\n\tCOMPRESSED_RG11_EAC: number;\n\tCOMPRESSED_SIGNED_RG11_EAC: number;\n\tCOMPRESSED_RGB8_ETC2: number;\n\tCOMPRESSED_RGBA8_ETC2_EAC: number;\n\tCOMPRESSED_SRGB8_ETC2: number;\n\tCOMPRESSED_SRGB8_ALPHA8_ETC2_EAC: number;\n\tCOMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: number;\n\tCOMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: number;\n}\n/**\n * WebGL extensions for texture compression using the ETC1 format.\n * @category rendering\n * @advanced\n */\ninterface WEBGL_compressed_texture_etc1$1 {\n\tCOMPRESSED_RGB_ETC1_WEBGL: number;\n}\n/**\n * WebGL extensions for texture compression using the ATC format.\n * @category rendering\n * @advanced\n */\nexport interface WEBGL_compressed_texture_atc {\n\tCOMPRESSED_RGB_ATC_WEBGL: number;\n\tCOMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: number;\n\tCOMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: number;\n}\n/**\n * WebGL extensions for texture compression using the BPTC format.\n * @category rendering\n * @advanced\n */\ninterface EXT_texture_compression_bptc$1 {\n\tCOMPRESSED_RGBA_BPTC_UNORM_EXT: number;\n\tCOMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT: number;\n\tCOMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT: number;\n\tCOMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT: number;\n}\n/**\n * WebGL extensions for texture compression using the RGTC format.\n * @category rendering\n * @advanced\n */\ninterface EXT_texture_compression_rgtc$1 {\n\tCOMPRESSED_RED_RGTC1_EXT: number;\n\tCOMPRESSED_SIGNED_RED_RGTC1_EXT: number;\n\tCOMPRESSED_RED_GREEN_RGTC2_EXT: number;\n\tCOMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: number;\n}\n/**\n * WebGL extensions that are available in the current context.\n * @category rendering\n * @advanced\n */\nexport interface WebGLExtensions {\n\tdrawBuffers?: WEBGL_draw_buffers;\n\tdepthTexture?: OES_texture_float;\n\tloseContext?: WEBGL_lose_context;\n\tvertexArrayObject?: OES_vertex_array_object;\n\tanisotropicFiltering?: EXT_texture_filter_anisotropic;\n\tuint32ElementIndex?: OES_element_index_uint;\n\tfloatTexture?: OES_texture_float;\n\tfloatTextureLinear?: OES_texture_float_linear;\n\ttextureHalfFloat?: OES_texture_half_float;\n\ttextureHalfFloatLinear?: OES_texture_half_float_linear;\n\tcolorBufferFloat?: EXT_color_buffer_float;\n\tvertexAttribDivisorANGLE?: ANGLE_instanced_arrays;\n\ts3tc?: WEBGL_compressed_texture_s3tc;\n\ts3tc_sRGB?: WEBGL_compressed_texture_s3tc_srgb;\n\tetc?: WEBGL_compressed_texture_etc$1;\n\tetc1?: WEBGL_compressed_texture_etc1$1;\n\tpvrtc?: WEBGL_compressed_texture_pvrtc$1;\n\tatc?: WEBGL_compressed_texture_atc;\n\tastc?: WEBGL_compressed_texture_astc;\n\tbptc?: EXT_texture_compression_bptc$1;\n\trgtc?: EXT_texture_compression_rgtc$1;\n\tsrgb?: EXT_sRGB;\n}\n/**\n * Options for the context system.\n * @category rendering\n * @advanced\n * @property {WebGL2RenderingContext | null} [context=null] - User-provided WebGL rendering context object.\n * @property {GpuPowerPreference} [powerPreference='default'] - An optional hint indicating what configuration\n * of GPU is suitable for the WebGL context, can be `'high-performance'` or `'low-power'`. Setting to `'high-performance'`\n * will prioritize rendering performance over power consumption, while setting to `'low-power'` will prioritize power saving\n * over rendering performance.\n * @property {boolean} [premultipliedAlpha=true] - Whether the compositor will assume the drawing buffer contains\n * colors with premultiplied alpha.\n * @property {boolean} [preserveDrawingBuffer=false] - Whether to enable drawing buffer preservation.\n * If enabled, the drawing buffer will preserve\n * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n * @property {boolean} [antialias] - Whether to enable antialiasing.\n * @property {1 | 2} [preferWebGLVersion=2] - The preferred WebGL version to use.\n */\nexport interface ContextSystemOptions {\n\t/**\n\t * User-provided WebGL rendering context object.\n\t * @default null\n\t */\n\tcontext: WebGL2RenderingContext | null;\n\t/**\n\t * An optional hint indicating what configuration of GPU is suitable for the WebGL context,\n\t * can be `'high-performance'` or `'low-power'`.\n\t * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n\t * while setting to `'low-power'` will prioritize power saving over rendering performance.\n\t * @default undefined\n\t */\n\tpowerPreference?: GpuPowerPreference;\n\t/**\n\t * Whether the compositor will assume the drawing buffer contains colors with premultiplied alpha.\n\t * @default true\n\t */\n\tpremultipliedAlpha: boolean;\n\t/**\n\t * Whether to enable drawing buffer preservation. If enabled, the drawing buffer will preserve\n\t * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n\t * @default false\n\t */\n\tpreserveDrawingBuffer: boolean;\n\tantialias?: boolean;\n\t/**\n\t * The preferred WebGL version to use.\n\t * @default 2\n\t */\n\tpreferWebGLVersion?: 1 | 2;\n\t/**\n\t * Whether to enable multi-view rendering. Set to true when rendering to multiple\n\t * canvases on the dom.\n\t * @default false\n\t */\n\tmultiView: boolean;\n}\n/**\n * System plugin to the renderer to manage the context\n * @category rendering\n * @advanced\n */\nexport class GlContextSystem implements System<ContextSystemOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"context\";\n\t};\n\t/** The default options for the system. */\n\tstatic defaultOptions: ContextSystemOptions;\n\tprotected CONTEXT_UID: number;\n\tprotected gl: WebGL2RenderingContext;\n\t/**\n\t * Features supported by current renderer.\n\t * @type {object}\n\t * @readonly\n\t */\n\tsupports: {\n\t\t/** Support for 32-bit indices buffer. */\n\t\tuint32Indices: boolean;\n\t\t/** Support for UniformBufferObjects */\n\t\tuniformBufferObject: boolean;\n\t\t/** Support for VertexArrayObjects */\n\t\tvertexArrayObject: boolean;\n\t\t/** Support for SRGB texture format */\n\t\tsrgbTextures: boolean;\n\t\t/** Support for wrapping modes if a texture is non-power of two */\n\t\tnonPowOf2wrapping: boolean;\n\t\t/** Support for MSAA (antialiasing of dynamic textures) */\n\t\tmsaa: boolean;\n\t\t/** Support for mipmaps if a texture is non-power of two */\n\t\tnonPowOf2mipmaps: boolean;\n\t};\n\t/**\n\t * Extensions available.\n\t * @type {object}\n\t * @readonly\n\t * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension\n\t * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension\n\t * @property {OES_texture_float} floatTexture - WebGL v1 extension\n\t * @property {WEBGL_lose_context} loseContext - WebGL v1 extension\n\t * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension\n\t * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension\n\t */\n\textensions: WebGLExtensions;\n\twebGLVersion: 1 | 2;\n\t/**\n\t * Whether to enable multi-view rendering. Set to true when rendering to multiple\n\t * canvases on the dom.\n\t * @default false\n\t */\n\tmultiView: boolean;\n\t/**\n\t * The canvas that the WebGL Context is rendering to.\n\t * This will be the view canvas. But if multiView is enabled, this canvas will not be attached to the DOM.\n\t * It will be rendered to and then copied to the target canvas.\n\t * @readonly\n\t */\n\tcanvas: ICanvas;\n\tprivate _renderer;\n\tprivate _contextLossForced;\n\t/** @param renderer - The renderer this System works for. */\n\tconstructor(renderer: WebGLRenderer);\n\t/**\n\t * `true` if the context is lost\n\t * @readonly\n\t */\n\tget isLost(): boolean;\n\t/**\n\t * Handles the context change event.\n\t * @param {WebGLRenderingContext} gl - New WebGL context.\n\t */\n\tprotected contextChange(gl: WebGL2RenderingContext): void;\n\tinit(options: ContextSystemOptions): void;\n\tensureCanvasSize(targetCanvas: ICanvas): void;\n\t/**\n\t * Initializes the context.\n\t * @protected\n\t * @param {WebGLRenderingContext} gl - WebGL context\n\t */\n\tprotected initFromContext(gl: WebGL2RenderingContext): void;\n\t/**\n\t * Initialize from context options\n\t * @protected\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n\t * @param preferWebGLVersion\n\t * @param {object} options - context attributes\n\t */\n\tprotected createContext(preferWebGLVersion: 1 | 2, options: WebGLContextAttributes): void;\n\t/** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n\tprotected getExtensions(): void;\n\t/**\n\t * Handles a lost webgl context\n\t * @param {WebGLContextEvent} event - The context lost event.\n\t */\n\tprotected handleContextLost(event: WebGLContextEvent): void;\n\t/** Handles a restored webgl context. */\n\tprotected handleContextRestored(): void;\n\tdestroy(): void;\n\t/**\n\t * this function can be called to force a webGL context loss\n\t * this will release all resources on the GPU.\n\t * Useful if you need to put Pixi to sleep, and save some GPU memory\n\t *\n\t * As soon as render is called - all resources will be created again.\n\t */\n\tforceContextLoss(): void;\n\t/**\n\t * Validate context.\n\t * @param {WebGLRenderingContext} gl - Render context.\n\t */\n\tprotected validateContext(gl: WebGL2RenderingContext): void;\n}\n/**\n * @param format\n * @internal\n */\nexport function getGlTypeFromFormat(format: VertexFormat): number;\n/**\n * The options for the back buffer system.\n * @category rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n * @advanced\n */\nexport interface GlBackBufferOptions {\n\t/**\n\t * if true will use the back buffer where required\n\t * @default false\n\t */\n\tuseBackBuffer?: boolean;\n\t/** if true will ensure the texture is antialiased */\n\tantialias?: boolean;\n}\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it and copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @category rendering\n * @advanced\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"backBuffer\";\n\t\treadonly priority: 1;\n\t};\n\t/** default options for the back buffer system */\n\tstatic defaultOptions: GlBackBufferOptions;\n\t/** if true, the back buffer is used */\n\tuseBackBuffer: boolean;\n\tprivate _backBufferTexture;\n\tprivate readonly _renderer;\n\tprivate _targetTexture;\n\tprivate _useBackBufferThisRender;\n\tprivate _antialias;\n\tprivate _state;\n\tprivate _bigTriangleShader;\n\tconstructor(renderer: WebGLRenderer);\n\tinit(options?: GlBackBufferOptions): void;\n\t/**\n\t * This is called before the RenderTargetSystem is started. This is where\n\t * we replace the target with the back buffer if required.\n\t * @param options - The options for this render.\n\t */\n\tprotected renderStart(options: RenderOptions): void;\n\tprotected renderEnd(): void;\n\tprivate _presentBackBuffer;\n\tprivate _getBackBufferTexture;\n\t/** destroys the back buffer */\n\tdestroy(): void;\n}\n/**\n * The system that handles color masking for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlColorMaskSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"colorMask\";\n\t};\n\tprivate readonly _renderer;\n\tprivate _colorMaskCache;\n\tconstructor(renderer: WebGLRenderer);\n\tsetMask(colorMask: number): void;\n\tdestroy?: () => void;\n}\n/**\n * The system that handles encoding commands for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlEncoderSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"encoder\";\n\t};\n\treadonly commandFinished: Promise<void>;\n\tprivate readonly _renderer;\n\tconstructor(renderer: WebGLRenderer);\n\tsetGeometry(geometry: Geometry, shader?: Shader): void;\n\tfinishRenderPass(): void;\n\tdraw(options: {\n\t\tgeometry: Geometry;\n\t\tshader: Shader;\n\t\tstate?: State;\n\t\ttopology?: Topology;\n\t\tsize?: number;\n\t\tstart?: number;\n\t\tinstanceCount?: number;\n\t\tskipSync?: boolean;\n\t}): void;\n\tdestroy(): void;\n}\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the GL rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGlRenderer();\n * await renderer.init();\n *\n * console.log(renderer.limits.maxTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GlLimitsSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"limits\";\n\t};\n\t/** The maximum number of textures that can be used by a shader */\n\tmaxTextures: number;\n\t/** The maximum number of batchable textures */\n\tmaxBatchableTextures: number;\n\t/** The maximum number of uniform bindings */\n\tmaxUniformBindings: number;\n\tprivate readonly _renderer;\n\tconstructor(renderer: WebGLRenderer);\n\tcontextChange(): void;\n\tdestroy(): void;\n}\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GlStencilSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"stencil\";\n\t};\n\tprivate _gl;\n\tprivate readonly _stencilCache;\n\tprivate _renderTargetStencilState;\n\tprivate _stencilOpsMapping;\n\tprivate _comparisonFuncMapping;\n\tprivate _activeRenderTarget;\n\tconstructor(renderer: WebGLRenderer);\n\tprotected contextChange(gl: WebGLRenderingContext): void;\n\tprotected onRenderTargetChange(renderTarget: RenderTarget): void;\n\tresetState(): void;\n\tsetStencilMode(stencilMode: STENCIL_MODES, stencilReference: number): void;\n\tdestroy?: () => void;\n}\n/**\n * System plugin to the renderer to manage uniform buffers. But with an WGSL adaptor.\n * @category rendering\n * @advanced\n */\nexport class GlUboSystem extends UboSystem {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"ubo\";\n\t};\n\tconstructor();\n}\n/**\n * The precision types available in WebGL shaders.\n *\n * These types define the precision of floating-point calculations in shaders.\n * - `highp`: High precision, typically 32-bit floating-point.\n * - `mediump`: Medium precision, typically 16-bit floating-point.\n * - `lowp`: Low precision, typically 8-bit floating-point.\n * @category rendering\n * @advanced\n */\nexport type PRECISION = `highp` | `mediump` | `lowp`;\n/** @private */\nexport class IGLUniformData {\n\tlocation: WebGLUniformLocation;\n\tvalue: number | boolean | Float32Array | Int32Array | Uint32Array | boolean[];\n}\n/**\n * Helper class to create a WebGL Program\n * @private\n */\nexport class GlProgramData {\n\t/** The shader program. */\n\tprogram: WebGLProgram;\n\t/**\n\t * Holds the uniform data which contains uniform locations\n\t * and current uniform values used for caching and preventing unneeded GPU commands.\n\t */\n\tuniformData: Record<string, any>;\n\t/**\n\t * UniformGroups holds the various upload functions for the shader. Each uniform group\n\t * and program have a unique upload function generated.\n\t */\n\tuniformGroups: Record<string, any>;\n\t/** A hash that stores where UBOs are bound to on the program. */\n\tuniformBlockBindings: Record<string, any>;\n\t/** A hash for lazily-generated uniform uploading functions. */\n\tuniformSync: Record<string, any>;\n\t/**\n\t * A place where dirty ticks are stored for groups\n\t * If a tick here does not match with the Higher level Programs tick, it means\n\t * we should re upload the data.\n\t */\n\tuniformDirtyGroups: Record<string, any>;\n\t/**\n\t * Makes a new Pixi program.\n\t * @param program - webgl program\n\t * @param uniformData - uniforms\n\t */\n\tconstructor(program: WebGLProgram, uniformData: {\n\t\t[key: string]: IGLUniformData;\n\t});\n\t/** Destroys this program. */\n\tdestroy(): void;\n}\n/** @internal */\nexport interface ShaderSyncData {\n\ttextureCount: number;\n\tblockIndex: number;\n}\n/** @internal */\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlShaderSystem {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"shader\";\n\t};\n\t/** @internal */\n\t_activeProgram: GlProgram;\n\tprivate _programDataHash;\n\tprivate readonly _renderer;\n\t/** @internal */\n\t_gl: WebGL2RenderingContext;\n\tprivate _shaderSyncFunctions;\n\tconstructor(renderer: WebGLRenderer);\n\tprotected contextChange(gl: GlRenderingContext): void;\n\t/**\n\t * Changes the current shader to the one given in parameter.\n\t * @param shader - the new shader\n\t * @param skipSync - false if the shader should automatically sync its uniforms.\n\t * @returns the glProgram that belongs to the shader.\n\t */\n\tbind(shader: Shader, skipSync?: boolean): void;\n\t/**\n\t * Updates the uniform group.\n\t * @param uniformGroup - the uniform group to update\n\t */\n\tupdateUniformGroup(uniformGroup: UniformGroup): void;\n\t/**\n\t * Binds a uniform block to the shader.\n\t * @param uniformGroup - the uniform group to bind\n\t * @param name - the name of the uniform block\n\t * @param index - the index of the uniform block\n\t */\n\tbindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index?: number): void;\n\tprivate _setProgram;\n\t/**\n\t * @param program - the program to get the data for\n\t * @internal\n\t */\n\t_getProgramData(program: GlProgram): GlProgramData;\n\tprivate _createProgramData;\n\tdestroy(): void;\n\t/**\n\t * Creates a function that can be executed that will sync the shader as efficiently as possible.\n\t * Overridden by the unsafe eval package if you don't want eval used in your project.\n\t * @param shader - the shader to generate the sync function for\n\t * @param shaderSystem - the shader system to use\n\t * @returns - the generated sync function\n\t * @ignore\n\t */\n\t_generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction;\n\tresetState(): void;\n}\n/**\n * Generates the a function that will efficiently sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n * @internal\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction;\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n * @internal\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number): UniformGroup<any>;\n/**\n * System plugin to the renderer to manage shaders.\n * @category rendering\n * @advanced\n */\nexport class GlUniformGroupSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"uniformGroup\";\n\t};\n\t/**\n\t * The current WebGL rendering context.\n\t * @type {WebGLRenderingContext}\n\t */\n\tprotected gl: GlRenderingContext;\n\t/** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n\tprivate _cache;\n\tprivate _renderer;\n\tprivate _uniformGroupSyncHash;\n\t/** @param renderer - The renderer this System works for. */\n\tconstructor(renderer: WebGLRenderer);\n\tprotected contextChange(gl: GlRenderingContext): void;\n\t/**\n\t * Uploads the uniforms values to the currently bound shader.\n\t * @param group - the uniforms values that be applied to the current shader\n\t * @param program\n\t * @param syncData\n\t * @param syncData.textureCount\n\t */\n\tupdateUniformGroup(group: UniformGroup, program: GlProgram, syncData: {\n\t\ttextureCount: number;\n\t}): void;\n\t/**\n\t * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n\t * @param group\n\t * @param program\n\t */\n\tprivate _getUniformSyncFunction;\n\tprivate _createUniformSyncFunction;\n\tprivate _generateUniformsSync;\n\t/**\n\t * Takes a uniform group and data and generates a unique signature for them.\n\t * @param group - The uniform group to get signature of\n\t * @param group.uniforms\n\t * @param uniformData - Uniform information generated by the shader\n\t * @param preFix\n\t * @returns Unique signature of the uniform group\n\t */\n\tprivate _getSignature;\n\t/** Destroys this System and removes all its textures. */\n\tdestroy(): void;\n}\n/**\n * @param fragmentShader\n * @internal\n */\nexport function migrateFragmentFromV7toV8(fragmentShader: string): string;\n/**\n * @private\n * @param {WebGLRenderingContext} gl - The current WebGL context {WebGLProgram}\n * @param {number} type - the type, can be either VERTEX_SHADER or FRAGMENT_SHADER\n * @param {string} src - The vertex shader source as an array of strings.\n * @returns {WebGLShader} the shader\n */\nexport function compileShader(gl: WebGLRenderingContextBase, type: number, src: string): WebGLShader;\n/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function defaultValue(type: string, size: number): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[];\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in any gaps. We do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of the time users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way,\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n * @internal\n */\nexport function ensureAttributes(geometry: Geometry, extractedData: Record<string, ExtractedAttributeData>): void;\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n * @private\n */\nexport function generateProgram(gl: GlRenderingContext, program: GlProgram): GlProgramData;\n/** @internal */\nexport function getMaxFragmentPrecision(): PRECISION;\n/**\n * returns a little WebGL context to use for program inspection.\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext;\n/**\n * returns the uniform block data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUboData(program: WebGLProgram, gl: WebGL2RenderingContext): Record<string, GlUniformBlockData>;\n/**\n * returns the uniform data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUniformData(program: WebGLProgram, gl: WebGLRenderingContextBase): {\n\t[key: string]: GlUniformData;\n};\n/**\n *\n * logs out any program errors\n * @param gl - The current WebGL context\n * @param program - the WebGL program to display errors for\n * @param vertexShader  - the fragment WebGL shader program\n * @param fragmentShader - the vertex WebGL shader program\n * @private\n */\nexport function logProgramError(gl: WebGLRenderingContext, program: WebGLProgram, vertexShader: WebGLShader, fragmentShader: WebGLShader): void;\n/**\n * @private\n * @param {string} type\n */\nexport function mapSize(type: string): number;\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapType(gl: any, type: number): string;\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapGlToVertexFormat(gl: any, type: number): VertexFormat;\n/**\n * @param src\n * @param isES300\n * @param isFragment\n * @internal\n */\nexport function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean): string;\ninterface EnsurePrecisionOptions {\n\trequestedVertexPrecision: PRECISION;\n\trequestedFragmentPrecision: PRECISION;\n\tmaxSupportedVertexPrecision: PRECISION;\n\tmaxSupportedFragmentPrecision: PRECISION;\n}\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(src: string, options: EnsurePrecisionOptions, isFragment: boolean): string;\n/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function insertVersion(src: string, isES300: boolean): string;\n/**\n * @param src\n * @param root0\n * @param root0.name\n * @param isFragment\n * @internal\n */\nexport function setProgramName(src: string, { name }: {\n\tname: string;\n}, isFragment?: boolean): string;\n/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function stripVersion(src: string, isES300: boolean): string;\n/** @internal */\nexport const WGSL_TO_STD40_SIZE: Record<string, number>;\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout;\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionSTD40(uboElements: UboElement[]): UniformsSyncCallback;\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the std140 layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncSTD40(uboElement: UboElement, offsetToAdd: number): string;\n/**\n * @param group\n * @param uniformData\n * @internal\n */\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback;\n/** @internal */\nexport const UNIFORM_TO_SINGLE_SETTERS: Record<UNIFORM_TYPES | string, string>;\n/** @internal */\nexport const UNIFORM_TO_ARRAY_SETTERS: Record<UNIFORM_TYPES | string, string>;\n/**\n * System plugin to the renderer to manage WebGL state machines\n * @category rendering\n * @advanced\n */\nexport class GlStateSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"state\";\n\t};\n\t/**\n\t * State ID\n\t * @readonly\n\t */\n\tstateId: number;\n\t/**\n\t * Polygon offset\n\t * @readonly\n\t */\n\tpolygonOffset: number;\n\t/**\n\t * Blend mode\n\t * @default 'none'\n\t * @readonly\n\t */\n\tblendMode: BLEND_MODES;\n\t/** Whether current blend equation is different */\n\tprotected _blendEq: boolean;\n\t/**\n\t * GL context\n\t * @type {WebGLRenderingContext}\n\t * @readonly\n\t */\n\tprotected gl: GlRenderingContext;\n\tprotected blendModesMap: Record<BLEND_MODES, number[]>;\n\t/**\n\t * Collection of calls\n\t * @type {Function[]}\n\t */\n\tprotected readonly map: ((value: boolean) => void)[];\n\t/**\n\t * Collection of check calls\n\t * @type {Function[]}\n\t */\n\tprotected readonly checks: ((system: this, state: State) => void)[];\n\t/**\n\t * Default WebGL State\n\t * @readonly\n\t */\n\tprotected defaultState: State;\n\t/**\n\t * Whether to invert the front face when rendering\n\t * This is used for render textures where the Y-coordinate is flipped\n\t * @default false\n\t */\n\tprivate _invertFrontFace;\n\tprivate _glFrontFace;\n\tprivate _cullFace;\n\tprivate _frontFaceDirty;\n\tprivate _frontFace;\n\tconstructor(renderer: WebGLRenderer);\n\tprotected onRenderTargetChange(renderTarget: RenderTarget): void;\n\tprotected contextChange(gl: GlRenderingContext): void;\n\t/**\n\t * Sets the current state\n\t * @param {*} state - The state to set.\n\t */\n\tset(state: State): void;\n\t/**\n\t * Sets the state, when previous state is unknown.\n\t * @param {*} state - The state to set\n\t */\n\tforceState(state: State): void;\n\t/**\n\t * Sets whether to enable or disable blending.\n\t * @param value - Turn on or off WebGl blending.\n\t */\n\tsetBlend(value: boolean): void;\n\t/**\n\t * Sets whether to enable or disable polygon offset fill.\n\t * @param value - Turn on or off webgl polygon offset testing.\n\t */\n\tsetOffset(value: boolean): void;\n\t/**\n\t * Sets whether to enable or disable depth test.\n\t * @param value - Turn on or off webgl depth testing.\n\t */\n\tsetDepthTest(value: boolean): void;\n\t/**\n\t * Sets whether to enable or disable depth mask.\n\t * @param value - Turn on or off webgl depth mask.\n\t */\n\tsetDepthMask(value: boolean): void;\n\t/**\n\t * Sets whether to enable or disable cull face.\n\t * @param {boolean} value - Turn on or off webgl cull face.\n\t */\n\tsetCullFace(value: boolean): void;\n\t/**\n\t * Sets the gl front face.\n\t * @param {boolean} value - true is clockwise and false is counter-clockwise\n\t */\n\tsetFrontFace(value: boolean): void;\n\t/**\n\t * Sets the blend mode.\n\t * @param {number} value - The blend mode to set to.\n\t */\n\tsetBlendMode(value: BLEND_MODES): void;\n\t/**\n\t * Sets the polygon offset.\n\t * @param {number} value - the polygon offset\n\t * @param {number} scale - the polygon offset scale\n\t */\n\tsetPolygonOffset(value: number, scale: number): void;\n\t/** Resets all the logic and disables the VAOs. */\n\tresetState(): void;\n\t/**\n\t * Checks to see which updates should be checked based on which settings have been activated.\n\t *\n\t * For example, if blend is enabled then we should check the blend modes each time the state is changed\n\t * or if polygon fill is activated then we need to check if the polygon offset changes.\n\t * The idea is that we only check what we have too.\n\t * @param func - the checking function to add or remove\n\t * @param value - should the check function be added or removed.\n\t */\n\tprivate _updateCheck;\n\t/**\n\t * A private little wrapper function that we call to check the blend mode.\n\t * @param system - the System to perform the state check on\n\t * @param state - the state that the blendMode will pulled from\n\t */\n\tprivate static _checkBlendMode;\n\t/**\n\t * A private little wrapper function that we call to check the polygon offset.\n\t * @param system - the System to perform the state check on\n\t * @param state - the state that the blendMode will pulled from\n\t */\n\tprivate static _checkPolygonOffset;\n\t/** @ignore */\n\tdestroy(): void;\n}\n/**\n * Maps gl blend combinations to WebGL.\n * @param gl\n * @returns {object} Map of gl blend combinations to WebGL.\n * @internal\n */\nexport function mapWebGLBlendModesToPixi(gl: GlRenderingContext): Record<BLEND_MODES, number[]>;\n/**\n * The system for managing textures in WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlTextureSystem implements System, CanvasGenerator {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"texture\";\n\t};\n\tprivate readonly _renderer;\n\tprivate readonly _managedTextures;\n\t/**\n\t * @deprecated since 8.15.0\n\t */\n\tget managedTextures(): Readonly<TextureSource[]>;\n\tprivate _glSamplers;\n\tprivate _boundTextures;\n\tprivate _activeTextureLocation;\n\tprivate _boundSamplers;\n\tprivate readonly _uploads;\n\tprivate _gl;\n\tprivate _mapFormatToInternalFormat;\n\tprivate _mapFormatToType;\n\tprivate _mapFormatToFormat;\n\tprivate _premultiplyAlpha;\n\tprivate readonly _useSeparateSamplers;\n\tconstructor(renderer: WebGLRenderer);\n\tprotected contextChange(gl: GlRenderingContext): void;\n\t/**\n\t * Initializes a texture source, if it has already been initialized nothing will happen.\n\t * @param source - The texture source to initialize.\n\t * @returns The initialized texture source.\n\t */\n\tinitSource(source: TextureSource): void;\n\tbind(texture: BindableTexture, location?: number): void;\n\tbindSource(source: TextureSource, location?: number): void;\n\tprivate _bindSampler;\n\tunbind(texture: BindableTexture): void;\n\tprivate _activateLocation;\n\tprivate _initSource;\n\tprotected onStyleChange(source: TextureSource): void;\n\tprotected updateStyle(source: TextureSource, firstCreation: boolean): void;\n\tprotected onSourceUnload(source: TextureSource, contextLost?: boolean): void;\n\tprotected onSourceUpdate(source: TextureSource): void;\n\tprotected onUpdateMipmaps(source: TextureSource, bind?: boolean): void;\n\tprivate _initSampler;\n\tprivate _getGlSampler;\n\tgetGlSource(source: TextureSource): GlTexture;\n\tgenerateCanvas(texture: Texture): ICanvas;\n\tgetPixels(texture: Texture): GetPixelsOutput;\n\tdestroy(): void;\n\tresetState(): void;\n}\n/** @internal */\nexport interface GLTextureUploader {\n\tid: string;\n\tupload(source: TextureSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number): void;\n}\n/** @internal */\nexport const glUploadBufferImageResource: GLTextureUploader;\n/** @internal */\nexport const glUploadCompressedTextureResource: GLTextureUploader;\n/** @internal */\nexport const glUploadImageResource: GLTextureUploader;\n/** @internal */\nexport const glUploadVideoResource: GLTextureUploader;\n/**\n * @param style\n * @param gl\n * @param mipmaps\n * @param anisotropicExt\n * @param glFunctionName\n * @param firstParam\n * @param forceClamp\n * @param firstCreation\n * @internal\n */\nexport function applyStyleParams(style: TextureStyle, gl: WebGL2RenderingContext, mipmaps: boolean, anisotropicExt: EXT_texture_filter_anisotropic, glFunctionName: \"samplerParameteri\" | \"texParameteri\", firstParam: 3553 | WebGLSampler, forceClamp: boolean, \n/** if true we can skip setting certain values if the values is the same as the default gl values */\nfirstCreation: boolean): void;\n/** @internal */\nexport function getSupportedGlCompressedTextureFormats(): TEXTURE_FORMATS[];\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlFormat(gl: GlRenderingContext): Record<string, number>;\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param gl - The rendering context.\n * @param extensions - The WebGL extensions.\n * @returns Lookup table.\n */\nexport function mapFormatToGlInternalFormat(gl: GlRenderingContext, extensions: WebGLExtensions): Record<string, number>;\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlType(gl: GlRenderingContext): Record<string, number>;\n/** @internal */\nexport const scaleModeToGlFilter: {\n\tlinear: number;\n\tnearest: number;\n};\n/** @internal */\nexport const mipmapScaleModeToGlFilter: {\n\tlinear: {\n\t\tlinear: number;\n\t\tnearest: number;\n\t};\n\tnearest: {\n\t\tlinear: number;\n\t\tnearest: number;\n\t};\n};\n/** @internal */\nexport const wrapModeToGlAddress: {\n\t\"clamp-to-edge\": number;\n\trepeat: number;\n\t\"mirror-repeat\": number;\n};\n/** @internal */\nexport const compareModeToGlCompare: {\n\tnever: number;\n\tless: number;\n\tequal: number;\n\t\"less-equal\": number;\n\tgreater: number;\n\t\"not-equal\": number;\n\t\"greater-equal\": number;\n\talways: number;\n};\n/**\n * @param pixels\n * @internal\n */\nexport function unpremultiplyAlpha(pixels: Uint8Array | Uint8ClampedArray): void;\n/** @internal */\nexport class UboBatch {\n\tdata: Float32Array;\n\tprivate readonly _minUniformOffsetAlignment;\n\tbyteIndex: number;\n\tconstructor({ minUniformOffsetAlignment }: {\n\t\tminUniformOffsetAlignment: number;\n\t});\n\tclear(): void;\n\taddEmptyGroup(size: number): number;\n\taddGroup(array: Float32Array): number;\n\tdestroy(): void;\n}\n/**\n * @param pm\n * @param x\n * @param y\n * @param width\n * @param height\n * @param flipY\n * @internal\n */\nexport function calculateProjection(pm: Matrix, x: number, y: number, width: number, height: number, flipY: boolean): Matrix;\n/** @internal */\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {\n\talign: number;\n\tsize: number;\n}>;\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout;\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionWGSL(uboElements: UboElement[]): UniformsSyncCallback;\n/**\n * @param root0\n * @param root0.source\n * @param root0.entryPoint\n * @internal\n */\nexport function extractAttributesFromGpuProgram({ source, entryPoint }: ProgramSource): Record<string, ExtractedAttributeData>;\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string;\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription;\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout;\n/**\n * @param vertexStructsAndGroups\n * @param fragmentStructsAndGroups\n * @internal\n */\nexport function removeStructAndGroupDuplicates(vertexStructsAndGroups: StructsAndGroups, fragmentStructsAndGroups: StructsAndGroups): {\n\tstructs: {\n\t\tname: string;\n\t\tmembers: Record<string, string>;\n\t}[];\n\tgroups: {\n\t\tgroup: number;\n\t\tbinding: number;\n\t\tname: string;\n\t\tisUniform: boolean;\n\t\ttype: string;\n\t}[];\n};\n/** @internal */\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>>;\n/**\n * The stencil state for the GPU renderer.\n * This is used to define how the stencil buffer should be configured.\n * @category rendering\n * @advanced\n */\nexport interface StencilState {\n\tstencilWriteMask?: number;\n\tstencilReadMask?: number;\n\tstencilFront?: {\n\t\tcompare: \"always\" | \"equal\" | \"not-equal\";\n\t\tpassOp: \"increment-clamp\" | \"decrement-clamp\" | \"keep\" | \"replace\";\n\t};\n\tstencilBack?: {\n\t\tcompare: \"always\" | \"equal\" | \"not-equal\";\n\t\tpassOp: \"increment-clamp\" | \"decrement-clamp\" | \"keep\" | \"replace\";\n\t};\n}\n/** @internal */\nexport const GpuStencilModesToPixi: StencilState[];\n/** @internal */\nexport interface GpuTextureUploader<T extends TextureSource = TextureSource> {\n\ttype: string;\n\tupload(source: T, gpuTexture: GPUTexture, gpu: GPU$1): void;\n}\n/** @internal */\nexport const gpuUploadBufferImageResource: GpuTextureUploader<BufferImageSource>;\n/**\n * A texture source that uses a compressed resource, such as an array of Uint8Arrays.\n * It is used for compressed textures that can be uploaded to the GPU.\n * @category rendering\n * @advanced\n */\nexport class CompressedSource extends TextureSource<Uint8Array[]> {\n\treadonly uploadMethodId = \"compressed\";\n\tconstructor(options: TextureSourceOptions);\n}\n/** @internal */\nexport const blockDataMap: Record<string, {\n\tblockBytes: number;\n\tblockWidth: number;\n\tblockHeight: number;\n}>;\n/** @internal */\nexport const gpuUploadCompressedTextureResource: GpuTextureUploader<CompressedSource>;\n/** @internal */\nexport const gpuUploadImageResource: GpuTextureUploader<TextureSource<any>>;\n/**\n * A utility type that represents a tuple of length L containing elements of type T.\n * @category utils\n * @advanced\n */\nexport type ArrayFixed<T, L extends number> = [\n\tT,\n\t...Array<T>\n] & {\n\tlength: L;\n};\n/**\n * A dictionary type that maps string keys to values of type T.\n * @category utils\n * @advanced\n */\nexport type Dict<T> = {\n\t[key: string]: T;\n};\n/**\n * The type of resource used for video textures.\n * This is typically an HTMLVideoElement.\n * @category rendering\n * @advanced\n */\nexport type VideoResource = HTMLVideoElement;\n/**\n * Options for video sources.\n * @category rendering\n * @advanced\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource> {\n\t/** If true, the video will start loading immediately. */\n\tautoLoad?: boolean;\n\t/** If true, the video will start playing as soon as it is loaded. */\n\tautoPlay?: boolean;\n\t/** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n\tupdateFPS?: number;\n\t/** If true, the video will be loaded with the `crossorigin` attribute. */\n\tcrossorigin?: boolean | string;\n\t/** If true, the video will loop when it ends. */\n\tloop?: boolean;\n\t/** If true, the video will be muted. */\n\tmuted?: boolean;\n\t/** If true, the video will play inline. */\n\tplaysinline?: boolean;\n\t/** If true, the video will be preloaded. */\n\tpreload?: boolean;\n\t/** The time in milliseconds to wait for the video to preload before timing out. */\n\tpreloadTimeoutMs?: number;\n\t/** The alpha mode of the video. */\n\talphaMode?: ALPHA_MODES;\n}\n/**\n * A texture source that uses a video as its resource.\n * It automatically resizes the texture based on the video dimensions.\n * It also provides methods to control playback and handle video events.\n * This class supports automatic loading, playback, and frame updates.\n * It can also handle cross-origin videos and provides options for looping, muting, and inline playback.\n * @category rendering\n * @advanced\n */\nexport class VideoSource extends TextureSource<VideoResource> {\n\tstatic extension: ExtensionMetadata;\n\t/** The default options for video sources. */\n\tstatic defaultOptions: VideoSourceOptions;\n\t/** Whether or not the video is ready to play. */\n\tisReady: boolean;\n\t/** The upload method for this texture. */\n\tuploadMethodId: string;\n\t/**\n\t * When set to true will automatically play videos used by this texture once\n\t * they are loaded. If false, it will not modify the playing state.\n\t * @default true\n\t */\n\tprotected autoPlay: boolean;\n\t/**\n\t * `true` to use Ticker.shared to auto update the base texture.\n\t * @default true\n\t */\n\tprivate _autoUpdate;\n\t/**\n\t * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n\t * @default false\n\t */\n\tprivate _isConnectedToTicker;\n\t/**\n\t * Promise when loading.\n\t * @default null\n\t */\n\tprivate _load;\n\tprivate _msToNextUpdate;\n\tprivate _preloadTimeout;\n\t/** Callback when completed with load. */\n\tprivate _resolve;\n\tprivate _reject;\n\tprivate _updateFPS;\n\tprivate _videoFrameRequestCallbackHandle;\n\tconstructor(options: VideoSourceOptions);\n\t/** Update the video frame if the source is not destroyed and meets certain conditions. */\n\tprotected updateFrame(): void;\n\t/** Callback to update the video frame and potentially request the next frame update. */\n\tprivate _videoFrameRequestCallback;\n\t/**\n\t * Checks if the resource has valid dimensions.\n\t * @returns {boolean} True if width and height are set, otherwise false.\n\t */\n\tget isValid(): boolean;\n\t/**\n\t * Start preloading the video resource.\n\t * @returns {Promise<this>} Handle the validate event\n\t */\n\tload(): Promise<this>;\n\t/**\n\t * Handle video error events.\n\t * @param event - The error event\n\t */\n\tprivate _onError;\n\t/**\n\t * Checks if the underlying source is playing.\n\t * @returns True if playing.\n\t */\n\tprivate _isSourcePlaying;\n\t/**\n\t * Checks if the underlying source is ready for playing.\n\t * @returns True if ready.\n\t */\n\tprivate _isSourceReady;\n\t/** Runs the update loop when the video is ready to play. */\n\tprivate _onPlayStart;\n\t/** Stops the update loop when a pause event is triggered. */\n\tprivate _onPlayStop;\n\t/** Handles behavior when the video completes seeking to the current playback position. */\n\tprivate _onSeeked;\n\tprivate _onCanPlay;\n\tprivate _onCanPlayThrough;\n\t/** Fired when the video is loaded and ready to play. */\n\tprivate _mediaReady;\n\t/** Cleans up resources and event listeners associated with this texture. */\n\tdestroy(): void;\n\t/** Should the base texture automatically update itself, set to true by default. */\n\tget autoUpdate(): boolean;\n\tset autoUpdate(value: boolean);\n\t/**\n\t * How many times a second to update the texture from the video.\n\t * Leave at 0 to update at every render.\n\t * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n\t */\n\tget updateFPS(): number;\n\tset updateFPS(value: number);\n\t/**\n\t * Configures the updating mechanism based on the current state and settings.\n\t *\n\t * This method decides between using the browser's native video frame callback or a custom ticker\n\t * for updating the video frame. It ensures optimal performance and responsiveness\n\t * based on the video's state, playback status, and the desired frames-per-second setting.\n\t *\n\t * - If `_autoUpdate` is enabled and the video source is playing:\n\t *   - It will prefer the native video frame callback if available and no specific FPS is set.\n\t *   - Otherwise, it will use a custom ticker for manual updates.\n\t * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n\t */\n\tprivate _configureAutoUpdate;\n\t/**\n\t * Map of video MIME types that can't be directly derived from file extensions.\n\t * @readonly\n\t */\n\tstatic MIME_TYPES: Dict<string>;\n\tstatic test(resource: any): resource is VideoResource;\n}\n/** @internal */\nexport const gpuUploadVideoResource: GpuTextureUploader<VideoSource>;\n/** @internal */\nexport function getSupportedGPUCompressedTextureFormats(): Promise<TEXTURE_FORMATS[]>;\n/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @category rendering\n * @ignore\n */\nexport class GpuMipmapGenerator {\n\tdevice: GPUDevice;\n\tsampler: GPUSampler;\n\tpipelines: Record<string, GPURenderPipeline>;\n\tmipmapShaderModule: any;\n\tconstructor(device: GPUDevice);\n\tprivate _getMipmapPipeline;\n\t/**\n\t * Generates mipmaps for the given GPUTexture from the data in level 0.\n\t * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n\t * @returns {module:External.GPUTexture} - The originally passed texture\n\t */\n\tgenerateMipmap(texture: GPUTexture): GPUTexture;\n}\n/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void;\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @internal\n */\nexport function buildUvs(vertices: number[], verticesStride: number, verticesOffset: number, uvs: number[], uvsOffset: number, uvsStride: number, size: number, matrix?: Matrix): void;\n/**\n * @param uvs\n * @param uvsOffset\n * @param uvsStride\n * @param size\n * @internal\n */\nexport function buildSimpleUvs(uvs: number[], uvsOffset: number, uvsStride: number, size: number): void;\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @category rendering\n * @internal\n */\nexport function ensureIsBuffer(buffer: Buffer$1 | TypedArray | number[], index: boolean): Buffer$1;\n/**\n * @param format\n * @internal\n */\nexport function getAttributeInfoFromFormat(format: VertexFormat): {\n\tsize: number;\n\tstride: number;\n\tnormalised: boolean;\n};\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n * @internal\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds;\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @category rendering\n * @internal\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number): void;\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n * @internal\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean;\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @category rendering\n * @advanced\n */\nexport class SchedulerSystem implements System<null> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"scheduler\";\n\t\treadonly priority: 0;\n\t};\n\tprivate readonly _tasks;\n\t/** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n\tprivate _offset;\n\t/** Initializes the scheduler system and starts the ticker. */\n\tinit(): void;\n\t/**\n\t * Schedules a repeating task.\n\t * @param func - The function to execute.\n\t * @param duration - The interval duration in milliseconds.\n\t * @param useOffset - this will spread out tasks so that they do not all run at the same time\n\t * @returns The unique identifier for the scheduled task.\n\t */\n\trepeat(func: (elapsed: number) => void, duration: number, useOffset?: boolean): number;\n\t/**\n\t * Cancels a scheduled task.\n\t * @param id - The unique identifier of the task to cancel.\n\t */\n\tcancel(id: number): void;\n\t/**\n\t * Updates and executes the scheduled tasks.\n\t * @private\n\t */\n\tprivate _update;\n\t/**\n\t * Destroys the scheduler system and removes all tasks.\n\t * @internal\n\t */\n\tdestroy(): void;\n}\n/** @internal */\nexport enum ShaderStage {\n\tVERTEX = 1,\n\tFRAGMENT = 2,\n\tCOMPUTE = 4\n}\n/**\n * System plugin to the renderer to manage the shaders.\n * @category rendering\n * @advanced\n */\nexport interface ShaderSystem extends System {\n\t/** the maximum number of textures that can be bound to a shader */\n\treadonly maxTextures: number;\n}\n/**\n * @param uboElements\n * @param parserCode\n * @param arrayGenerationFunction\n * @param singleSettersMap\n * @internal\n */\nexport function createUboSyncFunction(uboElements: UboElement[], parserCode: \"uboWgsl\" | \"uboStd40\", arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string, singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>): UniformsSyncCallback;\n/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(type: string, size: number): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[];\n/** @internal */\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string>;\n/** @internal */\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string>;\ninterface UniformParserDefinition {\n\ttype: UNIFORM_TYPES;\n\ttest(data: UniformData): boolean;\n\tubo?: string;\n\tuboWgsl?: string;\n\tuboStd40?: string;\n\tuniform?: string;\n}\n/** @internal */\nexport const uniformParsers: UniformParserDefinition[];\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @category rendering\n * @advanced\n */\nexport interface HelloSystemOptions {\n\t/**\n\t * Whether to log the version and type information of renderer to console.\n\t * @default false\n\t */\n\thello: boolean;\n}\n/**\n * A simple system responsible for initiating the renderer.\n * @category rendering\n * @advanced\n */\nexport class HelloSystem implements System<HelloSystemOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"hello\";\n\t\treadonly priority: -2;\n\t};\n\t/** The default options for the system. */\n\tstatic defaultOptions: HelloSystemOptions;\n\tprivate readonly _renderer;\n\tconstructor(renderer: Renderer);\n\t/**\n\t * It all starts here! This initiates every system, passing in the options for any system by name.\n\t * @param options - the config for the renderer and all its systems\n\t */\n\tinit(options: HelloSystemOptions): void;\n}\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n * @internal\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES;\ninterface System$1 {\n\textension: {\n\t\tname: string;\n\t};\n\tdefaultOptions?: any;\n\tnew (...args: any): any;\n}\ntype SystemsWithExtensionList = System$1[];\ntype InstanceType$1<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;\ntype NameType<T extends SystemsWithExtensionList> = T[number][\"extension\"][\"name\"];\n/**\n * Create a mapped type where each property key is a 'name' value,\n * and each property value is an ElementType with a matching 'name'\n * @internal\n */\nexport type ExtractSystemTypes<T extends SystemsWithExtensionList> = {\n\t[K in NameType<T>]: InstanceType$1<Extract<T[number], {\n\t\textension: {\n\t\t\tname: K;\n\t\t};\n\t}>>;\n};\ntype NotUnknown<T> = T extends unknown ? keyof T extends never ? never : T : T;\ntype KnownProperties<T> = {\n\t[K in keyof T as NotUnknown<T[K]> extends never ? never : K]: T[K];\n};\ntype FlattenOptions<T> = T extends {\n\t[K: string]: infer U;\n} ? U : never;\ntype OptionsUnion<T extends SystemsWithExtensionList> = FlattenOptions<SeparateOptions<T>>;\ntype DefaultOptionsTypes<T extends SystemsWithExtensionList> = {\n\t[K in NameType<T>]: Extract<T[number], {\n\t\textension: {\n\t\t\tname: K;\n\t\t};\n\t}>[\"defaultOptions\"];\n};\ntype SeparateOptions<T extends SystemsWithExtensionList> = KnownProperties<DefaultOptionsTypes<T>>;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n/** @internal */\nexport type ExtractRendererOptions<T extends SystemsWithExtensionList> = UnionToIntersection<OptionsUnion<T>>;\n/**\n * A utility type that represents a canvas and its rendering context.\n * @category rendering\n * @internal\n */\nexport interface CanvasAndContext {\n\t/** The canvas element. */\n\tcanvas: ICanvas;\n\t/** The rendering context of the canvas. */\n\tcontext: ICanvasRenderingContext2D;\n}\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport class CanvasPoolClass {\n\tcanvasOptions: ICanvasRenderingContext2DSettings;\n\t/**\n\t * Allow renderTextures of the same size as screen, not just pow2\n\t *\n\t * Automatically sets to true after `setScreenSize`\n\t * @default false\n\t */\n\tenableFullScreen: boolean;\n\tprivate _canvasPool;\n\tconstructor(canvasOptions?: ICanvasRenderingContext2DSettings);\n\t/**\n\t * Creates texture with params that were specified in pool constructor.\n\t * @param pixelWidth - Width of texture in pixels.\n\t * @param pixelHeight - Height of texture in pixels.\n\t */\n\tprivate _createCanvasAndContext;\n\t/**\n\t * Gets a Power-of-Two render texture or fullScreen texture\n\t * @param minWidth - The minimum width of the render texture.\n\t * @param minHeight - The minimum height of the render texture.\n\t * @param resolution - The resolution of the render texture.\n\t * @returns The new render texture.\n\t */\n\tgetOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution?: number): CanvasAndContext;\n\t/**\n\t * Place a render texture back into the pool.\n\t * @param canvasAndContext\n\t */\n\treturnCanvasAndContext(canvasAndContext: CanvasAndContext): void;\n\tclear(): void;\n}\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport const CanvasPool: CanvasPoolClass;\n/**\n * Options for the {@link RenderableGCSystem}.\n * @category rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n * @advanced\n */\nexport interface RenderableGCSystemOptions {\n\t/**\n\t * If set to true, this will enable the garbage collector on the GPU.\n\t * @default true\n\t */\n\trenderableGCActive: boolean;\n\t/**\n\t * The maximum idle frames before a texture is destroyed by garbage collection.\n\t * @default 60 * 60\n\t */\n\trenderableGCMaxUnusedTime: number;\n\t/**\n\t * Frames between two garbage collections.\n\t * @default 600\n\t */\n\trenderableGCFrequency: number;\n}\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n * @example\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions> {\n\t/**\n\t * Extension metadata for registering this system with the renderer.\n\t * @ignore\n\t */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"renderableGC\";\n\t\treadonly priority: 0;\n\t};\n\t/**\n\t * Default configuration options for the garbage collection system.\n\t * These can be overridden when initializing the renderer.\n\t */\n\tstatic defaultOptions: RenderableGCSystemOptions;\n\t/** Maximum time in ms a resource can be unused before being garbage collected */\n\tmaxUnusedTime: number;\n\t/** Reference to the renderer this system belongs to */\n\tprivate _renderer;\n\t/** Array of renderables being tracked for garbage collection */\n\tprivate readonly _managedRenderables;\n\t/** ID of the main GC scheduler handler */\n\tprivate _handler;\n\t/** How frequently GC runs in ms */\n\tprivate _frequency;\n\t/** Current timestamp used for age calculations */\n\tprivate _now;\n\t/** Array of hash objects being tracked for cleanup */\n\tprivate readonly _managedHashes;\n\t/** ID of the hash cleanup scheduler handler */\n\tprivate _hashHandler;\n\t/** Array of arrays being tracked for cleanup */\n\tprivate readonly _managedArrays;\n\t/** ID of the array cleanup scheduler handler */\n\tprivate _arrayHandler;\n\t/**\n\t * Creates a new RenderableGCSystem instance.\n\t * @param renderer - The renderer this garbage collection system works for\n\t */\n\tconstructor(renderer: Renderer);\n\t/**\n\t * Initializes the garbage collection system with the provided options.\n\t * @param options - Configuration options for the renderer\n\t */\n\tinit(options: RenderableGCSystemOptions): void;\n\t/**\n\t * Gets whether the garbage collection system is currently enabled.\n\t * @returns True if GC is enabled, false otherwise\n\t */\n\tget enabled(): boolean;\n\t/**\n\t * Enables or disables the garbage collection system.\n\t * When enabled, schedules periodic cleanup of resources.\n\t * When disabled, cancels all scheduled cleanups.\n\t */\n\tset enabled(value: boolean);\n\t/**\n\t * Adds a hash table to be managed by the garbage collector.\n\t * @param context - The object containing the hash table\n\t * @param hash - The property name of the hash table\n\t */\n\taddManagedHash<T>(context: T, hash: string): void;\n\t/**\n\t * Adds an array to be managed by the garbage collector.\n\t * @param context - The object containing the array\n\t * @param hash - The property name of the array\n\t */\n\taddManagedArray<T>(context: T, hash: string): void;\n\t/**\n\t * Updates the GC timestamp and tracking before rendering.\n\t * @param options - The render options\n\t * @param options.container - The container to render\n\t */\n\tprerender({ container }: RenderOptions): void;\n\t/**\n\t * Starts tracking a renderable for garbage collection.\n\t * @param renderable - The renderable to track\n\t */\n\taddRenderable(renderable: Renderable): void;\n\t/**\n\t * Performs garbage collection by cleaning up unused renderables.\n\t * Removes renderables that haven't been used for longer than maxUnusedTime.\n\t */\n\trun(): void;\n\t/** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n\tdestroy(): void;\n\t/**\n\t * Removes a renderable from being tracked when it's destroyed.\n\t * @param renderable - The renderable to stop tracking\n\t */\n\tprivate _removeRenderable;\n\t/**\n\t * Updates the GC tick counter for a render group and its children.\n\t * @param renderGroup - The render group to update\n\t * @param gcTick - The new tick value\n\t */\n\tprivate _updateInstructionGCTick;\n}\n/**\n * Options for creating a CanvasSource.\n * @category rendering\n * @advanced\n */\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas> {\n\t/**\n\t * Should the canvas be resized to preserve its screen width and height regardless\n\t * of the resolution of the renderer, this is only supported for HTMLCanvasElement\n\t * and will be ignored if the canvas is an OffscreenCanvas.\n\t */\n\tautoDensity?: boolean;\n\t/** if true, this canvas will be set up to be transparent where possible */\n\ttransparent?: boolean;\n}\n/**\n * A texture source that uses a canvas as its resource.\n * It automatically resizes the canvas based on the width, height, and resolution.\n * It also provides a 2D rendering context for drawing.\n * @category rendering\n * @advanced\n */\nexport class CanvasSource extends TextureSource<ICanvas> {\n\tstatic extension: ExtensionMetadata;\n\tuploadMethodId: string;\n\tautoDensity: boolean;\n\ttransparent: boolean;\n\tprivate _context2D;\n\tconstructor(options: CanvasSourceOptions);\n\tresizeCanvas(): void;\n\tresize(width?: number, height?: number, resolution?: number): boolean;\n\tstatic test(resource: any): resource is ICanvas;\n\t/**\n\t * Returns the 2D rendering context for the canvas.\n\t * Caches the context after creating it.\n\t * @returns The 2D rendering context of the canvas.\n\t */\n\tget context2D(): CanvasRenderingContext2D;\n}\n/**\n * The type of image-like resource that can be used as a texture source.\n *\n * - `ImageBitmap` is used for bitmap images.\n * - `HTMLCanvasElement` and `OffscreenCanvas` are used for canvas elements.\n * - `ICanvas` is an interface for canvas-like objects.\n * - `VideoFrame` is used for video frames.\n * - `HTMLImageElement` is used for HTML image elements.\n * - `HTMLVideoElement` is used for HTML video elements.\n * @category rendering\n * @advanced\n */\nexport type ImageResource = ImageBitmap | HTMLCanvasElement | OffscreenCanvas | ICanvas | VideoFrame | HTMLImageElement | HTMLVideoElement;\n/**\n * A texture source that uses an image-like resource as its resource.\n * It can handle HTMLImageElement, ImageBitmap, VideoFrame, and HTMLVideoElement.\n * It is used for textures that can be uploaded to the GPU.\n * @category rendering\n * @advanced\n */\nexport class ImageSource extends TextureSource<ImageResource> {\n\tstatic extension: ExtensionMetadata;\n\tuploadMethodId: string;\n\tconstructor(options: TextureSourceOptions<ImageResource>);\n\tstatic test(resource: any): resource is ImageResource;\n}\n/**\n * Options for the {@link TextureGCSystem}.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport interface TextureGCSystemOptions {\n\t/**\n\t * If set to true, this will enable the garbage collector on the GPU.\n\t * @default true\n\t * @deprecated since 8.15.0\n\t */\n\ttextureGCActive: boolean;\n\t/**\n\t * @deprecated since 8.3.0\n\t * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n\t */\n\ttextureGCAMaxIdle: number;\n\t/**\n\t * The maximum idle frames before a texture is destroyed by garbage collection.\n\t * @default 60 * 60\n\t * @deprecated since 8.15.0\n\t */\n\ttextureGCMaxIdle: number;\n\t/**\n\t * Frames between two garbage collections.\n\t * @default 600\n\t * @deprecated since 8.15.0\n\t */\n\ttextureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"textureGC\";\n\t};\n\t/**\n\t * Default options for the TextureGCSystem\n\t * @deprecated since 8.15.0\n\t */\n\tstatic defaultOptions: TextureGCSystemOptions;\n\t/**\n\t * Frame count since started.\n\t * @readonly\n\t * @deprecated since 8.15.0\n\t */\n\tget count(): number;\n\t/**\n\t * Frame count since last garbage collection.\n\t * @readonly\n\t * @deprecated since 8.15.0\n\t */\n\tget checkCount(): number;\n\tset checkCount(value: number);\n\tprivate _checkCount;\n\t/**\n\t * Maximum idle frames before a texture is destroyed by garbage collection.\n\t * @see TextureGCSystem.defaultMaxIdle\n\t * @deprecated since 8.15.0\n\t */\n\tget maxIdle(): number;\n\tset maxIdle(value: number);\n\t/**\n\t * Frames between two garbage collections.\n\t * @see TextureGCSystem.defaultCheckCountMax\n\t * @deprecated since 8.15.0\n\t */\n\tget checkCountMax(): number;\n\tset checkCountMax(_value: number);\n\t/**\n\t * Current garbage collection mode.\n\t * @see TextureGCSystem.defaultMode\n\t * @deprecated since 8.15.0\n\t */\n\tget active(): boolean;\n\tset active(value: boolean);\n\tprivate _renderer;\n\t/** @param renderer - The renderer this System works for. */\n\tconstructor(renderer: Renderer);\n\tinit(options: TextureGCSystemOptions): void;\n\t/**\n\t * Checks to see when the last time a texture was used.\n\t * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n\t * @deprecated since 8.15.0\n\t */\n\trun(): void;\n\tdestroy(): void;\n}\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @category rendering\n * @advanced\n */\nexport class TextureMatrix {\n\t/**\n\t * Matrix operation that converts texture region coords to texture coords\n\t * @readonly\n\t */\n\tmapCoord: Matrix;\n\t/**\n\t * Changes frame clamping\n\t * Works with TilingSprite and Mesh\n\t * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n\t * @default 0\n\t */\n\tclampOffset: number;\n\t/**\n\t * Changes frame clamping\n\t * Works with TilingSprite and Mesh\n\t * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n\t * @default 0.5\n\t */\n\tclampMargin: number;\n\t/**\n\t * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n\t * Calculated based on clampOffset.\n\t */\n\treadonly uClampFrame: Float32Array;\n\t/** Normalized clamp offset. Calculated based on clampOffset. */\n\treadonly uClampOffset: Float32Array;\n\t/**\n\t * Tracks Texture frame changes.\n\t * @ignore\n\t */\n\t_updateID: number;\n\t/**\n\t * Tracks Texture frame changes.\n\t * @protected\n\t */\n\tprotected _textureID: number;\n\tprotected _texture: Texture;\n\t/**\n\t * If texture size is the same as baseTexture.\n\t * @default false\n\t * @readonly\n\t */\n\tisSimple: boolean;\n\t/**\n\t * @param texture - observed texture\n\t * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n\t */\n\tconstructor(texture: Texture, clampMargin?: number);\n\t/** Texture property. */\n\tget texture(): Texture;\n\tset texture(value: Texture);\n\t/**\n\t * Multiplies uvs array to transform\n\t * @param uvs - mesh uvs\n\t * @param [out=uvs] - output\n\t * @returns - output\n\t */\n\tmultiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array;\n\t/**\n\t * Updates matrices if texture was changed\n\t * @returns - whether or not it was updated\n\t */\n\tupdate(): boolean;\n}\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @category rendering\n * @advanced\n */\nexport class TexturePoolClass {\n\t/** The default options for texture pool */\n\ttextureOptions: TextureSourceOptions;\n\t/** The default texture style for the pool */\n\ttextureStyle: TextureStyle;\n\t/**\n\t * Allow renderTextures of the same size as screen, not just pow2\n\t *\n\t * Automatically sets to true after `setScreenSize`\n\t * @default false\n\t */\n\tenableFullScreen: boolean;\n\tprivate _texturePool;\n\tprivate _poolKeyHash;\n\t/**\n\t * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n\t * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n\t */\n\tconstructor(textureOptions?: TextureSourceOptions);\n\t/**\n\t * Creates texture with params that were specified in pool constructor.\n\t * @param pixelWidth - Width of texture in pixels.\n\t * @param pixelHeight - Height of texture in pixels.\n\t * @param antialias\n\t */\n\tcreateTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture;\n\t/**\n\t * Gets a Power-of-Two render texture or fullScreen texture\n\t * @param frameWidth - The minimum width of the render texture.\n\t * @param frameHeight - The minimum height of the render texture.\n\t * @param resolution - The resolution of the render texture.\n\t * @param antialias\n\t * @returns The new render texture.\n\t */\n\tgetOptimalTexture(frameWidth: number, frameHeight: number, resolution: number, antialias: boolean): Texture;\n\t/**\n\t * Gets extra texture of the same size as input renderTexture\n\t * @param texture - The texture to check what size it is.\n\t * @param antialias - Whether to use antialias.\n\t * @returns A texture that is a power of two\n\t */\n\tgetSameSizeTexture(texture: Texture, antialias?: boolean): Texture<TextureSource<any>>;\n\t/**\n\t * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.\n\t * useful if you modified the style of the texture after getting it from the pool.\n\t * @param renderTexture - The renderTexture to free\n\t * @param resetStyle - Whether to reset the style of the texture to the default texture style\n\t */\n\treturnTexture(renderTexture: Texture, resetStyle?: boolean): void;\n\t/**\n\t * Clears the pool.\n\t * @param destroyTextures - Destroy all stored textures.\n\t */\n\tclear(destroyTextures?: boolean): void;\n}\n/**\n * The default texture pool instance.\n * @category rendering\n * @advanced\n */\nexport const TexturePool: TexturePoolClass;\n/**\n * Stores a texture's frame in UV coordinates, in\n * which everything lies in the rectangle `[(0,0), (1,0),\n * (1,1), (0,1)]`.\n *\n * | Corner       | Coordinates |\n * |--------------|-------------|\n * | Top-Left     | `(x0,y0)`   |\n * | Top-Right    | `(x1,y1)`   |\n * | Bottom-Right | `(x2,y2)`   |\n * | Bottom-Left  | `(x3,y3)`   |\n * @protected\n * @category rendering\n * @advanced\n */\nexport class TextureUvs {\n\t/** X-component of top-left corner `(x0,y0)`. */\n\tx0: number;\n\t/** Y-component of top-left corner `(x0,y0)`. */\n\ty0: number;\n\t/** X-component of top-right corner `(x1,y1)`. */\n\tx1: number;\n\t/** Y-component of top-right corner `(x1,y1)`. */\n\ty1: number;\n\t/** X-component of bottom-right corner `(x2,y2)`. */\n\tx2: number;\n\t/** Y-component of bottom-right corner `(x2,y2)`. */\n\ty2: number;\n\t/** X-component of bottom-left corner `(x3,y3)`. */\n\tx3: number;\n\t/** Y-component of bottom-right corner `(x3,y3)`. */\n\ty3: number;\n\tuvsFloat32: Float32Array;\n\tconstructor();\n\t/**\n\t * Sets the texture Uvs based on the given frame information.\n\t * @protected\n\t * @param frame - The frame of the texture\n\t * @param baseFrame - The base frame of the texture\n\t * @param rotate - Rotation of frame, see {@link groupD8}\n\t */\n\tset(frame: Rectangle, baseFrame: Size, rotate: number): void;\n\ttoString(): string;\n}\n/**\n * @param canvas\n * @param options\n * @internal\n */\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>;\n/**\n * @param canvas\n * @internal\n */\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean;\n/** @internal */\nexport function getSupportedCompressedTextureFormats(): Promise<TEXTURE_FORMATS[]>;\n/** @internal */\nexport const nonCompressedFormats: TEXTURE_FORMATS[];\n/** @internal */\nexport function getSupportedTextureFormats(): Promise<TEXTURE_FORMATS[]>;\n/**\n * The type of resource or options that can be used to create a texture source.\n * This includes ImageResource, TextureSourceOptions, BufferSourceOptions, and CanvasSourceOptions.\n * @category rendering\n * @advanced\n */\nexport type TextureResourceOrOptions = ImageResource | TextureSourceOptions<ImageResource> | BufferSourceOptions | CanvasSourceOptions;\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n * @category rendering\n * @internal\n */\nexport function autoDetectSource(options?: TextureResourceOrOptions): TextureSource;\n/**\n * @param options\n * @param skipCache\n * @internal\n */\nexport function resourceToTexture(options?: TextureResourceOrOptions, skipCache?: boolean): Texture;\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n * @category utils\n * @internal\n */\nexport function textureFrom(id: TextureSourceLike, skipCache?: boolean): Texture;\n/**\n * @param value\n * @param groupId\n * @internal\n */\nexport function createIdFromString(value: string, groupId: string): number;\n/**\n * @param fn\n * @internal\n */\nexport function parseFunctionBody(fn: (...args: any[]) => any): string;\n/** @internal */\nexport interface ViewObserver {\n\tonViewUpdate: () => void;\n}\n/**\n * A view is something that is able to be rendered by the renderer.\n * @category scene\n * @advanced\n */\nexport interface View {\n\t/** a unique id for this view */\n\treadonly uid: number;\n\t/** whether or not this view should be batched */\n\tbatched: boolean;\n\t/**\n\t * an identifier that is used to identify the type of system that will be used to render this renderable\n\t * eg, 'sprite' will use the sprite system (based on the systems name\n\t */\n\treadonly renderPipeId: string;\n\t/** this is an int because it is packed directly into an attribute in the shader */\n\t_roundPixels: 0 | 1;\n\t/** @private */\n\t_lastUsed: number;\n\t/**\n\t *  Whether or not to round the x/y position of the object.\n\t * @type {boolean}\n\t */\n\tget roundPixels(): boolean;\n\t/** if true, the view will have its position rounded to the nearest whole number */\n\tset roundPixels(value: boolean);\n\t/** this is the AABB rectangle bounds of the view in local untransformed space. */\n\tbounds: BoundsData;\n\t/** Checks if the point is within the view */\n\tcontainsPoint: (point: Point) => boolean;\n}\n/**\n * Options passed to the ViewSystem\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemOptions {\n\t/**\n\t * The width of the screen.\n\t * @default 800\n\t */\n\twidth?: number;\n\t/**\n\t * The height of the screen.\n\t * @default 600\n\t */\n\theight?: number;\n\t/** The canvas to use as a view, optional. */\n\tcanvas?: ICanvas;\n\t/**\n\t * Alias for `canvas`.\n\t * @deprecated since 8.0.0\n\t */\n\tview?: ICanvas;\n\t/**\n\t * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n\t *\n\t * This is only supported for HTMLCanvasElement\n\t * and will be ignored if the canvas is an OffscreenCanvas.\n\t */\n\tautoDensity?: boolean;\n\t/** The resolution / device pixel ratio of the renderer. */\n\tresolution?: number;\n\t/** Whether to enable anti-aliasing. This may affect performance. */\n\tantialias?: boolean;\n\t/** Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer. */\n\tdepth?: boolean;\n}\n/**\n * Options for destroying the ViewSystem.\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemDestroyOptions {\n\t/** Whether to remove the view element from the DOM. Defaults to `false`. */\n\tremoveView?: boolean;\n}\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @advanced\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions>> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"view\";\n\t\treadonly priority: 0;\n\t};\n\t/** The default options for the view system. */\n\tstatic defaultOptions: ViewSystemOptions;\n\t/** The canvas element that everything is drawn to. */\n\tcanvas: ICanvas;\n\t/** The texture that is used to draw the canvas to the screen. */\n\ttexture: Texture<CanvasSource>;\n\t/**\n\t * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n\t * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n\t * @type {boolean}\n\t */\n\tget autoDensity(): boolean;\n\tset autoDensity(value: boolean);\n\t/** Whether to enable anti-aliasing. This may affect performance. */\n\tantialias: boolean;\n\t/**\n\t * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n\t *\n\t * Its safe to use as filterArea or hitArea for the whole stage.\n\t */\n\tscreen: Rectangle;\n\t/** The render target that the view is drawn to. */\n\trenderTarget: RenderTarget;\n\t/** The resolution / device pixel ratio of the renderer. */\n\tget resolution(): number;\n\tset resolution(value: number);\n\t/**\n\t * initiates the view system\n\t * @param options - the options for the view\n\t */\n\tinit(options: ViewSystemOptions): void;\n\t/**\n\t * Resizes the screen and canvas to the specified dimensions.\n\t * @param desiredScreenWidth - The new width of the screen.\n\t * @param desiredScreenHeight - The new height of the screen.\n\t * @param resolution\n\t */\n\tresize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void;\n\t/**\n\t * Destroys this System and optionally removes the canvas from the dom.\n\t * @param {options | false} options - The options for destroying the view, or \"false\".\n\t * @example\n\t * viewSystem.destroy();\n\t * viewSystem.destroy(true);\n\t * viewSystem.destroy({ removeView: true });\n\t */\n\tdestroy(options?: TypeOrBool<ViewSystemDestroyOptions>): void;\n}\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @category rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget> {\n\tprivate _renderTargetSystem;\n\tprivate _renderer;\n\tprivate _clearColorCache;\n\tprivate _viewPortCache;\n\t/** Pre-computed draw buffers arrays for MRT, indexed by color attachment count */\n\tprivate _drawBuffersCache;\n\tinit(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void;\n\tcontextChange(): void;\n\tcopyToTexture(sourceRenderSurfaceTexture: RenderTarget, destinationTexture: Texture, originSrc: {\n\t\tx: number;\n\t\ty: number;\n\t}, size: {\n\t\twidth: number;\n\t\theight: number;\n\t}, originDest: {\n\t\tx: number;\n\t\ty: number;\n\t}): Texture<TextureSource<any>>;\n\tstartRenderPass(renderTarget: RenderTarget, clear?: CLEAR_OR_BOOL, clearColor?: RgbaArray, viewport?: Rectangle): void;\n\tfinishRenderPass(renderTarget?: RenderTarget): void;\n\tinitGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget;\n\tdestroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget): void;\n\tclear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray): void;\n\tresizeGpuRenderTarget(renderTarget: RenderTarget): void;\n\tprivate _initColor;\n\tprivate _resizeColor;\n\tprivate _initStencil;\n\tprivate _resizeStencil;\n\tprerender(renderTarget: RenderTarget): void;\n\tpostrender(renderTarget: RenderTarget): void;\n\tprivate _setDrawBuffers;\n}\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GlRenderTargetSystem extends RenderTargetSystem<GlRenderTarget> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem\n\t\t];\n\t\treadonly name: \"renderTarget\";\n\t};\n\tadaptor: GlRenderTargetAdaptor;\n\tconstructor(renderer: WebGLRenderer);\n}\n/**\n * Type definition for the global uniforms used in the renderer.\n * This includes projection matrix, world transform matrix, world color, and resolution.\n * @category rendering\n * @advanced\n */\nexport type GlobalUniformGroup = UniformGroup<{\n\tuProjectionMatrix: {\n\t\tvalue: Matrix;\n\t\ttype: \"mat3x3<f32>\";\n\t};\n\tuWorldTransformMatrix: {\n\t\tvalue: Matrix;\n\t\ttype: \"mat3x3<f32>\";\n\t};\n\tuWorldColorAlpha: {\n\t\tvalue: Float32Array;\n\t\ttype: \"vec4<f32>\";\n\t};\n\tuResolution: {\n\t\tvalue: number[];\n\t\ttype: \"vec2<f32>\";\n\t};\n}>;\n/**\n * Options for the global uniforms system.\n * This includes size, projection matrix, world transform matrix, world color, and offset.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformOptions {\n\tsize?: number[];\n\tprojectionMatrix?: Matrix;\n\tworldTransformMatrix?: Matrix;\n\tworldColor?: number;\n\toffset?: PointData;\n}\n/**\n * Data structure for the global uniforms used in the renderer.\n * This includes the projection matrix, world transform matrix, world color, resolution, and bind group.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformData {\n\tprojectionMatrix: Matrix;\n\tworldTransformMatrix: Matrix;\n\tworldColor: number;\n\tresolution: number[];\n\toffset: PointData;\n\tbindGroup: BindGroup;\n}\n/** @internal */\nexport interface GlobalUniformRenderer {\n\trenderTarget: GlRenderTargetSystem | GpuRenderTargetSystem;\n\trenderPipes: Renderer[\"renderPipes\"];\n\tubo: UboSystem;\n\ttype: RendererType;\n}\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @category rendering\n * @advanced\n */\nexport class GlobalUniformSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"globalUniforms\";\n\t};\n\tprivate readonly _renderer;\n\tprivate _stackIndex;\n\tprivate _globalUniformDataStack;\n\tprivate readonly _uniformsPool;\n\tprivate readonly _activeUniforms;\n\tprivate readonly _bindGroupPool;\n\tprivate readonly _activeBindGroups;\n\tprivate _currentGlobalUniformData;\n\tconstructor(renderer: GlobalUniformRenderer);\n\treset(): void;\n\tstart(options: GlobalUniformOptions): void;\n\tbind({ size, projectionMatrix, worldTransformMatrix, worldColor, offset, }: GlobalUniformOptions): void;\n\tpush(options: GlobalUniformOptions): void;\n\tpop(): void;\n\tget bindGroup(): BindGroup;\n\tget globalUniformData(): GlobalUniformData;\n\tget uniformGroup(): UniformGroup<any>;\n\tprivate _createUniforms;\n\tdestroy(): void;\n}\n/**\n * Shared systems for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedSystems: (typeof BackgroundSystem | typeof GlobalUniformSystem | typeof HelloSystem | typeof ViewSystem | typeof RenderGroupSystem | typeof GCSystem | typeof TextureGCSystem | typeof GenerateTextureSystem | typeof ExtractSystem | typeof RendererInitHook | typeof RenderableGCSystem | typeof SchedulerSystem)[];\n/**\n * Shared render pipes for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedRenderPipes: (typeof BlendModePipe | typeof BatcherPipe | typeof SpritePipe | typeof RenderGroupPipe | typeof AlphaMaskPipe | typeof StencilMaskPipe | typeof ColorMaskPipe | typeof CustomRenderPipe)[];\n/**\n * Options for the shared systems of a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions {\n\t/**\n\t * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n\t * It is false by default, and means PixiJS will load all the default extensions, based\n\t * on the environment e.g browser/webworker.\n\t * If you set this to true, then you will need to manually import the systems and extensions you need.\n\t *\n\t * e.g.\n\t * ```js\n\t * import 'accessibility';\n\t * import 'app';\n\t * import 'events';\n\t * import 'spritesheet';\n\t * import 'graphics';\n\t * import 'mesh';\n\t * import 'text';\n\t * import 'text-bitmap';\n\t * import 'text-html';\n\t * import { autoDetectRenderer } from 'pixi.js';\n\t *\n\t * const renderer = await autoDetectRenderer({\n\t *   width: 800,\n\t *   height: 600,\n\t *   skipExtensionImports: true,\n\t * });\n\t * ```\n\t * @default false\n\t */\n\tskipExtensionImports?: boolean;\n\t/**\n\t * @default true\n\t * @deprecated since 8.1.6\n\t * @see `skipExtensionImports`\n\t */\n\tmanageImports?: boolean;\n}\ndeclare const DefaultWebGPUSystems: (typeof BackgroundSystem | typeof GlobalUniformSystem | typeof HelloSystem | typeof ViewSystem | typeof RenderGroupSystem | typeof GCSystem | typeof TextureGCSystem | typeof GenerateTextureSystem | typeof ExtractSystem | typeof RendererInitHook | typeof RenderableGCSystem | typeof SchedulerSystem | typeof GpuUboSystem | typeof GpuEncoderSystem | typeof GpuDeviceSystem | typeof GpuLimitsSystem | typeof GpuBufferSystem | typeof GpuTextureSystem | typeof GpuRenderTargetSystem | typeof GpuShaderSystem | typeof GpuStateSystem | typeof PipelineSystem | typeof GpuColorMaskSystem | typeof GpuStencilSystem | typeof BindGroupSystem)[];\ndeclare const DefaultWebGPUPipes: (typeof BlendModePipe | typeof BatcherPipe | typeof SpritePipe | typeof RenderGroupPipe | typeof AlphaMaskPipe | typeof StencilMaskPipe | typeof ColorMaskPipe | typeof CustomRenderPipe | typeof GpuUniformBatchPipe)[];\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> & PixiMixins.RendererSystems & PixiMixins.WebGPUSystems;\n/**\n * The WebGPU renderer pipes. These are used to render the scene.\n * @see {@link WebGPURenderer}\n * @internal\n */\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> & PixiMixins.RendererPipes & PixiMixins.WebGPUPipes;\n/**\n * Options for WebGPURenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGPUOptions extends SharedRendererOptions, ExtractRendererOptions<typeof DefaultWebGPUSystems>, PixiMixins.WebGPUOptions {\n}\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>, WebGPUSystems {\n}\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @standard\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T> implements WebGPUSystems {\n\t/** The WebGPU Device. */\n\tgpu: GPU$1;\n\tconstructor();\n}\n/**\n * The GPU object.\n * Contains the GPU adapter and device.\n * @category rendering\n * @advanced\n */\ninterface GPU$1 {\n\t/** The GPU adapter */\n\tadapter: GPUAdapter;\n\t/** The GPU device */\n\tdevice: GPUDevice;\n}\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @category rendering\n * @advanced\n */\nexport interface GpuContextOptions {\n\t/**\n\t * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n\t * can be `'high-performance'` or `'low-power'`.\n\t * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n\t * while setting to `'low-power'` will prioritize power saving over rendering performance.\n\t * @default undefined\n\t */\n\tpowerPreference?: GpuPowerPreference;\n\t/**\n\t * Force the use of the fallback adapter\n\t * @default false\n\t */\n\tforceFallbackAdapter: boolean;\n\t/** Using shared device and adaptor from other engine */\n\tgpu?: GPU$1;\n}\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"device\";\n\t};\n\t/** The default options for the GpuDeviceSystem. */\n\tstatic defaultOptions: GpuContextOptions;\n\t/** The GPU device */\n\tgpu: GPU$1;\n\tprivate _renderer;\n\tprivate _initPromise;\n\t/**\n\t * @param {WebGPURenderer} renderer - The renderer this System works for.\n\t */\n\tconstructor(renderer: WebGPURenderer);\n\tinit(options: GpuContextOptions): Promise<void>;\n\t/**\n\t * Handle the context change event\n\t * @param gpu\n\t */\n\tprotected contextChange(gpu: GPU$1): void;\n\t/**\n\t * Helper class to create a WebGL Context\n\t * @param {object} options - An options object that gets passed in to the canvas element containing the\n\t *    context attributes\n\t * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n\t * @returns {WebGLRenderingContext} the WebGL context\n\t */\n\tprivate _createDeviceAndAdaptor;\n\tdestroy(): void;\n}\n/**\n * Stores GPU-specific data for a Texture instance in WebGL context.\n * @internal\n */\nexport class GPUTextureGpuData implements GPUData {\n\tgpuTexture: GPUTexture;\n\ttextureView: GPUTextureView;\n\tconstructor(gpuTexture: GPUTexture);\n\t/** Destroys this GPU data instance. */\n\tdestroy(): void;\n}\n/**\n * The system that handles textures for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuTextureSystem implements System, CanvasGenerator {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"texture\";\n\t};\n\tprotected CONTEXT_UID: number;\n\tprivate _gpuSamplers;\n\tprivate _bindGroupHash;\n\tprivate readonly _uploads;\n\tprivate _gpu;\n\tprivate _mipmapGenerator?;\n\tprivate readonly _renderer;\n\tprivate readonly _managedTextures;\n\t/**\n\t * @deprecated since 8.15.0\n\t */\n\tget managedTextures(): Readonly<TextureSource[]>;\n\tconstructor(renderer: WebGPURenderer);\n\tprotected contextChange(gpu: GPU$1): void;\n\t/**\n\t * Initializes a texture source, if it has already been initialized nothing will happen.\n\t * @param source - The texture source to initialize.\n\t * @returns The initialized texture source.\n\t */\n\tinitSource(source: TextureSource): GPUTexture;\n\tprivate _initSource;\n\tprotected onSourceUpdate(source: TextureSource): void;\n\tprotected onUpdateMipmaps(source: TextureSource): void;\n\tprotected onSourceUnload(source: TextureSource): void;\n\tprotected onSourceResize(source: TextureSource): void;\n\tprivate _initSampler;\n\tgetGpuSampler(sampler: TextureStyle): GPUSampler;\n\tgetGpuSource(source: TextureSource): GPUTexture;\n\t/**\n\t * this returns s bind group for a specific texture, the bind group contains\n\t * - the texture source\n\t * - the texture style\n\t * - the texture matrix\n\t * This is cached so the bind group should only be created once per texture\n\t * @param texture - the texture you want the bindgroup for\n\t * @returns the bind group for the texture\n\t */\n\tgetTextureBindGroup(texture: Texture): BindGroup;\n\tprivate _createTextureBindGroup;\n\tgetTextureView(texture: BindableTexture): GPUTextureView;\n\tgenerateCanvas(texture: Texture): ICanvas;\n\tgetPixels(texture: Texture): GetPixelsOutput;\n\tdestroy(): void;\n}\n/**\n * options for creating a new TextureSource\n * @category rendering\n * @advanced\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions {\n\t/**\n\t * the resource that will be uploaded to the GPU. This is where we get our pixels from\n\t * eg an ImageBimt / Canvas / Video etc\n\t */\n\tresource?: T;\n\t/** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n\twidth?: number;\n\t/** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n\theight?: number;\n\t/** the resolution of the texture. */\n\tresolution?: number;\n\t/** the format that the texture data has */\n\tformat?: TEXTURE_FORMATS;\n\t/**\n\t * Used by internal textures\n\t * @ignore\n\t */\n\tsampleCount?: number;\n\t/**\n\t * Only really affects RenderTextures.\n\t * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n\t * Blit operation will be required to resolve the texture.\n\t */\n\tantialias?: boolean;\n\t/** how many dimensions does this texture have? currently v8 only supports 2d */\n\tdimensions?: TEXTURE_DIMENSIONS;\n\t/** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n\tmipLevelCount?: number;\n\t/**\n\t * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n\t * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n\t * can look better when scaled down.\n\t *\n\t * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n\t * If you do, make sure to call `updateMipmaps` after you update the texture.\n\t */\n\tautoGenerateMipmaps?: boolean;\n\t/** the alpha mode of the texture */\n\talphaMode?: ALPHA_MODES;\n\t/** optional label, can be used for debugging */\n\tlabel?: string;\n\t/** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n\tautoGarbageCollect?: boolean;\n\t/** Used by RenderTexture.create to allow resizing. Not used by TextureSource itself. */\n\tdynamic?: boolean;\n}\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @category rendering\n * @advanced\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n\tchange: BindResource;\n\tupdate: TextureSource;\n\tunload: TextureSource;\n\tdestroy: TextureSource;\n\tresize: TextureSource;\n\tstyleChange: TextureSource;\n\tupdateMipmaps: TextureSource;\n\terror: Error;\n}> implements BindResource, GPUDataOwner, GCable {\n\tprotected readonly options: TextureSourceOptions<T>;\n\t/** The default options used when creating a new TextureSource. override these to add your own defaults */\n\tstatic defaultOptions: TextureSourceOptions;\n\t/** @internal */\n\t_gpuData: Record<number, GlTexture | GPUTextureGpuData>;\n\t/** GC tracking data, undefined if not being tracked */\n\t_gcData?: GCData;\n\t/** @internal */\n\t_gcLastUsed: number;\n\t/** unique id for this Texture source */\n\treadonly uid: number;\n\t/** optional label, can be used for debugging */\n\tlabel: string;\n\t/**\n\t * The resource type used by this TextureSource. This is used by the bind groups to determine\n\t * how to handle this resource.\n\t * @internal\n\t */\n\treadonly _resourceType = \"textureSource\";\n\t/**\n\t * i unique resource id, used by the bind group systems.\n\t * This can change if the texture is resized or its resource changes\n\t * @internal\n\t */\n\t_resourceId: number;\n\t/**\n\t * this is how the backends know how to upload this texture to the GPU\n\t * It changes depending on the resource type. Classes that extend TextureSource\n\t * should override this property.\n\t * @internal\n\t */\n\tuploadMethodId: string;\n\t/** @internal */\n\t_resolution: number;\n\t/** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n\tpixelWidth: number;\n\t/** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n\tpixelHeight: number;\n\t/**\n\t * the width of this texture source, accounting for resolution\n\t * eg pixelWidth 200, resolution 2, then width will be 100\n\t */\n\twidth: number;\n\t/**\n\t * the height of this texture source, accounting for resolution\n\t * eg pixelHeight 200, resolution 2, then height will be 100\n\t */\n\theight: number;\n\t/**\n\t * the resource that will be uploaded to the GPU. This is where we get our pixels from\n\t * eg an ImageBimt / Canvas / Video etc\n\t */\n\tresource: T;\n\t/**\n\t * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n\t * To enable multisample for a texture, set antialias to true\n\t * @internal\n\t */\n\tsampleCount: number;\n\t/** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n\tmipLevelCount: number;\n\t/**\n\t * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n\t * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n\t * can look better when scaled down.\n\t *\n\t * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n\t * If you do, make sure to call `updateMipmaps` after you update the texture.\n\t */\n\tautoGenerateMipmaps: boolean;\n\t/** the format that the texture data has */\n\tformat: TEXTURE_FORMATS;\n\t/** how many dimensions does this texture have? currently v8 only supports 2d */\n\tdimension: TEXTURE_DIMENSIONS;\n\t/** the alpha mode of the texture */\n\talphaMode: ALPHA_MODES;\n\tprivate _style;\n\t/**\n\t * Only really affects RenderTextures.\n\t * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n\t * Blit operation will be required to resolve the texture.\n\t */\n\tantialias: boolean;\n\t/**\n\t * Has the source been destroyed?\n\t * @readonly\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n\t * @protected\n\t */\n\t_touched: number;\n\t/**\n\t * Used by the batcher to build texture batches. faster to have the variable here!\n\t * @protected\n\t */\n\t_batchTick: number;\n\t/**\n\t * A temporary batch location for the texture batching. Here for performance reasons only!\n\t * @protected\n\t */\n\t_textureBindLocation: number;\n\tisPowerOfTwo: boolean;\n\t/** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n\tautoGarbageCollect: boolean;\n\t/**\n\t * used internally to know where a texture came from. Usually assigned by the asset loader!\n\t * @ignore\n\t */\n\t_sourceOrigin: string;\n\t/**\n\t * @param options - options for creating a new TextureSource\n\t */\n\tconstructor(options?: TextureSourceOptions<T>);\n\t/** returns itself */\n\tget source(): TextureSource;\n\t/** the style of the texture */\n\tget style(): TextureStyle;\n\tset style(value: TextureStyle);\n\t/** Specifies the maximum anisotropy value clamp used by the sampler. */\n\tset maxAnisotropy(value: number);\n\tget maxAnisotropy(): number;\n\t/** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n\tget addressMode(): WRAP_MODE;\n\tset addressMode(value: WRAP_MODE);\n\t/** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n\tget repeatMode(): WRAP_MODE;\n\tset repeatMode(value: WRAP_MODE);\n\t/** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n\tget magFilter(): SCALE_MODE;\n\tset magFilter(value: SCALE_MODE);\n\t/** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n\tget minFilter(): SCALE_MODE;\n\tset minFilter(value: SCALE_MODE);\n\t/** Specifies behavior for sampling between mipmap levels. */\n\tget mipmapFilter(): SCALE_MODE;\n\tset mipmapFilter(value: SCALE_MODE);\n\t/** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n\tget lodMinClamp(): number;\n\tset lodMinClamp(value: number);\n\t/** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n\tget lodMaxClamp(): number;\n\tset lodMaxClamp(value: number);\n\tprivate _onStyleChange;\n\t/** call this if you have modified the texture outside of the constructor */\n\tupdate(): void;\n\t/** Destroys this texture source */\n\tdestroy(): void;\n\t/**\n\t * This will unload the Texture source from the GPU. This will free up the GPU memory\n\t * As soon as it is required fore rendering, it will be re-uploaded.\n\t */\n\tunload(): void;\n\t/** the width of the resource. This is the REAL pure number, not accounting resolution   */\n\tget resourceWidth(): number;\n\t/** the height of the resource. This is the REAL pure number, not accounting resolution */\n\tget resourceHeight(): number;\n\t/**\n\t * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n\t * but will the size of the texture when rendered.\n\t *\n\t * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n\t * density will have increased)\n\t */\n\tget resolution(): number;\n\tset resolution(resolution: number);\n\t/**\n\t * Resize the texture, this is handy if you want to use the texture as a render texture\n\t * @param width - the new width of the texture\n\t * @param height - the new height of the texture\n\t * @param resolution - the new resolution of the texture\n\t * @returns - if the texture was resized\n\t */\n\tresize(width?: number, height?: number, resolution?: number): boolean;\n\t/**\n\t * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n\t * This is only important for RenderTexture instances, as standard Texture instances will have their\n\t * mipmaps generated on upload. You should call this method after you make any change to the texture\n\t *\n\t * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n\t * We want you, the developer to specify when this action should happen.\n\t *\n\t * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n\t */\n\tupdateMipmaps(): void;\n\tset wrapMode(value: WRAP_MODE);\n\tget wrapMode(): WRAP_MODE;\n\tset scaleMode(value: SCALE_MODE);\n\t/** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n\tget scaleMode(): SCALE_MODE;\n\t/**\n\t * Refresh check for isPowerOfTwo texture based on size\n\t * @private\n\t */\n\tprotected _refreshPOT(): void;\n\tstatic test(_resource: any): any;\n\t/**\n\t * A helper function that creates a new TextureSource based on the resource you provide.\n\t * @param resource - The resource to create the texture source from.\n\t */\n\tstatic from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n/**\n * Options for creating a BufferImageSource.\n * @category rendering\n * @advanced\n */\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer> {\n\twidth: number;\n\theight: number;\n}\n/**\n * A texture source that uses a TypedArray or ArrayBuffer as its resource.\n * It automatically determines the format based on the type of TypedArray provided.\n * @category rendering\n * @advanced\n */\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer> {\n\tstatic extension: ExtensionMetadata;\n\tuploadMethodId: string;\n\tconstructor(options: BufferSourceOptions);\n\tstatic test(resource: any): resource is TypedArray | ArrayBuffer;\n}\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link NineSlicePlane} texture.\n * @category rendering\n * @advanced\n */\nexport interface TextureBorders {\n\t/** left border in pixels */\n\tleft: number;\n\t/** top border in pixels */\n\ttop: number;\n\t/** right border in pixels */\n\tright: number;\n\t/** bottom border in pixels */\n\tbottom: number;\n}\n/**\n * The UVs data structure for a texture.\n * @category rendering\n * @advanced\n */\nexport type UVs = {\n\tx0: number;\n\ty0: number;\n\tx1: number;\n\ty1: number;\n\tx2: number;\n\ty2: number;\n\tx3: number;\n\ty3: number;\n};\n/**\n * The options that can be passed to a new Texture\n * @category rendering\n * @standard\n */\nexport interface TextureOptions<TextureSourceType extends TextureSource = TextureSource> {\n\t/** the underlying texture data that this texture will use  */\n\tsource?: TextureSourceType;\n\t/** optional label, for debugging */\n\tlabel?: string;\n\t/** The rectangle frame of the texture to show */\n\tframe?: Rectangle;\n\t/** The area of original texture */\n\torig?: Rectangle;\n\t/** Trimmed rectangle of original texture */\n\ttrim?: Rectangle;\n\t/** Default anchor point used for sprite placement / rotation */\n\tdefaultAnchor?: {\n\t\tx: number;\n\t\ty: number;\n\t};\n\t/** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n\tdefaultBorders?: TextureBorders;\n\t/** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n\trotate?: number;\n\t/**\n\t * Set to true if you plan on modifying this texture's frame, UVs, or swapping its source at runtime.\n\t * This is false by default as it improves performance. Generally, it's recommended to create new\n\t * textures and swap those rather than modifying an existing texture's properties unless you are\n\t * working with a dynamic frames.\n\t * Not setting this to true when modifying the texture can lead to visual artifacts.\n\t *\n\t * If this is false and you modify the texture, you can manually update the sprite's texture by calling\n\t * `sprite.onViewUpdate()`.\n\t */\n\tdynamic?: boolean;\n}\n/**\n * A texture that can be bound to a shader as it has a texture source.\n * @category rendering\n * @advanced\n */\nexport interface BindableTexture {\n\tsource: TextureSource;\n}\n/**\n * A texture source can be a string, an image, a video, a canvas, or a texture resource.\n * @category rendering\n * @advanced\n * @see {@link TextureSource}\n * @see {@link TextureResourceOrOptions}\n * @see {@link Texture.from}\n */\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load a texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Assets.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Assets.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Assets.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @category rendering\n * @class\n * @standard\n */\nexport class Texture<TextureSourceType extends TextureSource = TextureSource> extends EventEmitter<{\n\tupdate: Texture;\n\tdestroy: Texture;\n}> implements BindableTexture {\n\t/**\n\t * Helper function that creates a returns Texture based on the source you provide.\n\t * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n\t * @param id - String or Source to create texture from\n\t * @param skipCache - Skip adding the texture to the cache\n\t * @returns The texture based on the Id provided\n\t */\n\tstatic from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\t/** label used for debugging */\n\tlabel?: string;\n\t/** unique id for this texture */\n\treadonly uid: number;\n\t/**\n\t * Has the texture been destroyed?\n\t * @readonly\n\t */\n\tdestroyed: boolean;\n\t/** @internal */\n\t_source: TextureSourceType;\n\t/**\n\t * Indicates whether the texture is rotated inside the atlas\n\t * set to 2 to compensate for texture packer rotation\n\t * set to 6 to compensate for spine packer rotation\n\t * can be used to rotate or mirror sprites\n\t * See {@link groupD8} for explanation\n\t */\n\treadonly rotate: number;\n\t/** A uvs object based on the given frame and the texture source */\n\treadonly uvs: UVs;\n\t/**\n\t * Anchor point that is used as default if sprite is created with this texture.\n\t * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n\t * @default {0,0}\n\t */\n\treadonly defaultAnchor?: {\n\t\tx: number;\n\t\ty: number;\n\t};\n\t/**\n\t * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n\t * @since 7.2.0\n\t * @see NineSliceSprite\n\t */\n\treadonly defaultBorders?: TextureBorders;\n\t/**\n\t * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n\t * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n\t */\n\treadonly frame: Rectangle;\n\t/** This is the area of original texture, before it was put in atlas. */\n\treadonly orig: Rectangle;\n\t/**\n\t * This is the trimmed area of original texture, before it was put in atlas\n\t * Please call `updateUvs()` after you change coordinates of `trim` manually.\n\t */\n\treadonly trim: Rectangle;\n\t/**\n\t * Does this Texture have any frame data assigned to it?\n\t *\n\t * This mode is enabled automatically if no frame was passed inside constructor.\n\t *\n\t * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n\t *\n\t * Beware, after loading or resize of baseTexture event can fired two times!\n\t * If you want more control, subscribe on baseTexture itself.\n\t * @example\n\t * texture.on('update', () => {});\n\t */\n\tnoFrame: boolean;\n\t/**\n\t * Set to true if you plan on modifying the uvs of this texture.\n\t * When this is the case, sprites and other objects using the texture will\n\t * make sure to listen for changes to the uvs and update their vertices accordingly.\n\t */\n\tdynamic: boolean;\n\tprivate _textureMatrix;\n\t/** is it a texture? yes! used for type checking */\n\treadonly isTexture = true;\n\t/**\n\t * @param {TextureOptions} options - Options for the texture\n\t */\n\tconstructor({ source, label, frame, orig, trim, defaultAnchor, defaultBorders, rotate, dynamic }?: TextureOptions<TextureSourceType>);\n\tset source(value: TextureSourceType);\n\t/** the underlying source of the texture (equivalent of baseTexture in v7) */\n\tget source(): TextureSourceType;\n\t/** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n\tget textureMatrix(): TextureMatrix;\n\t/** The width of the Texture in pixels. */\n\tget width(): number;\n\t/** The height of the Texture in pixels. */\n\tget height(): number;\n\t/** Call this function when you have modified the frame of this texture. */\n\tupdateUvs(): void;\n\t/**\n\t * Destroys this texture\n\t * @param destroySource - Destroy the source when the texture is destroyed.\n\t */\n\tdestroy(destroySource?: boolean): void;\n\t/**\n\t * Call this if you have modified the `texture outside` of the constructor.\n\t *\n\t * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n\t */\n\tupdate(): void;\n\t/** @deprecated since 8.0.0 */\n\tget baseTexture(): TextureSource;\n\t/** an Empty Texture used internally by the engine */\n\tstatic EMPTY: Texture;\n\t/** a White texture used internally by the engine */\n\tstatic WHITE: Texture<BufferImageSource>;\n}\n/**\n * A render texture, extends `Texture`.\n * @see {@link Texture}\n * @category rendering\n * @advanced\n */\nexport class RenderTexture extends Texture {\n\t/**\n\t * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n\t * @param options - Options for the RenderTexture, including width, height, and dynamic.\n\t * @returns A new RenderTexture instance.\n\t * @example\n\t * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n\t * rt.resize(500, 500);\n\t */\n\tstatic create(options: TextureSourceOptions): RenderTexture;\n\t/**\n\t * Resizes the render texture.\n\t * @param width - The new width of the render texture.\n\t * @param height - The new height of the render texture.\n\t * @param resolution - The new resolution of the render texture.\n\t * @returns This texture.\n\t */\n\tresize(width: number, height: number, resolution?: number): this;\n}\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, \"resource\" | \"width\" | \"height\" | \"resolution\">;\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n\t/**\n\t * The container to generate the texture from.\n\t * This can be any display object like Sprite, Container, or Graphics.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics()\n\t *     .circle(0, 0, 50)\n\t *     .fill('red');\n\t *\n\t * const texture = renderer.generateTexture({\n\t *     target: graphics\n\t * });\n\t * ```\n\t */\n\ttarget: Container;\n\t/**\n\t * The region of the container that should be rendered.\n\t * If not specified, defaults to the local bounds of the container.\n\t * @example\n\t * ```ts\n\t * // Extract only a portion of the container\n\t * const texture = renderer.generateTexture({\n\t *     target: container,\n\t *     frame: new Rectangle(10, 10, 100, 100)\n\t * });\n\t * ```\n\t */\n\tframe?: Rectangle;\n\t/**\n\t * The resolution of the texture being generated.\n\t * Higher values create sharper textures at the cost of memory.\n\t * @default renderer.resolution\n\t * @example\n\t * ```ts\n\t * // Generate a high-resolution texture\n\t * const hiResTexture = renderer.generateTexture({\n\t *     target: sprite,\n\t *     resolution: 2 // 2x resolution\n\t * });\n\t * ```\n\t */\n\tresolution?: number;\n\t/**\n\t * The color used to clear the texture before rendering.\n\t * Can be a hex number, string, or array of numbers.\n\t * @example\n\t * ```ts\n\t * // Clear with red background\n\t * const texture = renderer.generateTexture({\n\t *     target: sprite,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Clear with semi-transparent black\n\t * const texture = renderer.generateTexture({\n\t *     target: sprite,\n\t *     clearColor: [0, 0, 0, 0.5]\n\t * });\n\t * ```\n\t */\n\tclearColor?: ColorSource;\n\t/**\n\t * Whether to enable anti-aliasing. This may affect performance.\n\t * @default false\n\t * @example\n\t * ```ts\n\t * // Generate a smooth texture\n\t * const texture = renderer.generateTexture({\n\t *     target: graphics,\n\t *     antialias: true\n\t * });\n\t * ```\n\t */\n\tantialias?: boolean;\n\t/**\n\t * Advanced options for configuring the texture source.\n\t * Controls texture properties like scale mode and filtering.\n\t * @advanced\n\t * @example\n\t * ```ts\n\t * const texture = renderer.generateTexture({\n\t *     target: sprite,\n\t *     textureSourceOptions: {\n\t *         scaleMode: 'linear',\n\t *     }\n\t * });\n\t * ```\n\t */\n\ttextureSourceOptions?: GenerateTextureSourceOptions;\n};\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"textureGenerator\";\n\t};\n\tprivate readonly _renderer;\n\tconstructor(renderer: Renderer);\n\t/**\n\t * Creates a texture from a display object that can be used for creating sprites and other textures.\n\t * This is particularly useful for optimizing performance when a complex container needs to be reused.\n\t * @param options - Generate texture options or a container to convert to texture\n\t * @returns A new RenderTexture containing the rendered display object\n\t * @example\n\t * ```ts\n\t * // Basic usage with a container\n\t * const container = new Container();\n\t * container.addChild(\n\t *     new Graphics()\n\t *         .circle(0, 0, 50)\n\t *         .fill('red')\n\t * );\n\t *\n\t * const texture = renderer.textureGenerator.generateTexture(container);\n\t *\n\t * // Advanced usage with options\n\t * const texture = renderer.textureGenerator.generateTexture({\n\t *     target: container,\n\t *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n\t *     resolution: 2,                        // High DPI\n\t *     clearColor: '#ff0000',               // Red background\n\t *     antialias: true                      // Smooth edges\n\t * });\n\t *\n\t * // Create a sprite from the generated texture\n\t * const sprite = new Sprite(texture);\n\t *\n\t * // Clean up when done\n\t * texture.destroy(true);\n\t * ```\n\t * @see {@link GenerateTextureOptions} For detailed texture generation options\n\t * @see {@link RenderTexture} For the type of texture created\n\t * @category rendering\n\t */\n\tgenerateTexture(options: GenerateTextureOptions | Container): RenderTexture;\n\tdestroy(): void;\n}\n/**\n * The configuration for the renderer.\n * This is used to define the systems and render pipes that will be used by the renderer.\n * @category rendering\n * @advanced\n */\nexport interface RendererConfig {\n\ttype: number;\n\tname: string;\n\trunners?: string[];\n\tsystems: {\n\t\tname: string;\n\t\tvalue: SystemConstructor;\n\t}[];\n\trenderPipes: {\n\t\tname: string;\n\t\tvalue: PipeConstructor;\n\t}[];\n\trenderPipeAdaptors: {\n\t\tname: string;\n\t\tvalue: any;\n\t}[];\n}\n/**\n * The options for rendering a view.\n * @category rendering\n * @standard\n */\nexport interface RenderOptions extends ClearOptions {\n\t/** The container to render. */\n\tcontainer: Container;\n\t/** the transform to apply to the container. */\n\ttransform?: Matrix;\n}\n/**\n * The options for clearing the render target.\n * @category rendering\n * @advanced\n */\nexport interface ClearOptions {\n\t/**\n\t * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n\t * please ensure you have set `multiView` to `true` on renderer.\n\t */\n\ttarget?: RenderSurface;\n\t/** The color to clear with. */\n\tclearColor?: ColorSource;\n\t/** The clear mode to use. */\n\tclear?: CLEAR_OR_BOOL;\n}\n/**\n * Options for destroying the renderer.\n * This can be a boolean or an object.\n * @category rendering\n * @standard\n */\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions & {\n\t/** Whether to clean up global resource pools/caches */\n\treleaseGlobalResources?: boolean;\n}>;\ndeclare const defaultRunners: readonly [\n\t\"init\",\n\t\"destroy\",\n\t\"contextChange\",\n\t\"resolutionChange\",\n\t\"resetState\",\n\t\"renderEnd\",\n\t\"renderStart\",\n\t\"render\",\n\t\"update\",\n\t\"postrender\",\n\t\"prerender\"\n];\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {\n\t[key in DefaultRunners]: SystemRunner;\n} & {\n\t[K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@link WebGLRenderer}\n * or {@link WebGPURenderer}.\n * Alternatively, you can also use {@link autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link EventSystem}           | This manages UI events.                                                       |\n * | {@link AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @category rendering\n * @advanced\n * @property {HelloSystem} hello - HelloSystem instance.\n * @property {TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {FilterSystem} filter - FilterSystem instance.\n * @property {GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {TextureSystem} texture - TextureSystem instance.\n * @property {EventSystem} events - EventSystem instance.\n * @property {ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\nexport class AbstractRenderer<PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement> extends EventEmitter<{\n\tresize: [\n\t\tscreenWidth: number,\n\t\tscreenHeight: number,\n\t\tresolution: number\n\t];\n}> {\n\t/** The default options for the renderer. */\n\tstatic defaultOptions: {\n\t\t/**\n\t\t * Default resolution / device pixel ratio of the renderer.\n\t\t * @default 1\n\t\t */\n\t\tresolution: number;\n\t\t/**\n\t\t * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n\t\t * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n\t\t * performance issues when using WebGL.\n\t\t *\n\t\t * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n\t\t * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n\t\t * driver version blacklisted by the\n\t\t * browser.\n\t\t *\n\t\t * If your application requires high performance rendering, you may wish to set this to false.\n\t\t * We recommend one of two options if you decide to set this flag to false:\n\t\t *\n\t\t * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n\t\t *    not supported.\n\t\t *\n\t\t * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n\t\t *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n\t\t *    device & browser combination does not support high performance WebGL.\n\t\t *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n\t\t * @default false\n\t\t */\n\t\tfailIfMajorPerformanceCaveat: boolean;\n\t\t/**\n\t\t * Should round pixels be forced when rendering?\n\t\t * @default false\n\t\t */\n\t\troundPixels: boolean;\n\t};\n\t/** @internal */\n\treadonly type: number;\n\t/** The name of the renderer. */\n\treadonly name: string;\n\t/** The current tick of the renderer. */\n\ttick: number;\n\t/** @internal */\n\treadonly uid: number;\n\t/** @internal */\n\t_roundPixels: 0 | 1;\n\t/** @internal */\n\treadonly runners: Runners;\n\t/** @internal */\n\treadonly renderPipes: PIPES;\n\t/** The view system manages the main canvas that is attached to the DOM */\n\tview: ViewSystem;\n\t/** The background system manages the background color and alpha of the main view. */\n\tbackground: BackgroundSystem;\n\t/** System that manages the generation of textures from the renderer */\n\ttextureGenerator: GenerateTextureSystem;\n\tprotected _initOptions: OPTIONS;\n\tprotected config: RendererConfig;\n\tprivate _systemsHash;\n\tprivate _lastObjectRendered;\n\t/**\n\t * Set up a system with a collection of SystemClasses and runners.\n\t * Systems are attached dynamically to this class when added.\n\t * @param config - the config for the system manager\n\t */\n\tconstructor(config: RendererConfig);\n\t/**\n\t * Initialize the renderer.\n\t * @param options - The options to use to create the renderer.\n\t */\n\tinit(options?: Partial<OPTIONS>): Promise<void>;\n\t/**\n\t * Renders the object to its view.\n\t * @param options - The options to render with.\n\t * @param options.container - The container to render.\n\t * @param [options.target] - The target to render to.\n\t */\n\trender(options: RenderOptions | Container): void;\n\t/** @deprecated since 8.0.0 */\n\trender(container: Container, options: {\n\t\trenderTexture: any;\n\t}): void;\n\t/**\n\t * Resizes the WebGL view to the specified width and height.\n\t * @param desiredScreenWidth - The desired width of the screen.\n\t * @param desiredScreenHeight - The desired height of the screen.\n\t * @param resolution - The resolution / device pixel ratio of the renderer.\n\t */\n\tresize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void;\n\t/**\n\t * Clears the render target.\n\t * @param options - The options to use when clearing the render target.\n\t * @param options.target - The render target to clear.\n\t * @param options.clearColor - The color to clear with.\n\t * @param options.clear - The clear mode to use.\n\t * @advanced\n\t */\n\tclear(options?: ClearOptions): void;\n\t/** The resolution / device pixel ratio of the renderer. */\n\tget resolution(): number;\n\tset resolution(value: number);\n\t/**\n\t * Same as view.width, actual number of pixels in the canvas by horizontal.\n\t * @type {number}\n\t * @readonly\n\t * @default 800\n\t */\n\tget width(): number;\n\t/**\n\t * Same as view.height, actual number of pixels in the canvas by vertical.\n\t * @default 600\n\t */\n\tget height(): number;\n\t/**\n\t * The canvas element that everything is drawn to.\n\t * @type {environment.ICanvas}\n\t */\n\tget canvas(): CANVAS;\n\t/**\n\t * the last object rendered by the renderer. Useful for other plugins like interaction managers\n\t * @readonly\n\t */\n\tget lastObjectRendered(): Container;\n\t/**\n\t * Flag if we are rendering to the screen vs renderTexture\n\t * @readonly\n\t * @default true\n\t */\n\tget renderingToScreen(): boolean;\n\t/**\n\t * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n\t *\n\t * Its safe to use as filterArea or hitArea for the whole stage.\n\t */\n\tget screen(): Rectangle;\n\t/**\n\t * Create a bunch of runners based of a collection of ids\n\t * @param runnerIds - the runner ids to add\n\t */\n\tprivate _addRunners;\n\tprivate _addSystems;\n\t/**\n\t * Add a new system to the renderer.\n\t * @param ClassRef - Class reference\n\t * @param name - Property name for system, if not specified\n\t *        will use a static `name` property on the class itself. This\n\t *        name will be assigned as s property on the Renderer so make\n\t *        sure it doesn't collide with properties on Renderer.\n\t * @returns Return instance of renderer\n\t */\n\tprivate _addSystem;\n\tprivate _addPipes;\n\tdestroy(options?: RendererDestroyOptions): void;\n\t/**\n\t * Generate a texture from a container.\n\t * @param options - options or container target to use when generating the texture\n\t * @returns a texture\n\t */\n\tgenerateTexture(options: GenerateTextureOptions | Container): Texture;\n\t/**\n\t * Whether the renderer will round coordinates to whole pixels when rendering.\n\t * Can be overridden on a per scene item basis.\n\t */\n\tget roundPixels(): boolean;\n\t/**\n\t * Overridable function by `pixi.js/unsafe-eval` to silence\n\t * throwing an error if platform doesn't support unsafe-evals.\n\t * @private\n\t * @ignore\n\t */\n\t_unsafeEvalCheck(): void;\n\t/**\n\t * Resets the rendering state of the renderer.\n\t * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n\t * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n\t * render will reset all internal caches and ensure it executes correctly.\n\t *\n\t * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n\t * ```js\n\t * // Reset Three.js state\n\t * threeRenderer.resetState();\n\t *\n\t * // Render a Three.js scene\n\t * threeRenderer.render(threeScene, threeCamera);\n\t *\n\t * // Reset PixiJS state since Three.js modified the WebGL context\n\t * pixiRenderer.resetState();\n\t *\n\t * // Now render Pixi content\n\t * pixiRenderer.render(pixiScene);\n\t * ```\n\t * @advanced\n\t */\n\tresetState(): void;\n}\ndeclare const DefaultWebGLSystems: (typeof BackgroundSystem | typeof GlobalUniformSystem | typeof HelloSystem | typeof ViewSystem | typeof RenderGroupSystem | typeof GCSystem | typeof TextureGCSystem | typeof GenerateTextureSystem | typeof ExtractSystem | typeof RendererInitHook | typeof RenderableGCSystem | typeof SchedulerSystem | typeof GlUboSystem | typeof GlBackBufferSystem | typeof GlContextSystem | typeof GlLimitsSystem | typeof GlBufferSystem | typeof GlTextureSystem | typeof GlRenderTargetSystem | typeof GlGeometrySystem | typeof GlUniformGroupSystem | typeof GlShaderSystem | typeof GlEncoderSystem | typeof GlStateSystem | typeof GlStencilSystem | typeof GlColorMaskSystem)[];\ndeclare const DefaultWebGLPipes: (typeof BlendModePipe | typeof BatcherPipe | typeof SpritePipe | typeof RenderGroupPipe | typeof AlphaMaskPipe | typeof StencilMaskPipe | typeof ColorMaskPipe | typeof CustomRenderPipe)[];\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems> & PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @internal\n */\nexport type WebGLPipes = ExtractSystemTypes<typeof DefaultWebGLPipes> & PixiMixins.RendererPipes & PixiMixins.WebGLPipes;\n/**\n * Options for WebGLRenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGLOptions extends SharedRendererOptions, ExtractRendererOptions<typeof DefaultWebGLSystems>, PixiMixins.WebGLOptions {\n}\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGLPipes, WebGLOptions, T>, WebGLSystems {\n}\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @property {GlUboSystem} ubo - UboSystem instance.\n * @property {GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {GlContextSystem} context - ContextSystem instance.\n * @property {GlBufferSystem} buffer - BufferSystem instance.\n * @property {GlTextureSystem} texture - TextureSystem instance.\n * @property {GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {GlShaderSystem} shader - ShaderSystem instance.\n * @property {GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {GlStateSystem} state - StateSystem instance.\n * @property {GlStencilSystem} stencil - StencilSystem instance.\n * @property {GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @extends AbstractRenderer\n * @standard\n */\nexport class WebGLRenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGLPipes, WebGLOptions, T> implements WebGLSystems {\n\tgl: GlRenderingContext;\n\tconstructor();\n}\n/**\n * A generic renderer that can be either a WebGL or WebGPU renderer.\n * @category rendering\n * @extends WebGLRenderer\n * @extends WebGPURenderer\n * @standard\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\n/**\n * Generic pipes for the renderer.\n * @category rendering\n * @advanced\n */\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * Options for the renderer.\n * @extends WebGLOptions\n * @extends WebGPUOptions\n * @category rendering\n * @standard\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {\n}\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n * @category rendering\n * @internal\n */\nexport enum RendererType {\n\t/** The WebGL renderer */\n\tWEBGL = 1,\n\t/** The WebGPU renderer */\n\tWEBGPU = 2,\n\t/** Either WebGL or WebGPU renderer */\n\tBOTH = 3\n}\n/**\n * The GPU power preference for the WebGPU context.\n * This is an optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n *\n * - `'high-performance'` will prioritize rendering performance over power consumption,\n * - `'low-power'` will prioritize power saving over rendering performance.\n * @category rendering\n * @advanced\n */\nexport type GpuPowerPreference = \"low-power\" | \"high-performance\"; /** @internal */\n/**\n * A resource that can have GPU data associated with it.\n * @category rendering\n * @advanced\n */\nexport interface GPUDataOwner<GPU_DATA extends GPUData = any> {\n\t_gpuData: Record<number, GPU_DATA>;\n\tunload: () => void;\n}\n/**\n * Data stored on a GC-managed resource.\n * @category rendering\n * @advanced\n */\nexport interface GCData {\n\t/** Index in the managed resources array */\n\tindex?: number;\n\t/** Type of the resource */\n\ttype: \"resource\" | \"renderable\";\n}\n/**\n * Interface for resources that can be garbage collected.\n * @category rendering\n * @advanced\n */\nexport interface GCable extends GPUDataOwner {\n\t/** Timestamp of last use */\n\t_gcLastUsed: number;\n\t/** GC tracking data, null if not being tracked */\n\t_gcData?: GCData | null;\n\t/** If set to true, the resource will be garbage collected automatically when it is not used. */\n\tautoGarbageCollect?: boolean;\n\t/** An optional callback for when an item is touched */\n\t_onTouch?(now: number): void;\n}\ntype GCableEventEmitter = GCable & Pick<EventEmitter, \"once\" | \"off\">;\ninterface GCResourceHashEntry {\n\tcontext: any;\n\thash: string;\n\ttype: GCData[\"type\"];\n\tpriority: number;\n}\n/**\n * Options for the {@link GCSystem}.\n * @category rendering\n * @advanced\n */\nexport interface GCSystemOptions {\n\t/**\n\t * If set to true, this will enable the garbage collector.\n\t * @default true\n\t */\n\tgcActive: boolean;\n\t/**\n\t * The maximum time in milliseconds a resource can be unused before being garbage collected.\n\t * @default 60000\n\t */\n\tgcMaxUnusedTime: number;\n\t/**\n\t * How frequently to run garbage collection in milliseconds.\n\t * @default 30000\n\t */\n\tgcFrequency: number;\n}\n/**\n * A unified garbage collection system for managing GPU resources.\n * Resources register themselves with a cleanup callback and are automatically\n * cleaned up when they haven't been used for a specified amount of time.\n * @example\n * ```ts\n * // Register a resource for GC\n * gc.addResource(myResource, () => {\n *     // cleanup logic here\n *     myResource.unload();\n * });\n *\n * // Touch the resource when used (resets idle timer)\n * gc.touch(myResource);\n *\n * // Remove from GC tracking (e.g., on manual destroy)\n * gc.removeResource(myResource);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GCSystem implements System<GCSystemOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"gc\";\n\t\treadonly priority: 0;\n\t};\n\t/** Default options for the GCSystem */\n\tstatic defaultOptions: GCSystemOptions;\n\t/** Maximum time in ms a resource can be unused before being garbage collected */\n\tmaxUnusedTime: number;\n\t/** Reference to the renderer this system belongs to */\n\tprivate _renderer;\n\t/** Array of resources being tracked for garbage collection */\n\tprivate readonly _managedResources;\n\tprivate readonly _managedResourceHashes;\n\t/** ID of the GC scheduler handler */\n\tprivate _handler;\n\t/** How frequently GC runs in ms */\n\tprivate _frequency;\n\t/** Current timestamp used for age calculations */\n\tnow: number;\n\tprivate _ready;\n\t/**\n\t * Creates a new GCSystem instance.\n\t * @param renderer - The renderer this garbage collection system works for\n\t */\n\tconstructor(renderer: Renderer);\n\t/**\n\t * Initializes the garbage collection system with the provided options.\n\t * @param options - Configuration options\n\t */\n\tinit(options: GCSystemOptions): void;\n\t/**\n\t * Gets whether the garbage collection system is currently enabled.\n\t * @returns True if GC is enabled, false otherwise\n\t */\n\tget enabled(): boolean;\n\t/**\n\t * Enables or disables the garbage collection system.\n\t * When enabled, schedules periodic cleanup of resources.\n\t * When disabled, cancels all scheduled cleanups.\n\t */\n\tset enabled(value: boolean);\n\t/**\n\t * Called before rendering. Updates the current timestamp.\n\t * @param options - The render options\n\t * @param options.container - The container to render\n\t */\n\tprotected prerender({ container }: RenderOptions): void;\n\t/** Performs garbage collection after rendering. */\n\tprotected postrender(): void;\n\t/**\n\t * Updates the GC tick counter for a render group and its children.\n\t * @param renderGroup - The render group to update\n\t * @param gcTick - The new tick value\n\t */\n\tprivate _updateInstructionGCTick;\n\t/**\n\t * Registers a resource for garbage collection tracking.\n\t * @param resource - The resource to track\n\t * @param type - The type of resource to track\n\t */\n\taddResource(resource: GCableEventEmitter, type: GCData[\"type\"]): void;\n\t/**\n\t * Removes a resource from garbage collection tracking.\n\t * Call this when manually destroying a resource.\n\t * @param resource - The resource to stop tracking\n\t */\n\tremoveResource(resource: GCable): void;\n\t/**\n\t * Registers a hash-based resource collection for garbage collection tracking.\n\t * Resources in the hash will be automatically tracked and cleaned up when unused.\n\t * @param context - The object containing the hash property\n\t * @param hash - The property name on context that holds the resource hash\n\t * @param type - The type of resources in the hash ('resource' or 'renderable')\n\t * @param priority - Processing priority (lower values are processed first)\n\t */\n\taddResourceHash(context: any, hash: string, type: GCData[\"type\"], priority?: number): void;\n\t/**\n\t * Performs garbage collection by cleaning up unused resources.\n\t * Removes resources that haven't been used for longer than maxUnusedTime.\n\t */\n\trun(): void;\n\tprotected updateRenderableGCTick(renderable: Renderable & GCable, now: number): void;\n\tprotected runOnResource(resource: GCableEventEmitter, now: number, writeIndex: number): number;\n\t/**\n\t * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n\t * @param hashValue - The original hash to clone from\n\t * @param stopKey - The key to stop at (exclusive)\n\t * @returns A new hash object with copied entries\n\t */\n\tprivate _createHashClone;\n\tprotected runOnHash(hashEntry: GCResourceHashEntry, now: number): void;\n\t/** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n\tdestroy(): void;\n}\n/**\n * A GPU Data object\n * @internal\n */\nexport interface GPUData {\n\tdestroy: () => void;\n}\n/** @internal */\nexport interface GPUDataContainer<GPU_DATA extends GPUData = any> {\n\t_gpuData: Record<number, GPU_DATA>;\n\tunload: () => void;\n}\n/**\n * Options for the construction of a ViewContainer.\n * @category scene\n * @advanced\n */\nexport interface ViewContainerOptions extends ContainerOptions, PixiMixins.ViewContainerOptions {\n\t/** If set to true, the resource will be garbage collected automatically when it is not used. */\n\tautoGarbageCollect?: boolean;\n}\nexport interface ViewContainer<GPU_DATA extends GPUData = any> extends PixiMixins.ViewContainer, Container, GPUDataOwner<GPU_DATA>, GCable {\n}\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @category scene\n * @advanced\n */\nexport abstract class ViewContainer<GPU_DATA extends GPUData = any> extends Container implements View, GCable {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/** @internal */\n\treadonly canBundle = true;\n\t/** @internal */\n\tallowChildren: boolean;\n\t/** @internal */\n\t_roundPixels: 0 | 1;\n\t/** @internal */\n\t_lastUsed: number;\n\t/** @internal */\n\t_gpuData: Record<number, GPU_DATA>;\n\t/** @internal */\n\t_gcData?: GCData;\n\t/** If set to true, the resource will be garbage collected automatically when it is not used. */\n\tautoGarbageCollect: boolean;\n\t/** @internal */\n\t_gcLastUsed: number;\n\tprotected _bounds: Bounds;\n\tprotected _boundsDirty: boolean;\n\t/**\n\t * The local bounds of the view in its own coordinate space.\n\t * Bounds are automatically updated when the view's content changes.\n\t * @example\n\t * ```ts\n\t * // Get bounds dimensions\n\t * const bounds = view.bounds;\n\t * console.log(`Width: ${bounds.maxX - bounds.minX}`);\n\t * console.log(`Height: ${bounds.maxY - bounds.minY}`);\n\t * ```\n\t * @returns The rectangular bounds of the view\n\t * @see {@link Bounds} For bounds operations\n\t */\n\tget bounds(): Bounds;\n\t/** @private */\n\tprotected abstract updateBounds(): void;\n\t/**\n\t * Whether or not to round the x/y position of the sprite.\n\t * @example\n\t * ```ts\n\t * // Enable pixel rounding for crisp rendering\n\t * view.roundPixels = true;\n\t * ```\n\t * @default false\n\t */\n\tget roundPixels(): boolean;\n\tset roundPixels(value: boolean);\n\tconstructor(options: ViewContainerOptions);\n\t/**\n\t * Checks if the object contains the given point in local coordinates.\n\t * Uses the view's bounds for hit testing.\n\t * @example\n\t * ```ts\n\t * // Basic point check\n\t * const localPoint = { x: 50, y: 25 };\n\t * const contains = view.containsPoint(localPoint);\n\t * console.log('Point is inside:', contains);\n\t * ```\n\t * @param point - The point to check in local coordinates\n\t * @returns True if the point is within the view's bounds\n\t * @see {@link ViewContainer#bounds} For the bounds used in hit testing\n\t * @see {@link Container#toLocal} For converting global coordinates to local\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/** @private */\n\tabstract batched: boolean;\n\t/** @private */\n\tprotected onViewUpdate(): void;\n\t/** Unloads the GPU data from the view. */\n\tunload(): void;\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * Collects renderables for the view container.\n\t * @param instructionSet - The instruction set to collect renderables for.\n\t * @param renderer - The renderer to collect renderables for.\n\t * @param currentLayer - The current render layer.\n\t * @internal\n\t */\n\tcollectRenderablesSimple(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n}\n/**\n * Represents a renderable object in the rendering system.\n * This is typically a view container that can be rendered to a target.\n * @internal\n */\nexport type Renderable = ViewContainer;\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @category rendering\n * @advanced\n */\nexport class InstructionSet {\n\t/** a unique id for this instruction set used through the renderer */\n\treadonly uid: number;\n\t/** the array of instructions */\n\treadonly instructions: Instruction[];\n\t/** the actual size of the array (any instructions passed this should be ignored) */\n\tinstructionSize: number;\n\t/** allows for access to the render pipes of the renderer */\n\trenderPipes: any;\n\trenderables: Renderable[];\n\t/** used by the garbage collector to track when the instruction set was last used */\n\tgcTick: number;\n\t/** reset the instruction set so it can be reused set size back to 0 */\n\treset(): void;\n\t/**\n\t * Destroy the instruction set, clearing the instructions and renderables.\n\t * @internal\n\t */\n\tdestroy(): void;\n\t/**\n\t * Add an instruction to the set\n\t * @param instruction - add an instruction to the set\n\t */\n\tadd(instruction: Instruction): void;\n\t/**\n\t * Log the instructions to the console (for debugging)\n\t * @internal\n\t */\n\tlog(): void;\n}\n/**\n * Options for configuring a RenderLayer. A RenderLayer allows control over rendering order\n * independent of the scene graph hierarchy.\n * @example\n * ```ts\n * // Basic layer with automatic sorting\n * const layer = new RenderLayer({\n *     sortableChildren: true\n * });\n *\n * // Layer with custom sort function\n * const customLayer = new RenderLayer({\n *     sortableChildren: true,\n *     sortFunction: (a, b) => {\n *         // Sort by y position\n *         return a.position.y - b.position.y;\n *     }\n * });\n *\n * // Add objects to layer while maintaining scene graph parent\n * const sprite = new Sprite(texture);\n * container.addChild(sprite);      // Add to scene graph\n * layer.attach(sprite);            // Add to render layer\n *\n * // Manual sorting when needed\n * const manualLayer = new RenderLayer({\n *     sortableChildren: false\n * });\n * manualLayer.attach(sprite1, sprite2);\n * manualLayer.sortRenderLayerChildren(); // Sort manually\n * ```\n * @category scene\n * @standard\n */\nexport interface RenderLayerOptions {\n\t/**\n\t * If true, the layer's children will be sorted by zIndex before rendering.\n\t * If false, you can manually sort the children using sortRenderLayerChildren when needed.\n\t * @default false\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer({\n\t *     sortableChildren: true // Automatically sorts children by zIndex\n\t * });\n\t * ```\n\t * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n\t * @see {@link RenderLayer#sortFunction} For customizing the sort logic\n\t * @see {@link Container#zIndex} For the default sort property\n\t */\n\tsortableChildren?: boolean;\n\t/**\n\t * Custom sort function to sort layer children. Default sorts by zIndex.\n\t * @param a - First container to compare\n\t * @param b - Second container to compare\n\t * @returns Negative if a should render before b, positive if b should render before a\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer({\n\t *     sortFunction: (a, b) => {\n\t *         // Sort by y position\n\t *         return a.position.y - b.position.y;\n\t *     }\n\t * });\n\t * ```\n\t * @see {@link RenderLayer#sortableChildren} For enabling automatic sorting\n\t * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n\t * @see {@link Container#zIndex} For the default sort property\n\t * @default (a, b) => a.zIndex - b.zIndex\n\t */\n\tsortFunction?: (a: Container, b: Container) => number;\n}\n/**\n * The RenderLayer API provides a way to control the rendering order of objects independently\n * of their logical parent-child relationships in the scene graph.\n * This allows developers to decouple how objects are transformed\n * (via their logical parent) from how they are rendered on the screen.\n *\n * ### Key Concepts\n *\n * #### RenderLayers Control Rendering Order:\n * - RenderLayers define where in the render stack objects are drawn,\n * but they do not affect an object's transformations (e.g., position, scale, rotation) or logical hierarchy.\n * - RenderLayers can be added anywhere in the scene graph.\n *\n * #### Logical Parenting Remains Unchanged:\n * - Objects still have a logical parent for transformations via addChild.\n * - Assigning an object to a layer does not reparent it.\n *\n * #### Explicit Control:\n * - Developers assign objects to layers using renderLayer.add and remove them using renderLayer.remove.\n * ---\n * ### API Details\n *\n * #### 1. Creating a RenderLayer\n * A RenderLayer is a lightweight object responsible for controlling render order.\n * It has no children or transformations of its own\n * but can be inserted anywhere in the scene graph to define its render position.\n * ```js\n * const layer = new RenderLayer();\n * app.stage.addChild(layer); // Insert the layer into the scene graph\n * ```\n *\n * #### 2. Adding Objects to a Layer\n * Use renderLayer.add to assign an object to a layer.\n * This overrides the object's default render order defined by its logical parent.\n * ```js\n * const rect = new Graphics();\n * container.addChild(rect);    // Add to logical parent\n * layer.attach(rect);      // Control render order via the layer\n * ```\n *\n * #### 3. Removing Objects from a Layer\n * To stop an object from being rendered in the layer, use remove.\n * ```js\n * layer.remove(rect); // Stop rendering rect via the layer\n * ```\n * When an object is removed from its logical parent (removeChild), it is automatically removed from the layer.\n *\n * #### 4. Re-Adding Objects to Layers\n * If an object is re-added to a logical parent, it does not automatically reassign itself to the layer.\n * Developers must explicitly reassign it.\n * ```js\n * container.addChild(rect);    // Logical parent\n * layer.attach(rect);      // Explicitly reassign to the layer\n * ```\n *\n * #### 5. Layer Position in Scene Graph\n * A layer's position in the scene graph determines its render priority relative to other layers and objects.\n * Layers can be inserted anywhere in the scene graph.\n * ```js\n * const backgroundLayer = new RenderLayer();\n * const uiLayer = new RenderLayer();\n *\n * app.stage.addChild(backgroundLayer);\n * app.stage.addChild(world);\n * app.stage.addChild(uiLayer);\n * ```\n * This is a new API and therefore considered experimental at this stage.\n * While the core is pretty robust, there are still a few tricky issues we need to tackle.\n * However, even with the known issues below, we believe this API is incredibly useful!\n *\n * Known issues:\n *  - Interaction may not work as expected since hit testing does not account for the visual render order created by layers.\n *    For example, if an object is visually moved to the front via a layer, hit testing will still use its original position.\n *  - RenderLayers and their children must all belong to the same renderGroup to work correctly\n * @category scene\n * @class\n * @extends null\n * @standard\n */\nexport class RenderLayer extends Container {\n\t/**\n\t * Default options for RenderLayer instances. These options control the sorting behavior\n\t * of objects within the render layer.\n\t * @example\n\t * ```ts\n\t * // Create a custom render layer with modified default options\n\t * RenderLayer.defaultOptions = {\n\t *     sortableChildren: true,\n\t *     sortFunction: (a, b) => a.y - b.y // Sort by vertical position\n\t * };\n\t *\n\t * // All new render layers will use these defaults\n\t * const layer1 = new RenderLayer();\n\t * // layer1 will have sortableChildren = true\n\t * ```\n\t * @property {boolean} sortableChildren -\n\t * @property {Function} sortFunction -\n\t * @see {@link RenderLayer} For the main render layer class\n\t * @see {@link Container#zIndex} For the default sort property\n\t * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n\t */\n\tstatic defaultOptions: RenderLayerOptions;\n\t/** Function used to sort layer children if sortableChildren is true */\n\tsortFunction: (a: Container, b: Container) => number;\n\t/**\n\t * The list of objects that this layer is responsible for rendering. Objects in this list maintain\n\t * their original parent in the scene graph but are rendered as part of this layer.\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer();\n\t * const sprite = new Sprite(texture);\n\t *\n\t * // Add sprite to scene graph for transforms\n\t * container.addChild(sprite);\n\t *\n\t * // Add to layer for render order control\n\t * layer.attach(sprite);\n\t * console.log(layer.renderLayerChildren.length); // 1\n\t *\n\t * // Access objects in the layer\n\t * layer.renderLayerChildren.forEach(child => {\n\t *     console.log('Layer child:', child);\n\t * });\n\t *\n\t * // Check if object is in layer\n\t * const isInLayer = layer.renderLayerChildren.includes(sprite);\n\t *\n\t * // Clear all objects from layer\n\t * layer.detachAll();\n\t * console.log(layer.renderLayerChildren.length); // 0\n\t * ```\n\t * @readonly\n\t * @see {@link RenderLayer#attach} For adding objects to the layer\n\t * @see {@link RenderLayer#detach} For removing objects from the layer\n\t * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n\t */\n\trenderLayerChildren: Container[];\n\t/** @internal */\n\tparent: Container | null;\n\t/** @internal */\n\tdidChange: boolean;\n\t/** @internal */\n\t_updateFlags: number;\n\t/** @internal */\n\tparentRenderLayer: null;\n\t/** @internal */\n\tdestroyed: boolean;\n\t/** @internal */\n\tlayerParentId: string;\n\t/**\n\t * If true, the layer's children will be sorted by zIndex before rendering.\n\t * If false, you can manually sort the children using sortRenderLayerChildren when needed.\n\t * @default false\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer({\n\t *     sortableChildren: true // Automatically sorts children by zIndex\n\t * });\n\t * ```\n\t * @see {@link RenderLayer#sortRenderLayerChildren} For manual sorting\n\t * @see {@link RenderLayer#sortFunction} For customizing the sort logic\n\t * @see {@link Container#zIndex} For the default sort property\n\t */\n\tsortableChildren: boolean;\n\t/**\n\t * Creates a new RenderLayer instance\n\t * @param options - Configuration options for the RenderLayer\n\t * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render\n\t * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex\n\t */\n\tconstructor(options?: RenderLayerOptions);\n\t/**\n\t * Adds one or more Containers to this render layer. The Containers will be rendered as part of this layer\n\t * while maintaining their original parent in the scene graph.\n\t *\n\t * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer();\n\t * const container = new Container();\n\t * const sprite1 = new Sprite(texture1);\n\t * const sprite2 = new Sprite(texture2);\n\t *\n\t * // Add sprites to scene graph for transforms\n\t * container.addChild(sprite1, sprite2);\n\t *\n\t * // Add sprites to layer for render order control\n\t * layer.attach(sprite1, sprite2);\n\t *\n\t * // Add single sprite with type checking\n\t * const typedSprite = layer.attach<Sprite>(new Sprite(texture3));\n\t * typedSprite.tint = 'red';\n\t *\n\t * // Automatically removes from previous layer if needed\n\t * const otherLayer = new RenderLayer();\n\t * otherLayer.attach(sprite1); // Removes from previous layer\n\t * ```\n\t * @param children - The Container(s) to add to this layer. Can be any Container or array of Containers.\n\t * @returns The first child that was added, for method chaining\n\t * @see {@link RenderLayer#detach} For removing objects from the layer\n\t * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n\t * @see {@link Container#addChild} For adding to scene graph hierarchy\n\t */\n\tattach<U extends Container[]>(...children: U): U[0];\n\t/**\n\t * Removes one or more Containers from this render layer. The Containers will maintain their\n\t * original parent in the scene graph but will no longer be rendered as part of this layer.\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer();\n\t * const container = new Container();\n\t * const sprite1 = new Sprite(texture1);\n\t * const sprite2 = new Sprite(texture2);\n\t *\n\t * // Add sprites to scene graph and layer\n\t * container.addChild(sprite1, sprite2);\n\t * layer.attach(sprite1, sprite2);\n\t *\n\t * // Remove single sprite from layer\n\t * layer.detach(sprite1);\n\t * // sprite1 is still child of container but not rendered in layer\n\t *\n\t * // Remove multiple sprites at once\n\t * const otherLayer = new RenderLayer();\n\t * otherLayer.attach(sprite3, sprite4);\n\t * otherLayer.detach(sprite3, sprite4);\n\t *\n\t * // Type-safe detachment\n\t * const typedSprite = layer.detach<Sprite>(spriteInLayer);\n\t * typedSprite.texture = newTexture; // TypeScript knows this is a Sprite\n\t * ```\n\t * @param children - The Container(s) to remove from this layer\n\t * @returns The first child that was removed, for method chaining\n\t * @see {@link RenderLayer#attach} For adding objects to the layer\n\t * @see {@link RenderLayer#detachAll} For removing all objects from the layer\n\t * @see {@link Container#removeChild} For removing from scene graph hierarchy\n\t */\n\tdetach<U extends Container[]>(...children: U): U[0];\n\t/**\n\t * Removes all objects from this render layer. Objects will maintain their\n\t * original parent in the scene graph but will no longer be rendered as part of this layer.\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer();\n\t * const container = new Container();\n\t *\n\t * // Add multiple sprites to scene graph and layer\n\t * const sprites = [\n\t *     new Sprite(texture1),\n\t *     new Sprite(texture2),\n\t *     new Sprite(texture3)\n\t * ];\n\t *\n\t * container.addChild(...sprites);  // Add to scene graph\n\t * layer.attach(...sprites);       // Add to render layer\n\t *\n\t * // Later, remove all sprites from layer at once\n\t * layer.detachAll();\n\t * console.log(layer.renderLayerChildren.length); // 0\n\t * console.log(container.children.length);        // 3 (still in scene graph)\n\t * ```\n\t * @returns The RenderLayer instance for method chaining\n\t * @see {@link RenderLayer#attach} For adding objects to the layer\n\t * @see {@link RenderLayer#detach} For removing individual objects\n\t * @see {@link Container#removeChildren} For removing from scene graph\n\t */\n\tdetachAll(): void;\n\t/**\n\t * Collects renderables for this layer and its children.\n\t * This method is called by the renderer to gather all objects that should be rendered in this layer.\n\t * @param instructionSet - The set of instructions to collect renderables into.\n\t * @param renderer - The renderer that is collecting renderables.\n\t * @param _currentLayer - The current render layer being processed.\n\t * @internal\n\t */\n\tcollectRenderables(instructionSet: InstructionSet, renderer: Renderer, _currentLayer: RenderLayer): void;\n\t/**\n\t * Sort the layer's children using the defined sort function. This method allows manual sorting\n\t * of layer children and is automatically called during rendering if sortableChildren is true.\n\t * @example\n\t * ```ts\n\t * const layer = new RenderLayer();\n\t *\n\t * // Add multiple sprites at different depths\n\t * const sprite1 = new Sprite(texture);\n\t * const sprite2 = new Sprite(texture);\n\t * const sprite3 = new Sprite(texture);\n\t *\n\t * sprite1.zIndex = 3;\n\t * sprite2.zIndex = 1;\n\t * sprite3.zIndex = 2;\n\t *\n\t * layer.attach(sprite1, sprite2, sprite3);\n\t *\n\t * // Manual sorting with default zIndex sort\n\t * layer.sortRenderLayerChildren();\n\t * // Order is now: sprite2 (1), sprite3 (2), sprite1 (3)\n\t *\n\t * // Custom sort by y position\n\t * layer.sortFunction = (a, b) => a.y - b.y;\n\t * layer.sortRenderLayerChildren();\n\t *\n\t * // Automatic sorting\n\t * layer.sortableChildren = true; // Will sort each render\n\t * ```\n\t * @returns The RenderLayer instance for method chaining\n\t * @see {@link RenderLayer#sortableChildren} For enabling automatic sorting\n\t * @see {@link RenderLayer#sortFunction} For customizing the sort logic\n\t */\n\tsortRenderLayerChildren(): void;\n\t/**\n\t * Recursively calculates the global bounds of this RenderLayer and its children.\n\t * @param factorRenderLayers\n\t * @param bounds\n\t * @param _currentLayer\n\t * @internal\n\t */\n\t_getGlobalBoundsRecursive(factorRenderLayers: boolean, bounds: Bounds, _currentLayer: RenderLayer): void;\n\t/**\n\t * @inheritdoc\n\t * @internal\n\t */\n\tgetFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error. Please use `RenderLayer.attach()` instead.\n\t * @param {...any} _children\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\taddChild<U extends Container[]>(..._children: U): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.\n\t * @param {...any} _children\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tremoveChild<U extends Container[]>(..._children: U): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error. Please use `RenderLayer.detach()` instead.\n\t * @param {number} [_beginIndex]\n\t * @param {number} [_endIndex]\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tremoveChildren(_beginIndex?: number, _endIndex?: number): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tremoveChildAt(_index: number): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tgetChildAt(_index: number): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param {Container} _child\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tsetChildIndex(_child: Container, _index: number): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param {Container} _child\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tgetChildIndex(_child: Container): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param {Container} _child\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\taddChildAt<U extends Container>(_child: U, _index: number): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param {Container} _child\n\t * @param {Container} _child2\n\t * @ignore\n\t */\n\tswapChildren<U extends Container>(_child: U, _child2: U): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param _child - The child to reparent\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\treparentChild(..._child: Container[]): never;\n\t/**\n\t * This method is not available in RenderLayer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param _child - The child to reparent\n\t * @param _index - The index to reparent the child to\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\treparentChildAt(_child: Container, _index: number): never;\n}\n/**\n * The type of child that can be added to a {@link Container}.\n * This is a generic type that extends the {@link Container} class.\n * @category scene\n * @standard\n */\nexport type ContainerChild = Container;\n/**\n * Events that can be emitted by a Container. These events provide lifecycle hooks and notifications\n * for container state changes.\n * @example\n * ```ts\n * import { Container, Sprite } from 'pixi.js';\n *\n * // Setup container with event listeners\n * const container = new Container();\n *\n * // Listen for child additions\n * container.on('childAdded', (child, container, index) => {\n *     console.log(`Child added at index ${index}:`, child);\n * });\n *\n * // Listen for child removals\n * container.on('childRemoved', (child, container, index) => {\n *     console.log(`Child removed from index ${index}:`, child);\n * });\n *\n * // Listen for when container is added to parent\n * container.on('added', (parent) => {\n *     console.log('Added to parent:', parent);\n * });\n *\n * // Listen for when container is removed from parent\n * container.on('removed', (parent) => {\n *     console.log('Removed from parent:', parent);\n * });\n *\n * // Listen for container destruction\n * container.on('destroyed', (container) => {\n *     console.log('Container destroyed:', container);\n * });\n * ```\n * @category scene\n * @standard\n */\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents {\n\t/**\n\t * Emitted when this container is added to a new container.\n\t * Useful for setting up parent-specific behaviors.\n\t * @param container - The parent container this was added to\n\t * @example\n\t * ```ts\n\t * const child = new Container();\n\t * child.on('added', (parent) => {\n\t *     console.log('Child added to parent:', parent.label);\n\t * });\n\t * parentContainer.addChild(child);\n\t * ```\n\t */\n\tadded: [\n\t\tcontainer: Container\n\t];\n\t/**\n\t * Emitted when a child is added to this container.\n\t * Useful for tracking container composition changes.\n\t * @param child - The child that was added\n\t * @param container - The container the child was added to (this container)\n\t * @param index - The index at which the child was added\n\t * @example\n\t * ```ts\n\t * const parent = new Container();\n\t * parent.on('childAdded', (child, container, index) => {\n\t *     console.log(`New child at index ${index}:`, child);\n\t * });\n\t * ```\n\t */\n\tchildAdded: [\n\t\tchild: C,\n\t\tcontainer: Container,\n\t\tindex: number\n\t];\n\t/**\n\t * Emitted when this container is removed from its parent.\n\t * Useful for cleanup and state management.\n\t * @param container - The parent container this was removed from\n\t * @example\n\t * ```ts\n\t * const child = new Container();\n\t * child.on('removed', (oldParent) => {\n\t *     console.log('Child removed from parent:', oldParent.label);\n\t * });\n\t * ```\n\t */\n\tremoved: [\n\t\tcontainer: Container\n\t];\n\t/**\n\t * Emitted when a child is removed from this container.\n\t * Useful for cleanup and maintaining container state.\n\t * @param child - The child that was removed\n\t * @param container - The container the child was removed from (this container)\n\t * @param index - The index from which the child was removed\n\t * @example\n\t * ```ts\n\t * const parent = new Container();\n\t * parent.on('childRemoved', (child, container, index) => {\n\t *     console.log(`Child removed from index ${index}:`, child);\n\t * });\n\t * ```\n\t */\n\tchildRemoved: [\n\t\tchild: C,\n\t\tcontainer: Container,\n\t\tindex: number\n\t];\n\t/**\n\t * Emitted when the container is destroyed.\n\t * Useful for final cleanup and resource management.\n\t * @param container - The container that was destroyed\n\t * @example\n\t * ```ts\n\t * const container = new Container();\n\t * container.on('destroyed', (container) => {\n\t *     console.log('Container destroyed:', container.label);\n\t * });\n\t * ```\n\t */\n\tdestroyed: [\n\t\tcontainer: Container\n\t];\n}\ntype AnyEvent = {\n\t[K: ({} & string) | ({} & symbol)]: any;\n};\n/** @internal */\nexport const UPDATE_COLOR = 1;\n/** @internal */\nexport const UPDATE_BLEND = 2;\n/** @internal */\nexport const UPDATE_VISIBLE = 4;\n/** @internal */\nexport const UPDATE_TRANSFORM = 8;\n/**\n * Options for updating the transform of a container.\n * @category scene\n * @standard\n */\nexport interface UpdateTransformOptions {\n\tx: number;\n\ty: number;\n\tscaleX: number;\n\tscaleY: number;\n\trotation: number;\n\tskewX: number;\n\tskewY: number;\n\tpivotX: number;\n\tpivotY: number;\n\toriginX: number;\n\toriginY: number;\n}\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @category scene\n * @standard\n * @see Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions {\n\t/** @see Container#isRenderGroup */\n\tisRenderGroup?: boolean;\n\t/**\n\t * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n\t *\n\t * Setting to 'normal' will reset to default blending.\n\t * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n\t * @example\n\t * ```ts\n\t * // Basic blend modes\n\t * new Container({ blendMode: 'normal' }); // Default blending\n\t * new Container({ blendMode: 'add' });    // Additive blending\n\t * new Container({ blendMode: 'multiply' }); // Multiply colors\n\t * new Container({ blendMode: 'screen' }); // Screen blend\n\t * ```\n\t * @default 'normal'\n\t * @see {@link Container#alpha} For transparency\n\t * @see {@link Container#tint} For color adjustments\n\t */\n\tblendMode?: BLEND_MODES;\n\t/**\n\t * The tint applied to the sprite.\n\t *\n\t * This can be any valid {@link ColorSource}.\n\t * @example\n\t * ```ts\n\t * new Container({ tint: 0xff0000 }); // Red tint\n\t * new Container({ tint: 'blue' }); // Blue tint\n\t * new Container({ tint: '#00ff00' }); // Green tint\n\t * new Container({ tint: 'rgb(0,0,255)' }); // Blue tint\n\t * ```\n\t * @default 0xFFFFFF\n\t * @see {@link Container#alpha} For transparency\n\t * @see {@link Container#visible} For visibility control\n\t */\n\ttint?: ColorSource;\n\t/**\n\t * The opacity of the object relative to its parent's opacity.\n\t * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n\t * @example\n\t * ```ts\n\t * new Container({ alpha: 0.5 }); // 50% opacity\n\t * new Container({ alpha: 1 }); // Fully opaque\n\t * ```\n\t * @default 1\n\t * @see {@link Container#visible} For toggling visibility\n\t * @see {@link Container#renderable} For render control\n\t */\n\talpha?: number;\n\t/**\n\t * The angle of the object in degrees.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * ```ts\n\t * new Container({ angle: 45 }); // Rotate 45 degrees\n\t * new Container({ angle: 90 }); // Rotate 90 degrees\n\t * ```\n\t */\n\tangle?: number;\n\t/**\n\t * The array of children of this container. Each child must be a Container or extend from it.\n\t *\n\t * The array is read-only, but its contents can be modified using Container methods.\n\t * @example\n\t * ```ts\n\t * new Container({\n\t *    children: [\n\t *        new Container(), // First child\n\t *        new Container(), // Second child\n\t *    ],\n\t * });\n\t * ```\n\t * @readonly\n\t * @see {@link Container#addChild} For adding children\n\t * @see {@link Container#removeChild} For removing children\n\t */\n\tchildren?: C[];\n\t/**\n\t * The display object container that contains this display object.\n\t * This represents the parent-child relationship in the display tree.\n\t * @readonly\n\t * @see {@link Container#addChild} For adding to a parent\n\t * @see {@link Container#removeChild} For removing from parent\n\t */\n\tparent?: Container;\n\t/**\n\t * Controls whether this object can be rendered. If false the object will not be drawn,\n\t * but the transform will still be updated. This is different from visible, which skips\n\t * transform updates.\n\t * @example\n\t * ```ts\n\t * new Container({ renderable: false }); // Will not be drawn, but transforms will update\n\t * ```\n\t * @default true\n\t * @see {@link Container#visible} For skipping transform updates\n\t * @see {@link Container#alpha} For transparency\n\t */\n\trenderable?: boolean;\n\t/**\n\t * The rotation of the object in radians.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * ```ts\n\t * new Container({ rotation: Math.PI / 4 }); // Rotate 45 degrees\n\t * new Container({ rotation: Math.PI / 2 }); // Rotate 90 degrees\n\t * ```\n\t */\n\trotation?: number;\n\t/**\n\t * The scale factors of this object along the local coordinate axes.\n\t *\n\t * The default scale is (1, 1).\n\t * @example\n\t * ```ts\n\t * new Container({ scale: new Point(2, 2) }); // Scale by 2x\n\t * new Container({ scale: 0.5 }); // Scale by 0.5x\n\t * new Container({ scale: { x: 1.5, y: 1.5 } }); // Scale by 1.5x\n\t * ```\n\t */\n\tscale?: PointData | number;\n\t/**\n\t * The center of rotation, scaling, and skewing for this display object in its local space.\n\t * The `position` is the projection of `pivot` in the parent's local space.\n\t *\n\t * By default, the pivot is the origin (0, 0).\n\t * @example\n\t * ```ts\n\t * new Container({ pivot: new Point(100, 200) }); // Set pivot to (100, 200)\n\t * new Container({ pivot: 50 }); // Set pivot to (50, 50)\n\t * new Container({ pivot: { x: 150, y: 150 } }); // Set pivot to (150, 150)\n\t * ```\n\t */\n\tpivot?: PointData | number;\n\t/**\n\t * The origin point around which the container rotates and scales.\n\t * Unlike pivot, changing origin will not move the container's position.\n\t * @example\n\t * ```ts\n\t * new Container({ origin: new Point(100, 100) }); // Rotate around point (100,100)\n\t * new Container({ origin: 50 }); // Rotate around point (50, 50)\n\t * new Container({ origin: { x: 150, y: 150 } }); // Rotate around point (150, 150)\n\t * ```\n\t */\n\torigin?: PointData | number;\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t * @example\n\t * ```ts\n\t * new Container({ position: new Point(100, 200) }); // Set position to (100, 200)\n\t * new Container({ position: { x: 150, y: 150 } }); // Set position to (150, 150)\n\t * ```\n\t */\n\tposition?: PointData;\n\t/**\n\t * The skew factor for the object in radians. Skewing is a transformation that distorts\n\t * the object by rotating it differently at each point, creating a non-uniform shape.\n\t * @example\n\t * ```ts\n\t * new Container({ skew: new Point(0.1, 0.2) }); // Skew by 0.1 radians on x and 0.2 radians on y\n\t * new Container({ skew: { x: 0.1, y: 0.2 } }); // Skew by 0.1 radians on x and 0.2 radians on y\n\t * ```\n\t * @default { x: 0, y: 0 }\n\t */\n\tskew?: PointData;\n\t/**\n\t * The visibility of the object. If false the object will not be drawn,\n\t * and the transform will not be updated.\n\t * @example\n\t * ```ts\n\t * new Container({ visible: false }); // Will not be drawn and transforms will not update\n\t * new Container({ visible: true }); // Will be drawn and transforms will update\n\t * ```\n\t * @default true\n\t * @see {@link Container#renderable} For render-only control\n\t * @see {@link Container#alpha} For transparency\n\t */\n\tvisible?: boolean;\n\t/**\n\t * The position of the container on the x axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.x\n\t * @example\n\t * ```ts\n\t * new Container({ x: 100 }); // Set x position to 100\n\t * ```\n\t */\n\tx?: number;\n\t/**\n\t * The position of the container on the y axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.y\n\t * @example\n\t * ```ts\n\t * new Container({ y: 200 }); // Set y position to 200\n\t * ```\n\t */\n\ty?: number;\n\t/**\n\t * An optional bounds area for this container. Setting this rectangle will stop the renderer\n\t * from recursively measuring the bounds of each children and instead use this single boundArea.\n\t *\n\t * > [!IMPORTANT] This is great for optimisation! If for example you have a\n\t * > 1000 spinning particles and you know they all sit within a specific bounds,\n\t * > then setting it will mean the renderer will not need to measure the\n\t * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n\t * @example\n\t * ```ts\n\t * const container = new Container({\n\t *    boundsArea: new Rectangle(0, 0, 500, 500) // Set a fixed bounds area\n\t * });\n\t * ```\n\t */\n\tboundsArea?: Rectangle;\n}\nexport interface Container<C extends ContainerChild> extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {\n}\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link Container#localTransform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *          and \"skew.y\" is , then the line x = 0 will be rotated by  (y = -x*cot) and the line y = 0 will be\n *         rotated by  (y = x*tan). A line y = x*tan (i.e. a line at angle  to the x-axis in local-space) will\n *         be rotated by an angle between  and .\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = - and \"skew.y\" = , it will produce an equivalent of \"rotation\" = .\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJSs rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @category scene\n * @standard\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent> {\n\t/**\n\t * Mixes all enumerable properties and methods from a source object to Container.\n\t * @param source - The source of properties and methods to mix in.\n\t * @deprecated since 8.8.0\n\t */\n\tstatic mixin(source: Dict<any>): void;\n\t/**\n\t * unique id for this container\n\t * @internal\n\t */\n\treadonly uid: number;\n\t/** @private */\n\t_updateFlags: number;\n\t/** @private */\n\trenderGroup: RenderGroup;\n\t/** @private */\n\tparentRenderGroup: RenderGroup;\n\t/** @private */\n\tparentRenderGroupIndex: number;\n\t/** @private */\n\tdidChange: boolean;\n\t/** @private */\n\tdidViewUpdate: boolean;\n\t/** @private */\n\trelativeRenderGroupDepth: number;\n\t/**\n\t * The array of children of this container. Each child must be a Container or extend from it.\n\t *\n\t * The array is read-only, but its contents can be modified using Container methods.\n\t * @example\n\t * ```ts\n\t * // Access children\n\t * const firstChild = container.children[0];\n\t * const lastChild = container.children[container.children.length - 1];\n\t * ```\n\t * @readonly\n\t * @see {@link Container#addChild} For adding children\n\t * @see {@link Container#removeChild} For removing children\n\t */\n\tchildren: C[];\n\t/**\n\t * The display object container that contains this display object.\n\t * This represents the parent-child relationship in the display tree.\n\t * @example\n\t * ```ts\n\t * // Basic parent access\n\t * const parent = sprite.parent;\n\t *\n\t * // Walk up the tree\n\t * let current = sprite;\n\t * while (current.parent) {\n\t *     console.log('Level up:', current.parent.constructor.name);\n\t *     current = current.parent;\n\t * }\n\t * ```\n\t * @readonly\n\t * @see {@link Container#addChild} For adding to a parent\n\t * @see {@link Container#removeChild} For removing from parent\n\t */\n\tparent: Container | null;\n\t/** @private */\n\tincludeInBuild: boolean;\n\t/** @private */\n\tmeasurable: boolean;\n\t/** @private */\n\tisSimple: boolean;\n\t/**\n\t * The RenderLayer this container belongs to, if any.\n\t * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.\n\t * @readonly\n\t * @advanced\n\t */\n\tparentRenderLayer: RenderLayer | null;\n\t/** @internal */\n\tupdateTick: number;\n\t/**\n\t * Current transform of the object based on local factors: position, scale, other stuff.\n\t * This matrix represents the local transformation without any parent influence.\n\t * @example\n\t * ```ts\n\t * // Basic transform access\n\t * const localMatrix = sprite.localTransform;\n\t * console.log(localMatrix.toString());\n\t * ```\n\t * @readonly\n\t * @see {@link Container#worldTransform} For global transform\n\t * @see {@link Container#groupTransform} For render group transform\n\t */\n\tlocalTransform: Matrix;\n\t/**\n\t * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n\t * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n\t * If this container is is self a render group matrix will be relative to its parent render group\n\t * @readonly\n\t * @advanced\n\t */\n\trelativeGroupTransform: Matrix;\n\t/**\n\t * The group transform is a transform relative to the render group it belongs too.\n\t * If this container is render group then this will be an identity matrix. other wise it\n\t * will be the same as the relativeGroupTransform.\n\t * Use this value when actually rendering things to the screen\n\t * @readonly\n\t * @advanced\n\t */\n\tgroupTransform: Matrix;\n\tprivate _worldTransform;\n\t/**\n\t * Whether this object has been destroyed. If true, the object should no longer be used.\n\t * After an object is destroyed, all of its functionality is disabled and references are removed.\n\t * @example\n\t * ```ts\n\t * // Cleanup with destroy\n\t * sprite.destroy();\n\t * console.log(sprite.destroyed); // true\n\t * ```\n\t * @default false\n\t * @see {@link Container#destroy} For destroying objects\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t * @internal\n\t */\n\t_position: ObservablePoint;\n\t/**\n\t * The scale factor of the object.\n\t * @internal\n\t */\n\t_scale: ObservablePoint;\n\t/**\n\t * The pivot point of the container that it rotates around.\n\t * @internal\n\t */\n\t_pivot: ObservablePoint;\n\t/**\n\t * The origin point around which the container rotates and scales.\n\t * Unlike pivot, changing origin will not move the container's position.\n\t * @private\n\t */\n\t_origin: ObservablePoint;\n\t/**\n\t * The skew amount, on the x and y axis.\n\t * @internal\n\t */\n\t_skew: ObservablePoint;\n\t/**\n\t * The X-coordinate value of the normalized local X axis,\n\t * the first column of the local transformation matrix without a scale.\n\t * @internal\n\t */\n\t_cx: number;\n\t/**\n\t * The Y-coordinate value of the normalized local X axis,\n\t * the first column of the local transformation matrix without a scale.\n\t * @internal\n\t */\n\t_sx: number;\n\t/**\n\t * The X-coordinate value of the normalized local Y axis,\n\t * the second column of the local transformation matrix without a scale.\n\t * @internal\n\t */\n\t_cy: number;\n\t/**\n\t * The Y-coordinate value of the normalized local Y axis,\n\t * the second column of the local transformation matrix without a scale.\n\t * @internal\n\t */\n\t_sy: number;\n\t/**\n\t * The rotation amount.\n\t * @internal\n\t */\n\tprivate _rotation;\n\t/** @internal */\n\tlocalColor: number;\n\t/** @internal */\n\tlocalAlpha: number;\n\t/** @internal */\n\tgroupAlpha: number;\n\t/** @internal */\n\tgroupColor: number;\n\t/** @internal */\n\tgroupColorAlpha: number;\n\t/** @internal */\n\tlocalBlendMode: BLEND_MODES;\n\t/** @internal */\n\tgroupBlendMode: BLEND_MODES;\n\t/**\n\t * This property holds three bits: culled, visible, renderable\n\t * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n\t * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n\t * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n\t * @internal\n\t */\n\tlocalDisplayStatus: number;\n\t/** @internal */\n\tglobalDisplayStatus: number;\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/**\n\t * An optional bounds area for this container. Setting this rectangle will stop the renderer\n\t * from recursively measuring the bounds of each children and instead use this single boundArea.\n\t *\n\t * > [!IMPORTANT] This is great for optimisation! If for example you have a\n\t * > 1000 spinning particles and you know they all sit within a specific bounds,\n\t * > then setting it will mean the renderer will not need to measure the\n\t * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n\t * @example\n\t * ```ts\n\t * const container = new Container();\n\t * container.boundsArea = new Rectangle(0, 0, 500, 500);\n\t * ```\n\t */\n\tboundsArea: Rectangle;\n\t/**\n\t * A value that increments each time the containe is modified\n\t * eg children added, removed etc\n\t * @ignore\n\t */\n\t_didContainerChangeTick: number;\n\t/**\n\t * A value that increments each time the container view is modified\n\t * eg texture swap, geometry change etc\n\t * @ignore\n\t */\n\t_didViewChangeTick: number;\n\t/** @internal */\n\tlayerParentId: string;\n\t/**\n\t * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n\t * @deprecated since 8.2.6\n\t * @ignore\n\t */\n\tset _didChangeId(value: number);\n\t/** @ignore */\n\tget _didChangeId(): number;\n\t/**\n\t * property that tracks if the container transform has changed\n\t * @ignore\n\t */\n\tprivate _didLocalTransformChangeId;\n\tconstructor(options?: ContainerOptions<C>);\n\t/**\n\t * Adds one or more children to the container.\n\t * The children will be rendered as part of this container's display list.\n\t * @example\n\t * ```ts\n\t * // Add a single child\n\t * container.addChild(sprite);\n\t *\n\t * // Add multiple children\n\t * container.addChild(background, player, foreground);\n\t *\n\t * // Add with type checking\n\t * const sprite = container.addChild<Sprite>(new Sprite(texture));\n\t * sprite.tint = 'red';\n\t * ```\n\t * @param children - The Container(s) to add to the container\n\t * @returns The first child that was added\n\t * @see {@link Container#removeChild} For removing children\n\t * @see {@link Container#addChildAt} For adding at specific index\n\t */\n\taddChild<U extends C[]>(...children: U): U[0];\n\t/**\n\t * Removes one or more children from the container.\n\t * When removing multiple children, events will be triggered for each child in sequence.\n\t * @example\n\t * ```ts\n\t * // Remove a single child\n\t * const removed = container.removeChild(sprite);\n\t *\n\t * // Remove multiple children\n\t * const bg = container.removeChild(background, player, userInterface);\n\t *\n\t * // Remove with type checking\n\t * const sprite = container.removeChild<Sprite>(childSprite);\n\t * sprite.texture = newTexture;\n\t * ```\n\t * @param children - The Container(s) to remove\n\t * @returns The first child that was removed\n\t * @see {@link Container#addChild} For adding children\n\t * @see {@link Container#removeChildren} For removing multiple children\n\t */\n\tremoveChild<U extends C[]>(...children: U): U[0];\n\t/** @ignore */\n\t_onUpdate(point?: ObservablePoint): void;\n\tset isRenderGroup(value: boolean);\n\t/**\n\t * Returns true if this container is a render group.\n\t * This means that it will be rendered as a separate pass, with its own set of instructions\n\t * @advanced\n\t */\n\tget isRenderGroup(): boolean;\n\t/**\n\t * Calling this enables a render group for this container.\n\t * This means it will be rendered as a separate set of instructions.\n\t * The transform of the container will also be handled on the GPU rather than the CPU.\n\t * @advanced\n\t */\n\tenableRenderGroup(): void;\n\t/**\n\t * This will disable the render group for this container.\n\t * @advanced\n\t */\n\tdisableRenderGroup(): void;\n\t/** @ignore */\n\t_updateIsSimple(): void;\n\t/**\n\t * Current transform of the object based on world (parent) factors.\n\t *\n\t * This matrix represents the absolute transformation in the scene graph.\n\t * @example\n\t * ```ts\n\t * // Get world position\n\t * const worldPos = container.worldTransform;\n\t * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);\n\t * ```\n\t * @readonly\n\t * @see {@link Container#localTransform} For local space transform\n\t */\n\tget worldTransform(): Matrix;\n\t/**\n\t * The position of the container on the x axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.x\n\t * @example\n\t * ```ts\n\t * // Basic position\n\t * container.x = 100;\n\t * ```\n\t */\n\tget x(): number;\n\tset x(value: number);\n\t/**\n\t * The position of the container on the y axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.y\n\t * @example\n\t * ```ts\n\t * // Basic position\n\t * container.y = 200;\n\t * ```\n\t */\n\tget y(): number;\n\tset y(value: number);\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t * @example\n\t * ```ts\n\t * // Basic position setting\n\t * container.position.set(100, 200);\n\t * container.position.set(100); // Sets both x and y to 100\n\t * // Using point data\n\t * container.position = { x: 50, y: 75 };\n\t * ```\n\t * @since 4.0.0\n\t */\n\tget position(): ObservablePoint;\n\tset position(value: PointData);\n\t/**\n\t * The rotation of the object in radians.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * ```ts\n\t * // Basic rotation\n\t * container.rotation = Math.PI / 4; // 45 degrees\n\t *\n\t * // Convert from degrees\n\t * const degrees = 45;\n\t * container.rotation = degrees * Math.PI / 180;\n\t *\n\t * // Rotate around center\n\t * container.pivot.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // 180 degrees\n\t *\n\t * // Rotate around center with origin\n\t * container.origin.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // 180 degrees\n\t * ```\n\t */\n\tget rotation(): number;\n\tset rotation(value: number);\n\t/**\n\t * The angle of the object in degrees.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * ```ts\n\t * // Basic angle rotation\n\t * sprite.angle = 45; // 45 degrees\n\t *\n\t * // Rotate around center\n\t * sprite.pivot.set(sprite.width / 2, sprite.height / 2);\n\t * sprite.angle = 180; // Half rotation\n\t *\n\t * // Rotate around center with origin\n\t * sprite.origin.set(sprite.width / 2, sprite.height / 2);\n\t * sprite.angle = 180; // Half rotation\n\t *\n\t * // Reset rotation\n\t * sprite.angle = 0;\n\t * ```\n\t */\n\tget angle(): number;\n\tset angle(value: number);\n\t/**\n\t * The center of rotation, scaling, and skewing for this display object in its local space.\n\t * The `position` is the projection of `pivot` in the parent's local space.\n\t *\n\t * By default, the pivot is the origin (0, 0).\n\t * @example\n\t * ```ts\n\t * // Rotate around center\n\t * container.pivot.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // Rotates around center\n\t * ```\n\t * @since 4.0.0\n\t */\n\tget pivot(): ObservablePoint;\n\tset pivot(value: PointData | number);\n\t/**\n\t * The skew factor for the object in radians. Skewing is a transformation that distorts\n\t * the object by rotating it differently at each point, creating a non-uniform shape.\n\t * @example\n\t * ```ts\n\t * // Basic skewing\n\t * container.skew.set(0.5, 0); // Skew horizontally\n\t * container.skew.set(0, 0.5); // Skew vertically\n\t *\n\t * // Skew with point data\n\t * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew\n\t *\n\t * // Reset skew\n\t * container.skew.set(0, 0);\n\t *\n\t * // Animate skew\n\t * app.ticker.add(() => {\n\t *     // Create wave effect\n\t *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;\n\t * });\n\t *\n\t * // Combine with rotation\n\t * container.rotation = Math.PI / 4; // 45 degrees\n\t * container.skew.set(0.2, 0.2); // Skew the rotated object\n\t * ```\n\t * @since 4.0.0\n\t * @type {ObservablePoint} Point-like object with x/y properties in radians\n\t * @default {x: 0, y: 0}\n\t */\n\tget skew(): ObservablePoint;\n\tset skew(value: PointData);\n\t/**\n\t * The scale factors of this object along the local coordinate axes.\n\t *\n\t * The default scale is (1, 1).\n\t * @example\n\t * ```ts\n\t * // Basic scaling\n\t * container.scale.set(2, 2); // Scales to double size\n\t * container.scale.set(2); // Scales uniformly to double size\n\t * container.scale = 2; // Scales uniformly to double size\n\t * // Scale to a specific width and height\n\t * container.setSize(200, 100); // Sets width to 200 and height to 100\n\t * ```\n\t * @since 4.0.0\n\t */\n\tget scale(): ObservablePoint;\n\tset scale(value: PointData | number | string);\n\t/**\n\t * @experimental\n\t * The origin point around which the container rotates and scales without affecting its position.\n\t * Unlike pivot, changing the origin will not move the container's position.\n\t * @example\n\t * ```ts\n\t * // Rotate around center point\n\t * container.origin.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // Rotates around center\n\t *\n\t * // Reset origin\n\t * container.origin.set(0, 0);\n\t * ```\n\t */\n\tget origin(): ObservablePoint;\n\tset origin(value: PointData | number);\n\t/**\n\t * The width of the Container, setting this will actually modify the scale to achieve the value set.\n\t * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.\n\t * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n\t * as it is more optimized by not recalculating the local bounds twice.\n\t * @example\n\t * ```ts\n\t * // Basic width setting\n\t * container.width = 100;\n\t * // Optimized width setting\n\t * container.setSize(100, 100);\n\t * ```\n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height of the Container,\n\t * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.\n\t * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n\t * as it is more optimized by not recalculating the local bounds twice.\n\t * @example\n\t * ```ts\n\t * // Basic height setting\n\t * container.height = 200;\n\t * // Optimized height setting\n\t * container.setSize(100, 200);\n\t * ```\n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * Retrieves the size of the container as a [Size]{@link Size} object.\n\t *\n\t * This is faster than get the width and height separately.\n\t * @example\n\t * ```ts\n\t * // Basic size retrieval\n\t * const size = container.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * container.getSize(reuseSize);\n\t * ```\n\t * @param out - Optional object to store the size in.\n\t * @returns The size of the container.\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Sets the size of the container to the specified width and height.\n\t * This is more efficient than setting width and height separately as it only recalculates bounds once.\n\t * @example\n\t * ```ts\n\t * // Basic size setting\n\t * container.setSize(100, 200);\n\t *\n\t * // Set uniform size\n\t * container.setSize(100); // Sets both width and height to 100\n\t * ```\n\t * @param value - This can be either a number or a [Size]{@link Size} object.\n\t * @param height - The height to set. Defaults to the value of `width` if not provided.\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n\t/** Called when the skew or the rotation changes. */\n\tprivate _updateSkew;\n\t/**\n\t * Updates the transform properties of the container.\n\t * Allows partial updates of transform properties for optimized manipulation.\n\t * @example\n\t * ```ts\n\t * // Basic transform update\n\t * container.updateTransform({\n\t *     x: 100,\n\t *     y: 200,\n\t *     rotation: Math.PI / 4\n\t * });\n\t *\n\t * // Scale and rotate around center\n\t * sprite.updateTransform({\n\t *     pivotX: sprite.width / 2,\n\t *     pivotY: sprite.height / 2,\n\t *     scaleX: 2,\n\t *     scaleY: 2,\n\t *     rotation: Math.PI\n\t * });\n\t *\n\t * // Update position only\n\t * button.updateTransform({\n\t *     x: button.x + 10, // Move right\n\t *     y: button.y      // Keep same y\n\t * });\n\t * ```\n\t * @param opts - Transform options to update\n\t * @param opts.x - The x position\n\t * @param opts.y - The y position\n\t * @param opts.scaleX - The x-axis scale factor\n\t * @param opts.scaleY - The y-axis scale factor\n\t * @param opts.rotation - The rotation in radians\n\t * @param opts.skewX - The x-axis skew factor\n\t * @param opts.skewY - The y-axis skew factor\n\t * @param opts.pivotX - The x-axis pivot point\n\t * @param opts.pivotY - The y-axis pivot point\n\t * @returns This container, for chaining\n\t * @see {@link Container#setFromMatrix} For matrix-based transforms\n\t * @see {@link Container#position} For direct position access\n\t */\n\tupdateTransform(opts: Partial<UpdateTransformOptions>): this;\n\t/**\n\t * Updates the local transform properties by decomposing the given matrix.\n\t * Extracts position, scale, rotation, and skew from a transformation matrix.\n\t * @example\n\t * ```ts\n\t * // Basic matrix transform\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4)\n\t *     .scale(2, 2);\n\t *\n\t * container.setFromMatrix(matrix);\n\t *\n\t * // Copy transform from another container\n\t * const source = new Container();\n\t * source.position.set(100, 100);\n\t * source.rotation = Math.PI / 2;\n\t *\n\t * target.setFromMatrix(source.localTransform);\n\t *\n\t * // Reset transform\n\t * container.setFromMatrix(Matrix.IDENTITY);\n\t * ```\n\t * @param matrix - The matrix to use for updating the transform\n\t * @see {@link Container#updateTransform} For property-based updates\n\t * @see {@link Matrix#decompose} For matrix decomposition details\n\t */\n\tsetFromMatrix(matrix: Matrix): void;\n\t/** Updates the local transform. */\n\tupdateLocalTransform(): void;\n\tset alpha(value: number);\n\t/**\n\t * The opacity of the object relative to its parent's opacity.\n\t * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n\t * @example\n\t * ```ts\n\t * // Basic transparency\n\t * sprite.alpha = 0.5; // 50% opacity\n\t *\n\t * // Inherited opacity\n\t * container.alpha = 0.5;\n\t * const child = new Sprite(texture);\n\t * child.alpha = 0.5;\n\t * container.addChild(child);\n\t * // child's effective opacity is 0.25 (0.5 * 0.5)\n\t * ```\n\t * @default 1\n\t * @see {@link Container#visible} For toggling visibility\n\t * @see {@link Container#renderable} For render control\n\t */\n\tget alpha(): number;\n\tset tint(value: ColorSource);\n\t/**\n\t * The tint applied to the sprite.\n\t *\n\t * This can be any valid {@link ColorSource}.\n\t * @example\n\t * ```ts\n\t * // Basic color tinting\n\t * container.tint = 0xff0000; // Red tint\n\t * container.tint = 'red';    // Same as above\n\t * container.tint = '#00ff00'; // Green\n\t * container.tint = 'rgb(0,0,255)'; // Blue\n\t *\n\t * // Remove tint\n\t * container.tint = 0xffffff; // White = no tint\n\t * container.tint = null;     // Also removes tint\n\t * ```\n\t * @default 0xFFFFFF\n\t * @see {@link Container#alpha} For transparency\n\t * @see {@link Container#visible} For visibility control\n\t */\n\tget tint(): number;\n\tset blendMode(value: BLEND_MODES);\n\t/**\n\t * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n\t *\n\t * Setting to 'normal' will reset to default blending.\n\t * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n\t * @example\n\t * ```ts\n\t * // Basic blend modes\n\t * sprite.blendMode = 'add';        // Additive blending\n\t * sprite.blendMode = 'multiply';   // Multiply colors\n\t * sprite.blendMode = 'screen';     // Screen blend\n\t *\n\t * // Reset blend mode\n\t * sprite.blendMode = 'normal';     // Normal blending\n\t * ```\n\t * @default 'normal'\n\t * @see {@link Container#alpha} For transparency\n\t * @see {@link Container#tint} For color adjustments\n\t */\n\tget blendMode(): BLEND_MODES;\n\t/**\n\t * The visibility of the object. If false the object will not be drawn,\n\t * and the transform will not be updated.\n\t * @example\n\t * ```ts\n\t * // Basic visibility toggle\n\t * sprite.visible = false; // Hide sprite\n\t * sprite.visible = true;  // Show sprite\n\t * ```\n\t * @default true\n\t * @see {@link Container#renderable} For render-only control\n\t * @see {@link Container#alpha} For transparency\n\t */\n\tget visible(): boolean;\n\tset visible(value: boolean);\n\t/** @ignore */\n\tget culled(): boolean;\n\t/** @ignore */\n\tset culled(value: boolean);\n\t/**\n\t * Controls whether this object can be rendered. If false the object will not be drawn,\n\t * but the transform will still be updated. This is different from visible, which skips\n\t * transform updates.\n\t * @example\n\t * ```ts\n\t * // Basic render control\n\t * sprite.renderable = false; // Skip rendering\n\t * sprite.renderable = true;  // Enable rendering\n\t * ```\n\t * @default true\n\t * @see {@link Container#visible} For skipping transform updates\n\t * @see {@link Container#alpha} For transparency\n\t */\n\tget renderable(): boolean;\n\tset renderable(value: boolean);\n\t/**\n\t * Whether or not the object should be rendered.\n\t * @advanced\n\t */\n\tget isRenderable(): boolean;\n\t/**\n\t * Removes all internal references and listeners as well as removes children from the display list.\n\t * Do not use a Container after calling `destroy`.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * ```ts\n\t * container.destroy();\n\t * container.destroy(true);\n\t * container.destroy({ children: true });\n\t * container.destroy({ children: true, texture: true, textureSource: true });\n\t * ```\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * The type of the pointer event to listen for.\n * @category accessibility\n * @standard\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = \"auto\" | \"none\" | \"visiblePainted\" | \"visibleFill\" | \"visibleStroke\" | \"visible\" | \"painted\" | \"fill\" | \"stroke\" | \"all\" | \"inherit\";\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @example\n * const container = new Container();\n * container.accessible = true;\n * container.accessibleTitle = 'My Container';\n * container.accessibleHint = 'This is a container';\n * container.tabIndex = 0;\n * @category accessibility\n * @standard\n */\nexport interface AccessibleOptions {\n\t/**\n\t * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n\t * shadow div with attributes set\n\t * @default false\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * ```\n\t */\n\taccessible: boolean;\n\t/**\n\t * Sets the title attribute of the shadow div\n\t * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n\t * @type {string}\n\t * @default null\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleTitle = 'My Container';\n\t * ```\n\t */\n\taccessibleTitle: string | null;\n\t/**\n\t * Sets the aria-label attribute of the shadow div\n\t * @default null\n\t * @advanced\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleHint = 'This is a container';\n\t * ```\n\t */\n\taccessibleHint: string | null;\n\t/**\n\t * Sets the tabIndex of the shadow div. You can use this to set the order of the\n\t * elements when using the tab key to navigate.\n\t * @default 0\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * container.tabIndex = 0;\n\t *\n\t * const sprite = new Sprite(texture);\n\t * sprite.accessible = true;\n\t * sprite.tabIndex = 1;\n\t * ```\n\t */\n\ttabIndex: number;\n\t/**\n\t * Specify the type of div the accessible layer is. Screen readers treat the element differently\n\t * depending on this type. Defaults to button.\n\t * @default 'button'\n\t * @type {string}\n\t * @advanced\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleType = 'button'; // or 'link', 'checkbox', etc.\n\t * ```\n\t */\n\taccessibleType: keyof HTMLElementTagNameMap;\n\t/**\n\t * Specify the pointer-events the accessible div will use\n\t * Defaults to auto.\n\t * @default 'auto'\n\t * @type {PointerEvents}\n\t * @advanced\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * container.accessiblePointerEvents = 'none'; // or 'auto', 'visiblePainted', etc.\n\t * ```\n\t */\n\taccessiblePointerEvents: PointerEvents;\n\t/**\n\t * Sets the text content of the shadow\n\t * @default null\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleText = 'This is a container';\n\t * ```\n\t */\n\taccessibleText: string | null;\n\t/**\n\t * Setting to false will prevent any children inside this container to\n\t * be accessible. Defaults to true.\n\t * @default true\n\t * @example\n\t * ```js\n\t * const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleChildren = false; // This will prevent any children from being accessible\n\t *\n\t * const sprite = new Sprite(texture);\n\t * sprite.accessible = true; // This will not work since accessibleChildren is false\n\t * ```\n\t */\n\taccessibleChildren: boolean;\n}\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions {\n\t/** @private */\n\t_accessibleActive: boolean;\n\t/** @private */\n\t_accessibleDiv: AccessibleHTMLElement | null;\n\t/** @private */\n\t_renderId: number;\n}\n/** @internal */\nexport interface AccessibleHTMLElement extends HTMLElement {\n\ttype?: string;\n\tcontainer?: Container;\n}\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @internal\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget;\n/**\n * The result of the mobile device detection system.\n * Provides detailed information about device type and platform.\n * @example\n * ```ts\n * // Type usage with isMobile\n * const deviceInfo: isMobileResult = isMobile;\n *\n * // Check device categories\n * if (deviceInfo.apple.device) {\n *     console.log('iOS Device Details:', {\n *         isPhone: deviceInfo.apple.phone,\n *         isTablet: deviceInfo.apple.tablet,\n *         isUniversal: deviceInfo.apple.universal\n *     });\n * }\n *\n * // Platform-specific checks\n * const platformInfo = {\n *     isApple: deviceInfo.apple.device,\n *     isAndroid: deviceInfo.android.device,\n *     isAmazon: deviceInfo.amazon.device,\n *     isWindows: deviceInfo.windows.device\n * };\n * ```\n * @category utils\n * @standard\n */\nexport type isMobileResult = {\n\t/**\n\t * Apple device detection information.\n\t * Provides detailed iOS device categorization.\n\t * @example\n\t * ```ts\n\t * // iOS device checks\n\t * if (isMobile.apple.device) {\n\t *     if (isMobile.apple.tablet) {\n\t *         // iPad-specific code\n\t *         useTabletLayout();\n\t *     } else if (isMobile.apple.phone) {\n\t *         // iPhone-specific code\n\t *         usePhoneLayout();\n\t *     }\n\t * }\n\t * ```\n\t */\n\tapple: {\n\t\t/** Whether the device is an iPhone */\n\t\tphone: boolean;\n\t\t/** Whether the device is an iPod Touch */\n\t\tipod: boolean;\n\t\t/** Whether the device is an iPad */\n\t\ttablet: boolean;\n\t\t/** Whether app is running in iOS universal mode */\n\t\tuniversal: boolean;\n\t\t/** Whether device is any Apple mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Amazon device detection information.\n\t * Identifies Amazon Fire tablets and phones.\n\t * @example\n\t * ```ts\n\t * // Amazon Fire tablet detection\n\t * if (isMobile.amazon.tablet) {\n\t *     // Fire tablet optimizations\n\t *     optimizeForFireTablet();\n\t * }\n\t * ```\n\t */\n\tamazon: {\n\t\t/** Whether device is a Fire Phone */\n\t\tphone: boolean;\n\t\t/** Whether device is a Fire Tablet */\n\t\ttablet: boolean;\n\t\t/** Whether device is any Amazon mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Android device detection information.\n\t * Categorizes Android phones and tablets.\n\t * @example\n\t * ```ts\n\t * // Android device handling\n\t * if (isMobile.android.device) {\n\t *     // Check specific type\n\t *     const deviceType = isMobile.android.tablet ?\n\t *         'tablet' : 'phone';\n\t *     console.log(`Android ${deviceType} detected`);\n\t * }\n\t * ```\n\t */\n\tandroid: {\n\t\t/** Whether device is an Android phone */\n\t\tphone: boolean;\n\t\t/** Whether device is an Android tablet */\n\t\ttablet: boolean;\n\t\t/** Whether device is any Android device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Windows device detection information.\n\t * Identifies Windows phones and tablets.\n\t * @example\n\t * ```ts\n\t * // Windows device checks\n\t * if (isMobile.windows.tablet) {\n\t *     // Surface tablet optimizations\n\t *     enableTouchFeatures();\n\t * }\n\t * ```\n\t */\n\twindows: {\n\t\t/** Whether device is a Windows Phone */\n\t\tphone: boolean;\n\t\t/** Whether device is a Windows tablet */\n\t\ttablet: boolean;\n\t\t/** Whether device is any Windows mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Other device detection information.\n\t * Covers additional platforms and browsers.\n\t * @example\n\t * ```ts\n\t * // Check other platforms\n\t * if (isMobile.other.blackberry10) {\n\t *     // BlackBerry 10 specific code\n\t * } else if (isMobile.other.chrome) {\n\t *     // Chrome mobile specific code\n\t * }\n\t * ```\n\t */\n\tother: {\n\t\t/** Whether device is a BlackBerry */\n\t\tblackberry: boolean;\n\t\t/** Whether device is a BlackBerry 10 */\n\t\tblackberry10: boolean;\n\t\t/** Whether browser is Opera Mobile */\n\t\topera: boolean;\n\t\t/** Whether browser is Firefox Mobile */\n\t\tfirefox: boolean;\n\t\t/** Whether browser is Chrome Mobile */\n\t\tchrome: boolean;\n\t\t/** Whether device is any other mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Whether the device is any type of phone.\n\t * Combines detection across all platforms.\n\t * @example\n\t * ```ts\n\t * // Check if device is a phone\n\t * if (isMobile.phone) {\n\t *     console.log('Running on a mobile phone');\n\t * }\n\t * ```\n\t */\n\tphone: boolean;\n\t/**\n\t * Whether the device is any type of tablet.\n\t * Combines detection across all platforms.\n\t * @example\n\t * ```ts\n\t * // Check if device is a tablet\n\t * if (isMobile.tablet) {\n\t *     console.log('Running on a mobile tablet');\n\t * }\n\t * ```\n\t */\n\ttablet: boolean;\n\t/**\n\t * Whether the device is any type of mobile device.\n\t * True if any mobile platform is detected.\n\t * @example\n\t * ```ts\n\t * // Check if device is mobile\n\t * if (isMobile.any) {\n\t *     console.log('Running on a mobile device');\n\t * }\n\t * ```\n\t */\n\tany: boolean;\n};\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * Provides a comprehensive detection system for mobile platforms and devices.\n * @example\n * ```ts\n * import { isMobile } from 'pixi.js';\n *\n * // Check specific device types\n * if (isMobile.apple.tablet) {\n *    console.log('Running on iPad');\n * }\n *\n * // Check platform categories\n * if (isMobile.android.any) {\n *    console.log('Running on Android');\n * }\n *\n * // Conditional rendering\n * if (isMobile.phone) {\n *    renderer.resolution = 2;\n *    view.style.width = '100vw';\n * }\n * ```\n * @remarks\n * - Detects all major mobile platforms\n * - Distinguishes between phones and tablets\n * - Updates when navigator changes\n * - Common in responsive design\n * @category utils\n * @standard\n * @see {@link isMobileResult} For full type definition\n */\nexport const isMobile: isMobileResult;\n/**\n * Initialisation options for the accessibility system when used with an Application.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilitySystemOptions {\n\t/** Options for the accessibility system */\n\taccessibilityOptions?: AccessibilityOptions;\n}\n/**\n * The options for the accessibility system.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilityOptions {\n\t/** Whether to enable accessibility features on initialization instead of waiting for tab key */\n\tenabledByDefault?: boolean;\n\t/** Whether to visually show the accessibility divs for debugging */\n\tdebug?: boolean;\n\t/** Whether to allow tab key press to activate accessibility features */\n\tactivateOnTab?: boolean;\n\t/** Whether to deactivate accessibility when mouse moves */\n\tdeactivateOnMouseMove?: boolean;\n}\n/**\n * The Accessibility system provides screen reader and keyboard navigation support for PixiJS content.\n * It creates an accessible DOM layer over the canvas that can be controlled programmatically or through user interaction.\n *\n * By default, the system activates when users press the tab key. This behavior can be customized through options:\n * ```js\n * const app = new Application({\n *     accessibilityOptions: {\n *     // Enable immediately instead of waiting for tab\n *     enabledByDefault: true,\n *     // Disable tab key activation\n *     activateOnTab: false,\n *     // Show/hide accessibility divs\n *     debug: false,\n *     // Prevent accessibility from being deactivated when mouse moves\n *     deactivateOnMouseMove: false,\n * }\n * });\n * ```\n *\n * The system can also be controlled programmatically by accessing the `renderer.accessibility` property:\n * ```js\n * app.renderer.accessibility.setAccessibilityEnabled(true);\n * ```\n *\n * To make individual containers accessible:\n * ```js\n * container.accessible = true;\n * ```\n * There are several properties that can be set on a Container to control its accessibility which can\n * be found here: {@link AccessibleOptions}.\n * @category accessibility\n * @standard\n */\nexport class AccessibilitySystem implements System<AccessibilitySystemOptions> {\n\tprivate readonly _mobileInfo;\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"accessibility\";\n\t};\n\t/**\n\t * The default options used by the system.\n\t * You can set these before initializing the {@link Application} to change the default behavior.\n\t * @example\n\t * ```js\n\t * import { AccessibilitySystem } from 'pixi.js';\n\t *\n\t * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n\t *\n\t * const app = new Application()\n\t * app.init()\n\t * ```\n\t */\n\tstatic defaultOptions: AccessibilityOptions;\n\t/** Whether accessibility divs are visible for debugging */\n\tdebug: boolean;\n\t/** Whether to activate on tab key press */\n\tprivate _activateOnTab;\n\t/** Whether to deactivate accessibility when mouse moves */\n\tprivate _deactivateOnMouseMove;\n\t/**\n\t * The renderer this accessibility manager works for.\n\t * @type {WebGLRenderer|WebGPURenderer}\n\t */\n\tprivate _renderer;\n\t/** Internal variable, see isActive getter. */\n\tprivate _isActive;\n\t/** Internal variable, see isMobileAccessibility getter. */\n\tprivate _isMobileAccessibility;\n\t/** Button element for handling touch hooks. */\n\tprivate _hookDiv;\n\t/** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n\tprivate _div;\n\t/** A simple pool for storing divs. */\n\tprivate _pools;\n\t/** This is a tick used to check if an object is no longer being rendered. */\n\tprivate _renderId;\n\t/** The array of currently active accessible items. */\n\tprivate _children;\n\t/** Count to throttle div updates on android devices. */\n\tprivate _androidUpdateCount;\n\t/**  The frequency to update the div elements. */\n\tprivate readonly _androidUpdateFrequency;\n\tprivate _canvasObserver;\n\tprivate _isRunningTests;\n\t/** Bound function references for proper event listener removal */\n\tprivate _boundOnKeyDown;\n\tprivate _boundOnMouseMove;\n\t/**\n\t * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n\t */\n\tconstructor(renderer: Renderer, _mobileInfo?: isMobileResult);\n\t/**\n\t * Value of `true` if accessibility is currently active and accessibility layers are showing.\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget isActive(): boolean;\n\t/**\n\t * Value of `true` if accessibility is enabled for touch devices.\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget isMobileAccessibility(): boolean;\n\t/**\n\t * Button element for handling touch hooks.\n\t * @readonly\n\t */\n\tget hookDiv(): HTMLElement;\n\t/**\n\t * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n\t * @readonly\n\t */\n\tget div(): HTMLElement;\n\t/**\n\t * Creates the touch hooks.\n\t * @private\n\t */\n\tprivate _createTouchHook;\n\t/**\n\t * Destroys the touch hooks.\n\t * @private\n\t */\n\tprivate _destroyTouchHook;\n\t/**\n\t * Activating will cause the Accessibility layer to be shown.\n\t * This is called when a user presses the tab key.\n\t * @private\n\t */\n\tprivate _activate;\n\tprivate _initAccessibilitySetup;\n\t/**\n\t * Deactivates the accessibility system. Removes listeners and accessibility elements.\n\t * @private\n\t */\n\tprivate _deactivate;\n\t/**\n\t * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n\t * @private\n\t * @param {Container} container - The Container to check.\n\t */\n\tprivate _updateAccessibleObjects;\n\t/**\n\t * Runner init called, view is available at this point.\n\t * @ignore\n\t */\n\tinit(options?: AccessibilitySystemOptions): void;\n\t/**\n\t * Updates the accessibility layer during rendering.\n\t * - Removes divs for containers no longer in the scene\n\t * - Updates the position and dimensions of the root div\n\t * - Updates positions of active accessibility divs\n\t * Only fires while the accessibility system is active.\n\t * @ignore\n\t */\n\tpostrender(): void;\n\t/**\n\t * private function that will visually add the information to the\n\t * accessibility div\n\t * @param {HTMLElement} div -\n\t */\n\tprivate _updateDebugHTML;\n\t/**\n\t * Adjust the hit area based on the bounds of a display object\n\t * @param {Rectangle} hitArea - Bounds of the child\n\t */\n\tprivate _capHitArea;\n\t/**\n\t * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n\t * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n\t * @private\n\t * @param {Container} container - The child to make accessible.\n\t */\n\tprivate _addChild;\n\t/**\n\t * Dispatch events with the EventSystem.\n\t * @param e\n\t * @param type\n\t * @private\n\t */\n\tprivate _dispatchEvent;\n\t/**\n\t * Maps the div button press to pixi's EventSystem (click)\n\t * @private\n\t * @param {MouseEvent} e - The click event.\n\t */\n\tprivate _onClick;\n\t/**\n\t * Maps the div focus events to pixi's EventSystem (mouseover)\n\t * @private\n\t * @param {FocusEvent} e - The focus event.\n\t */\n\tprivate _onFocus;\n\t/**\n\t * Maps the div focus events to pixi's EventSystem (mouseout)\n\t * @private\n\t * @param {FocusEvent} e - The focusout event.\n\t */\n\tprivate _onFocusOut;\n\t/**\n\t * Is called when a key is pressed\n\t * @private\n\t * @param {KeyboardEvent} e - The keydown event.\n\t */\n\tprivate _onKeyDown;\n\t/**\n\t * Is called when the mouse moves across the renderer element\n\t * @private\n\t * @param {MouseEvent} e - The mouse event.\n\t */\n\tprivate _onMouseMove;\n\t/**\n\t * Destroys the accessibility system. Removes all elements and listeners.\n\t * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n\t * > A typically user should not need to call this method directly.\n\t */\n\tdestroy(): void;\n\t/**\n\t * Enables or disables the accessibility system.\n\t * @param enabled - Whether to enable or disable accessibility.\n\t * @example\n\t * ```js\n\t * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n\t * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n\t * ```\n\t */\n\tsetAccessibilityEnabled(enabled: boolean): void;\n\tprivate _getPool;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Container extends Partial<AccessibleTarget> {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerOptions extends Partial<AccessibleOptions> {\n\t\t}\n\t\tinterface RendererSystems {\n\t\t\taccessibility: AccessibilitySystem;\n\t\t}\n\t}\n}\n/**\n * A callback which can be added to a ticker.\n * The callback receives the Ticker instance as its parameter, providing access to timing properties.\n * @example\n * ```ts\n * ticker.add((ticker) => {\n *    // Access deltaTime (dimensionless scalar ~1.0 at 60fps)\n *    sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *    // Access deltaMS (milliseconds elapsed)\n *    const progress = ticker.deltaMS / animationDuration;\n * });\n * ```\n * @category ticker\n * @standard\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * Used for managing animation frames and timing in a PixiJS application.\n *\n * It provides a way to add listeners that will be called on each frame,\n * allowing for smooth animations and updates.\n *\n * ## Time Units\n * - `deltaTime`: Dimensionless scalar (typically ~1.0 at 60 FPS) for frame-independent animations\n * - `deltaMS`: Milliseconds elapsed (capped and speed-scaled) for time-based calculations\n * - `elapsedMS`: Raw milliseconds elapsed (uncapped, unscaled) for measurements\n * - `lastTime`: Timestamp in milliseconds since epoch (performance.now() format)\n *\n * Animation frames are requested\n * only when necessary, e.g., when the ticker is started and the emitter has listeners.\n * @example\n * ```ts\n * // Basic ticker usage with different time units\n * const ticker = new Ticker();\n * ticker.add((ticker) => {\n *     // Frame-independent animation using dimensionless deltaTime\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *     // Time-based animation using deltaMS (milliseconds)\n *     sprite.x += (100 / 1000) * ticker.deltaMS; // 100 pixels per second\n * });\n * ticker.start();\n *\n * // Control update priority\n * ticker.add(\n *     (ticker) => {\n *         // High priority updates run first\n *         physics.update(ticker.deltaTime);\n *     },\n *     undefined,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // One-time updates\n * ticker.addOnce(() => {\n *     console.log('Runs on next frame only');\n * });\n * ```\n * @see {@link TickerPlugin} For use with Application\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @see {@link TickerCallback} For listener function type\n * @category ticker\n * @standard\n */\nexport class Ticker {\n\t/**\n\t * Target frame rate in frames per millisecond.\n\t * Used for converting deltaTime to a scalar time delta.\n\t * @example\n\t * ```ts\n\t * // Default is 0.06 (60 FPS)\n\t * console.log(Ticker.targetFPMS); // 0.06\n\t *\n\t * // Calculate target frame duration\n\t * const frameDuration = 1 / Ticker.targetFPMS; //  16.67ms\n\t *\n\t * // Use in custom timing calculations\n\t * const deltaTime = elapsedMS * Ticker.targetFPMS;\n\t * ```\n\t * @remarks\n\t * - Default is 0.06 (equivalent to 60 FPS)\n\t * - Used in deltaTime calculations\n\t * - Affects all ticker instances\n\t * @default 0.06\n\t * @see {@link Ticker#deltaTime} For time scaling\n\t * @see {@link Ticker#FPS} For actual frame rate\n\t */\n\tstatic targetFPMS: number;\n\t/** The private shared ticker instance */\n\tprivate static _shared;\n\t/** The private system ticker instance  */\n\tprivate static _system;\n\t/**\n\t * Whether or not this ticker should invoke the method {@link Ticker#start|start}\n\t * automatically when a listener is added.\n\t * @example\n\t * ```ts\n\t * // Default behavior (manual start)\n\t * const ticker = new Ticker();\n\t * ticker.autoStart = false;\n\t * ticker.add(() => {\n\t *     // Won't run until ticker.start() is called\n\t * });\n\t *\n\t * // Auto-start behavior\n\t * const autoTicker = new Ticker();\n\t * autoTicker.autoStart = true;\n\t * autoTicker.add(() => {\n\t *     // Runs immediately when added\n\t * });\n\t * ```\n\t * @default false\n\t * @see {@link Ticker#start} For manually starting the ticker\n\t * @see {@link Ticker#stop} For manually stopping the ticker\n\t */\n\tautoStart: boolean;\n\t/**\n\t * Scalar representing the delta time factor.\n\t * This is a dimensionless value representing the fraction of a frame at the target framerate.\n\t * At 60 FPS, this value is typically around 1.0.\n\t *\n\t * This is NOT in milliseconds - it's a scalar multiplier for frame-independent animations.\n\t * For actual milliseconds, use {@link Ticker#deltaMS}.\n\t * @example\n\t * ```ts\n\t * // Frame-independent animation using deltaTime scalar\n\t * ticker.add((ticker) => {\n\t *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime\n\t *     sprite.rotation += 0.1 * ticker.deltaTime;\n\t * });\n\t * ```\n\t */\n\tdeltaTime: number;\n\t/**\n\t * Scalar time elapsed in milliseconds from last frame to this frame.\n\t * Provides precise timing for animations and updates.\n\t *\n\t * This value is capped by setting {@link Ticker#minFPS|minFPS}\n\t * and is scaled with {@link Ticker#speed|speed}.\n\t *\n\t * If the platform supports DOMHighResTimeStamp,\n\t * this value will have a precision of 1 s.\n\t *\n\t * Defaults to target frame time\n\t *\n\t * > [!NOTE] The cap may be exceeded by scaling.\n\t * @example\n\t * ```ts\n\t * // Animation timing\n\t * ticker.add((ticker) => {\n\t *     // Use millisecond timing for precise animations\n\t *     const progress = (ticker.deltaMS / animationDuration);\n\t *     sprite.alpha = Math.min(1, progress);\n\t * });\n\t * ```\n\t * @default 16.66\n\t */\n\tdeltaMS: number;\n\t/**\n\t * Time elapsed in milliseconds from the last frame to this frame.\n\t * This value is not capped or scaled and provides raw timing information.\n\t *\n\t * Unlike {@link Ticker#deltaMS}, this value is unmodified by speed scaling or FPS capping.\n\t * @example\n\t * ```ts\n\t * ticker.add((ticker) => {\n\t *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n\t * });\n\t * ```\n\t */\n\telapsedMS: number;\n\t/**\n\t * The last time update was invoked, in milliseconds since epoch.\n\t * Similar to performance.now() timestamp format.\n\t *\n\t * Used internally for calculating time deltas between frames.\n\t * @example\n\t * ```ts\n\t * ticker.add((ticker) => {\n\t *     const currentTime = performance.now();\n\t *     const timeSinceLastFrame = currentTime - ticker.lastTime;\n\t *     console.log(`Time since last frame: ${timeSinceLastFrame}ms`);\n\t * });\n\t * ```\n\t */\n\tlastTime: number;\n\t/**\n\t * Factor of current {@link Ticker#deltaTime|deltaTime}.\n\t * Used to scale time for slow motion or fast-forward effects.\n\t * @example\n\t * ```ts\n\t * // Basic speed adjustment\n\t * ticker.speed = 0.5; // Half speed (slow motion)\n\t * ticker.speed = 2.0; // Double speed (fast forward)\n\t *\n\t * // Temporary speed changes\n\t * function slowMotion() {\n\t *     const normalSpeed = ticker.speed;\n\t *     ticker.speed = 0.2;\n\t *     setTimeout(() => {\n\t *         ticker.speed = normalSpeed;\n\t *     }, 1000);\n\t * }\n\t * ```\n\t */\n\tspeed: number;\n\t/**\n\t * Whether or not this ticker has been started.\n\t *\n\t * `true` if {@link Ticker#start|start} has been called.\n\t * `false` if {@link Ticker#stop|Stop} has been called.\n\t *\n\t * While `false`, this value may change to `true` in the\n\t * event of {@link Ticker#autoStart|autoStart} being `true`\n\t * and a listener is added.\n\t * @example\n\t * ```ts\n\t * // Check ticker state\n\t * const ticker = new Ticker();\n\t * console.log(ticker.started); // false\n\t *\n\t * // Start and verify\n\t * ticker.start();\n\t * console.log(ticker.started); // true\n\t * ```\n\t */\n\tstarted: boolean;\n\t/** The first listener. All new listeners added are chained on this. */\n\tprivate _head;\n\t/** Internal current frame request ID */\n\tprivate _requestId;\n\t/**\n\t * Internal value managed by minFPS property setter and getter.\n\t * This is the maximum allowed milliseconds between updates.\n\t */\n\tprivate _maxElapsedMS;\n\t/**\n\t * Internal value managed by minFPS property setter and getter.\n\t * This is the minimum allowed milliseconds between updates.\n\t */\n\tprivate _minElapsedMS;\n\t/** If enabled, deleting is disabled.*/\n\tprivate _protected;\n\t/** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n\tprivate _lastFrame;\n\t/**\n\t * Internal tick method bound to ticker instance.\n\t * This is because in early 2015, Function.bind\n\t * is still 60% slower in high performance scenarios.\n\t * Also separating frame requests from update method\n\t * so listeners may be called at any time and with\n\t * any animation API, just invoke ticker.update(time).\n\t * @param time - Time since last tick.\n\t */\n\tprivate readonly _tick;\n\tconstructor();\n\t/**\n\t * Conditionally requests a new animation frame.\n\t * If a frame has not already been requested, and if the internal\n\t * emitter has listeners, a new frame is requested.\n\t */\n\tprivate _requestIfNeeded;\n\t/** Conditionally cancels a pending animation frame. */\n\tprivate _cancelIfNeeded;\n\t/**\n\t * Conditionally requests a new animation frame.\n\t * If the ticker has been started it checks if a frame has not already\n\t * been requested, and if the internal emitter has listeners. If these\n\t * conditions are met, a new frame is requested. If the ticker has not\n\t * been started, but autoStart is `true`, then the ticker starts now,\n\t * and continues with the previous conditions to request a new frame.\n\t */\n\tprivate _startIfPossible;\n\t/**\n\t * Register a handler for tick events.\n\t * @param fn - The listener function to add. Receives the Ticker instance as parameter\n\t * @param context - The context for the listener\n\t * @param priority - The priority of the listener\n\t * @example\n\t * ```ts\n\t * // Access time properties through the ticker parameter\n\t * ticker.add((ticker) => {\n\t *     // Use deltaTime (dimensionless scalar) for frame-independent animations\n\t *     sprite.rotation += 0.1 * ticker.deltaTime;\n\t *\n\t *     // Use deltaMS (milliseconds) for time-based calculations\n\t *     const progress = ticker.deltaMS / animationDuration;\n\t *\n\t *     // Use elapsedMS for raw timing measurements\n\t *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n\t * });\n\t * ```\n\t */\n\tadd<T = any>(fn: TickerCallback<T>, context?: T, priority?: number): this;\n\t/**\n\t * Add a handler for the tick event which is only executed once on the next frame.\n\t * @example\n\t * ```ts\n\t * // Basic one-time update\n\t * ticker.addOnce(() => {\n\t *     console.log('Runs next frame only');\n\t * });\n\t *\n\t * // With specific context\n\t * const game = {\n\t *     init(ticker) {\n\t *         this.loadResources();\n\t *         console.log('Game initialized');\n\t *     }\n\t * };\n\t * ticker.addOnce(game.init, game);\n\t *\n\t * // With priority\n\t * ticker.addOnce(\n\t *     () => {\n\t *         // High priority one-time setup\n\t *         physics.init();\n\t *     },\n\t *     undefined,\n\t *     UPDATE_PRIORITY.HIGH\n\t * );\n\t * ```\n\t * @param fn - The listener function to be added for one update\n\t * @param context - The listener context\n\t * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)\n\t * @returns This instance of a ticker\n\t * @see {@link Ticker#add} For continuous updates\n\t * @see {@link Ticker#remove} For removing handlers\n\t */\n\taddOnce<T = any>(fn: TickerCallback<T>, context?: T, priority?: number): this;\n\t/**\n\t * Internally adds the event handler so that it can be sorted by priority.\n\t * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n\t * before the rendering.\n\t * @private\n\t * @param listener - Current listener being added.\n\t * @returns This instance of a ticker\n\t */\n\tprivate _addListener;\n\t/**\n\t * Removes any handlers matching the function and context parameters.\n\t * If no handlers are left after removing, then it cancels the animation frame.\n\t * @example\n\t * ```ts\n\t * // Basic removal\n\t * const onTick = () => {\n\t *     sprite.rotation += 0.1;\n\t * };\n\t * ticker.add(onTick);\n\t * ticker.remove(onTick);\n\t *\n\t * // Remove with context\n\t * const game = {\n\t *     update(ticker) {\n\t *         this.physics.update(ticker.deltaTime);\n\t *     }\n\t * };\n\t * ticker.add(game.update, game);\n\t * ticker.remove(game.update, game);\n\t *\n\t * // Remove all matching handlers\n\t * // (if same function was added multiple times)\n\t * ticker.add(onTick);\n\t * ticker.add(onTick);\n\t * ticker.remove(onTick); // Removes all instances\n\t * ```\n\t * @param fn - The listener function to be removed\n\t * @param context - The listener context to be removed\n\t * @returns This instance of a ticker\n\t * @see {@link Ticker#add} For adding handlers\n\t * @see {@link Ticker#addOnce} For one-time handlers\n\t */\n\tremove<T = any>(fn: TickerCallback<T>, context?: T): this;\n\t/**\n\t * The number of listeners on this ticker, calculated by walking through linked list.\n\t * @example\n\t * ```ts\n\t * // Check number of active listeners\n\t * const ticker = new Ticker();\n\t * console.log(ticker.count); // 0\n\t *\n\t * // Add some listeners\n\t * ticker.add(() => {});\n\t * ticker.add(() => {});\n\t * console.log(ticker.count); // 2\n\t *\n\t * // Check after cleanup\n\t * ticker.destroy();\n\t * console.log(ticker.count); // 0\n\t * ```\n\t * @readonly\n\t * @see {@link Ticker#add} For adding listeners\n\t * @see {@link Ticker#remove} For removing listeners\n\t */\n\tget count(): number;\n\t/**\n\t * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.\n\t * @example\n\t * ```ts\n\t * // Basic manual start\n\t * const ticker = new Ticker();\n\t * ticker.add(() => {\n\t *     // Animation code here\n\t * });\n\t * ticker.start();\n\t * ```\n\t * @see {@link Ticker#stop} For stopping the ticker\n\t * @see {@link Ticker#autoStart} For automatic starting\n\t * @see {@link Ticker#started} For checking ticker state\n\t */\n\tstart(): void;\n\t/**\n\t * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.\n\t * @example\n\t * ```ts\n\t * // Basic stop\n\t * const ticker = new Ticker();\n\t * ticker.stop();\n\t * ```\n\t * @see {@link Ticker#start} For starting the ticker\n\t * @see {@link Ticker#started} For checking ticker state\n\t * @see {@link Ticker#destroy} For cleaning up the ticker\n\t */\n\tstop(): void;\n\t/**\n\t * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.\n\t * @example\n\t * ```ts\n\t * // Clean up with active listeners\n\t * const ticker = new Ticker();\n\t * ticker.add(() => {});\n\t * ticker.destroy(); // Removes all listeners\n\t * ```\n\t * @see {@link Ticker#stop} For stopping without destroying\n\t * @see {@link Ticker#remove} For removing specific listeners\n\t */\n\tdestroy(): void;\n\t/**\n\t * Triggers an update.\n\t *\n\t * An update entails setting the\n\t * current {@link Ticker#elapsedMS|elapsedMS},\n\t * the current {@link Ticker#deltaTime|deltaTime},\n\t * invoking all listeners with current deltaTime,\n\t * and then finally setting {@link Ticker#lastTime|lastTime}\n\t * with the value of currentTime that was provided.\n\t *\n\t * This method will be called automatically by animation\n\t * frame callbacks if the ticker instance has been started\n\t * and listeners are added.\n\t * @example\n\t * ```ts\n\t * // Basic manual update\n\t * const ticker = new Ticker();\n\t * ticker.update(performance.now());\n\t * ```\n\t * @param currentTime - The current time of execution (defaults to performance.now())\n\t * @see {@link Ticker#deltaTime} For frame delta value\n\t * @see {@link Ticker#elapsedMS} For raw elapsed time\n\t */\n\tupdate(currentTime?: number): void;\n\t/**\n\t * The frames per second at which this ticker is running.\n\t * The default is approximately 60 in most modern browsers.\n\t * > [!NOTE] This does not factor in the value of\n\t * > {@link Ticker#speed|speed}, which is specific\n\t * > to scaling {@link Ticker#deltaTime|deltaTime}.\n\t * @example\n\t * ```ts\n\t * // Basic FPS monitoring\n\t * ticker.add(() => {\n\t *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);\n\t * });\n\t * ```\n\t * @readonly\n\t */\n\tget FPS(): number;\n\t/**\n\t * Manages the maximum amount of milliseconds allowed to\n\t * elapse between invoking {@link Ticker#update|update}.\n\t *\n\t * This value is used to cap {@link Ticker#deltaTime|deltaTime},\n\t * but does not effect the measured value of {@link Ticker#FPS|FPS}.\n\t *\n\t * When setting this property it is clamped to a value between\n\t * `0` and `Ticker.targetFPMS * 1000`.\n\t * @example\n\t * ```ts\n\t * // Set minimum acceptable frame rate\n\t * const ticker = new Ticker();\n\t * ticker.minFPS = 30; // Never go below 30 FPS\n\t *\n\t * // Use with maxFPS for frame rate clamping\n\t * ticker.minFPS = 30;\n\t * ticker.maxFPS = 60;\n\t *\n\t * // Monitor delta capping\n\t * ticker.add(() => {\n\t *     // Delta time will be capped based on minFPS\n\t *     console.log(`Delta time: ${ticker.deltaTime}`);\n\t * });\n\t * ```\n\t * @default 10\n\t */\n\tget minFPS(): number;\n\tset minFPS(fps: number);\n\t/**\n\t * Manages the minimum amount of milliseconds required to\n\t * elapse between invoking {@link Ticker#update|update}.\n\t *\n\t * This will effect the measured value of {@link Ticker#FPS|FPS}.\n\t *\n\t * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n\t * Otherwise it will be at least `minFPS`\n\t * @example\n\t * ```ts\n\t * // Set minimum acceptable frame rate\n\t * const ticker = new Ticker();\n\t * ticker.maxFPS = 60; // Never go above 60 FPS\n\t *\n\t * // Use with maxFPS for frame rate clamping\n\t * ticker.minFPS = 30;\n\t * ticker.maxFPS = 60;\n\t *\n\t * // Monitor delta capping\n\t * ticker.add(() => {\n\t *     // Delta time will be capped based on maxFPS\n\t *     console.log(`Delta time: ${ticker.deltaTime}`);\n\t * });\n\t * ```\n\t * @default 0\n\t */\n\tget maxFPS(): number;\n\tset maxFPS(fps: number);\n\t/**\n\t * The shared ticker instance used by {@link AnimatedSprite} and by\n\t * {@link VideoSource} to update animation frames / video textures.\n\t *\n\t * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n\t *\n\t * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n\t * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n\t * @example\n\t * import { Ticker } from 'pixi.js';\n\t *\n\t * const ticker = Ticker.shared;\n\t * // Set this to prevent starting this ticker when listeners are added.\n\t * // By default this is true only for the Ticker.shared instance.\n\t * ticker.autoStart = false;\n\t *\n\t * // FYI, call this to ensure the ticker is stopped. It should be stopped\n\t * // if you have not attempted to render anything yet.\n\t * ticker.stop();\n\t *\n\t * // Call this when you are ready for a running shared ticker.\n\t * ticker.start();\n\t * @example\n\t * import { autoDetectRenderer, Container } from 'pixi.js';\n\t *\n\t * // You may use the shared ticker to render...\n\t * const renderer = autoDetectRenderer();\n\t * const stage = new Container();\n\t * document.body.appendChild(renderer.view);\n\t * ticker.add((time) => renderer.render(stage));\n\t *\n\t * // Or you can just update it manually.\n\t * ticker.autoStart = false;\n\t * ticker.stop();\n\t * const animate = (time) => {\n\t *     ticker.update(time);\n\t *     renderer.render(stage);\n\t *     requestAnimationFrame(animate);\n\t * };\n\t * animate(performance.now());\n\t * @type {Ticker}\n\t * @readonly\n\t */\n\tstatic get shared(): Ticker;\n\t/**\n\t * The system ticker instance used by {@link PrepareBase} for core timing\n\t * functionality that shouldn't usually need to be paused, unlike the `shared`\n\t * ticker which drives visual animations and rendering which may want to be paused.\n\t *\n\t * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n\t * @type {Ticker}\n\t * @readonly\n\t * @advanced\n\t */\n\tstatic get system(): Ticker;\n}\ntype ResizeableRenderer = Pick<Renderer, \"resize\">;\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * ```ts\n * // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n * ```\n * @category app\n * @standard\n */\nexport interface ResizePluginOptions {\n\t/**\n\t * Element to automatically resize the renderer to.\n\t * @example\n\t * ```ts\n\t * const app = new Application();\n\t * await app.init({\n\t *     resizeTo: window, // Resize to the entire window\n\t *     // or\n\t *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n\t *     // or\n\t *     resizeTo: null, // Disable auto-resize\n\t * });\n\t * ```\n\t * @default null\n\t */\n\tresizeTo?: Window | HTMLElement;\n}\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * ```ts\n * import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n * ```\n * @category app\n * @standard\n */\nexport class ResizePlugin {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\t/** @internal */\n\tstatic resizeTo: Window | HTMLElement;\n\t/** @internal */\n\tstatic resize: () => void;\n\t/** @internal */\n\tstatic renderer: ResizeableRenderer;\n\t/** @internal */\n\tstatic queueResize: () => void;\n\t/** @internal */\n\tstatic render: () => void;\n\t/** @internal */\n\tprivate static _resizeId;\n\t/** @internal */\n\tprivate static _resizeTo;\n\t/** @internal */\n\tprivate static _cancelResize;\n\t/**\n\t * Initialize the plugin with scope of application instance\n\t * @private\n\t * @param {object} [options] - See application options\n\t */\n\tstatic init(options: ResizePluginOptions): void;\n\t/**\n\t * Clean up the ticker, scoped to application\n\t * @private\n\t */\n\tstatic destroy(): void;\n}\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n * ```\n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For update priority constants\n * @category app\n * @standard\n */\nexport interface TickerPluginOptions {\n\t/**\n\t * Controls whether the animation loop starts automatically after initialization.\n\t * > [!IMPORTANT]\n\t * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n\t * > You must stop the shared ticker manually if needed.\n\t * @example\n\t * ```ts\n\t * // Auto-start (default behavior)\n\t * await app.init({ autoStart: true });\n\t *\n\t * // Manual start\n\t * await app.init({ autoStart: false });\n\t * app.start(); // Start when ready\n\t * ```\n\t * @default true\n\t */\n\tautoStart?: boolean;\n\t/**\n\t * Controls whether to use the shared global ticker or create a new instance.\n\t *\n\t * The shared ticker is useful when you have multiple instances that should sync their updates.\n\t * However, it has some limitations regarding update order control.\n\t *\n\t * Update Order:\n\t * 1. System ticker (always runs first)\n\t * 2. Shared ticker (if enabled)\n\t * 3. App ticker (if using own ticker)\n\t * @example\n\t * ```ts\n\t * // Use shared ticker (global instance)\n\t * await app.init({ sharedTicker: true });\n\t *\n\t * // Use dedicated ticker (default)\n\t * await app.init({ sharedTicker: false });\n\t *\n\t * // Access ticker properties\n\t * console.log(app.ticker.FPS);    // Current FPS\n\t * console.log(app.ticker.deltaMS); // MS since last update\n\t * ```\n\t * @default false\n\t */\n\tsharedTicker?: boolean;\n}\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * ```ts\n * import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n * ```\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @category app\n * @standard\n */\nexport class TickerPlugin {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\t/** @internal */\n\tstatic start: () => void;\n\t/** @internal */\n\tstatic stop: () => void;\n\t/** @internal */\n\tprivate static _ticker;\n\t/** @internal */\n\tstatic ticker: Ticker;\n\t/**\n\t * Initialize the plugin with scope of application instance\n\t * @private\n\t * @param {object} [options] - See application options\n\t */\n\tstatic init(options?: PixiMixins.ApplicationOptions): void;\n\t/**\n\t * Clean up the ticker, scoped to application.\n\t * @private\n\t */\n\tstatic destroy(): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// Extend the Application interface with resize and ticker functionalities\n\t\tinterface Application {\n\t\t\t/**\n\t\t\t * Element to automatically resize the renderer to.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * const app = new Application();\n\t\t\t * await app.init({\n\t\t\t *     resizeTo: window, // Resize to the entire window\n\t\t\t *     // or\n\t\t\t *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n\t\t\t *     // or\n\t\t\t *     resizeTo: null, // Disable auto-resize\n\t\t\t * });\n\t\t\t * ```\n\t\t\t * @default null\n\t\t\t */\n\t\t\tresizeTo: Window | HTMLElement;\n\t\t\t/**\n\t\t\t * Element to automatically resize the renderer to.\n\t\t\t * > [!IMPORTANT]\n\t\t\t * > You do not need to call this method manually in most cases.\n\t\t\t * > A `resize` event will be dispatched automatically when the `resizeTo` element changes size.\n\t\t\t * @remarks\n\t\t\t * - Automatically resizes the renderer to match the size of the `resizeTo` element\n\t\t\t * - If `resizeTo` is `null`, auto-resizing is disabled\n\t\t\t * - If `resizeTo` is a `Window`, it resizes to the full window size\n\t\t\t * - If `resizeTo` is an `HTMLElement`, it resizes to the element's bounding client rectangle\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * const app = new Application();\n\t\t\t * await app.init({\n\t\t\t *     resizeTo: window, // Resize to the entire window\n\t\t\t *     // or\n\t\t\t *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n\t\t\t *     // or\n\t\t\t *     resizeTo: null, // Disable auto-resize\n\t\t\t * });\n\t\t\t *\n\t\t\t * // Manually trigger a resize\n\t\t\t * app.resize();\n\t\t\t * ```\n\t\t\t * @default null\n\t\t\t */\n\t\t\tresize(): void;\n\t\t\t/**\n\t\t\t * Queue a resize operation for the next animation frame. This method is throttled\n\t\t\t * and optimized for frequent calls.\n\t\t\t * > [!IMPORTANT]\n\t\t\t * > You do not need to call this method manually in most cases.\n\t\t\t * > A `resize` event will be dispatched automatically when the `resizeTo` element changes size.\n\t\t\t * @remarks\n\t\t\t * - Safe to call multiple times per frame\n\t\t\t * - Only one resize will occur on next frame\n\t\t\t * - Cancels any previously queued resize\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * app.queueResize(); // Queue for next frame\n\t\t\t * ```\n\t\t\t */\n\t\t\tqueueResize(): void;\n\t\t\t/**\n\t\t\t * Cancel any pending resize operation that was queued with `queueResize()`.\n\t\t\t * @remarks\n\t\t\t * - Clears the resize operation queued for next frame\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Queue a resize\n\t\t\t * app.queueResize();\n\t\t\t *\n\t\t\t * // Cancel if needed\n\t\t\t * app.cancelResize();\n\t\t\t * ```\n\t\t\t */\n\t\t\tcancelResize(): void;\n\t\t\t/**\n\t\t\t * The application's ticker instance that manages the update/render loop.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Basic animation\n\t\t\t * app.ticker.add((ticker) => {\n\t\t\t *     sprite.rotation += 0.1 * ticker.deltaTime;\n\t\t\t * });\n\t\t\t *\n\t\t\t * // Control update priority\n\t\t\t * app.ticker.add(\n\t\t\t *     (ticker) => {\n\t\t\t *         // Physics update (runs first)\n\t\t\t *     },\n\t\t\t *     undefined,\n\t\t\t *     UPDATE_PRIORITY.HIGH\n\t\t\t * );\n\t\t\t *\n\t\t\t * // One-time update\n\t\t\t * app.ticker.addOnce(() => {\n\t\t\t *     console.log('Runs next frame only');\n\t\t\t * });\n\t\t\t *\n\t\t\t * // Access timing info\n\t\t\t * console.log(app.ticker.FPS);      // Current FPS\n\t\t\t * console.log(app.ticker.deltaTime); // Scaled time delta\n\t\t\t * console.log(app.ticker.deltaMS);   // MS since last update\n\t\t\t * ```\n\t\t\t * @see {@link Ticker} For detailed ticker functionality\n\t\t\t * @see {@link UPDATE_PRIORITY} For priority constants\n\t\t\t */\n\t\t\tticker: Ticker;\n\t\t\t/**\n\t\t\t * Stops the render/update loop.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Stop the application\n\t\t\t * app.stop();\n\t\t\t * // ... custom update logic ...\n\t\t\t * app.render(); // Manual render\n\t\t\t * ```\n\t\t\t */\n\t\t\tstop(): void;\n\t\t\t/**\n\t\t\t * Starts the render/update loop.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Initialize without auto-start\n\t\t\t * await app.init({ autoStart: false });\n\t\t\t *\n\t\t\t * // Start when ready\n\t\t\t * app.start();\n\t\t\t * ```\n\t\t\t */\n\t\t\tstart(): void;\n\t\t}\n\t\t// Combine ResizePluginOptions and TickerPluginOptions into ApplicationOptions\n\t\tinterface ApplicationOptions extends ResizePluginOptions, TickerPluginOptions {\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface AssetsPreferences {\n\t\t}\n\t}\n}\n/**\n * The CullingMixin interface provides properties and methods for managing culling behavior\n * of a display object. Culling is the process of determining whether an object should be rendered\n * based on its visibility within the current view or frame.\n *\n * Key Features:\n * - Custom culling areas for better performance\n * - Per-object culling control\n * - Child culling management\n * @example\n * ```ts\n * // Enable culling for a container\n * const container = new Container();\n * container.cullable = true;\n *\n * // Set custom cull area for better performance\n * container.cullArea = new Rectangle(0, 0, 800, 600);\n *\n * // Disable child culling for static scenes\n * container.cullableChildren = false;\n * ```\n * @category scene\n * @standard\n */\nexport interface CullingMixinConstructor {\n\t/**\n\t * Custom shape used for culling calculations instead of object bounds.\n\t * Defined in local space coordinates relative to the object.\n\t * > [!NOTE]\n\t * > Setting this to a custom Rectangle allows you to define a specific area for culling,\n\t * > which can improve performance by avoiding expensive bounds calculations.\n\t * @example\n\t * ```ts\n\t * const container = new Container();\n\t *\n\t * // Define custom culling boundary\n\t * container.cullArea = new Rectangle(0, 0, 800, 600);\n\t *\n\t * // Reset to use object bounds\n\t * container.cullArea = null;\n\t * ```\n\t * @remarks\n\t * - Improves performance by avoiding bounds calculations\n\t * - Useful for containers with many children\n\t * - Set to null to use object bounds\n\t * @default null\n\t */\n\tcullArea: Rectangle;\n\t/**\n\t * Controls whether this object should be culled when out of view.\n\t * When true, the object will not be rendered if its bounds are outside the visible area.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t *\n\t * // Enable culling\n\t * sprite.cullable = true;\n\t *\n\t * // Force object to always render\n\t * sprite.cullable = false;\n\t * ```\n\t * @remarks\n\t * - Does not affect transform updates\n\t * - Applies to this object only\n\t * - Children follow their own cullable setting\n\t * @default false\n\t */\n\tcullable: boolean;\n\t/**\n\t * Controls whether children of this container can be culled.\n\t * When false, skips recursive culling checks for better performance.\n\t * @example\n\t * ```ts\n\t * const container = new Container();\n\t *\n\t * // Enable container culling\n\t * container.cullable = true;\n\t *\n\t * // Disable child culling for performance\n\t * container.cullableChildren = false;\n\t *\n\t * // Children will always render if container is visible\n\t * container.addChild(sprite1, sprite2, sprite3);\n\t * ```\n\t * @remarks\n\t * - Improves performance for static scenes\n\t * - Useful when children are always within container bounds\n\t * - Parent culling still applies\n\t * @default true\n\t */\n\tcullableChildren: boolean;\n}\n/** @internal */\nexport const cullingMixin: CullingMixinConstructor;\n/**\n * Application options for the {@link CullerPlugin}.\n * These options control how your application handles culling of display objects.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n * await app.init({\n *     culler: {\n *         updateTransform: false // Skip updating transforms for culled objects\n *     }\n * });\n * ```\n * @category app\n * @standard\n */\nexport interface CullerPluginOptions {\n\t/**\n\t * Options for the culler behavior.\n\t * @example\n\t * ```ts\n\t * // Basic culling options\n\t * const app = new Application();\n\t * await app.init({\n\t *     culler: {...}\n\t * });\n\t * ```\n\t */\n\tculler?: {\n\t\t/**\n\t\t * Update the transform of culled objects.\n\t\t *\n\t\t * > [!IMPORTANT] Keeping this as `false` can improve performance by avoiding unnecessary calculations,\n\t\t * > however, the transform used for culling may not be up-to-date if the object has moved since the last render.\n\t\t * @default true\n\t\t * @example\n\t\t * ```ts\n\t\t * const app = new Application();\n\t\t * await app.init({\n\t\t *     culler: {\n\t\t *         updateTransform: false // Skip updating transforms for culled objects\n\t\t *     }\n\t\t * });\n\t\t * ```\n\t\t */\n\t\tupdateTransform?: boolean;\n\t};\n}\n/**\n * An {@link Application} plugin that automatically culls (hides) display objects that are outside\n * the visible screen area. This improves performance by not rendering objects that aren't visible.\n *\n * Key Features:\n * - Automatic culling based on screen boundaries\n * - Configurable culling areas and behavior per container\n * - Can improve rendering performance\n * @example\n * ```ts\n * import { Application, CullerPlugin, Container, Rectangle } from 'pixi.js';\n *\n * // Register the plugin\n * extensions.add(CullerPlugin);\n *\n * // Create application\n * const app = new Application();\n * await app.init({...});\n *\n * // Create a container with culling enabled\n * const container = new Container();\n * container.cullable = true;         // Enable culling for this container\n * container.cullableChildren = true; // Enable culling for children (default)\n * app.stage.addChild(container);\n *\n * // Optional: Set custom cull area to avoid expensive bounds calculations\n * container.cullArea = new Rectangle(0, 0, app.screen.width, app.screen.height);\n *\n * // Add many sprites to the group\n * for (let j = 0; j < 100; j++) {\n *     const sprite = Sprite.from('texture.png');\n *     sprite.x = Math.random() * 2000;\n *     sprite.y = Math.random() * 2000;\n *\n *     sprite.cullable = true; // Enable culling for each sprite\n *\n *     // Set cullArea if needed\n *     // sprite.cullArea = new Rectangle(0, 0, 100, 100); // Optional\n *\n *     // Add to container\n *     container.addChild(sprite);\n * }\n * ```\n * @remarks\n * To enable culling, you must set the following properties on your containers:\n * - `cullable`: Set to `true` to enable culling for the container\n * - `cullableChildren`: Set to `true` to enable culling for children (default)\n * - `cullArea`: Optional custom Rectangle for culling bounds\n *\n * Performance Tips:\n * - Group objects that are spatially related\n * - Use `cullArea` for containers with many children to avoid bounds calculations\n * - Set `cullableChildren = false` for containers that are always fully visible\n * @category app\n * @standard\n * @see {@link Culler} For the underlying culling implementation\n * @see {@link CullingMixinConstructor} For culling properties documentation\n */\nexport class CullerPlugin {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\t/** @internal */\n\tstatic renderer: Renderer;\n\t/** @internal */\n\tstatic stage: Container;\n\t/** @internal */\n\tstatic render: () => void;\n\tprivate static _renderRef;\n\t/**\n\t * Initialize the plugin with scope of application instance\n\t * @private\n\t * @param {object} [options] - See application options\n\t */\n\tstatic init(options?: PixiMixins.ApplicationOptions): void;\n\t/** @internal */\n\tstatic destroy(): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Container extends Partial<CullingMixinConstructor> {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerOptions extends Partial<CullingMixinConstructor> {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ApplicationOptions extends Partial<CullerPluginOptions> {\n\t\t}\n\t}\n}\n/**\n * Options for configuring a {@link DOMContainer}.\n * Controls how DOM elements are integrated into the PixiJS scene graph.\n * @example\n * ```ts\n * // Create with a custom element\n * const domContainer = new DOMContainer({\n *     element: document.createElement('input'),\n *     anchor: { x: 0.5, y: 0.5 } // or anchor: 0.5 to center both x and y\n * });\n * ```\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface DOMContainerOptions extends ViewContainerOptions {\n\t/**\n\t * The DOM element to use for the container.\n\t * Can be any HTML element like div, input, textarea, etc.\n\t *\n\t * If not provided, creates a new div element.\n\t * @default document.createElement('div')\n\t */\n\telement?: HTMLElement;\n\t/**\n\t * The anchor point of the container.\n\t * - Can be a single number to set both x and y\n\t * - Can be a point-like object with x,y coordinates\n\t * - (0,0) is top-left\n\t * - (1,1) is bottom-right\n\t * - (0.5,0.5) is center\n\t * @default 0\n\t */\n\tanchor?: PointData | number;\n}\n/**\n * The DOMContainer object is used to render DOM elements within the PixiJS scene graph.\n * It allows you to integrate HTML elements into your PixiJS application while maintaining\n * proper transform hierarchy and visibility.\n *\n * DOMContainer is especially useful for rendering standard DOM elements\n * that handle user input, such as `<input>` or `<textarea>`.\n * This is often simpler and more flexible than trying to implement text input\n * directly in PixiJS. For instance, if you need text fields or text areas,\n * you can embed them through this container for native browser text handling.\n *\n * --------- EXPERIMENTAL ---------\n *\n * This is a new API, things may change and it may not work as expected.\n * We want to hear your feedback as we go!\n *\n * --------------------------------\n * @example\n * @example\n * ```ts\n * // Basic text display\n * const textContainer = new DOMContainer();\n * textContainer.element.innerHTML = 'Hello World!';\n * app.stage.addChild(textContainer);\n *\n * // Input field with centered anchor\n * const inputContainer = new DOMContainer({\n *     element: document.createElement('input'),\n *     anchor: 0.5\n * });\n * inputContainer.position.set(400, 300);\n * app.stage.addChild(inputContainer);\n *\n * // Rich text area\n * const textArea = new DOMContainer({\n *     element: document.createElement('textarea'),\n *     anchor: { x: 0, y: 0 }\n * });\n * textArea.scale.set(2);\n * app.stage.addChild(textArea);\n * ```\n * @category scene\n * @standard\n */\nexport class DOMContainer extends ViewContainer<never> {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/** @internal */\n\tbatched: boolean;\n\t/**\n\t * The anchor point of the container.\n\t * @internal\n\t */\n\treadonly _anchor: Point;\n\t/** The DOM element that this container is using. */\n\tprivate _element;\n\t/**\n\t * @param options - The options for creating the DOM container.\n\t */\n\tconstructor(options?: DOMContainerOptions);\n\t/**\n\t * The anchor sets the origin point of the container.\n\t * Controls the relative positioning of the DOM element.\n\t *\n\t * The default is `(0,0)`, this means the container's origin is the top left.\n\t * Setting the anchor to `(0.5,0.5)` means the container's origin is centered.\n\t * Setting the anchor to `(1,1)` would mean the container's origin point will be the bottom right corner.\n\t * @example\n\t * ```ts\n\t * const container = new DOMContainer();\n\t *\n\t * // Set anchor to center (shorthand)\n\t * container.anchor = 0.5;\n\t *\n\t * // Set anchor to bottom-right\n\t * container.anchor = { x: 1, y: 1 };\n\t *\n\t * // Set anchor to custom position\n\t * container.anchor = new Point(0.3, 0.7);\n\t * ```\n\t */\n\tget anchor(): Point;\n\t/**\n\t * Sets the anchor point of the container.\n\t * @param value - New anchor value:\n\t * - number: Sets both x and y to same value\n\t * - PointData: Sets x and y separately\n\t */\n\tset anchor(value: PointData | number);\n\t/**\n\t * Sets the DOM element for this container.\n\t * This will replace the current element and update the view.\n\t * @param value - The new DOM element to use\n\t * @example\n\t * ```ts\n\t * const domContainer = new DOMContainer();\n\t * domContainer.element = document.createElement('input');\n\t * ```\n\t */\n\tset element(value: HTMLElement);\n\t/**\n\t * The DOM element associated with this container.\n\t * @example\n\t * ```ts\n\t * const domContainer = new DOMContainer();\n\t * domContainer.element.innerHTML = 'Hello World!';\n\t * document.body.appendChild(domContainer.element);\n\t * ```\n\t */\n\tget element(): HTMLElement;\n\t/** @private */\n\tprotected updateBounds(): void;\n\t/**\n\t * Destroys this DOM container.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that\n\t * @example\n\t * domContainer.destroy();\n\t * domContainer.destroy(true);\n\t */\n\tdestroy(options?: boolean): void;\n}\n/**\n * The DOMPipe class is responsible for managing and rendering DOM elements within a PixiJS scene.\n * It maps dom elements to the canvas and ensures they are correctly positioned and visible.\n * @internal\n */\nexport class DOMPipe implements RenderPipe<DOMContainer> {\n\t/**\n\t * Static property defining the extension type and name for the DOMPipe.\n\t * This is used to register the DOMPipe with different rendering pipelines.\n\t */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"dom\";\n\t};\n\tprivate _renderer;\n\t/** Array to keep track of attached DOM elements */\n\tprivate readonly _attachedDomElements;\n\t/** The main DOM element that acts as a container for other DOM elements */\n\tprivate readonly _domElement;\n\t/** The CanvasTransformSync instance that keeps the DOM element in sync with the canvas */\n\tprivate _canvasObserver;\n\t/**\n\t * Constructor for the DOMPipe class.\n\t * @param renderer - The renderer instance that this DOMPipe will be associated with.\n\t */\n\tconstructor(renderer: Renderer);\n\t/** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */\n\tinit(): void;\n\t/**\n\t * Adds a renderable DOM container to the list of attached elements.\n\t * @param domContainer - The DOM container to be added.\n\t * @param _instructionSet - The instruction set (unused).\n\t */\n\taddRenderable(domContainer: DOMContainer, _instructionSet: InstructionSet): void;\n\t/**\n\t * Updates a renderable DOM container.\n\t * @param _domContainer - The DOM container to be updated (unused).\n\t */\n\tupdateRenderable(_domContainer: DOMContainer): void;\n\t/**\n\t * Validates a renderable DOM container.\n\t * @param _domContainer - The DOM container to be validated (unused).\n\t * @returns Always returns true as validation is not required.\n\t */\n\tvalidateRenderable(_domContainer: DOMContainer): boolean;\n\t/** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n\tpostrender(): void;\n\t/** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n\tdestroy(): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tdom: DOMPipe;\n\t\t}\n\t}\n}\n/**\n * A specialized event class for wheel/scroll interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide wheel-specific properties while\n * maintaining compatibility with the DOM WheelEvent interface.\n *\n * Key features:\n * - Provides scroll delta information\n * - Supports different scroll modes (pixel, line, page)\n * - Inherits mouse event properties\n * - Normalizes cross-browser wheel events\n * @example\n * ```ts\n * // Basic wheel event handling\n * sprite.on('wheel', (event: FederatedWheelEvent) => {\n *     // Get scroll amount\n *     console.log('Vertical scroll:', event.deltaY);\n *     console.log('Horizontal scroll:', event.deltaX);\n *\n *     // Check scroll mode\n *     if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_LINE) {\n *         console.log('Scrolling by lines');\n *     } else if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_PAGE) {\n *         console.log('Scrolling by pages');\n *     } else {\n *         console.log('Scrolling by pixels');\n *     }\n *\n *     // Get scroll position\n *     console.log('Scroll at:', event.global.x, event.global.y);\n * });\n *\n * // Common use case: Zoom control\n * container.on('wheel', (event: FederatedWheelEvent) => {\n *     // Prevent page scrolling\n *     event.preventDefault();\n *\n *     // Zoom in/out based on scroll direction\n *     const zoomFactor = 1 + (event.deltaY / 1000);\n *     container.scale.set(container.scale.x * zoomFactor);\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent} DOM WheelEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent {\n\t/**\n\t * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n\t * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n\t */\n\tdeltaMode: number;\n\t/** Horizontal scroll amount */\n\tdeltaX: number;\n\t/** Vertical scroll amount */\n\tdeltaY: number;\n\t/** z-axis scroll amount. */\n\tdeltaZ: number;\n\t/**\n\t * Units specified in pixels.\n\t * @ignore\n\t */\n\tstatic readonly DOM_DELTA_PIXEL = 0;\n\t/**\n\t * Units specified in pixels.\n\t * @ignore\n\t */\n\treadonly DOM_DELTA_PIXEL = 0;\n\t/**\n\t * Units specified in lines.\n\t * @ignore\n\t */\n\tstatic readonly DOM_DELTA_LINE = 1;\n\t/**\n\t * Units specified in lines.\n\t * @ignore\n\t */\n\treadonly DOM_DELTA_LINE = 1;\n\t/**\n\t * Units specified in pages.\n\t * @ignore\n\t */\n\tstatic readonly DOM_DELTA_PAGE = 2;\n\t/**\n\t * Units specified in pages.\n\t * @ignore\n\t */\n\treadonly DOM_DELTA_PAGE = 2;\n}\n/**\n * The tracking data for each pointer held in the state of an {@link EventBoundary}.\n *\n * ```ts\n * pressTargetsByButton: {\n *     [id: number]: Container[];\n * };\n * clicksByButton: {\n *     [id: number]: {\n *         clickCount: number;\n *         target: Container;\n *         timeStamp: number;\n *     };\n * };\n * overTargets: Container[];\n * ```\n * @typedef {object} TrackingData\n * @property {Record.<number, Container>} pressTargetsByButton - The pressed containers'\n *  propagation paths by each button of the pointer.\n * @property {Record.<number, object>} clicksByButton - Holds clicking data for each button of the pointer.\n * @property {Container[]} overTargets - The Container propagation path over which the pointer is hovering.\n * @category events\n * @internal\n */\nexport type TrackingData = {\n\tpressTargetsByButton: {\n\t\t[id: number]: Container[];\n\t};\n\tclicksByButton: {\n\t\t[id: number]: {\n\t\t\tclickCount: number;\n\t\t\ttarget: Container;\n\t\t\ttimeStamp: number;\n\t\t};\n\t};\n\toverTargets: Container[];\n};\ntype EmitterListener = {\n\tfn(...args: any[]): any;\n\tcontext: any;\n\tonce: boolean;\n};\n/**\n * Internal storage of event listeners in EventEmitter.\n * @ignore\n */\nexport type EmitterListeners = Record<string, EmitterListener | EmitterListener[]>;\n/**\n * The type of cursor to use when the mouse pointer is hovering over an interactive element.\n * Accepts any valid CSS cursor value.\n * @example\n * ```ts\n * // Basic cursor types\n * sprite.cursor = 'pointer';    // Hand cursor for clickable elements\n * sprite.cursor = 'grab';       // Grab cursor for draggable elements\n * sprite.cursor = 'crosshair';  // Precise cursor for selection\n *\n * // Direction cursors\n * sprite.cursor = 'n-resize';   // North resize\n * sprite.cursor = 'ew-resize';  // East-west resize\n * sprite.cursor = 'nesw-resize';// Northeast-southwest resize\n *\n * // Custom cursor with fallback\n * sprite.cursor = 'url(\"custom.png\"), auto';\n * ```\n *\n * Common cursor values:\n * - Basic: `auto`, `default`, `none`, `pointer`, `wait`\n * - Text: `text`, `vertical-text`\n * - Links: `alias`, `copy`, `move`\n * - Selection: `cell`, `crosshair`\n * - Drag: `grab`, `grabbing`\n * - Disabled: `not-allowed`, `no-drop`\n * - Resize: `n-resize`, `e-resize`, `s-resize`, `w-resize`\n * - Bidirectional: `ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`\n * - Other: `help`, `progress`\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n * @category events\n * @standard\n */\nexport type Cursor = \"auto\" | \"default\" | \"none\" | \"context-menu\" | \"help\" | \"pointer\" | \"progress\" | \"wait\" | \"cell\" | \"crosshair\" | \"text\" | \"vertical-text\" | \"alias\" | \"copy\" | \"move\" | \"no-drop\" | \"not-allowed\" | \"e-resize\" | \"n-resize\" | \"ne-resize\" | \"nw-resize\" | \"s-resize\" | \"se-resize\" | \"sw-resize\" | \"w-resize\" | \"ns-resize\" | \"ew-resize\" | \"nesw-resize\" | \"col-resize\" | \"nwse-resize\" | \"row-resize\" | \"all-scroll\" | \"zoom-in\" | \"zoom-out\" | \"grab\" | \"grabbing\";\n/**\n * Interface defining a hit area for pointer interaction. The hit area specifies\n * the region in which pointer events should be captured by a display object.\n * @example\n * ```ts\n * // Create a rectangular hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Create a circular hit area\n * sprite.hitArea = new Circle(50, 50, 50);\n *\n * // Custom hit area implementation\n * sprite.hitArea = {\n *     contains(x: number, y: number) {\n *         // Custom hit testing logic\n *         return x >= 0 && x <= 100 && y >= 0 && y <= 100;\n *     }\n * };\n * ```\n * @remarks\n * - Hit areas override the default bounds-based hit testing\n * - Can improve performance by simplifying hit tests\n * - Useful for irregular shapes or precise interaction areas\n * - Common implementations include Rectangle, Circle, Polygon\n * @see {@link Container.eventMode} For enabling interactivity\n * @see {@link Container.interactive} For backwards compatibility\n * @category events\n * @standard\n */\nexport interface IHitArea {\n\t/**\n\t * Checks if the given coordinates are inside this hit area.\n\t * @param {number} x - The x coordinate to check\n\t * @param {number} y - The y coordinate to check\n\t * @returns True if the coordinates are inside the hit area\n\t */\n\tcontains(x: number, y: number): boolean;\n}\n/**\n * Function type for handlers, e.g., onclick\n * @category events\n * @advanced\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n/**\n * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n * @example\n * ```ts\n * // Basic event mode setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';    // Enable standard interaction\n * sprite.on('pointerdown', () => { console.log('clicked!'); });\n *\n * // Different event modes\n * sprite.eventMode = 'none';      // Disable all interaction\n * sprite.eventMode = 'passive';   // Only allow interaction on children\n * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n * sprite.eventMode = 'dynamic';   // For moving/animated objects\n * ```\n *\n * Available modes:\n * - `'none'`: Ignores all interaction events, even on its children\n * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n * a ticker to allow for interaction when the mouse isn't moving\n *\n * Performance tips:\n * - Use `'none'` for pure visual elements\n * - Use `'passive'` for containers with some interactive children\n * - Use `'static'` for standard buttons/controls\n * - Use `'dynamic'` only for moving/animated interactive elements\n * @since 7.2.0\n * @category events\n * @standard\n */\nexport type EventMode = \"none\" | \"passive\" | \"auto\" | \"static\" | \"dynamic\";\n/**\n * The properties available for any interactive object. This interface defines the core interaction\n * properties and event handlers that can be set on any Container in PixiJS.\n * @example\n * ```ts\n * // Basic interactive setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';\n * sprite.cursor = 'pointer';\n *\n * // Using event handlers\n * sprite.on('click', (event) => console.log('Sprite clicked!', event));\n * sprite.on('pointerdown', (event) => console.log('Pointer down!', event));\n *\n * // Using property-based event handlers\n * sprite.onclick = (event) => console.log('Clicked!');\n * sprite.onpointerenter = () => sprite.alpha = 0.7;\n * sprite.onpointerleave = () => sprite.alpha = 1.0;\n *\n * // Custom hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n * ```\n *\n * Core Properties:\n * - `eventMode`: Controls how the object handles interaction events\n * - `cursor`: Sets the mouse cursor when hovering\n * - `hitArea`: Defines custom hit testing area\n * - `interactive`: Alias for `eventMode` to enable interaction with \"static\" or \"passive\" modes\n * - `interactiveChildren`: Controls hit testing on children\n *\n * Event Handlers:\n * - Mouse: click, mousedown, mouseup, mousemove, mouseenter, mouseleave\n * - Touch: touchstart, touchend, touchmove, tap\n * - Pointer: pointerdown, pointerup, pointermove, pointerover\n * - Global: globalpointermove, globalmousemove, globaltouchmove\n * > [!IMPORTANT] Global events are fired when the pointer moves even if it is outside the bounds of the Container.\n * @see {@link EventMode} For interaction mode details\n * @see {@link Cursor} For cursor style options\n * @see {@link IHitArea} For hit area implementation\n * @category events\n * @standard\n */\nexport interface FederatedOptions {\n\t/**\n\t * The cursor style to display when the mouse pointer is hovering over the object.\n\t * Accepts any valid CSS cursor value or custom cursor URL.\n\t * @example\n\t * ```ts\n\t * // Common cursor types\n\t * sprite.cursor = 'pointer';     // Hand cursor for clickable elements\n\t * sprite.cursor = 'grab';        // Grab cursor for draggable elements\n\t * sprite.cursor = 'crosshair';   // Precise cursor for selection\n\t * sprite.cursor = 'not-allowed'; // Indicate disabled state\n\t *\n\t * // Direction cursors\n\t * sprite.cursor = 'n-resize';    // North resize\n\t * sprite.cursor = 'ew-resize';   // East-west resize\n\t * sprite.cursor = 'nesw-resize'; // Northeast-southwest resize\n\t *\n\t * // Custom cursor with fallback\n\t * sprite.cursor = 'url(\"custom.png\"), auto';\n\t * sprite.cursor = 'url(\"cursor.cur\") 2 2, pointer'; // With hotspot offset\n\t * ```\n\t * @type {Cursor | string}\n\t * @default undefined\n\t * @see {@link EventSystem.cursorStyles} For setting global cursor styles\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n\t */\n\tcursor?: Cursor | (string & {});\n\t/**\n\t * Enable interaction events for the Container. Touch, pointer and mouse events are supported.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t *\n\t * // Enable standard interaction (like buttons)\n\t * sprite.eventMode = 'static';\n\t * sprite.on('pointerdown', () => console.log('clicked!'));\n\t *\n\t * // Enable for moving objects\n\t * sprite.eventMode = 'dynamic';\n\t * sprite.on('pointermove', () => updatePosition());\n\t *\n\t * // Disable all interaction\n\t * sprite.eventMode = 'none';\n\t *\n\t * // Only allow child interactions\n\t * sprite.eventMode = 'passive';\n\t * ```\n\t *\n\t * Available modes:\n\t *\n\t * - `'none'`: Ignores all interaction events, even on its children. Best for pure visuals.\n\t * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive\n\t * children. Interactive children will still emit events.\n\t * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7.\n\t * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7. Best for buttons/UI.\n\t * - `'dynamic'`: Like static but also receives synthetic events when pointer is idle. Best for moving objects.\n\t *\n\t * Performance tips:\n\t * - Use `'none'` for pure visual elements\n\t * - Use `'passive'` for containers with some interactive children\n\t * - Use `'static'` for standard UI elements\n\t * - Use `'dynamic'` only when needed for moving/animated elements\n\t * @since 7.2.0\n\t */\n\teventMode?: EventMode;\n\t/**\n\t * Whether this object should fire UI events. This is an alias for `eventMode` set to `'static'` or `'passive'`.\n\t * Setting this to true will enable interaction events like `pointerdown`, `click`, etc.\n\t * Setting it to false will disable all interaction events on this object.\n\t * @see {@link Container.eventMode}\n\t * @example\n\t * ```ts\n\t * // Enable interaction events\n\t * sprite.interactive = true;  // Sets eventMode = 'static'\n\t * sprite.interactive = false; // Sets eventMode = 'passive'\n\t * ```\n\t */\n\tinteractive?: boolean;\n\t/**\n\t * Controls whether children of this container can receive pointer events.\n\t *\n\t * Setting this to false allows PixiJS to skip hit testing on all children,\n\t * improving performance for containers with many non-interactive children.\n\t * @default true\n\t * @example\n\t * ```ts\n\t * // Container with many visual-only children\n\t * const container = new Container();\n\t * container.interactiveChildren = false; // Skip hit testing children\n\t *\n\t * // Menu with interactive buttons\n\t * const menu = new Container();\n\t * menu.interactiveChildren = true; // Test all children\n\t * menu.addChild(button1, button2, button3);\n\t *\n\t * // Performance optimization\n\t * background.interactiveChildren = false;\n\t * foreground.interactiveChildren = true;\n\t * ```\n\t */\n\tinteractiveChildren?: boolean;\n\t/**\n\t * Defines a custom hit area for pointer interaction testing. When set, this shape will be used\n\t * for hit testing instead of the container's standard bounds.\n\t * @example\n\t * ```ts\n\t * import { Rectangle, Circle, Sprite } from 'pixi.js';\n\t *\n\t * // Rectangular hit area\n\t * const button = new Sprite(texture);\n\t * button.eventMode = 'static';\n\t * button.hitArea = new Rectangle(0, 0, 100, 50);\n\t *\n\t * // Circular hit area\n\t * const icon = new Sprite(texture);\n\t * icon.eventMode = 'static';\n\t * icon.hitArea = new Circle(32, 32, 32);\n\t *\n\t * // Custom hit area with polygon\n\t * const custom = new Sprite(texture);\n\t * custom.eventMode = 'static';\n\t * custom.hitArea = new Polygon([0,0, 100,0, 100,100, 0,100]);\n\t *\n\t * // Custom hit testing logic\n\t * sprite.hitArea = {\n\t *     contains(x: number, y: number) {\n\t *         // Custom collision detection\n\t *         return x >= 0 && x <= width && y >= 0 && y <= height;\n\t *     }\n\t * };\n\t * ```\n\t * @remarks\n\t * - Takes precedence over the container's bounds for hit testing\n\t * - Can improve performance by simplifying collision checks\n\t * - Useful for irregular shapes or precise click areas\n\t */\n\thitArea?: IHitArea | null;\n\t/**\n\t * Property-based event handler for the `click` event.\n\t * Fired when a pointer device (mouse, touch, etc.) completes a click action.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('click', (event) => {\n\t *    console.log('Sprite clicked at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onclick = (event) => {\n\t *     console.log('Clicked at:', event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonclick?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mousedown` event.\n\t * Fired when a mouse button is pressed while the pointer is over the object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mousedown', (event) => {\n\t *    sprite.alpha = 0.5; // Visual feedback\n\t *    console.log('Mouse button:', event.button);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmousedown = (event) => {\n\t *     sprite.alpha = 0.5; // Visual feedback\n\t *     console.log('Mouse button:', event.button);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmousedown?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseenter` event.\n\t * Fired when the mouse pointer enters the bounds of the object. Does not bubble.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseenter', (event) => {\n\t *     sprite.scale.set(1.1);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseenter = (event) => {\n\t *     sprite.scale.set(1.1);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmouseenter?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseleave` event.\n\t * Fired when the pointer leaves the bounds of the display object. Does not bubble.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseleave', (event) => {\n\t *    sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseleave = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmouseleave?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mousemove` event.\n\t * Fired when the pointer moves while over the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mousemove', (event) => {\n\t *    // Get coordinates relative to the sprite\n\t *   console.log('Local:', event.getLocalPosition(sprite));\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmousemove = (event) => {\n\t *     // Get coordinates relative to the sprite\n\t *     console.log('Local:', event.getLocalPosition(sprite));\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmousemove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `globalmousemove` event.\n\t *\n\t * Fired when the mouse moves anywhere, regardless of whether the pointer is over this object.\n\t * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('globalmousemove', (event) => {\n\t *     // Move sprite to mouse position\n\t *     sprite.position.copyFrom(event.global);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onglobalmousemove = (event) => {\n\t *     // Move sprite to mouse position\n\t *     sprite.position.copyFrom(event.global);\n\t * };\n\t * ```\n\t * @default null\n\t * @remarks\n\t * - Fires even when the mouse is outside the object's bounds\n\t * - Useful for drag operations or global mouse tracking\n\t * - Must have `eventMode` set appropriately to receive events\n\t * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n\t */\n\tonglobalmousemove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseout` event.\n\t * Fired when the pointer moves out of the bounds of the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseout', (event) => {\n\t *    sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseout = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmouseout?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseover` event.\n\t * Fired when the pointer moves onto the bounds of the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseover', (event) => {\n\t *      sprite.scale.set(1.1);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseover = (event) => {\n\t *     sprite.scale.set(1.1);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmouseover?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseup` event.\n\t * Fired when a mouse button is released over the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseup', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseup = (event) => {\n\t *      sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmouseup?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseupoutside` event.\n\t * Fired when a mouse button is released outside the display object that initially\n\t * registered a mousedown.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseupoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseupoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonmouseupoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointercancel` event.\n\t * Fired when a pointer device interaction is canceled or lost.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointercancel', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointercancel = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointercancel?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerdown` event.\n\t * Fired when a pointer device button (mouse, touch, pen, etc.) is pressed.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerdown', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerdown = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointerdown?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerenter` event.\n\t * Fired when a pointer device enters the bounds of the display object. Does not bubble.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerenter', (event) => {\n\t *     sprite.scale.set(1.2);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerenter = (event) => {\n\t *     sprite.scale.set(1.2);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointerenter?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerleave` event.\n\t * Fired when a pointer device leaves the bounds of the display object. Does not bubble.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t * // Using emitter handler\n\t * sprite.on('pointerleave', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerleave = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointerleave?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointermove` event.\n\t * Fired when a pointer device moves while over the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointermove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointermove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointermove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `globalpointermove` event.\n\t *\n\t * Fired when the pointer moves anywhere, regardless of whether the pointer is over this object.\n\t * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('globalpointermove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onglobalpointermove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t * @remarks\n\t * - Fires even when the mouse is outside the object's bounds\n\t * - Useful for drag operations or global mouse tracking\n\t * - Must have `eventMode` set appropriately to receive events\n\t * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n\t */\n\tonglobalpointermove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerout` event.\n\t * Fired when the pointer moves out of the bounds of the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerout', (event) => {\n\t *    sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerout = (event) => {\n\t *    sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointerout?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerover` event.\n\t * Fired when the pointer moves over the bounds of the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerover', (event) => {\n\t *     sprite.scale.set(1.2);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerover = (event) => {\n\t *     sprite.scale.set(1.2);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointerover?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointertap` event.\n\t * Fired when a pointer device completes a tap action (e.g., touch or mouse click).\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointertap', (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointertap = (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointertap?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerup` event.\n\t * Fired when a pointer device button (mouse, touch, pen, etc.) is released.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerup', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerup = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointerup?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerupoutside` event.\n\t * Fired when a pointer device button is released outside the bounds of the display object\n\t * that initially registered a pointerdown.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerupoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerupoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonpointerupoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightclick` event.\n\t * Fired when a right-click (context menu) action is performed on the object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightclick', (event) => {\n\t *     console.log('Right-clicked at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightclick = (event) => {\n\t *     console.log('Right-clicked at:', event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonrightclick?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightdown` event.\n\t * Fired when a right mouse button is pressed down over the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightdown', (event) => {\n\t *     sprite.scale.set(0.9);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightdown = (event) => {\n\t *     sprite.scale.set(0.9);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonrightdown?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightup` event.\n\t * Fired when a right mouse button is released over the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightup', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightup = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonrightup?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightupoutside` event.\n\t * Fired when a right mouse button is released outside the bounds of the display object\n\t * that initially registered a rightdown.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightupoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightupoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonrightupoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `tap` event.\n\t * Fired when a tap action (touch) is completed on the object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('tap', (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontap = (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tontap?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchcancel` event.\n\t * Fired when a touch interaction is canceled, such as when the touch is interrupted.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchcancel', (event) => {\n\t *     console.log('Touch canceled at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchcancel = (event) => {\n\t *     console.log('Touch canceled at:', event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tontouchcancel?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchend` event.\n\t * Fired when a touch interaction ends, such as when the finger is lifted from the screen.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchend', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchend = (event) => {\n\t *    sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tontouchend?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchendoutside` event.\n\t * Fired when a touch interaction ends outside the bounds of the display object\n\t * that initially registered a touchstart.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchendoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchendoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tontouchendoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchmove` event.\n\t * Fired when a touch interaction moves while over the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchmove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchmove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tontouchmove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `globaltouchmove` event.\n\t *\n\t * Fired when a touch interaction moves anywhere, regardless of whether the pointer is over this object.\n\t * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('globaltouchmove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onglobaltouchmove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t * ```\n\t * @default null\n\t * @remarks\n\t * - Fires even when the touch is outside the object's bounds\n\t * - Useful for drag operations or global touch tracking\n\t * - Must have `eventMode` set appropriately to receive events\n\t * - Part of the global move events family along with `globalpointermove` and `globalmousemove`\n\t */\n\tonglobaltouchmove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchstart` event.\n\t * Fired when a touch interaction starts, such as when a finger touches the screen.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchstart', (event) => {\n\t *     sprite.scale.set(0.9);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchstart = (event) => {\n\t *     sprite.scale.set(0.9);\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tontouchstart?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `wheel` event.\n\t * Fired when the mouse wheel is scrolled while over the display object.\n\t * @example\n\t * ```ts\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('wheel', (event) => {\n\t *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n\t *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n\t * });\n\t * // Using property-based handler\n\t * sprite.onwheel = (event) => {\n\t *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n\t *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tonwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n/**\n * The options for the `addEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n * @category events\n * @advanced\n */\nexport type AddListenerOptions = boolean | AddEventListenerOptions;\n/**\n * The options for the `removeEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener}\n * @category events\n * @advanced\n */\nexport type RemoveListenerOptions = boolean | EventListenerOptions;\n/**\n * Additional properties for a Container that is used for interaction events.\n * @category events\n * @advanced\n */\nexport interface IFederatedContainer extends FederatedOptions {\n\t/** The parent of this event target. */\n\treadonly parent?: Container | null;\n\t/** The children of this event target. */\n\treadonly children?: ReadonlyArray<Container>;\n\t/** @private */\n\t_internalEventMode: EventMode;\n\t/**\n\t * Determines if the container is interactive or not\n\t * @returns {boolean} Whether the container is interactive or not\n\t * @since 7.2.0\n\t * @example\n\t * import { Sprite } from 'pixi.js';\n\t *\n\t * const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t * sprite.isInteractive(); // true\n\t *\n\t * sprite.eventMode = 'dynamic';\n\t * sprite.isInteractive(); // true\n\t *\n\t * sprite.eventMode = 'none';\n\t * sprite.isInteractive(); // false\n\t *\n\t * sprite.eventMode = 'passive';\n\t * sprite.isInteractive(); // false\n\t *\n\t * sprite.eventMode = 'auto';\n\t * sprite.isInteractive(); // false\n\t */\n\tisInteractive: () => boolean;\n\t/**\n\t * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n\t * seeks to be compatible with the DOM's `addEventListener` with support for options.\n\t * @param {any} type - The type of event to listen to.\n\t * @param {any} listener - The listener callback or object.\n\t * @param {any} options - Listener options, used for capture phase.\n\t * @example\n\t * // Tell the user whether they did a single, double, triple, or nth click.\n\t * button.addEventListener('click', {\n\t *     handleEvent(e): {\n\t *         let prefix;\n\t *\n\t *         switch (e.detail) {\n\t *             case 1: prefix = 'single'; break;\n\t *             case 2: prefix = 'double'; break;\n\t *             case 3: prefix = 'triple'; break;\n\t *             default: prefix = e.detail + 'th'; break;\n\t *         }\n\t *\n\t *         console.log('That was a ' + prefix + 'click');\n\t *     }\n\t * });\n\t *\n\t * // But skip the first click!\n\t * button.parent.addEventListener('click', function blockClickOnce(e) {\n\t *     e.stopImmediatePropagation();\n\t *     button.parent.removeEventListener('click', blockClickOnce, true);\n\t * }, {\n\t *     capture: true,\n\t * });\n\t */\n\taddEventListener<K extends keyof AllFederatedEventMap>(type: K, listener: (e: AllFederatedEventMap[K]) => any, options?: AddListenerOptions): void;\n\taddEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: AddListenerOptions): void;\n\t/**\n\t * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n\t * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n\t * @param {K} type - The type of event the listener is bound to.\n\t * @param {any} listener - The listener callback or object.\n\t * @param {RemoveListenerOptions} options - The original listener options.\n\t * This is required to deregister a capture phase listener.\n\t */\n\tremoveEventListener<K extends keyof AllFederatedEventMap>(type: K, listener: (e: AllFederatedEventMap[K]) => any, options?: RemoveListenerOptions): void;\n\tremoveEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: RemoveListenerOptions): void;\n\t/**\n\t * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n\t *\n\t * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n\t * @param {FederatedEvent} e - The event to dispatch.\n\t * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n\t * @example\n\t * // Reuse a click event!\n\t * button.dispatchEvent(clickEvent);\n\t */\n\tdispatchEvent(e: FederatedEvent): boolean;\n}\n/** @internal */\nexport const FederatedContainer: IFederatedContainer;\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @category events\n * @advanced\n */\nexport class EventBoundary {\n\t/**\n\t * The root event-target residing below the event boundary.\n\t * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n\t */\n\trootTarget: Container;\n\t/**\n\t * Emits events after they were dispatched into the scene graph.\n\t *\n\t * This can be used for global events listening, regardless of the scene graph being used. It should\n\t * not be used by interactive libraries for normal use.\n\t *\n\t * Special events that do not bubble all the way to the root target are not emitted from here,\n\t * e.g. pointerenter, pointerleave, click.\n\t */\n\tdispatch: EventEmitter;\n\t/** The cursor preferred by the event targets underneath this boundary. */\n\tcursor: Cursor | (string & {});\n\t/**\n\t * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n\t *\n\t * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n\t * the Pointer Event API's approach.\n\t */\n\tmoveOnAll: boolean;\n\t/** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n\tenableGlobalMoveEvents: boolean;\n\t/**\n\t * Maps event types to forwarding handles for them.\n\t *\n\t * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n\t * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n\t * @see EventBoundary#addEventMapping\n\t */\n\tprotected mappingTable: Record<string, Array<{\n\t\tfn: (e: FederatedEvent) => void;\n\t\tpriority: number;\n\t}>>;\n\t/**\n\t * State object for mapping methods.\n\t * @see EventBoundary#trackingData\n\t */\n\tprotected mappingState: Record<string, any>;\n\t/**\n\t * The event pool maps event constructors to an free pool of instances of those specific events.\n\t * @see EventBoundary#allocateEvent\n\t * @see EventBoundary#freeEvent\n\t */\n\tprotected eventPool: Map<typeof FederatedEvent, FederatedEvent[]>;\n\t/** Every interactive element gathered from the scene. Only used in `pointermove` */\n\tprivate readonly _allInteractiveElements;\n\t/** Every element that passed the hit test. Only used in `pointermove` */\n\tprivate _hitElements;\n\t/** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n\tprivate _isPointerMoveEvent;\n\t/**\n\t * @param rootTarget - The holder of the event boundary.\n\t */\n\tconstructor(rootTarget?: Container);\n\t/**\n\t * Adds an event mapping for the event `type` handled by `fn`.\n\t *\n\t * Event mappings can be used to implement additional or custom events. They take an event\n\t * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n\t * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n\t *\n\t * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n\t * instead.\n\t * @param type - The type of upstream event to map.\n\t * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n\t */\n\taddEventMapping(type: string, fn: (e: FederatedEvent) => void): void;\n\t/**\n\t * Dispatches the given event\n\t * @param e - The event to dispatch.\n\t * @param type - The type of event to dispatch. Defaults to `e.type`.\n\t */\n\tdispatchEvent(e: FederatedEvent, type?: string): void;\n\t/**\n\t * Maps the given upstream event through the event boundary and propagates it downstream.\n\t * @param e - The event to map.\n\t */\n\tmapEvent(e: FederatedEvent): void;\n\t/**\n\t * Finds the Container that is the target of a event at the given coordinates.\n\t *\n\t * The passed (x,y) coordinates are in the world space above this event boundary.\n\t * @param x - The x coordinate of the event.\n\t * @param y - The y coordinate of the event.\n\t */\n\thitTest(x: number, y: number): Container;\n\t/**\n\t * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n\t * target `e.target`.\n\t * @param e - The event to propagate.\n\t * @param type - The type of event to propagate. Defaults to `e.type`.\n\t */\n\tpropagate(e: FederatedEvent, type?: string): void;\n\t/**\n\t * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n\t *\n\t * This is used in the `globalpointermove` event.\n\t * @param e - The emitted event.\n\t * @param type - The listeners to notify.\n\t * @param targets - The targets to notify.\n\t */\n\tall(e: FederatedEvent, type?: string | string[], targets?: Container<ContainerChild>[]): void;\n\t/**\n\t * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n\t * `target`. The last element in the path is `target`.\n\t * @param target - The target to find the propagation path to.\n\t */\n\tpropagationPath(target: Container): Container[];\n\tprotected hitTestMoveRecursive(currentTarget: Container, eventMode: EventMode, location: Point, testFn: (object: Container, pt: Point) => boolean, pruneFn: (object: Container, pt: Point) => boolean, ignore?: boolean): Container[];\n\t/**\n\t * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n\t * @param currentTarget - The Container that is to be hit tested.\n\t * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n\t * @param location - The location that is being tested for overlap.\n\t * @param testFn - Callback that determines whether the target passes hit testing. This callback\n\t *  can assume that `pruneFn` failed to prune the container.\n\t * @param pruneFn - Callback that determiness whether the target and all of its children\n\t *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n\t *  of the scene graph.\n\t * @returns An array holding the hit testing target and all its ancestors in order. The first element\n\t *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n\t *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n\t */\n\tprotected hitTestRecursive(currentTarget: Container, eventMode: EventMode, location: Point, testFn: (object: Container, pt: Point) => boolean, pruneFn: (object: Container, pt: Point) => boolean): Container[];\n\tprivate _isInteractive;\n\tprivate _interactivePrune;\n\t/**\n\t * Checks whether the container or any of its children cannot pass the hit test at all.\n\t *\n\t * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n\t * and {@link Container._maskEffect} for pruning.\n\t * @param container - The container to prune.\n\t * @param location - The location to test for overlap.\n\t */\n\tprotected hitPruneFn(container: Container, location: Point): boolean;\n\t/**\n\t * Checks whether the container passes hit testing for the given location.\n\t * @param container - The container to test.\n\t * @param location - The location to test for overlap.\n\t * @returns - Whether `container` passes hit testing for `location`.\n\t */\n\tprotected hitTestFn(container: Container, location: Point): boolean;\n\t/**\n\t * Notify all the listeners to the event's `currentTarget`.\n\t *\n\t * If the `currentTarget` contains the property `on<type>`, then it is called here,\n\t * simulating the behavior from version 6.x and prior.\n\t * @param e - The event passed to the target.\n\t * @param type - The type of event to notify. Defaults to `e.type`.\n\t */\n\tprotected notifyTarget(e: FederatedEvent, type?: string): void;\n\t/**\n\t * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n\t *\n\t * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n\t * @param from - The upstream `pointerdown` event.\n\t */\n\tprotected mapPointerDown(from: FederatedEvent): void;\n\t/**\n\t * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n\t *\n\t * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n\t * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n\t * @param from - The upstream `pointermove` event.\n\t */\n\tprotected mapPointerMove(from: FederatedEvent): void;\n\t/**\n\t * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n\t *\n\t * The tracking data for the specific pointer gets a new `overTarget`.\n\t * @param from - The upstream `pointerover` event.\n\t */\n\tprotected mapPointerOver(from: FederatedEvent): void;\n\t/**\n\t * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n\t *\n\t * The tracking data for the specific pointer is cleared of a `overTarget`.\n\t * @param from - The upstream `pointerout` event.\n\t */\n\tprotected mapPointerOut(from: FederatedEvent): void;\n\t/**\n\t * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n\t * and `click`/`rightclick`/`pointertap` events, in that order.\n\t *\n\t * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n\t * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n\t * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n\t * specific pointer types.\n\t * @param from - The upstream `pointerup` event.\n\t */\n\tprotected mapPointerUp(from: FederatedEvent): void;\n\t/**\n\t * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n\t * `pointerdown` target to `rootTarget`.\n\t *\n\t * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n\t * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n\t *\n\t * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n\t * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n\t * @param from - The upstream `pointerupoutside` event.\n\t */\n\tprotected mapPointerUpOutside(from: FederatedEvent): void;\n\t/**\n\t * Maps the upstream `wheel` event to a downstream `wheel` event.\n\t * @param from - The upstream `wheel` event.\n\t */\n\tprotected mapWheel(from: FederatedEvent): void;\n\t/**\n\t * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n\t *\n\t * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n\t * or `pointerover` target was unmounted from the scene graph.\n\t * @param propagationPath - The propagation path was valid in the past.\n\t * @returns - The most specific event-target still mounted at the same location in the scene graph.\n\t */\n\tprotected findMountedTarget(propagationPath: Container[]): Container;\n\t/**\n\t * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n\t *\n\t * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n\t * @param from - The `originalEvent` for the returned event.\n\t * @param [type=from.type] - The type of the returned event.\n\t * @param target - The target of the returned event.\n\t */\n\tprotected createPointerEvent(from: FederatedPointerEvent, type?: string, target?: Container): FederatedPointerEvent;\n\t/**\n\t * Creates a wheel event whose `originalEvent` is `from`.\n\t *\n\t * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n\t * @param from - The upstream wheel event.\n\t */\n\tprotected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent;\n\t/**\n\t * Clones the event `from`, with an optional `type` override.\n\t *\n\t * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n\t * @param from - The event to clone.\n\t * @param [type=from.type] - The type of the returned event.\n\t */\n\tprotected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent;\n\t/**\n\t * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n\t *\n\t * The following properties are copied:\n\t * + deltaMode\n\t * + deltaX\n\t * + deltaY\n\t * + deltaZ\n\t * @param from - The event to copy data from.\n\t * @param to - The event to copy data into.\n\t */\n\tprotected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void;\n\t/**\n\t * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n\t *\n\t * The following properties are copied:\n\t * + pointerId\n\t * + width\n\t * + height\n\t * + isPrimary\n\t * + pointerType\n\t * + pressure\n\t * + tangentialPressure\n\t * + tiltX\n\t * + tiltY\n\t * @param from - The event to copy data from.\n\t * @param to - The event to copy data into.\n\t */\n\tprotected copyPointerData(from: FederatedEvent, to: FederatedEvent): void;\n\t/**\n\t * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n\t *\n\t * The following properties are copied:\n\t * + altKey\n\t * + button\n\t * + buttons\n\t * + clientX\n\t * + clientY\n\t * + metaKey\n\t * + movementX\n\t * + movementY\n\t * + pageX\n\t * + pageY\n\t * + x\n\t * + y\n\t * + screen\n\t * + shiftKey\n\t * + global\n\t * @param from - The event to copy data from.\n\t * @param to - The event to copy data into.\n\t */\n\tprotected copyMouseData(from: FederatedEvent, to: FederatedEvent): void;\n\t/**\n\t * Copies base {@link FederatedEvent} data from `from` into `to`.\n\t *\n\t * The following properties are copied:\n\t * + isTrusted\n\t * + srcElement\n\t * + timeStamp\n\t * + type\n\t * @param from - The event to copy data from.\n\t * @param to - The event to copy data into.\n\t */\n\tprotected copyData(from: FederatedEvent, to: FederatedEvent): void;\n\t/**\n\t * @param id - The pointer ID.\n\t * @returns The tracking data stored for the given pointer. If no data exists, a blank\n\t *  state will be created.\n\t */\n\tprotected trackingData(id: number): TrackingData;\n\t/**\n\t * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n\t *\n\t * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n\t * boundary.\n\t * @param constructor - The event's constructor.\n\t * @returns An event of the given type.\n\t */\n\tprotected allocateEvent<T extends FederatedEvent>(constructor: {\n\t\tnew (boundary: EventBoundary): T;\n\t}): T;\n\t/**\n\t * Frees the event and puts it back into the event pool.\n\t *\n\t * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n\t *\n\t * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n\t * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n\t * it to be allocated twice & result in overwriting.\n\t * @param event - The event to be freed.\n\t * @throws Error if the event is managed by another event boundary.\n\t */\n\tprotected freeEvent<T extends FederatedEvent>(event: T): void;\n\t/**\n\t * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n\t * is set on the event.\n\t * @param e - The event to call each listener with.\n\t * @param type - The event key.\n\t */\n\tprivate _notifyListeners;\n}\n/**\n * A PixiJS compatible touch event interface that extends the standard DOM Touch interface.\n * Provides additional properties to normalize touch input with mouse/pointer events.\n * @example\n * ```ts\n * // Access touch information\n * sprite.on('touchstart', (event) => {\n *     // Standard touch properties\n *     console.log('Touch position:', event.clientX, event.clientY);\n *     console.log('Touch ID:', event.pointerId);\n *\n *     // Additional PixiJS properties\n *     console.log('Pressure:', event.pressure);\n *     console.log('Size:', event.width, event.height);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n * });\n * ```\n * @category events\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch} DOM Touch Interface\n * @standard\n */\nexport interface PixiTouch extends Touch {\n\t/** The button being pressed (0: left, 1: middle, 2: right) */\n\tbutton: number;\n\t/** Bitmap of currently pressed buttons */\n\tbuttons: number;\n\t/** Whether this is the primary touch point */\n\tisPrimary: boolean;\n\t/** The width of the touch contact area */\n\twidth: number;\n\t/** The height of the touch contact area */\n\theight: number;\n\t/** The angle of tilt along the x-axis (in degrees) */\n\ttiltX: number;\n\t/** The angle of tilt along the y-axis (in degrees) */\n\ttiltY: number;\n\t/** The type of pointer that triggered this event */\n\tpointerType: string;\n\t/** Unique identifier for this touch point */\n\tpointerId: number;\n\t/** The normalized pressure of the pointer (0 to 1) */\n\tpressure: number;\n\t/** The rotation angle of the pointer (e.g., pen) */\n\ttwist: number;\n\t/** The normalized tangential pressure of the pointer */\n\ttangentialPressure: number;\n\t/** The x coordinate relative to the current layer */\n\tlayerX: number;\n\t/** The y coordinate relative to the current layer */\n\tlayerY: number;\n\t/** The x coordinate relative to the target's offset parent */\n\toffsetX: number;\n\t/** The y coordinate relative to the target's offset parent */\n\toffsetY: number;\n\t/** Whether the event was normalized by PixiJS */\n\tisNormalized: boolean;\n\t/** The type of touch event */\n\ttype: string;\n}\n/**\n * A DOM-compatible synthetic event implementation for PixiJS's event system.\n * This class implements the standard DOM Event interface while providing additional\n * functionality specific to PixiJS events.\n * > [!NOTE] You wont receive an instance of this class directly, but rather a subclass\n * > of this class, such as {@link FederatedPointerEvent}, {@link FederatedMouseEvent}, or\n * > {@link FederatedWheelEvent}. This class is the base for all federated events.\n * @example\n * ```ts\n * // Basic event handling\n * sprite.on('pointerdown', (event: FederatedEvent) => {\n *     // Access standard DOM event properties\n *     console.log('Target:', event.target);\n *     console.log('Phase:', event.eventPhase);\n *     console.log('Type:', event.type);\n *\n *     // Control propagation\n *     event.stopPropagation();\n * });\n * ```\n * @typeParam N - The type of native event held. Can be either a UIEvent or PixiTouch.\n * @remarks\n * - Implements the standard DOM UIEvent interface\n * - Provides event bubbling and capturing phases\n * - Supports propagation control\n * - Manages event paths through display tree\n * - Normalizes native browser events\n * @see {@link https://dom.spec.whatwg.org/#event} DOM Event Specification\n * @see {@link FederatedPointerEvent} For pointer-specific events\n * @see {@link FederatedMouseEvent} For mouse-specific events\n * @see {@link FederatedWheelEvent} For wheel-specific events\n * @category events\n * @standard\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent {\n\t/** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n\tbubbles: boolean;\n\t/** @deprecated since 7.0.0 */\n\tcancelBubble: boolean;\n\t/**\n\t * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n\t * false (for now).\n\t */\n\treadonly cancelable = false;\n\t/**\n\t * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n\t * API.\n\t * @see https://dom.spec.whatwg.org/#dom-event-composed\n\t * @ignore\n\t */\n\treadonly composed = false;\n\t/** The listeners of the event target that are being notified. */\n\tcurrentTarget: Container;\n\t/** Flags whether the default response of the user agent was prevent through this event. */\n\tdefaultPrevented: boolean;\n\t/**\n\t * The propagation phase.\n\t * @default {@link FederatedEvent.NONE}\n\t */\n\teventPhase: number;\n\t/** Flags whether this is a user-trusted event */\n\tisTrusted: boolean;\n\t/** @deprecated since 7.0.0 */\n\treturnValue: boolean;\n\t/** @deprecated since 7.0.0 */\n\tsrcElement: EventTarget;\n\t/** The event target that this will be dispatched to. */\n\ttarget: Container;\n\t/** The timestamp of when the event was created. */\n\ttimeStamp: number;\n\t/** The type of event, e.g. `\"mouseup\"`. */\n\ttype: string;\n\t/** The native event that caused the foremost original event. */\n\tnativeEvent: N;\n\t/** The original event that caused this event, if any. */\n\toriginalEvent: FederatedEvent<N>;\n\t/** Flags whether propagation was stopped. */\n\tpropagationStopped: boolean;\n\t/** Flags whether propagation was immediately stopped. */\n\tpropagationImmediatelyStopped: boolean;\n\t/** The composed path of the event's propagation. The `target` is at the end. */\n\tpath: Container[];\n\t/** The {@link EventBoundary} that manages this event. Null for root events. */\n\treadonly manager: EventBoundary;\n\t/** Event-specific detail */\n\tdetail: number;\n\t/** The global Window object. */\n\tview: WindowProxy;\n\t/**\n\t * Not supported.\n\t * @deprecated since 7.0.0\n\t * @ignore\n\t */\n\twhich: number;\n\t/** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n\tlayer: Point;\n\t/** @readonly */\n\tget layerX(): number;\n\t/** @readonly */\n\tget layerY(): number;\n\t/** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n\tpage: Point;\n\t/** @readonly */\n\tget pageX(): number;\n\t/** @readonly */\n\tget pageY(): number;\n\t/**\n\t * @param manager - The event boundary which manages this event. Propagation can only occur\n\t *  within the boundary's jurisdiction.\n\t */\n\tconstructor(manager: EventBoundary);\n\t/**\n\t * Fallback for the deprecated `InteractionEvent.data`.\n\t * @deprecated since 7.0.0\n\t */\n\tget data(): this;\n\t/**\n\t * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n\t * @advanced\n\t */\n\tcomposedPath(): Container[];\n\t/**\n\t * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n\t * @deprecated\n\t * @ignore\n\t * @param _type\n\t * @param _bubbles\n\t * @param _cancelable\n\t */\n\tinitEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void;\n\t/**\n\t * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n\t * @ignore\n\t * @deprecated\n\t * @param _typeArg\n\t * @param _bubblesArg\n\t * @param _cancelableArg\n\t * @param _viewArg\n\t * @param _detailArg\n\t */\n\tinitUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null, _detailArg?: number): void;\n\t/**\n\t * Prevent default behavior of both PixiJS and the user agent.\n\t * @example\n\t * ```ts\n\t * sprite.on('click', (event) => {\n\t *     // Prevent both browser's default click behavior\n\t *     // and PixiJS's default handling\n\t *     event.preventDefault();\n\t *\n\t *     // Custom handling\n\t *     customClickHandler();\n\t * });\n\t * ```\n\t * @remarks\n\t * - Only works if the native event is cancelable\n\t * - Does not stop event propagation\n\t */\n\tpreventDefault(): void;\n\t/**\n\t * Stop this event from propagating to any additional listeners, including those\n\t * on the current target and any following targets in the propagation path.\n\t * @example\n\t * ```ts\n\t * container.on('pointerdown', (event) => {\n\t *     // Stop all further event handling\n\t *     event.stopImmediatePropagation();\n\t *\n\t *     // These handlers won't be called:\n\t *     // - Other pointerdown listeners on this container\n\t *     // - Any pointerdown listeners on parent containers\n\t * });\n\t * ```\n\t * @remarks\n\t * - Immediately stops all event propagation\n\t * - Prevents other listeners on same target from being called\n\t * - More aggressive than stopPropagation()\n\t */\n\tstopImmediatePropagation(): void;\n\t/**\n\t * Stop this event from propagating to the next target in the propagation path.\n\t * The rest of the listeners on the current target will still be notified.\n\t * @example\n\t * ```ts\n\t * child.on('pointermove', (event) => {\n\t *     // Handle event on child\n\t *     updateChild();\n\t *\n\t *     // Prevent parent handlers from being called\n\t *     event.stopPropagation();\n\t * });\n\t *\n\t * // This won't be called if child handles the event\n\t * parent.on('pointermove', (event) => {\n\t *     updateParent();\n\t * });\n\t * ```\n\t * @remarks\n\t * - Stops event bubbling to parent containers\n\t * - Does not prevent other listeners on same target\n\t * - Less aggressive than stopImmediatePropagation()\n\t */\n\tstopPropagation(): void;\n\t/**\n\t * The event propagation phase NONE that indicates that the event is not in any phase.\n\t * @default 0\n\t * @advanced\n\t */\n\treadonly NONE = 0;\n\t/**\n\t * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n\t * @default 1\n\t * @advanced\n\t */\n\treadonly CAPTURING_PHASE = 1;\n\t/**\n\t * The event propagation phase AT_TARGET that indicates that the event is at the target.\n\t * @default 2\n\t * @advanced\n\t */\n\treadonly AT_TARGET = 2;\n\t/**\n\t * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n\t * @default 3\n\t * @advanced\n\t */\n\treadonly BUBBLING_PHASE = 3;\n}\n/**\n * A specialized event class for mouse interactions in PixiJS applications.\n * Extends {@link FederatedEvent} to provide mouse-specific properties and methods\n * while maintaining compatibility with the DOM MouseEvent interface.\n *\n * Key features:\n * - Tracks mouse button states\n * - Provides modifier key states\n * - Supports coordinate systems (client, screen, global)\n * - Enables precise position tracking\n * @example\n * ```ts\n * // Basic mouse event handling\n * sprite.on('mousemove', (event: FederatedMouseEvent) => {\n *     // Get coordinates in different spaces\n *     console.log('Global position:', event.global.x, event.global.y);\n *     console.log('Client position:', event.client.x, event.client.y);\n *     console.log('Screen position:', event.screen.x, event.screen.y);\n *\n *     // Check button and modifier states\n *     if (event.buttons === 1 && event.ctrlKey) {\n *         console.log('Left click + Control key');\n *     }\n *\n *     // Get local coordinates relative to any container\n *     const localPos = event.getLocalPosition(container);\n *     console.log('Local position:', localPos.x, localPos.y);\n * });\n *\n * // Handle mouse button states\n * sprite.on('mousedown', (event: FederatedMouseEvent) => {\n *     console.log('Mouse button:', event.button); // 0=left, 1=middle, 2=right\n *     console.log('Active buttons:', event.buttons);\n * });\n * ```\n * @category events\n * @see {@link FederatedEvent} For base event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} DOM MouseEvent Interface\n * @standard\n */\nexport class FederatedMouseEvent extends FederatedEvent<MouseEvent | PointerEvent | PixiTouch> implements MouseEvent {\n\t/** Whether the \"alt\" key was pressed when this mouse event occurred. */\n\taltKey: boolean;\n\t/** The specific button that was pressed in this mouse event. */\n\tbutton: number;\n\t/** The button depressed when this event occurred. */\n\tbuttons: number;\n\t/** Whether the \"control\" key was pressed when this mouse event occurred. */\n\tctrlKey: boolean;\n\t/** Whether the \"meta\" key was pressed when this mouse event occurred. */\n\tmetaKey: boolean;\n\t/** This is currently not implemented in the Federated Events API. */\n\trelatedTarget: EventTarget;\n\t/** Whether the \"shift\" key was pressed when this mouse event occurred. */\n\tshiftKey: boolean;\n\t/** The coordinates of the mouse event relative to the canvas. */\n\tclient: Point;\n\t/** @readonly */\n\tget clientX(): number;\n\t/** @readonly */\n\tget clientY(): number;\n\t/**\n\t * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n\t * @readonly\n\t */\n\tget x(): number;\n\t/**\n\t * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n\t * @readonly\n\t */\n\tget y(): number;\n\t/** This is the number of clicks that occurs in 200ms/click of each other. */\n\tdetail: number;\n\t/** The movement in this pointer relative to the last `mousemove` event. */\n\tmovement: Point;\n\t/** @readonly */\n\tget movementX(): number;\n\t/** @readonly */\n\tget movementY(): number;\n\t/** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n\toffset: Point;\n\t/** @readonly */\n\tget offsetX(): number;\n\t/** @readonly */\n\tget offsetY(): number;\n\t/** The pointer coordinates in world space. */\n\tglobal: Point;\n\t/** @readonly */\n\tget globalX(): number;\n\t/** @readonly */\n\tget globalY(): number;\n\t/**\n\t * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n\t * different semantics than native PointerEvent screenX/screenY.\n\t */\n\tscreen: Point;\n\t/**\n\t * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n\t * @readonly\n\t */\n\tget screenX(): number;\n\t/**\n\t * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n\t * @readonly\n\t */\n\tget screenY(): number;\n\t/**\n\t * Converts global coordinates into container-local coordinates.\n\t *\n\t * This method transforms coordinates from world space to a container's local space,\n\t * useful for precise positioning and hit testing.\n\t * @param container - The Container to get local coordinates for\n\t * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n\t * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n\t * @returns The local coordinates as a Point object\n\t * @example\n\t * ```ts\n\t * // Basic usage - get local coordinates relative to a container\n\t * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n\t *     // Get position relative to the sprite\n\t *     const localPos = event.getLocalPosition(sprite);\n\t *     console.log('Local position:', localPos.x, localPos.y);\n\t * });\n\t * // Using custom global coordinates\n\t * const customGlobal = new Point(100, 100);\n\t * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n\t *     // Transform custom coordinates\n\t *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n\t *     console.log('Custom local position:', localPos.x, localPos.y);\n\t * });\n\t * ```\n\t * @see {@link Container.worldTransform} For the transformation matrix\n\t * @see {@link Point} For the point class used to store coordinates\n\t */\n\tgetLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P;\n\t/**\n\t * Whether the modifier key was pressed when this event natively occurred.\n\t * @param key - The modifier key.\n\t */\n\tgetModifierState(key: string): boolean;\n\t/**\n\t * Not supported.\n\t * @param _typeArg\n\t * @param _canBubbleArg\n\t * @param _cancelableArg\n\t * @param _viewArg\n\t * @param _detailArg\n\t * @param _screenXArg\n\t * @param _screenYArg\n\t * @param _clientXArg\n\t * @param _clientYArg\n\t * @param _ctrlKeyArg\n\t * @param _altKeyArg\n\t * @param _shiftKeyArg\n\t * @param _metaKeyArg\n\t * @param _buttonArg\n\t * @param _relatedTargetArg\n\t * @deprecated since 7.0.0\n\t * @ignore\n\t */\n\tinitMouseEvent(_typeArg: string, _canBubbleArg: boolean, _cancelableArg: boolean, _viewArg: Window, _detailArg: number, _screenXArg: number, _screenYArg: number, _clientXArg: number, _clientYArg: number, _ctrlKeyArg: boolean, _altKeyArg: boolean, _shiftKeyArg: boolean, _metaKeyArg: boolean, _buttonArg: number, _relatedTargetArg: EventTarget): void;\n}\n/**\n * A specialized event class for pointer interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide advanced pointer-specific features\n * while maintaining compatibility with the DOM PointerEvent interface.\n *\n * Key features:\n * - Supports multi-touch interactions\n * - Provides pressure sensitivity\n * - Handles stylus input\n * - Tracks pointer dimensions\n * - Supports tilt detection\n * @example\n * ```ts\n * // Basic pointer event handling\n * sprite.on('pointerdown', (event: FederatedPointerEvent) => {\n *     // Access pointer information\n *     console.log('Pointer ID:', event.pointerId);\n *     console.log('Pointer Type:', event.pointerType);\n *     console.log('Is Primary:', event.isPrimary);\n *\n *     // Get pressure and tilt data\n *     console.log('Pressure:', event.pressure);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n *\n *     // Access contact geometry\n *     console.log('Size:', event.width, event.height);\n * });\n *\n * // Handle stylus-specific features\n * sprite.on('pointermove', (event: FederatedPointerEvent) => {\n *     if (event.pointerType === 'pen') {\n *         // Handle stylus tilt\n *         const tiltAngle = Math.atan2(event.tiltY, event.tiltX);\n *         console.log('Tilt angle:', tiltAngle);\n *\n *         // Use barrel button pressure\n *         console.log('Tangential pressure:', event.tangentialPressure);\n *     }\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent} DOM PointerEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent {\n\t/**\n\t * The unique identifier of the pointer.\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n\t */\n\tpointerId: number;\n\t/**\n\t * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n\t * radiusX of TouchEvents will be represented by this value.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n\t */\n\twidth: number;\n\t/**\n\t * The angle in radians of a pointer or stylus measuring the vertical angle between\n\t * the device's surface to the pointer or stylus.\n\t * A stylus at 0 degrees would be directly parallel whereas at /2 degrees it would be perpendicular.\n\t * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/altitudeAngle)\n\t */\n\taltitudeAngle: number;\n\t/**\n\t * The angle in radians of a pointer or stylus measuring an arc from the X axis of the device to\n\t * the pointer or stylus projected onto the screen's plane.\n\t * A stylus at 0 degrees would be pointing to the \"0 o'clock\" whereas at /2 degrees it would be pointing at \"6 o'clock\".\n\t * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/azimuthAngle)\n\t */\n\tazimuthAngle: number;\n\t/**\n\t * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n\t * radiusY of TouchEvents will be represented by this value.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n\t */\n\theight: number;\n\t/**\n\t * Indicates whether or not the pointer device that created the event is the primary pointer.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n\t */\n\tisPrimary: boolean;\n\t/**\n\t * The type of pointer that triggered the event.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n\t */\n\tpointerType: string;\n\t/**\n\t * Pressure applied by the pointing device during the event.\n\t *s\n\t * A Touch's force property will be represented by this value.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n\t */\n\tpressure: number;\n\t/**\n\t * Barrel pressure on a stylus pointer.\n\t * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n\t */\n\ttangentialPressure: number;\n\t/**\n\t * The angle, in degrees, between the pointer device and the screen.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n\t */\n\ttiltX: number;\n\t/**\n\t * The angle, in degrees, between the pointer device and the screen.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n\t */\n\ttiltY: number;\n\t/**\n\t * Twist of a stylus pointer.\n\t * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n\t */\n\ttwist: number;\n\t/** This is the number of clicks that occurs in 200ms/click of each other. */\n\tdetail: number;\n\t/**\n\t * Only included for completeness for now\n\t * @ignore\n\t */\n\tgetCoalescedEvents(): PointerEvent[];\n\t/**\n\t * Only included for completeness for now\n\t * @ignore\n\t */\n\tgetPredictedEvents(): PointerEvent[];\n}\n/**\n * The types for the events that can be emitted by a Container\n * @category events\n * @advanced\n */\nexport type FederatedEventMap = {\n\tclick: FederatedPointerEvent;\n\tmousedown: FederatedPointerEvent;\n\tmouseenter: FederatedPointerEvent;\n\tmouseleave: FederatedPointerEvent;\n\tmousemove: FederatedPointerEvent;\n\tmouseout: FederatedPointerEvent;\n\tmouseover: FederatedPointerEvent;\n\tmouseup: FederatedPointerEvent;\n\tmouseupoutside: FederatedPointerEvent;\n\tpointercancel: FederatedPointerEvent;\n\tpointerdown: FederatedPointerEvent;\n\tpointerenter: FederatedPointerEvent;\n\tpointerleave: FederatedPointerEvent;\n\tpointermove: FederatedPointerEvent;\n\tpointerout: FederatedPointerEvent;\n\tpointerover: FederatedPointerEvent;\n\tpointertap: FederatedPointerEvent;\n\tpointerup: FederatedPointerEvent;\n\tpointerupoutside: FederatedPointerEvent;\n\trightclick: FederatedPointerEvent;\n\trightdown: FederatedPointerEvent;\n\trightup: FederatedPointerEvent;\n\trightupoutside: FederatedPointerEvent;\n\ttap: FederatedPointerEvent;\n\ttouchcancel: FederatedPointerEvent;\n\ttouchend: FederatedPointerEvent;\n\ttouchendoutside: FederatedPointerEvent;\n\ttouchmove: FederatedPointerEvent;\n\ttouchstart: FederatedPointerEvent;\n\twheel: FederatedWheelEvent;\n};\n/**\n * The types for the global events that can be emitted by a Container\n * @category events\n * @advanced\n */\nexport type GlobalFederatedEventMap = {\n\tglobalmousemove: FederatedPointerEvent;\n\tglobalpointermove: FederatedPointerEvent;\n\tglobaltouchmove: FederatedPointerEvent;\n};\n/**\n * The types for the events that can be emitted by a Container\n * @category events\n * @advanced\n */\nexport type AllFederatedEventMap = FederatedEventMap & GlobalFederatedEventMap;\n/**\n * The types for the events that can be emitted by a Container\n * @category events\n * @advanced\n * @interface\n */\nexport type FederatedEventEmitterTypes = {\n\t[K in keyof FederatedEventMap as K | `${K}capture`]: [\n\t\tevent: FederatedEventMap[K]\n\t];\n} & {\n\t[K in keyof GlobalFederatedEventMap]: [\n\t\tevent: GlobalFederatedEventMap[K]\n\t];\n};\n/**\n * Options for configuring the PixiJS event system. These options control how the event system\n * handles different types of interactions and event propagation.\n * @example\n * ```ts\n * // Basic event system configuration\n * const app = new Application();\n * await app.init({\n *     // Configure default interaction mode\n *     eventMode: 'static',\n *\n *     // Configure event features\n *     eventFeatures: {\n *         move: true,           // Enable pointer movement events\n *         globalMove: false,    // Disable global move events\n *         click: true,          // Enable click events\n *         wheel: true          // Enable wheel/scroll events\n *     }\n * });\n *\n * // Access event system after initialization\n * const eventSystem = app.renderer.events;\n * console.log(eventSystem.features); // Check enabled features\n * ```\n * @see {@link EventSystem} For the main event system implementation\n * @see {@link EventMode} For interaction mode details\n * @see {@link EventSystemFeatures} For all available feature options\n * @advanced\n * @category events\n */\nexport interface EventSystemOptions {\n\t/**\n\t * The default event mode for all display objects.\n\t * Controls how objects respond to interaction events.\n\t *\n\t * Possible values:\n\t * - `'none'`: No interaction events\n\t * - `'passive'`: Only container's children receive events (default)\n\t * - `'auto'`: Receives events when parent is interactive\n\t * - `'static'`: Standard interaction events\n\t * - `'dynamic'`: Like static but with additional synthetic events\n\t * @default 'passive'\n\t */\n\teventMode?: EventMode;\n\t/**\n\t * Configuration for enabling/disabling specific event features.\n\t * Use this to optimize performance by turning off unused functionality.\n\t * @example\n\t * ```ts\n\t * const app = new Application();\n\t * await app.init({\n\t *     eventFeatures: {\n\t *         // Core interaction events\n\t *         move: true,        // Pointer/mouse/touch movement\n\t *         click: true,       // Click/tap events\n\t *         wheel: true,       // Mouse wheel/scroll events\n\t *         // Global tracking\n\t *         globalMove: false  // Global pointer movement\n\t *     }\n\t * });\n\t * ```\n\t */\n\teventFeatures?: Partial<EventSystemFeatures>;\n}\n/**\n * The event features that are enabled by the EventSystem. These features control\n * different types of interaction events in your PixiJS application.\n * @example\n * ```ts\n * // Configure features during application initialization\n * const app = new Application();\n * await app.init({\n *     eventFeatures: {\n *         // Basic interaction events\n *         move: true,        // Enable pointer movement tracking\n *         click: true,       // Enable click/tap events\n *         wheel: true,       // Enable mouse wheel/scroll events\n *         // Advanced features\n *         globalMove: false  // Disable global move tracking for performance\n *     }\n * });\n *\n * // Or configure after initialization\n * app.renderer.events.features.move = false;      // Disable movement events\n * app.renderer.events.features.globalMove = true; // Enable global tracking\n * ```\n * @since 7.2.0\n * @category events\n * @advanced\n */\nexport interface EventSystemFeatures {\n\t/**\n\t * Enables pointer events associated with pointer movement.\n\t *\n\t * When enabled, these events will fire:\n\t * - `pointermove` / `mousemove` / `touchmove`\n\t * - `pointerout` / `mouseout`\n\t * - `pointerover` / `mouseover`\n\t * @example\n\t * ```ts\n\t * // Enable movement events\n\t * app.renderer.events.features.move = true;\n\t *\n\t * // Listen for movement\n\t * sprite.on('pointermove', (event) => {\n\t *     console.log('Pointer position:', event.global.x, event.global.y);\n\t * });\n\t * ```\n\t * @default true\n\t */\n\tmove: boolean;\n\t/**\n\t * Enables global pointer move events that fire regardless of target.\n\t *\n\t * When enabled, these events will fire:\n\t * - `globalpointermove`\n\t * - `globalmousemove`\n\t * - `globaltouchmove`\n\t * @example\n\t * ```ts\n\t * // Enable global tracking\n\t * app.renderer.events.features.globalMove = true;\n\t *\n\t * // Track pointer globally\n\t * sprite.on('globalpointermove', (event) => {\n\t *     // Fires even when pointer is not over sprite\n\t *     console.log('Global position:', event.global.x, event.global.y);\n\t * });\n\t * ```\n\t * @default true\n\t */\n\tglobalMove: boolean;\n\t/**\n\t * Enables pointer events associated with clicking/tapping.\n\t *\n\t * When enabled, these events will fire:\n\t * - `pointerdown` / `mousedown` / `touchstart` / `rightdown`\n\t * - `pointerup` / `mouseup` / `touchend` / `rightup`\n\t * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / `rightupoutside`\n\t * - `click` / `tap`\n\t * @example\n\t * ```ts\n\t * // Enable click events\n\t * app.renderer.events.features.click = true;\n\t *\n\t * // Handle clicks\n\t * sprite.on('click', (event) => {\n\t *     console.log('Clicked at:', event.global.x, event.global.y);\n\t * });\n\t * ```\n\t * @default true\n\t */\n\tclick: boolean;\n\t/**\n\t * Enables mouse wheel/scroll events.\n\t * @example\n\t * ```ts\n\t * // Enable wheel events\n\t * app.renderer.events.features.wheel = true;\n\t *\n\t * // Handle scrolling\n\t * sprite.on('wheel', (event) => {\n\t *     // Zoom based on scroll direction\n\t *     const scale = 1 + (event.deltaY / 1000);\n\t *     sprite.scale.set(sprite.scale.x * scale);\n\t * });\n\t * ```\n\t * @default true\n\t */\n\twheel: boolean;\n}\n/**\n * The system for handling UI events in PixiJS applications. This class manages mouse, touch, and pointer events,\n * normalizing them into a consistent event model.\n * @example\n * ```ts\n * // Access event system through renderer\n * const eventSystem = app.renderer.events;\n *\n * // Configure event features\n * eventSystem.features.globalMove = false;  // Disable global move events\n * eventSystem.features.click = true;        // Enable click events\n *\n * // Set custom cursor styles\n * eventSystem.cursorStyles.default = 'pointer';\n * eventSystem.cursorStyles.grab = 'grab';\n *\n * // Get current pointer position\n * const pointer = eventSystem.pointer;\n * console.log(pointer.global.x, pointer.global.y);\n * ```\n *\n * Features:\n * - Normalizes browser events into consistent format\n * - Supports mouse, touch, and pointer events\n * - Handles event delegation and bubbling\n * - Provides cursor management\n * - Configurable event features\n * @see {@link EventBoundary} For event propagation and handling\n * @see {@link FederatedEvent} For the base event class\n * @see {@link EventMode} For interaction modes\n * @category events\n * @standard\n */\nexport class EventSystem implements System<EventSystemOptions> {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\t/**\n\t * The event features that are enabled by the EventSystem\n\t * @since 7.2.0\n\t * @example\n\t * ```ts\n\t * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n\t * // Access the default event features\n\t * EventSystem.defaultEventFeatures = {\n\t *     // Enable pointer movement events\n\t *     move: true,\n\t *     // Enable global pointer move events\n\t *     globalMove: true,\n\t *     // Enable click events\n\t *     click: true,\n\t *     // Enable wheel events\n\t *     wheel: true,\n\t * };\n\t * ```\n\t */\n\tstatic defaultEventFeatures: EventSystemFeatures;\n\tprivate static _defaultEventMode;\n\t/**\n\t * The default interaction mode for all display objects.\n\t * @see Container.eventMode\n\t * @type {EventMode}\n\t * @readonly\n\t * @since 7.2.0\n\t */\n\tstatic get defaultEventMode(): EventMode;\n\t/**\n\t * The {@link EventBoundary} for the stage.\n\t *\n\t * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n\t * the last rendered object before any event processing is initiated. This means the main scene\n\t * needs to be rendered atleast once before UI events will start propagating.\n\t *\n\t * The root boundary should only be changed during initialization. Otherwise, any state held by the\n\t * event boundary may be lost (like hovered & pressed Containers).\n\t * @advanced\n\t */\n\treadonly rootBoundary: EventBoundary;\n\t/**\n\t * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n\t * This is used to determine the appropriate event handling strategy.\n\t * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n\t * @readonly\n\t * @default 'ontouchstart' in globalThis\n\t */\n\treadonly supportsTouchEvents: boolean;\n\t/**\n\t * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n\t * Used to optimize event handling and provide more consistent cross-device interaction.\n\t * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n\t * @readonly\n\t * @default !!globalThis.PointerEvent\n\t */\n\treadonly supportsPointerEvents: boolean;\n\t/**\n\t * Controls whether default browser actions are automatically prevented on pointer events.\n\t * When true, prevents default browser actions from occurring on pointer events.\n\t * @remarks\n\t * - Does not apply to pointer events for backwards compatibility\n\t * - preventDefault on pointer events stops mouse events from firing\n\t * - For every pointer event, there will always be either a mouse or touch event alongside it\n\t * - Setting this to false allows default browser actions (text selection, dragging images, etc.)\n\t * @example\n\t * ```ts\n\t * // Allow default browser actions\n\t * app.renderer.events.autoPreventDefault = false;\n\t *\n\t * // Block default actions (default)\n\t * app.renderer.events.autoPreventDefault = true;\n\t *\n\t * // Example with text selection\n\t * const text = new Text('Selectable text');\n\t * text.eventMode = 'static';\n\t * app.renderer.events.autoPreventDefault = false; // Allow text selection\n\t * ```\n\t * @default true\n\t */\n\tautoPreventDefault: boolean;\n\t/**\n\t * Dictionary of custom cursor styles that can be used across the application.\n\t * Used to define how different cursor modes are handled when interacting with display objects.\n\t * @example\n\t * ```ts\n\t * // Access event system through renderer\n\t * const eventSystem = app.renderer.events;\n\t *\n\t * // Set string-based cursor styles\n\t * eventSystem.cursorStyles.default = 'pointer';\n\t * eventSystem.cursorStyles.hover = 'grab';\n\t * eventSystem.cursorStyles.drag = 'grabbing';\n\t *\n\t * // Use CSS object for complex styling\n\t * eventSystem.cursorStyles.custom = {\n\t *     cursor: 'url(\"custom.png\") 2 2, auto',\n\t *     userSelect: 'none'\n\t * };\n\t *\n\t * // Use a url for custom cursors\n\t * const defaultIcon = 'url(\\'https://pixijs.com/assets/bunny.png\\'),auto';\n\t * eventSystem.cursorStyles.icon = defaultIcon;\n\t *\n\t * // Use callback function for dynamic cursors\n\t * eventSystem.cursorStyles.dynamic = (mode) => {\n\t *     // Update cursor based on mode\n\t *     document.body.style.cursor = mode === 'hover'\n\t *         ? 'pointer'\n\t *         : 'default';\n\t * };\n\t *\n\t * // Apply cursor style to a sprite\n\t * sprite.cursor = 'hover'; // Will use the hover style defined above\n\t * sprite.cursor = 'icon'; // Will apply the icon cursor\n\t * sprite.cursor = 'custom'; // Will apply the custom CSS styles\n\t * sprite.cursor = 'drag'; // Will apply the grabbing cursor\n\t * sprite.cursor = 'default'; // Will apply the default pointer cursor\n\t * sprite.cursor = 'dynamic'; // Will call the dynamic function\n\t * ```\n\t * @remarks\n\t * - Strings are treated as CSS cursor values\n\t * - Objects are applied as CSS styles to the DOM element\n\t * - Functions are called directly for custom cursor handling\n\t * - Default styles for 'default' and 'pointer' are provided\n\t * @default\n\t * ```ts\n\t * {\n\t *     default: 'inherit',\n\t *     pointer: 'pointer' // Default cursor styles\n\t * }\n\t * ```\n\t */\n\tcursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\t/**\n\t * The DOM element to which the root event listeners are bound. This is automatically set to\n\t * the renderer's {@link Renderer#view view}.\n\t */\n\tdomElement: HTMLElement;\n\t/** The resolution used to convert between the DOM client space into world space. */\n\tresolution: number;\n\t/** The renderer managing this {@link EventSystem}. */\n\trenderer: Renderer;\n\t/**\n\t * The event features that are enabled by the EventSystem\n\t * @since 7.2.0\n\t * @example\n\t * const app = new Application()\n\t * app.renderer.events.features.globalMove = false\n\t *\n\t * // to override all features use Object.assign\n\t * Object.assign(app.renderer.events.features, {\n\t *  move: false,\n\t *  globalMove: false,\n\t *  click: false,\n\t *  wheel: false,\n\t * })\n\t */\n\treadonly features: EventSystemFeatures;\n\tprivate _currentCursor;\n\tprivate readonly _rootPointerEvent;\n\tprivate readonly _rootWheelEvent;\n\tprivate _eventsAdded;\n\t/**\n\t * @param {Renderer} renderer\n\t */\n\tconstructor(renderer: Renderer);\n\t/**\n\t * Runner init called, view is available at this point.\n\t * @ignore\n\t */\n\tinit(options: EventSystemOptions): void;\n\t/**\n\t * Handle changing resolution.\n\t * @ignore\n\t */\n\tresolutionChange(resolution: number): void;\n\t/** Destroys all event listeners and detaches the renderer. */\n\tdestroy(): void;\n\t/**\n\t * Sets the current cursor mode, handling any callbacks or CSS style changes.\n\t * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n\t * @param mode - Cursor mode to set. Can be:\n\t * - A CSS cursor string (e.g., 'pointer', 'grab')\n\t * - A key from the cursorStyles dictionary\n\t * - null/undefined to reset to default\n\t * @example\n\t * ```ts\n\t * // Using predefined cursor styles\n\t * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n\t * app.renderer.events.setCursor('grab');       // Set grab cursor\n\t * app.renderer.events.setCursor(null);         // Reset to default\n\t *\n\t * // Using custom cursor styles\n\t * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n\t * app.renderer.events.setCursor('custom');     // Apply custom cursor\n\t *\n\t * // Using callback-based cursor\n\t * app.renderer.events.cursorStyles.dynamic = (mode) => {\n\t *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n\t * };\n\t * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n\t * ```\n\t * @remarks\n\t * - Has no effect on OffscreenCanvas except for callback-based cursors\n\t * - Caches current cursor to avoid unnecessary DOM updates\n\t * - Supports CSS cursor values, style objects, and callback functions\n\t * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n\t */\n\tsetCursor(mode: string): void;\n\t/**\n\t * The global pointer event instance containing the most recent pointer state.\n\t * This is useful for accessing pointer information without listening to events.\n\t * @example\n\t * ```ts\n\t * // Access current pointer position at any time\n\t * const eventSystem = app.renderer.events;\n\t * const pointer = eventSystem.pointer;\n\t *\n\t * // Get global coordinates\n\t * console.log('Position:', pointer.global.x, pointer.global.y);\n\t *\n\t * // Check button state\n\t * console.log('Buttons pressed:', pointer.buttons);\n\t *\n\t * // Get pointer type and pressure\n\t * console.log('Type:', pointer.pointerType);\n\t * console.log('Pressure:', pointer.pressure);\n\t * ```\n\t * @readonly\n\t * @since 7.2.0\n\t * @see {@link FederatedPointerEvent} For all available pointer properties\n\t */\n\tget pointer(): Readonly<FederatedPointerEvent>;\n\t/**\n\t * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n\t * @param nativeEvent - The native mouse/pointer/touch event.\n\t */\n\tprivate _onPointerDown;\n\t/**\n\t * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n\t * @param nativeEvent - The native mouse/pointer/touch events.\n\t */\n\tprivate _onPointerMove;\n\t/**\n\t * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n\t * @param nativeEvent - The native mouse/pointer/touch event.\n\t */\n\tprivate _onPointerUp;\n\t/**\n\t * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n\t * @param nativeEvent - The native mouse/pointer/touch event.\n\t */\n\tprivate _onPointerOverOut;\n\t/**\n\t * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n\t * @param nativeEvent - The native wheel event.\n\t */\n\tprotected onWheel(nativeEvent: WheelEvent): void;\n\t/**\n\t * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n\t * This method manages the DOM event bindings for the event system, allowing you to\n\t * change or remove the target element that receives input events.\n\t * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n\t * > should not need to call this unless you are using a custom element.\n\t * @param element - The new DOM element to bind events to, or null to remove all event bindings\n\t * @example\n\t * ```ts\n\t * // Set a new canvas element as the target\n\t * const canvas = document.createElement('canvas');\n\t * app.renderer.events.setTargetElement(canvas);\n\t *\n\t * // Remove all event bindings\n\t * app.renderer.events.setTargetElement(null);\n\t *\n\t * // Switch to a different canvas\n\t * const newCanvas = document.querySelector('#game-canvas');\n\t * app.renderer.events.setTargetElement(newCanvas);\n\t * ```\n\t * @remarks\n\t * - Automatically removes event listeners from previous element\n\t * - Required for the event system to function\n\t * - Safe to call multiple times\n\t * @see {@link EventSystem#domElement} The current DOM element\n\t * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n\t */\n\tsetTargetElement(element: HTMLElement): void;\n\t/** Register event listeners on {@link Renderer#domElement this.domElement}. */\n\tprivate _addEvents;\n\t/** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n\tprivate _removeEvents;\n\t/**\n\t * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n\t * This takes into account the current scale, position, and resolution of the DOM element.\n\t * @param point - The point to store the mapped coordinates in\n\t * @param x - The x coordinate in DOM/client space\n\t * @param y - The y coordinate in DOM/client space\n\t * @example\n\t * ```ts\n\t * // Map mouse coordinates to PixiJS space\n\t * const point = new Point();\n\t * app.renderer.events.mapPositionToPoint(\n\t *     point,\n\t *     event.clientX,\n\t *     event.clientY\n\t * );\n\t * console.log('Mapped position:', point.x, point.y);\n\t *\n\t * // Using with pointer events\n\t * sprite.on('pointermove', (event) => {\n\t *     // event.global already contains mapped coordinates\n\t *     console.log('Global:', event.global.x, event.global.y);\n\t *\n\t *     // Map to local coordinates\n\t *     const local = event.getLocalPosition(sprite);\n\t *     console.log('Local:', local.x, local.y);\n\t * });\n\t * ```\n\t * @remarks\n\t * - Accounts for element scaling and positioning\n\t * - Adjusts for device pixel ratio/resolution\n\t */\n\tmapPositionToPoint(point: PointData, x: number, y: number): void;\n\t/**\n\t * Ensures that the original event object contains all data that a regular pointer event would have\n\t * @param event - The original event data from a touch or mouse event\n\t * @returns An array containing a single normalized pointer event, in the case of a pointer\n\t *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n\t */\n\tprivate _normalizeToPointerData;\n\t/**\n\t * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n\t *\n\t * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n\t * multiple native wheel events.\n\t * @param nativeEvent - The native wheel event that occurred on the canvas.\n\t * @returns A federated wheel event.\n\t */\n\tprotected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent;\n\t/**\n\t * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n\t * @param event\n\t * @param nativeEvent\n\t */\n\tprivate _bootstrapEvent;\n\t/**\n\t * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n\t * @param event\n\t * @param nativeEvent\n\t */\n\tprivate _transferMouseData;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Container extends IFederatedContainer {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerOptions extends FederatedOptions {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerEvents extends FederatedEventEmitterTypes {\n\t\t}\n\t\tinterface RendererOptions {\n\t\t\t/**\n\t\t\t * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Basic event mode setup\n\t\t\t * const sprite = new Sprite(texture);\n\t\t\t * sprite.eventMode = 'static';    // Enable standard interaction\n\t\t\t * sprite.on('pointerdown', () => { console.log('clicked!'); });\n\t\t\t *\n\t\t\t * // Different event modes\n\t\t\t * sprite.eventMode = 'none';      // Disable all interaction\n\t\t\t * sprite.eventMode = 'passive';   // Only allow interaction on children\n\t\t\t * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n\t\t\t * sprite.eventMode = 'dynamic';   // For moving/animated objects\n\t\t\t * ```\n\t\t\t *\n\t\t\t * Available modes:\n\t\t\t * - `'none'`: Ignores all interaction events, even on its children\n\t\t\t * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and\n\t\t\t * non-interactive children. Interactive children will still emit events.\n\t\t\t * - `'auto'`: Does not emit events but is hit tested if parent is interactive.\n\t\t\t * Same as `interactive = false` in v7\n\t\t\t * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n\t\t\t * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n\t\t\t * a ticker to allow for interaction when the mouse isn't moving\n\t\t\t *\n\t\t\t * Performance tips:\n\t\t\t * - Use `'none'` for pure visual elements\n\t\t\t * - Use `'passive'` for containers with some interactive children\n\t\t\t * - Use `'static'` for standard buttons/controls\n\t\t\t * - Use `'dynamic'` only for moving/animated interactive elements\n\t\t\t * @since 7.2.0\n\t\t\t */\n\t\t\teventMode?: EventMode;\n\t\t\t/**\n\t\t\t * Configuration for enabling/disabling specific event features.\n\t\t\t * Use this to optimize performance by turning off unused functionality.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * const app = new Application();\n\t\t\t * await app.init({\n\t\t\t *     eventFeatures: {\n\t\t\t *         // Core interaction events\n\t\t\t *         move: true,        // Pointer/mouse/touch movement\n\t\t\t *         click: true,       // Click/tap events\n\t\t\t *         wheel: true,       // Mouse wheel/scroll events\n\t\t\t *         // Global tracking\n\t\t\t *         globalMove: false  // Global pointer movement\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t * @since 7.2.0\n\t\t\t */\n\t\t\teventFeatures?: EventSystemOptions[\"eventFeatures\"];\n\t\t}\n\t\tinterface RendererSystems {\n\t\t\tevents: EventSystem;\n\t\t}\n\t}\n}\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction> {\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"filter\";\n\t};\n\tprivate _renderer;\n\tconstructor(renderer: Renderer);\n\tpush(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void;\n\tpop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void;\n\texecute(instruction: FilterInstruction): void;\n\tdestroy(): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\tfilter: FilterSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\tfilter: FilterPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Point extends Vector2Math {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ObservablePoint extends Vector2Math {\n\t\t}\n\t\tinterface Rectangle {\n\t\t\t/**\n\t\t\t * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.\n\t\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Basic equality check\n\t\t\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t\t\t * const rect2 = new Rectangle(0, 0, 100, 100);\n\t\t\t * console.log(rect1.equals(rect2)); // true\n\t\t\t *\n\t\t\t * // Check after modifications\n\t\t\t * rect2.width = 200;\n\t\t\t * console.log(rect1.equals(rect2)); // false\n\t\t\t *\n\t\t\t * // Compare with offset rectangle\n\t\t\t * const offset = new Rectangle(10, 10, 100, 100);\n\t\t\t * console.log(rect1.equals(offset)); // false\n\t\t\t * ```\n\t\t\t * @param {Rectangle} other - The Rectangle to compare with `this`\n\t\t\t * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.\n\t\t\t */\n\t\t\tequals(other: Rectangle): boolean;\n\t\t\t/**\n\t\t\t * If the area of the intersection between the Rectangles `other` and `this` is not zero,\n\t\t\t * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle\n\t\t\t * with its properties set to zero.\n\t\t\t *\n\t\t\t * Rectangles without area (width or height equal to zero) can't intersect or be intersected\n\t\t\t * and will always return an empty rectangle with its properties set to zero.\n\t\t\t *\n\t\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Basic intersection check\n\t\t\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t\t\t * const rect2 = new Rectangle(50, 50, 100, 100);\n\t\t\t *\n\t\t\t * const overlap = rect1.intersection(rect2);\n\t\t\t * console.log(overlap); // Rectangle(50, 50, 50, 50)\n\t\t\t *\n\t\t\t * // Using output rectangle\n\t\t\t * const out = new Rectangle();\n\t\t\t * rect1.intersection(rect2, out);\n\t\t\t *\n\t\t\t * // Zero-area rectangles\n\t\t\t * const empty = new Rectangle(0, 0, 0, 100);\n\t\t\t * const result = rect1.intersection(empty);\n\t\t\t * console.log(result); // Rectangle(0, 0, 0, 0)\n\t\t\t * ```\n\t\t\t * @param {Rectangle} other - The Rectangle to intersect with `this`.\n\t\t\t * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n\t\t\t * optional (otherwise will create a new Rectangle).\n\t\t\t * @returns {Rectangle} The intersection of `this` and `other`.\n\t\t\t * @see {@link Rectangle.intersects} For boolean intersection test\n\t\t\t * @see {@link Rectangle.union} For combining rectangles\n\t\t\t */\n\t\t\tintersection<T extends Rectangle = Rectangle>(other: Rectangle, outRect?: T): T;\n\t\t\t/**\n\t\t\t * Adds `this` and `other` Rectangles together to create a new Rectangle object filling\n\t\t\t * the horizontal and vertical space between the two rectangles.\n\t\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t\t * @example\n\t\t\t * ```ts\n\t\t\t * // Basic union\n\t\t\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t\t\t * const rect2 = new Rectangle(50, 50, 100, 100);\n\t\t\t * const combined = rect1.union(rect2);\n\t\t\t * console.log(combined); // Rectangle(0, 0, 150, 150)\n\t\t\t *\n\t\t\t * // Using output rectangle\n\t\t\t * const out = new Rectangle();\n\t\t\t * rect1.union(rect2, out);\n\t\t\t *\n\t\t\t * // Chain multiple unions\n\t\t\t * const rect3 = new Rectangle(200, 200, 50, 50);\n\t\t\t * const result = rect1.union(rect2).union(rect3);\n\t\t\t * ```\n\t\t\t * @param {Rectangle} other - The Rectangle to unite with `this`\n\t\t\t * @param {Rectangle} [outRect] - Optional Rectangle to store the result\n\t\t\t * @returns The union of `this` and `other`\n\t\t\t * @see {@link Rectangle.intersection} For overlap area\n\t\t\t * @see {@link Rectangle.containsRect} For containment testing\n\t\t\t */\n\t\t\tunion<T extends Rectangle = Rectangle>(other: Rectangle, outRect?: T): T;\n\t\t}\n\t}\n\tinterface Vector2Math {\n\t\t/**\n\t\t * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic point addition\n\t\t * const point = new Point(10, 20);\n\t\t * const other = new Point(5, 10);\n\t\t * const result = point.add(other);\n\t\t * console.log(result); // Point(15, 30)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.add(other, output);\n\t\t * console.log(output); // Point(15, 30)\n\t\t *\n\t\t * // Chain multiple additions\n\t\t * const final = point.add(other).add(new Point(2, 3));\n\t\t * ```\n\t\t * @param {PointData} other - The point to add to `this`\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with addition result\n\t\t * @see {@link Point.subtract} For point subtraction\n\t\t * @see {@link Point.multiply} For point multiplication\n\t\t */\n\t\tadd<T extends PointData = Point>(other: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic point subtraction\n\t\t * const point = new Point(10, 20);\n\t\t * const other = new Point(5, 10);\n\t\t * const result = point.subtract(other);\n\t\t * console.log(result); // Point(5, 10)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.subtract(other, output);\n\t\t * console.log(output); // Point(5, 10)\n\t\t *\n\t\t * // Chain multiple subtractions\n\t\t * const final = point.subtract(other).subtract(new Point(2, 3));\n\t\t * ```\n\t\t * @param {PointData} other - The point to subtract from `this`\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with subtraction result\n\t\t * @see {@link Point.add} For point addition\n\t\t * @see {@link Point.multiply} For point multiplication\n\t\t */\n\t\tsubtract<T extends PointData = Point>(other: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic point multiplication\n\t\t * const point = new Point(10, 20);\n\t\t * const other = new Point(2, 3);\n\t\t * const result = point.multiply(other);\n\t\t * console.log(result); // Point(20, 60)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.multiply(other, output);\n\t\t * console.log(output); // Point(20, 60)\n\t\t *\n\t\t * // Chain multiple operations\n\t\t * const final = point.multiply(other).add(new Point(5, 5));\n\t\t * ```\n\t\t * @param {PointData} other - The point to multiply with `this`\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with multiplication result\n\t\t * @see {@link Point.add} For point addition\n\t\t * @see {@link Point.multiplyScalar} For scalar multiplication\n\t\t */\n\t\tmultiply<T extends PointData = Point>(other: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic scalar multiplication\n\t\t * const point = new Point(10, 20);\n\t\t * const result = point.multiplyScalar(2);\n\t\t * console.log(result); // Point(20, 40)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.multiplyScalar(0.5, output);\n\t\t * console.log(output); // Point(5, 10)\n\t\t *\n\t\t * // Chain with other operations\n\t\t * const final = point.multiplyScalar(2).add(new Point(5, 5));\n\t\t * ```\n\t\t * @param {number} scalar - The number to multiply both components with\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with multiplication result\n\t\t * @see {@link Point.multiply} For point multiplication\n\t\t * @see {@link Point.normalize} For unit vector conversion\n\t\t */\n\t\tmultiplyScalar<T extends PointData = Point>(scalar: number, outPoint?: T): T;\n\t\t/**\n\t\t * Computes the dot product of `other` with `this` point.\n\t\t * The dot product is the sum of the products of the corresponding components of two vectors.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic dot product\n\t\t * const v1 = new Point(2, 3);\n\t\t * const v2 = new Point(4, 5);\n\t\t * const result = v1.dot(v2); // 2*4 + 3*5 = 23\n\t\t *\n\t\t * // Check if vectors are perpendicular\n\t\t * const isOrthogonal = v1.dot(v2) === 0;\n\t\t *\n\t\t * // Get angle between vectors\n\t\t * const cosTheta = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n\t\t * ```\n\t\t * @param {PointData} other - The other point to calculate the dot product with\n\t\t * @returns The scalar result of the dot product\n\t\t * @see {@link Point.cross} For cross product calculation\n\t\t * @see {@link Point.magnitude} For vector length\n\t\t */\n\t\tdot(other: PointData): number;\n\t\t/**\n\t\t * Computes the cross product of `other` with `this` point.\n\t\t * Returns the z-component of the 3D cross product, assuming z=0 for both vectors.\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic cross product\n\t\t * const v1 = new Point(2, 3);\n\t\t * const v2 = new Point(4, 5);\n\t\t * const result = v1.cross(v2); // 2*5 - 3*4 = -2\n\t\t *\n\t\t * // Check if vectors are parallel\n\t\t * const isParallel = v1.cross(v2) === 0;\n\t\t *\n\t\t * // Get signed area of parallelogram\n\t\t * const area = Math.abs(v1.cross(v2));\n\t\t * ```\n\t\t * @remarks\n\t\t * - Returns z-component only (x,y assumed in 2D plane)\n\t\t * - Positive result means counter-clockwise angle from this to other\n\t\t * - Magnitude equals area of parallelogram formed by vectors\n\t\t * @param {PointData} other - The other point to calculate the cross product with\n\t\t * @returns The z-component of the cross product\n\t\t * @see {@link Point.dot} For dot product calculation\n\t\t * @see {@link Point.normalize} For unit vector conversion\n\t\t */\n\t\tcross(other: PointData): number;\n\t\t/**\n\t\t * Computes a normalized version of `this` point.\n\t\t *\n\t\t * A normalized vector is a vector of magnitude (length) 1\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic normalization\n\t\t * const vector = new Point(3, 4);\n\t\t * const normalized = vector.normalize();\n\t\t * console.log(normalized.magnitude()); // 1\n\t\t *\n\t\t * // Using output point\n\t\t * const out = new Point();\n\t\t * vector.normalize(out);\n\t\t *\n\t\t * // Chain with other operations\n\t\t * const scaled = vector.normalize().multiplyScalar(5);\n\t\t * ```\n\t\t * @param {PointData} outPoint - Optional Point-like object to store result\n\t\t * @returns The normalized point\n\t\t * @see {@link Point.magnitude} For vector length\n\t\t * @see {@link Point.multiplyScalar} For scaling\n\t\t */\n\t\tnormalize<T extends PointData = Point>(outPoint?: T): T;\n\t\t/**\n\t\t * Computes the magnitude (length) of this point as Euclidean distance from origin.\n\t\t *\n\t\t * Defined as the square root of the sum of the squares of each component.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic length calculation\n\t\t * const vector = new Point(3, 4);\n\t\t * console.log(vector.magnitude()); // 5\n\t\t *\n\t\t * // Check if unit vector\n\t\t * const isUnit = Math.abs(vector.magnitude() - 1) < 0.0001;\n\t\t *\n\t\t * // Compare vector lengths\n\t\t * const longer = v1.magnitude() > v2.magnitude();\n\t\t * ```\n\t\t * @returns The magnitude (length) of the vector\n\t\t * @see {@link Point.magnitudeSquared} For efficient length comparison\n\t\t * @see {@link Point.normalize} For unit vector conversion\n\t\t */\n\t\tmagnitude(): number;\n\t\t/**\n\t\t * Computes the squared magnitude of this point.\n\t\t * More efficient than magnitude() for length comparisons.\n\t\t *\n\t\t * Defined as the sum of the squares of each component.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Efficient length comparison\n\t\t * const v1 = new Point(3, 4);\n\t\t * const v2 = new Point(1, 2);\n\t\t *\n\t\t * // Better than: v1.magnitude() > v2.magnitude()\n\t\t * const longer = v1.magnitudeSquared() > v2.magnitudeSquared();\n\t\t *\n\t\t * // Check if vector is longer than 5 units\n\t\t * const isLong = v1.magnitudeSquared() > 25; // 5 * 5\n\t\t * ```\n\t\t * @returns The squared magnitude of the vector\n\t\t * @see {@link Point.magnitude} For actual vector length\n\t\t * @see {@link Point.dot} For dot product calculation\n\t\t */\n\t\tmagnitudeSquared(): number;\n\t\t/**\n\t\t * Computes vector projection of `this` on `onto`.\n\t\t * Projects one vector onto another, creating a parallel vector with the length of the projection.\n\t\t *\n\t\t * Imagine a light source, parallel to `onto`, above `this`.\n\t\t * The light would cast rays perpendicular to `onto`.\n\t\t * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @remarks\n\t\t * - Results in zero vector if projecting onto zero vector\n\t\t * - Length depends on angle between vectors\n\t\t * - Result is parallel to `onto` vector\n\t\t * - Useful for physics and collision responses\n\t\t * @param {PointData} onto - Vector to project onto (should be non-zero)\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The projection of `this` onto `onto`\n\t\t * @see {@link Point.dot} For angle calculations\n\t\t * @see {@link Point.normalize} For unit vector conversion\n\t\t */\n\t\tproject<T extends PointData = Point>(onto: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Reflects `this` vector off of a plane orthogonal to `normal`.\n\t\t *\n\t\t * Like a light ray bouncing off a mirror surface.\n\t\t * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n\t\t * `this.reflect(normal)` is the reflection of `this` on that mirror.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic reflection\n\t\t * const ray = new Point(1, 1);\n\t\t * const surfaceNormal = new Point(0, 1).normalize();\n\t\t * const reflection = ray.reflect(surfaceNormal);\n\t\t *\n\t\t * // Using output point\n\t\t * const out = new Point();\n\t\t * ray.reflect(surfaceNormal, out);\n\t\t *\n\t\t * // Reflect off angled surface\n\t\t * const slope = new Point(1, 1).normalize();\n\t\t * const bounced = ray.reflect(slope);\n\t\t * ```\n\t\t * @remarks\n\t\t * - Normal vector should be normalized for accurate results\n\t\t * - Preserves vector magnitude\n\t\t * - Useful for physics simulations\n\t\t * - Common in light/particle effects\n\t\t * @param {PointData} normal - The normal vector of the reflecting plane\n\t\t * @param {PointData} outPoint - Optional Point-like object to store result\n\t\t * @returns The reflection of `this` off the plane\n\t\t * @see {@link Point.normalize} For normalizing vectors\n\t\t * @see {@link Point.dot} For angle calculations\n\t\t */\n\t\treflect<T extends PointData = Point>(normal: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Rotates `this` vector.\n\t\t *\n\t\t * Like a light ray bouncing off a mirror surface.\n\t\t * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n\t\t * `this.reflect(normal)` is the reflection of `this` on that mirror.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * ```ts\n\t\t * // Basic point rotation\n\t\t * const point = new Point(10, 20);\n\t\t * const degrees = 45\n\t\t * const radians = degrees * (Math.PI / 180)\n\t\t * const result = point.rotate(radians);\n\t\t * console.log(result); // {x: -7.071067811865474, y: 21.213203435596427}\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point(10, 20);\n\t\t * point.rotate(90 * (Math.PI / 180), output);\n\t\t * console.log(result); // {x: -7.071067811865474, y: 21.213203435596427}\n\t\t *\n\t\t * // Chain multiple additions\n\t\t * const final = point.rotate(radians).rotate(radians2);\n\t\t * ```\n\t\t * @remarks\n\t\t * convert degrees to radians with const radians = degrees * (Math.PI / 180)\n\t\t * @param {PointData} radians - The rotation angle in radians\n\t\t * @param {PointData} outPoint - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with rotated result\n\t\t */\n\t\trotate<T extends PointData = Point>(radians: number, outPoint?: T): T;\n\t}\n}\n/** @internal */\nexport interface GraphicsAdaptor {\n\tshader: Shader;\n\tcontextChange(renderer: Renderer): void;\n\texecute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n\tdestroy(): void;\n}\n/** @internal */\nexport class GraphicsGpuData implements GPUData {\n\tbatches: BatchableGraphics[];\n\tbatched: boolean;\n\tdestroy(): void;\n}\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"graphics\";\n\t};\n\trenderer: Renderer;\n\tstate: State;\n\tprivate _adaptor;\n\tprivate readonly _managedGraphics;\n\tconstructor(renderer: Renderer, adaptor: GraphicsAdaptor);\n\tcontextChange(): void;\n\tvalidateRenderable(graphics: Graphics): boolean;\n\taddRenderable(graphics: Graphics, instructionSet: InstructionSet): void;\n\tupdateRenderable(graphics: Graphics): void;\n\texecute(graphics: Graphics): void;\n\tprivate _rebuild;\n\tprivate _addToBatcher;\n\tprivate _getGpuDataForRenderable;\n\tprivate _initGpuDataForRenderable;\n\tprivate _updateBatchesForRenderable;\n\tdestroy(): void;\n}\n/**\n * The line cap styles for strokes.\n *\n * It can be:\n * - `butt`: The ends of the stroke are squared off at the endpoints.\n * - `round`: The ends of the stroke are rounded.\n * @category scene\n * @standard\n */\nexport type LineCap = \"butt\" | \"round\" | \"square\";\n/**\n * The line join styles for strokes.\n *\n * It can be:\n * - `round`: The corners of the stroke are rounded.\n * - `bevel`: The corners of the stroke are squared off.\n * - `miter`: The corners of the stroke are extended to meet at a point.\n * @category scene\n * @standard\n */\nexport type LineJoin = \"round\" | \"bevel\" | \"miter\";\n/** @internal */\nexport const closePointEps = 0.0001;\n/** @internal */\nexport const curveEps = 0.0001;\n/**\n * Defines the type of gradient to create.\n *\n * It can be:\n * - 'linear': A linear gradient that transitions colors along a straight line.\n * - 'radial': A radial gradient that transitions colors in a circular pattern from an inner circle to an outer circle.\n * @category scene\n * @standard\n */\nexport type GradientType = \"linear\" | \"radial\";\n/**\n * Represents the style options for a linear gradient fill.\n * @category scene\n * @standard\n */\nexport interface BaseGradientOptions {\n\t/** The type of gradient */\n\ttype?: GradientType;\n\t/** Array of colors stops to use in the gradient */\n\tcolorStops?: {\n\t\toffset: number;\n\t\tcolor: ColorSource;\n\t}[];\n\t/** Whether coordinates are 'global' or 'local' */\n\ttextureSpace?: TextureSpace;\n\t/**\n\t * The size of the texture to use for the gradient - this is for advanced usage.\n\t * The texture size does not need to match the size of the object being drawn.\n\t * Due to GPU interpolation, gradient textures can be relatively small!\n\t * Consider using a larger texture size if your gradient has a lot of very tight color steps\n\t */\n\ttextureSize?: number;\n\t/**\n\t * The wrap mode of the gradient.\n\t * This can be 'clamp-to-edge' or 'repeat'.\n\t * @default 'clamp-to-edge'\n\t */\n\twrapMode?: WRAP_MODE;\n}\n/**\n * Options specific to linear gradients.\n * A linear gradient creates a smooth transition between colors along a straight line defined by start and end points.\n * @category scene\n * @standard\n */\nexport interface LinearGradientOptions extends BaseGradientOptions {\n\t/** The type of gradient. Must be 'linear' for linear gradients. */\n\ttype?: \"linear\";\n\t/**\n\t * The start point of the gradient.\n\t * This point defines where the gradient begins.\n\t * It is represented as a PointData object containing x and y coordinates.\n\t * The coordinates are in local space by default (0-1), but can be in global space if specified.\n\t */\n\tstart?: PointData;\n\t/**\n\t * The end point of the gradient.\n\t * This point defines where the gradient ends.\n\t * It is represented as a PointData object containing x and y coordinates.\n\t * The coordinates are in local space by default (0-1), but can be in global space if specified.\n\t */\n\tend?: PointData;\n}\n/**\n * Options specific to radial gradients.\n * A radial gradient creates a smooth transition between colors that radiates outward in a circular pattern.\n * The gradient is defined by inner and outer circles, each with their own radius.\n * @category scene\n * @standard\n */\nexport interface RadialGradientOptions extends BaseGradientOptions {\n\t/** The type of gradient. Must be 'radial' for radial gradients. */\n\ttype?: \"radial\";\n\t/** The center point of the inner circle where the gradient begins. In local coordinates by default (0-1). */\n\tcenter?: PointData;\n\t/** The radius of the inner circle where the gradient begins. */\n\tinnerRadius?: number;\n\t/** The center point of the outer circle where the gradient ends. In local coordinates by default (0-1). */\n\touterCenter?: PointData;\n\t/** The radius of the outer circle where the gradient ends. */\n\touterRadius?: number;\n\t/**\n\t * The y scale of the gradient, use this to make the gradient elliptical.\n\t * NOTE: Only applied to radial gradients used with Graphics.\n\t */\n\tscale?: number;\n\t/**\n\t * The rotation of the gradient in radians, useful for making the gradient elliptical.\n\t * NOTE: Only applied to radial gradients used with Graphics.\n\t */\n\trotation?: number;\n}\n/**\n * Options for creating a gradient fill.\n * @category scene\n * @standard\n */\nexport type GradientOptions = LinearGradientOptions | RadialGradientOptions;\n/**\n * Class representing a gradient fill that can be used to fill shapes and text.\n * Supports both linear and radial gradients with multiple color stops.\n *\n * For linear gradients, color stops define colors and positions (0 to 1) along a line from start point (x0,y0)\n * to end point (x1,y1).\n *\n * For radial gradients, color stops define colors between two circles - an inner circle centered at (x0,y0) with radius r0,\n * and an outer circle centered at (x1,y1) with radius r1.\n * @example\n * ```ts\n * // Create a vertical linear gradient from red to blue\n * const linearGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },  // Start at top\n *     end: { x: 0, y: 1 },    // End at bottom\n *     colorStops: [\n *         { offset: 0, color: 'red' },   // Red at start\n *         { offset: 1, color: 'blue' }   // Blue at end\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a radial gradient from yellow center to green edge\n * const radialGradient = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.5, y: 0.5 },\n *     innerRadius: 0,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'yellow' }, // Center color\n *         { offset: 1, color: 'green' }   // Edge color\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a rainbow linear gradient in global coordinates\n * const globalGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 0 },\n *     colorStops: [\n *         { offset: 0, color: 0xff0000 },    // Red\n *         { offset: 0.33, color: 0x00ff00 }, // Green\n *         { offset: 0.66, color: 0x0000ff }, // Blue\n *         { offset: 1, color: 0xff00ff }     // Purple\n *     ],\n *     textureSpace: 'global'  // Use world coordinates\n * });\n *\n * // Create an offset radial gradient\n * const offsetRadial = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.3, y: 0.3 },\n *     innerRadius: 0.1,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'white' },\n *         { offset: 1, color: 'black' }\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n * ```\n *\n * Internally this creates a  texture of the gradient then applies a\n * transform to it to give it the correct size and angle.\n *\n * This means that it's important to destroy a gradient when it is no longer needed\n * to avoid memory leaks.\n *\n * If you want to animate a gradient then it's best to modify and update an existing one\n * rather than creating a whole new one each time. That or use a custom shader.\n * @category scene\n * @standard\n */\nexport class FillGradient implements CanvasGradient {\n\t/** Default options for creating a gradient fill */\n\tstatic readonly defaultLinearOptions: LinearGradientOptions;\n\t/** Default options for creating a radial gradient fill */\n\tstatic readonly defaultRadialOptions: RadialGradientOptions;\n\t/**\n\t * Unique identifier for this gradient instance\n\t * @internal\n\t */\n\treadonly uid: number;\n\t/**\n\t * Internal tick counter to track changes in the gradient.\n\t * This is used to invalidate the gradient when the texture changes.\n\t * @internal\n\t */\n\t_tick: number;\n\t/** Type of gradient - currently only supports 'linear' */\n\treadonly type: GradientType;\n\t/** Internal texture used to render the gradient */\n\ttexture: Texture;\n\t/** Transform matrix for positioning the gradient */\n\ttransform: Matrix;\n\t/** Array of color stops defining the gradient */\n\tcolorStops: Array<{\n\t\toffset: number;\n\t\tcolor: string;\n\t}>;\n\t/** Whether gradient coordinates are in local or global space */\n\ttextureSpace: TextureSpace;\n\tprivate readonly _textureSize;\n\t/** The start point of the linear gradient */\n\tstart: PointData;\n\t/** The end point of the linear gradient */\n\tend: PointData;\n\t/** The wrap mode of the gradient texture */\n\tprivate readonly _wrapMode;\n\t/** The center point of the inner circle of the radial gradient */\n\tcenter: PointData;\n\t/** The center point of the outer circle of the radial gradient */\n\touterCenter: PointData;\n\t/** The radius of the inner circle of the radial gradient */\n\tinnerRadius: number;\n\t/** The radius of the outer circle of the radial gradient */\n\touterRadius: number;\n\t/** The scale of the radial gradient */\n\tscale: number;\n\t/** The rotation of the radial gradient */\n\trotation: number;\n\t/**\n\t * Creates a new gradient fill. The constructor behavior changes based on the gradient type.\n\t * @param {GradientOptions} options - The options for the gradient\n\t * @see {@link LinearGradientOptions}\n\t * @see {@link RadialGradientOptions}\n\t */\n\tconstructor(options: GradientOptions);\n\t/**\n\t * Deprecated: Use the options object instead.\n\t * @deprecated since 8.5.2\n\t * @ignore\n\t */\n\tconstructor(x0?: number, y0?: number, x1?: number, y1?: number, textureSpace?: TextureSpace, textureSize?: number);\n\t/**\n\t * Adds a color stop to the gradient\n\t * @param offset - Position of the stop (0-1)\n\t * @param color - Color of the stop\n\t * @returns This gradient instance for chaining\n\t */\n\taddColorStop(offset: number, color: ColorSource): this;\n\t/**\n\t * Builds the internal texture and transform for the gradient.\n\t * Called automatically when the gradient is first used.\n\t * @internal\n\t */\n\tbuildLinearGradient(): void;\n\t/**\n\t * Builds the internal texture and transform for the gradient.\n\t * Called automatically when the gradient is first used.\n\t * @internal\n\t */\n\tbuildGradient(): void;\n\t/**\n\t * Builds the internal texture and transform for the radial gradient.\n\t * Called automatically when the gradient is first used.\n\t * @internal\n\t */\n\tbuildRadialGradient(): void;\n\t/** Destroys the gradient, releasing resources. This will also destroy the internal texture. */\n\tdestroy(): void;\n\t/**\n\t * Returns a unique key for this gradient instance.\n\t * This key is used for caching and texture management.\n\t * @returns {string} Unique key for the gradient\n\t */\n\tget styleKey(): string;\n}\n/**\n * Defines the repetition modes for fill patterns.\n *\n * - `repeat`: The pattern repeats in both directions.\n * - `repeat-x`: The pattern repeats horizontally only.\n * - `repeat-y`: The pattern repeats vertically only.\n * - `no-repeat`: The pattern does not repeat.\n * @category scene\n * @standard\n */\nexport type PatternRepetition = \"repeat\" | \"repeat-x\" | \"repeat-y\" | \"no-repeat\";\n/**\n * A class that represents a fill pattern for use in Text and Graphics fills.\n * It allows for textures to be used as patterns, with optional repetition modes.\n * @category scene\n * @standard\n * @example\n * const txt = await Assets.load('https://pixijs.com/assets/bg_scene_rotate.jpg');\n * const pat = new FillPattern(txt, 'repeat');\n *\n * const textPattern = new Text({\n *     text: 'PixiJS',\n *     style: {\n *         fontSize: 36,\n *         fill: 0xffffff,\n *         stroke: { fill: pat, width: 10 },\n *     },\n * });\n *\n * textPattern.y = (textGradient.height);\n */\nexport class FillPattern implements CanvasPattern {\n\t/**\n\t * unique id for this fill pattern\n\t * @internal\n\t */\n\treadonly uid: number;\n\t/**\n\t * Internal tick counter to track changes in the pattern.\n\t * This is used to invalidate the pattern when the texture or transform changes.\n\t * @internal\n\t */\n\t_tick: number;\n\t/** @internal */\n\t_texture: Texture;\n\t/** The transform matrix applied to the pattern */\n\ttransform: Matrix;\n\tconstructor(texture: Texture, repetition?: PatternRepetition);\n\t/**\n\t * Sets the transform for the pattern\n\t * @param transform - The transform matrix to apply to the pattern.\n\t * If not provided, the pattern will use the default transform.\n\t */\n\tsetTransform(transform?: Matrix): void;\n\t/** Internal texture used to render the gradient */\n\tget texture(): Texture;\n\tset texture(value: Texture);\n\t/**\n\t * Returns a unique key for this instance.\n\t * This key is used for caching.\n\t * @returns {string} Unique key for the instance\n\t */\n\tget styleKey(): string;\n\t/** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */\n\tdestroy(): void;\n}\n/**\n * Determines how texture coordinates are calculated\n * Local Space:              Global Space:\n *       \n *  A   B      A   B      A...B      ...B... \n *                                           \n *  C   D      C   D      C...D      ...D... \n *       \n * (Each shape   (Each shape  (Texture continues across\n * gets full     gets full    shapes as if they're texture)      texture)     windows to same texture)\n * @category scene\n * @advanced\n */\nexport type TextureSpace = \n/**\n * 'local' - Texture coordinates are relative to the shape's bounds.\n * The texture will stretch/fit to each individual shape's boundaries.\n * Think of it like the shape having its own coordinate system.\n */\n\"local\"\n/**\n * 'global' - Texture coordinates are in world space.\n * The texture position is consistent across all shapes,\n * as if the texture was laid down first and shapes were cut out of it.\n * Think of it like wallpaper that shows through shaped holes.\n */\n | \"global\";\n/**\n * Defines the style properties used for filling shapes in graphics and text operations.\n * This interface provides options for colors, textures, patterns, and gradients.\n * @example\n * ```ts\n * // Basic color fill\n * const fillStyle = {\n *     color: 0xff0000,  // Red\n *     alpha: 0.5        // 50% opacity\n * };\n *\n * // Textured fill ( Graphics only )\n * const fillStyle = {\n *     texture: Texture.from('myImage.png'),\n *     matrix: new Matrix().scale(0.5, 0.5),\n * };\n *\n * // Gradient fill\n * const gradient = new FillGradient({\n *    end: { x: 1, y: 0 },\n *    stops: [\n *        { color: 0xff0000, offset: 0 }, // Red at start\n *        { color: 0x0000ff, offset: 1 }, // Blue at end\n *    ]\n * })\n *\n * const fillStyle = {\n *     fill: gradient,\n *     alpha: 1\n * };\n * ```\n * @see {@link FillPattern} For creating pattern fills\n * @see {@link FillGradient} For creating gradient fills\n * @see {@link TextureSpace} For texture coordinate calculation modes\n * @category scene\n * @standard\n */\nexport interface FillStyle {\n\t/**\n\t * The color to use for the fill.\n\t * This can be any valid color source, such as a hex value, a Color object, or a string.\n\t * @example\n\t * ```ts\n\t * // Using a hex color\n\t * const fillStyle = { color: 0xff0000 }; // Red\n\t * // Using a Color object\n\t * const fillStyle = { color: new Color(1, 0, 0) }; // Red\n\t * // Using a string color\n\t * const fillStyle = { color: 'red' }; // Red\n\t * // Using object string\n\t * const fillStyle = { color: 'rgb(255, 0, 0)' }; // Red\n\t * ```\n\t * @see {@link ColorSource} For more details on color sources\n\t */\n\tcolor?: ColorSource;\n\t/**\n\t * The alpha value to use for the fill.\n\t * This value should be between 0 (fully transparent) and 1 (fully opaque).\n\t * @example\n\t * ```ts\n\t * const fillStyle = { alpha: 0.5 }; // 50% opacity\n\t * ```\n\t * @default 1\n\t * @see {@link ColorSource} For more details on color sources\n\t * @see {@link FillStyle#color} For color usage\n\t */\n\talpha?: number;\n\t/**\n\t * The texture to use for the fill.\n\t * @example\n\t * ```ts\n\t * const fillStyle = { texture: Texture.from('myImage.png') };\n\t * ```\n\t * @see {@link Texture} For more details on textures\n\t */\n\ttexture?: Texture | null;\n\t/**\n\t * The transformation matrix to apply to the fill pattern or texture.\n\t * Used to scale, rotate, translate, or skew the fill.\n\t * @example\n\t * ```ts\n\t * // Scale and rotate a texture fill\n\t * const fillStyle = {\n\t *     texture: Texture.from('myImage.png'),\n\t *     matrix: new Matrix()\n\t *         .scale(0.5, 0.5)\n\t *         .rotate(Math.PI / 4)\n\t * };\n\t * ```\n\t * @default null\n\t */\n\tmatrix?: Matrix | null;\n\t/**\n\t * The fill pattern or gradient to use. This can be either a FillPattern for\n\t * repeating textures or a FillGradient for color transitions.\n\t * @example\n\t * ```ts\n\t * // Using a gradient\n\t * const gradient = new FillGradient({\n\t *    end: { x: 1, y: 0 },\n\t *    stops: [\n\t *        { color: 0xff0000, offset: 0 }, // Red at start\n\t *        { color: 0x0000ff, offset: 1 }, // Blue at end\n\t *    ]\n\t * });\n\t *\n\t * const fillStyle = {\n\t *     fill: gradient,\n\t *     alpha: 0.8\n\t * };\n\t *\n\t * // Using a pattern\n\t * const pattern = new FillPattern(\n\t *     Texture.from('pattern.png'),\n\t *     'repeat' // or 'no-repeat', 'repeat-x', 'repeat-y'\n\t * );\n\t *\n\t * const fillStyle = {\n\t *     fill: pattern\n\t * };\n\t * ```\n\t * @see {@link FillPattern} For creating pattern fills\n\t * @see {@link FillGradient} For creating gradient fills\n\t */\n\tfill?: FillPattern | FillGradient | null;\n\t/**\n\t * Determines how texture coordinates are calculated across shapes.\n\t * - 'local': Texture coordinates are relative to each shape's bounds\n\t * - 'global': Texture coordinates are in world space\n\t * @example\n\t * ```ts\n\t * // Local space - texture fits each shape independently\n\t * const fillStyle = {\n\t *     texture: Texture.from('myImage.png'),\n\t *     textureSpace: 'local'\n\t * };\n\t *\n\t * // Global space - texture continues across shapes\n\t * const fillStyle = {\n\t *     texture: Texture.from('myImage.png'),\n\t *     textureSpace: 'global'\n\t * };\n\t * ```\n\t * @default 'local'\n\t * @see {@link TextureSpace} For more details on texture spaces\n\t */\n\ttextureSpace?: TextureSpace;\n}\n/**\n * A stroke attribute object that defines how lines and shape outlines are drawn.\n * Controls properties like width, alignment, line caps, joins, and more.\n * @example\n * ```ts\n * const graphics = new Graphics();\n *\n * // Basic stroke with width\n * graphics.stroke({\n *     width: 4,\n *     color: 0xff0000 // Or use a Color object\n * });\n *\n * // Stroke with rounded corners and ends\n * const text = new Text('Hello World', {\n *     fontSize: 32,\n *     fill: 0x000000, // Text color\n *     stroke: {\n *     width: 8,\n *         color: 0x00ff00, // Or use a Color object\n *         cap: 'round',    // Round end caps\n *         join: 'round',   // Round corner joins\n *         alignment: 0.5   // Center alignment\n *     }\n * });\n *\n * // Stroke with mitered corners\n * graphics.stroke({\n *     width: 6,\n *     color: 0x0000ff, // Or use a Color object\n *     join: 'miter',\n *     miterLimit: 3,   // Limit how far miter extends\n *     alignment: 0     // Outside alignment\n * });\n *\n * // Pixel-perfect line\n * graphics.stroke({\n *     width: 1,\n *     pixelLine: true, // Ensures crisp 1px lines\n *     color: 0x000000  // Or use a Color object\n * });\n * ```\n * @see {@link Graphics#stroke} For applying strokes to paths\n * @see {@link LineCap} For line end cap options\n * @see {@link LineJoin} For line join options\n * @category scene\n * @standard\n */\nexport interface StrokeAttributes {\n\t/**\n\t * The width of the stroke in pixels.\n\t * @example\n\t * ```ts\n\t * const stroke = { width: 4 };\n\t * ```\n\t * @default 1\n\t */\n\twidth?: number;\n\t/**\n\t * The alignment of the stroke relative to the path.\n\t * - 1: Inside the shape\n\t * - 0.5: Centered on the path (default)\n\t * - 0: Outside the shape\n\t * @example\n\t * ```ts\n\t * // Inside alignment\n\t * const stroke = { alignment: 1 };\n\t * // Centered alignment\n\t * const stroke = { alignment: 0.5 };\n\t * // Outside alignment\n\t * const stroke = { alignment: 0 };\n\t * ```\n\t * @default 0.5\n\t */\n\talignment?: number;\n\t/**\n\t * The style to use for the ends of open paths.\n\t * - 'butt': Ends at path end\n\t * - 'round': Rounds past path end\n\t * - 'square': Squares past path end\n\t * @example\n\t * ```ts\n\t * const stroke = { cap: 'round' };\n\t * ```\n\t * @default 'butt'\n\t * @see {@link LineCap} For line cap options\n\t */\n\tcap?: LineCap;\n\t/**\n\t * The style to use where paths connect.\n\t * - 'miter': Sharp corner\n\t * - 'round': Rounded corner\n\t * - 'bevel': Beveled corner\n\t * @example\n\t * ```ts\n\t * const stroke = { join: 'round' };\n\t * ```\n\t * @default 'miter'\n\t * @see {@link LineJoin} For line join options\n\t */\n\tjoin?: LineJoin;\n\t/**\n\t * Controls how far miter joins can extend. Only applies when join is 'miter'.\n\t * Higher values allow sharper corners.\n\t * @example\n\t * ```ts\n\t * const stroke = {\n\t *     join: 'miter',\n\t *     miterLimit: 3,\n\t * };\n\t * ```\n\t * @default 10\n\t */\n\tmiterLimit?: number;\n\t/**\n\t * When true, ensures crisp 1px lines by aligning to pixel boundaries.\n\t * > [!NOTE] Only available for Graphics fills.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw pixel-perfect line\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(150, 50)\n\t *     .stroke({\n\t *         width: 1,\n\t *         pixelLine: true,\n\t *         color: 0x000000\n\t *     });\n\t * ```\n\t * @default false\n\t */\n\tpixelLine?: boolean;\n}\n/**\n * A stroke style object that combines fill properties with stroke attributes to define\n * both the visual style and stroke behavior of lines, shape outlines, and text strokes.\n * @example\n * ```ts\n * // --- Graphics Examples ---\n * const graphics = new Graphics();\n *\n * // Basic solid color stroke\n * graphics.stroke({\n *     width: 4,\n *     color: 0xff0000,\n *     alpha: 0.8,\n *     join: 'round'\n * });\n *\n * // Gradient stroke with attributes\n * const gradient = new FillGradient({\n *    end: { x: 1, y: 0 },\n *    stops: [\n *        { color: 0xff0000, offset: 0 }, // Red at start\n *        { color: 0x0000ff, offset: 1 }, // Blue at end\n *    ]\n * });\n *\n * graphics.stroke({\n *     width: 8,\n *     fill: gradient,\n *     cap: 'round',\n *     join: 'round',\n *     alignment: 0.5\n * });\n *\n * // --- Text Examples ---\n *\n * // Basic text stroke\n * const text = new Text('Hello World', {\n *     fontSize: 48,\n *     stroke: {\n *         width: 4,\n *         color: 0x000000,\n *         alignment: 0  // Outside stroke\n *     }\n * });\n *\n * // Gradient text stroke\n * const textGradient = new FillGradient({\n *   end: { x: 1, y: 0 },\n *   stops: [\n *       { color: 0xff0000, offset: 0 }, // Red at start\n *       { color: 0x0000ff, offset: 1 }, // Blue at end\n *   ]\n * });\n *\n * const fancyText = new Text('Gradient Outline', {\n *     fontSize: 64,\n *     fill: 0xffffff,\n *     stroke: {\n *         width: 6,\n *         fill: textGradient,\n *         alignment: 0.5,\n *         join: 'round'\n *     }\n * });\n * ```\n * @see {@link FillStyle} For fill properties\n * @see {@link StrokeAttributes} For stroke properties\n * @see {@link Graphics#stroke} For applying strokes to paths\n * @see {@link Text} For text stroke options\n * @category scene\n * @standard\n * @interface\n */\nexport interface StrokeStyle extends FillStyle, StrokeAttributes {\n}\n/**\n * These can be directly used as a fill or a stroke\n * ```ts\n * graphics.fill(0xff0000);\n * graphics.fill(new FillPattern(texture));\n * graphics.fill(new FillGradient(0, 0, 200, 0));\n * graphics.fill({\n *   color: 0xff0000,\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * });\n * graphics.fill({\n *   fill: new FillPattern(texture),\n * });\n * graphics.fill({\n *   fill: new FillGradient(0, 0, 200, 0),\n * });\n * ```\n * @category scene\n * @standard\n */\nexport type FillInput = ColorSource | FillGradient | FillPattern | FillStyle | Texture;\n/**\n * These can be directly used as a stroke\n * ```ts\n * graphics.stroke(0xff0000);\n * graphics.stroke(new FillPattern(texture));\n * graphics.stroke(new FillGradient(0, 0, 200, 0));\n * graphics.stroke({\n *   color: 0xff0000,\n *   width?: 1,\n *   alignment?: 0.5,\n * });\n * graphics.stroke({\n *   fill: new FillPattern(texture),\n *   width: 1,\n *   alignment: 0.5,\n * });\n * graphics.stroke({\n *   fill: new FillGradient(0, 0, 200, 0),\n *   width: 1,\n *   alignment: 0.5,\n * });\n * ```\n * @category scene\n * @standard\n */\nexport type StrokeInput = ColorSource | FillGradient | FillPattern | StrokeStyle;\n/**\n * used internally and is a complete fill style\n * @category scene\n * @advanced\n * @interface\n */\nexport type ConvertedFillStyle = Omit<Required<FillStyle>, \"color\"> & {\n\tcolor: number;\n};\n/**\n * used internally and is a complete stroke style\n * @category scene\n * @advanced\n * @interface\n */\nexport type ConvertedStrokeStyle = ConvertedFillStyle & Required<StrokeAttributes>;\n/**\n * @deprecated since v8.1.6\n * @see FillInput\n * @category scene\n * @standard\n */\nexport type FillStyleInputs = ColorSource | FillGradient | FillPattern | FillStyle | ConvertedFillStyle | StrokeStyle | ConvertedStrokeStyle;\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(g: ShapePath, points: RoundedPoint[], radius: number): void;\n/**\n * Data structure for points with optional radius.\n * @category scene\n * @standard\n */\nexport type RoundedPoint = PointData & {\n\tradius?: number;\n};\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(g: ShapePath, points: RoundedPoint[], radius: number, smoothness?: number): void;\n/**\n * A type representing a shape primitive with optional transformation and holes.\n * @category scene\n * @advanced\n */\nexport type ShapePrimitiveWithHoles = {\n\tshape: ShapePrimitive;\n\ttransform?: Matrix;\n\tholes?: ShapePrimitiveWithHoles[];\n};\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @category scene\n * @advanced\n */\nexport class ShapePath {\n\t/** The list of shape primitives that make up the path. */\n\tshapePrimitives: ShapePrimitiveWithHoles[];\n\tprivate _currentPoly;\n\tprivate readonly _graphicsPath2D;\n\tprivate readonly _bounds;\n\treadonly signed: boolean;\n\tconstructor(graphicsPath2D: GraphicsPath);\n\t/**\n\t * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n\t * @param x - The x-coordinate for the starting point.\n\t * @param y - The y-coordinate for the starting point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tmoveTo(x: number, y: number): this;\n\t/**\n\t * Connects the current point to a new point with a straight line. This method updates the current path.\n\t * @param x - The x-coordinate of the new point to connect to.\n\t * @param y - The y-coordinate of the new point to connect to.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tlineTo(x: number, y: number): this;\n\t/**\n\t * Adds an arc to the path. The arc is centered at (x, y)\n\t *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n\t * @param x - The x-coordinate of the arc's center.\n\t * @param y - The y-coordinate of the arc's center.\n\t * @param radius - The radius of the arc.\n\t * @param startAngle - The starting angle of the arc, in radians.\n\t * @param endAngle - The ending angle of the arc, in radians.\n\t * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this;\n\t/**\n\t * Adds an arc to the path with the arc tangent to the line joining two specified points.\n\t * The arc radius is specified by `radius`.\n\t * @param x1 - The x-coordinate of the first point.\n\t * @param y1 - The y-coordinate of the first point.\n\t * @param x2 - The x-coordinate of the second point.\n\t * @param y2 - The y-coordinate of the second point.\n\t * @param radius - The radius of the arc.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n\t/**\n\t * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n\t * @param rx - The x-radius of the ellipse.\n\t * @param ry - The y-radius of the ellipse.\n\t * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n\t * to the x-axis of the coordinate system, in degrees.\n\t * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n\t * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n\t * @param x - The x-coordinate of the arc's end point.\n\t * @param y - The y-coordinate of the arc's end point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n\t/**\n\t * Adds a cubic Bezier curve to the path.\n\t * It requires three points: the first two are control points and the third one is the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cp1x - The x-coordinate of the first control point.\n\t * @param cp1y - The y-coordinate of the first control point.\n\t * @param cp2x - The x-coordinate of the second control point.\n\t * @param cp2y - The y-coordinate of the second control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tbezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cp1x - The x-coordinate of the control point.\n\t * @param cp1y - The y-coordinate of the control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tquadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this;\n\t/**\n\t * Closes the current path by drawing a straight line back to the start.\n\t * If the shape is already closed or there are no points in the path, this method does nothing.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tclosePath(): this;\n\t/**\n\t * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n\t * @param path - The `GraphicsPath` object representing the path to add.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n\t * @returns The instance of the current object for chaining.\n\t */\n\taddPath(path: GraphicsPath, transform?: Matrix): this;\n\t/**\n\t * Finalizes the drawing of the current path. Optionally, it can close the path.\n\t * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n\t */\n\tfinish(closePath?: boolean): void;\n\t/**\n\t * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\trect(x: number, y: number, w: number, h: number, transform?: Matrix): this;\n\t/**\n\t * Draws a circle shape. This method adds a new circle path to the current drawing.\n\t * @param x - The x-coordinate of the center of the circle.\n\t * @param y - The y-coordinate of the center of the circle.\n\t * @param radius - The radius of the circle.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tcircle(x: number, y: number, radius: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n\t * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n\t * representing the x and y coordinates of the polygon's vertices, in sequence.\n\t * @param close - A boolean indicating whether to close the polygon path. True by default.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tpoly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n\t/**\n\t * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tregularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon with rounded corners.\n\t * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param corner - The radius of the rounding of the corners.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number, smoothness?: number): this;\n\t/**\n\t * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n\t * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n\t * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n\t * A minimum of 3 points is required.\n\t * @param radius - The default radius for the corners.\n\t * This radius is applied to all corners unless overridden in `points`.\n\t * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n\t *  method instead of an arc method. Defaults to false.\n\t * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n\t * Higher values make the curve smoother.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n\t/**\n\t * Draw Rectangle with fillet corners. This is much like rounded rectangle\n\t * however it support negative numbers as well for the corner radius.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param fillet - accept negative or positive values\n\t */\n\tfilletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n\t/**\n\t * Draw Rectangle with chamfer corners. These are angled corners.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param chamfer - non-zero real number, size of corner cutout\n\t * @param transform\n\t */\n\tchamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n\t/**\n\t * Draws an ellipse at the specified location and with the given x and y radii.\n\t * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n\t * @param x - The x-coordinate of the center of the ellipse.\n\t * @param y - The y-coordinate of the center of the ellipse.\n\t * @param radiusX - The horizontal radius of the ellipse.\n\t * @param radiusY - The vertical radius of the ellipse.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this;\n\t/**\n\t * Draws a rectangle with rounded corners.\n\t * The corner radius can be specified to determine how rounded the corners should be.\n\t * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a given shape on the canvas.\n\t * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n\t * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n\t * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n\t * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n\t * scaling, and translations.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tdrawShape(shape: ShapePrimitive, matrix?: Matrix): this;\n\t/**\n\t * Starts a new polygon path from the specified starting point.\n\t * This method initializes a new polygon or ends the current one if it exists.\n\t * @param x - The x-coordinate of the starting point of the new polygon.\n\t * @param y - The y-coordinate of the starting point of the new polygon.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tstartPoly(x: number, y: number): this;\n\t/**\n\t * Ends the current polygon path. If `closePath` is set to true,\n\t * the path is closed by connecting the last point to the first one.\n\t * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n\t * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n\t *  back to the starting point. False by default.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tendPoly(closePath?: boolean): this;\n\tprivate _ensurePoly;\n\t/** Builds the path. */\n\tbuildPath(): void;\n\t/** Gets the bounds of the path. */\n\tget bounds(): Bounds;\n}\n/**\n * Represents a single drawing instruction in a `GraphicsPath`.\n * Each instruction consists of an action type and associated data.\n * @category scene\n * @advanced\n */\nexport interface PathInstruction {\n\taction: \"moveTo\" | \"lineTo\" | \"quadraticCurveTo\" | \"bezierCurveTo\" | \"arc\" | \"closePath\" | \"addPath\" | \"arcTo\" | \"ellipse\" | \"rect\" | \"roundRect\" | \"arcToSvg\" | \"poly\" | \"circle\" | \"regularPoly\" | \"roundPoly\" | \"roundShape\" | \"filletRect\" | \"chamferRect\";\n\tdata: any[];\n}\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n * @category scene\n * @advanced\n */\nexport class GraphicsPath {\n\tinstructions: PathInstruction[];\n\t/** unique id for this graphics path */\n\treadonly uid: number;\n\tprivate _dirty;\n\tprivate _shapePath;\n\t/**\n\t * Controls whether shapes in this path should be checked for holes using the non-zero fill rule.\n\t * When true, any closed shape that is fully contained within another shape will become\n\t * a hole in that shape during filling operations.\n\t *\n\t * This follows SVG's non-zero fill rule where:\n\t * 1. Shapes are analyzed to find containment relationships\n\t * 2. If Shape B is fully contained within Shape A, Shape B becomes a hole in Shape A\n\t * 3. Multiple nested holes are supported\n\t *\n\t * Mainly used internally by the SVG parser to correctly handle holes in complex paths.\n\t * When false, all shapes are filled independently without checking for holes.\n\t */\n\tcheckForHoles: boolean;\n\t/**\n\t * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n\t * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n\t */\n\tget shapePath(): ShapePath;\n\t/**\n\t * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n\t * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n\t * @param signed\n\t */\n\tconstructor(instructions?: string | PathInstruction[], signed?: boolean);\n\t/**\n\t * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n\t * @param path - The `GraphicsPath` to add.\n\t * @param transform - An optional transformation to apply to the added path.\n\t * @returns The instance of the current object for chaining.\n\t */\n\taddPath(path: GraphicsPath, transform?: Matrix): this;\n\t/**\n\t * Adds an arc to the path. The arc is centered at (x, y)\n\t *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n\t * @param x - The x-coordinate of the arc's center.\n\t * @param y - The y-coordinate of the arc's center.\n\t * @param radius - The radius of the arc.\n\t * @param startAngle - The starting angle of the arc, in radians.\n\t * @param endAngle - The ending angle of the arc, in radians.\n\t * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n\t/**\n\t * Adds an arc to the path with the arc tangent to the line joining two specified points.\n\t * The arc radius is specified by `radius`.\n\t * @param x1 - The x-coordinate of the first point.\n\t * @param y1 - The y-coordinate of the first point.\n\t * @param x2 - The x-coordinate of the second point.\n\t * @param y2 - The y-coordinate of the second point.\n\t * @param radius - The radius of the arc.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n\t/**\n\t * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n\t * @param rx - The x-radius of the ellipse.\n\t * @param ry - The y-radius of the ellipse.\n\t * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n\t * to the x-axis of the coordinate system, in degrees.\n\t * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n\t * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n\t * @param x - The x-coordinate of the arc's end point.\n\t * @param y - The y-coordinate of the arc's end point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n\t/**\n\t * Adds a cubic Bezier curve to the path.\n\t * It requires three points: the first two are control points and the third one is the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cp1x - The x-coordinate of the first control point.\n\t * @param cp1y - The y-coordinate of the first control point.\n\t * @param cp2x - The x-coordinate of the second control point.\n\t * @param cp2y - The y-coordinate of the second control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tbezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Adds a cubic Bezier curve to the path.\n\t * It requires two points: the second control point and the end point. The first control point is assumed to be\n\t * The starting point is the last point in the current path.\n\t * @param cp2x - The x-coordinate of the second control point.\n\t * @param cp2y - The y-coordinate of the second control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tbezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Closes the current path by drawing a straight line back to the start.\n\t * If the shape is already closed or there are no points in the path, this method does nothing.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tclosePath(): this;\n\t/**\n\t * Draws an ellipse at the specified location and with the given x and y radii.\n\t * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n\t * @param x - The x-coordinate of the center of the ellipse.\n\t * @param y - The y-coordinate of the center of the ellipse.\n\t * @param radiusX - The horizontal radius of the ellipse.\n\t * @param radiusY - The vertical radius of the ellipse.\n\t * @param matrix - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n\t/**\n\t * Connects the current point to a new point with a straight line. This method updates the current path.\n\t * @param x - The x-coordinate of the new point to connect to.\n\t * @param y - The y-coordinate of the new point to connect to.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tlineTo(x: number, y: number): this;\n\t/**\n\t * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n\t * @param x - The x-coordinate for the starting point.\n\t * @param y - The y-coordinate for the starting point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tmoveTo(x: number, y: number): this;\n\t/**\n\t * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cpx - The x-coordinate of the control point.\n\t * @param cpy - The y-coordinate of the control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tquadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Adds a quadratic curve to the path. It uses the previous point as the control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tquadraticCurveToShort(x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\trect(x: number, y: number, w: number, h: number, transform?: Matrix): this;\n\t/**\n\t * Draws a circle shape. This method adds a new circle path to the current drawing.\n\t * @param x - The x-coordinate of the center of the circle.\n\t * @param y - The y-coordinate of the center of the circle.\n\t * @param radius - The radius of the circle.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tcircle(x: number, y: number, radius: number, transform?: Matrix): this;\n\t/**\n\t * Draws a rectangle with rounded corners.\n\t * The corner radius can be specified to determine how rounded the corners should be.\n\t * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n\t * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n\t * rotated, or translated as needed.\n\t * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n\t * @param close - A boolean indicating whether to close the polygon path. True by default.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n\t * @returns The instance of the current object for chaining further drawing commands.\n\t */\n\tpoly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n\t/**\n\t * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tregularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon with rounded corners.\n\t * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param corner - The radius of the rounding of the corners.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n\t/**\n\t * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n\t * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n\t * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n\t * A minimum of 3 points is required.\n\t * @param radius - The default radius for the corners.\n\t * This radius is applied to all corners unless overridden in `points`.\n\t * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n\t *  method instead of an arc method. Defaults to false.\n\t * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n\t * Higher values make the curve smoother.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n\t/**\n\t * Draw Rectangle with fillet corners. This is much like rounded rectangle\n\t * however it support negative numbers as well for the corner radius.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param fillet - accept negative or positive values\n\t */\n\tfilletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n\t/**\n\t * Draw Rectangle with chamfer corners. These are angled corners.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param chamfer - non-zero real number, size of corner cutout\n\t * @param transform\n\t */\n\tchamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n\t/**\n\t * Draws a star shape centered at a specified location. This method allows for the creation\n\t *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n\t * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n\t * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n\t * @param x - The x-coordinate of the center of the star.\n\t * @param y - The y-coordinate of the center of the star.\n\t * @param points - The number of points of the star.\n\t * @param radius - The outer radius of the star (distance from the center to the outer points).\n\t * @param innerRadius - Optional. The inner radius of the star\n\t * (distance from the center to the inner points between the outer points).\n\t * If not provided, defaults to half of the `radius`.\n\t * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n\t * Defaults to 0, meaning one point is directly upward.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the star.\n\t * This can include rotations, scaling, and translations.\n\t * @returns The instance of the current object for chaining further drawing commands.\n\t */\n\tstar(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this;\n\t/**\n\t * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n\t * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n\t * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n\t * do not affect the original `GraphicsPath` and vice versa.\n\t * @param deep - A boolean flag indicating whether the clone should be deep.\n\t * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n\t */\n\tclone(deep?: boolean): GraphicsPath;\n\tclear(): this;\n\t/**\n\t * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n\t * This method enables the modification of the path's geometry according to the provided\n\t * transformation matrix, which can include translations, rotations, scaling, and skewing.\n\t *\n\t * Each drawing instruction in the path is updated to reflect the transformation,\n\t * ensuring the visual representation of the path is consistent with the applied matrix.\n\t *\n\t * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n\t * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n\t * allowing for fine-grained control over the path's appearance.\n\t * @param matrix - A `Matrix` object representing the transformation to apply.\n\t * @returns The instance of the current object for chaining further operations.\n\t */\n\ttransform(matrix: Matrix): this;\n\tget bounds(): Bounds;\n\t/**\n\t * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n\t * This method is useful for operations that depend on the path's current endpoint,\n\t * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n\t * ensuring the last point's position is accurately determined regardless of the path's complexity.\n\t *\n\t * If the last instruction is a `closePath`, the method iterates backward through the instructions\n\t *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n\t * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n\t * the last point from the nested path.\n\t * @param out - A `Point` object where the last point's coordinates will be stored.\n\t * This object is modified directly to contain the result.\n\t * @returns The `Point` object containing the last point's coordinates.\n\t */\n\tgetLastPoint(out: Point): Point;\n}\n/**\n * Constructor options used for Graphics instances.\n * Configures the initial state and behavior of a Graphics object.\n * @example\n * ```ts\n * const graphics = new Graphics({\n *     roundPixels: true,\n *     position: { x: 100.5, y: 100.5 }\n * });\n *\n * // Reuse graphics context\n * const sharedContext = new GraphicsContext();\n * const graphics1 = new Graphics({ context: sharedContext });\n * const graphics2 = new Graphics({ context: sharedContext });\n * ```\n * @see {@link Graphics} For the graphics class implementation\n * @see {@link GraphicsContext} For the graphics context API\n * @category scene\n * @standard\n */\nexport interface GraphicsOptions extends PixiMixins.GraphicsOptions, ViewContainerOptions {\n\t/**\n\t * The GraphicsContext to use, useful for reuse and optimisation\n\t * If not provided, a new GraphicsContext will be created.\n\t * @example\n\t * ```ts\n\t * const sharedContext = new GraphicsContext();\n\t * const graphics1 = new Graphics({ context: sharedContext });\n\t * const graphics2 = new Graphics({ context: sharedContext });\n\t * ```\n\t */\n\tcontext?: GraphicsContext;\n\t/**\n\t * Whether or not to round the x/y position.\n\t * @default false\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics({ roundPixels: true });\n\t * ```\n\t */\n\troundPixels?: boolean;\n}\nexport interface Graphics extends PixiMixins.Graphics, ViewContainer<GraphicsGpuData> {\n}\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them. It can also be used to create complex\n * masks and hit areas for interaction.\n * @example\n * ```ts\n * // Create a new graphics object\n * const graphics = new Graphics();\n *\n * // Draw a filled rectangle with a stroke\n * graphics\n *     .rect(0, 0, 100, 100)\n *     .fill({ color: 0xff0000 }) // Fill with red\n *     .stroke({ width: 2, color: 0x000000 }); // Stroke with black\n *\n * // Draw a complex shape\n * graphics\n *     .moveTo(50, 50)\n *     .lineTo(100, 100)\n *     .arc(100, 100, 50, 0, Math.PI)\n *     .closePath()\n *     .fill({ color: 0x00ff00, alpha: 0.5 }); // Fill the shape\n *\n * // Use as a mask\n * sprite.mask = graphics;\n * ```\n * @see {@link GraphicsContext} For the underlying drawing API\n * @see {@link GraphicsPath} For path creation\n * @category scene\n * @standard\n */\nexport class Graphics extends ViewContainer<GraphicsGpuData> implements Instruction {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/** @internal */\n\tbatched: boolean;\n\tprivate _context;\n\tprivate readonly _ownedContext;\n\t/**\n\t * Creates a new Graphics object.\n\t * @param options - Options for the Graphics.\n\t */\n\tconstructor(options?: GraphicsOptions | GraphicsContext);\n\tset context(context: GraphicsContext);\n\t/**\n\t * The underlying graphics context used for drawing operations.\n\t * Controls how shapes and paths are rendered.\n\t * @example\n\t * ```ts\n\t * // Create a shared context\n\t * const sharedContext = new GraphicsContext();\n\t *\n\t * // Create graphics objects sharing the same context\n\t * const graphics1 = new Graphics();\n\t * const graphics2 = new Graphics();\n\t *\n\t * // Assign shared context\n\t * graphics1.context = sharedContext;\n\t * graphics2.context = sharedContext;\n\t *\n\t * // Both graphics will show the same shapes\n\t * sharedContext\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({ color: 0xff0000 });\n\t * ```\n\t * @see {@link GraphicsContext} For drawing operations\n\t * @see {@link GraphicsOptions} For context configuration\n\t */\n\tget context(): GraphicsContext;\n\t/**\n\t * The local bounds of the graphics object.\n\t * Returns the boundaries after all graphical operations but before any transforms.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a shape\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Get bounds information\n\t * const bounds = graphics.bounds;\n\t * console.log(bounds.width);  // 100\n\t * console.log(bounds.height); // 100\n\t * ```\n\t * @readonly\n\t * @see {@link Bounds} For bounds operations\n\t * @see {@link Container#getBounds} For transformed bounds\n\t */\n\tget bounds(): Bounds;\n\t/**\n\t * Graphics objects do not need to update their bounds as the context handles this.\n\t * @private\n\t */\n\tprotected updateBounds(): void;\n\t/**\n\t * Checks if the object contains the given point.\n\t * Returns true if the point lies within the Graphics object's rendered area.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a shape\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Check point intersection\n\t * if (graphics.containsPoint({ x: 50, y: 50 })) {\n\t *     console.log('Point is inside rectangle!');\n\t * }\n\t * ```\n\t * @param point - The point to check in local coordinates\n\t * @returns True if the point is inside the Graphics object\n\t * @see {@link Graphics#bounds} For bounding box checks\n\t * @see {@link PointData} For point data structure\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/**\n\t * Destroys this graphics renderable and optionally its context.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *\n\t * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n\t * then the context will still be destroyed.\n\t *\n\t * If you want to explicitly not destroy this context that this graphics created,\n\t * then you should pass destroy({ context: false })\n\t *\n\t * If the context was passed in as an argument to the constructor then it will not be destroyed\n\t * @example\n\t * ```ts\n\t * // Destroy the graphics and its context\n\t * graphics.destroy();\n\t * graphics.destroy(true);\n\t * graphics.destroy({ context: true, texture: true, textureSource: true });\n\t * ```\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * @param now - The current time in milliseconds.\n\t * @internal\n\t */\n\t_onTouch(now: number): void;\n\tprivate _callContextMethod;\n\t/**\n\t * Sets the current fill style of the graphics context.\n\t * The fill style can be a color, gradient, pattern, or a complex style object.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic color fill\n\t * graphics\n\t *     .setFillStyle({ color: 0xff0000 }) // Red fill\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill();\n\t *\n\t * // Gradient fill\n\t * const gradient = new FillGradient({\n\t *    end: { x: 1, y: 0 },\n\t *    colorStops: [\n\t *         { offset: 0, color: 0xff0000 }, // Red at start\n\t *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n\t *         { offset: 1, color: 0x0000ff }, // Blue at end\n\t *    ],\n\t * });\n\t *\n\t * graphics\n\t *     .setFillStyle(gradient)\n\t *     .circle(100, 100, 50)\n\t *     .fill();\n\t *\n\t * // Pattern fill\n\t * const pattern = new FillPattern(texture);\n\t * graphics\n\t *     .setFillStyle({\n\t *         fill: pattern,\n\t *         alpha: 0.5\n\t *     })\n\t *     .rect(0, 0, 200, 200)\n\t *     .fill();\n\t * ```\n\t * @param {FillInput} args - The fill style to apply\n\t * @returns The Graphics instance for chaining\n\t * @see {@link FillStyle} For fill style options\n\t * @see {@link FillGradient} For gradient fills\n\t * @see {@link FillPattern} For pattern fills\n\t */\n\tsetFillStyle(...args: Parameters<GraphicsContext[\"setFillStyle\"]>): this;\n\t/**\n\t * Sets the current stroke style of the graphics context.\n\t * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic color stroke\n\t * graphics\n\t *     .setStrokeStyle({\n\t *         width: 2,\n\t *         color: 0x000000\n\t *     })\n\t *     .rect(0, 0, 100, 100)\n\t *     .stroke();\n\t *\n\t * // Complex stroke style\n\t * graphics\n\t *     .setStrokeStyle({\n\t *         width: 4,\n\t *         color: 0xff0000,\n\t *         alpha: 0.5,\n\t *         join: 'round',\n\t *         cap: 'round',\n\t *         alignment: 0.5\n\t *     })\n\t *     .circle(100, 100, 50)\n\t *     .stroke();\n\t *\n\t * // Gradient stroke\n\t * const gradient = new FillGradient({\n\t *    end: { x: 1, y: 0 },\n\t *    colorStops: [\n\t *         { offset: 0, color: 0xff0000 }, // Red at start\n\t *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n\t *         { offset: 1, color: 0x0000ff }, // Blue at end\n\t *    ],\n\t * });\n\t *\n\t * graphics\n\t *     .setStrokeStyle({\n\t *         width: 10,\n\t *         fill: gradient\n\t *     })\n\t *     .poly([0,0, 100,50, 0,100])\n\t *     .stroke();\n\t * ```\n\t * @param {StrokeInput} args - The stroke style to apply\n\t * @returns The Graphics instance for chaining\n\t * @see {@link StrokeStyle} For stroke style options\n\t * @see {@link FillGradient} For gradient strokes\n\t * @see {@link FillPattern} For pattern strokes\n\t */\n\tsetStrokeStyle(...args: Parameters<GraphicsContext[\"setStrokeStyle\"]>): this;\n\t/**\n\t * Fills the current or given path with the current fill style or specified style.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Fill with direct color\n\t * graphics\n\t *     .circle(50, 50, 25)\n\t *     .fill('red'); // Red fill\n\t *\n\t * // Fill with texture\n\t * graphics\n\t *    .rect(0, 0, 100, 100)\n\t *    .fill(myTexture); // Fill with texture\n\t *\n\t * // Fill with complex style\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({\n\t *         color: 0x00ff00,\n\t *         alpha: 0.5,\n\t *         texture: myTexture,\n\t *         matrix: new Matrix()\n\t *     });\n\t *\n\t * // Fill with gradient\n\t * const gradient = new FillGradient({\n\t *     end: { x: 1, y: 0 },\n\t *     colorStops: [\n\t *         { offset: 0, color: 0xff0000 },\n\t *         { offset: 0.5, color: 0x00ff00 },\n\t *         { offset: 1, color: 0x0000ff },\n\t *     ],\n\t * });\n\t *\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill(gradient);\n\t * ```\n\t * @param {FillInput} style - The style to fill the path with. Can be:\n\t * - A ColorSource\n\t * - A gradient\n\t * - A pattern\n\t * - A complex style object\n\t * If omitted, uses current fill style.\n\t * @returns The Graphics instance for chaining\n\t * @see {@link FillStyle} For fill style options\n\t * @see {@link FillGradient} For gradient fills\n\t * @see {@link FillPattern} For pattern fills\n\t */\n\tfill(style?: FillInput): this;\n\t/** @deprecated 8.0.0 */\n\tfill(color: ColorSource, alpha?: number): this;\n\t/**\n\t * Strokes the current path with the current stroke style or specified style.\n\t * Outlines the shape using the stroke settings.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Stroke with direct color\n\t * graphics\n\t *     .circle(50, 50, 25)\n\t *     .stroke({\n\t *         width: 2,\n\t *         color: 0xff0000\n\t *     }); // 2px red stroke\n\t *\n\t * // Fill with texture\n\t * graphics\n\t *    .rect(0, 0, 100, 100)\n\t *    .stroke(myTexture); // Fill with texture\n\t *\n\t * // Stroke with gradient\n\t * const gradient = new FillGradient({\n\t *     end: { x: 1, y: 0 },\n\t *     colorStops: [\n\t *         { offset: 0, color: 0xff0000 },\n\t *         { offset: 0.5, color: 0x00ff00 },\n\t *         { offset: 1, color: 0x0000ff },\n\t *     ],\n\t * });\n\t *\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .stroke({\n\t *         width: 4,\n\t *         fill: gradient,\n\t *         alignment: 0.5,\n\t *         join: 'round'\n\t *     });\n\t * ```\n\t * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n\t * - A stroke style object with width, color, etc.\n\t * - A gradient\n\t * - A pattern\n\t * If omitted, uses current stroke style.\n\t * @returns The Graphics instance for chaining\n\t * @see {@link StrokeStyle} For stroke style options\n\t * @see {@link FillGradient} For gradient strokes\n\t * @see {@link setStrokeStyle} For setting default stroke style\n\t */\n\tstroke(...args: Parameters<GraphicsContext[\"stroke\"]>): this;\n\t/**\n\t * Adds a texture to the graphics context. This method supports multiple ways to draw textures\n\t * including basic textures, tinted textures, and textures with custom dimensions.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic texture drawing\n\t * graphics.texture(myTexture);\n\t *\n\t * // Tinted texture with position\n\t * graphics.texture(myTexture, 0xff0000); // Red tint\n\t *\n\t * // Texture with custom position and dimensions\n\t * graphics\n\t *     .texture(\n\t *         myTexture,    // texture\n\t *         0xffffff,     // white tint\n\t *         100, 100,     // position\n\t *         200, 150      // dimensions\n\t *     );\n\t * ```\n\t * Basic texture drawing:\n\t * @param texture - The Texture object to use.\n\t * @returns The instance of the current Graphics for chaining.\n\t *\n\t * Extended texture drawing:\n\t * @param texture - The Texture object to use.\n\t *        tint - A ColorSource to tint the texture (defaults to white).\n\t *        dx - The x-coordinate for the texture placement.\n\t *        dy - The y-coordinate for the texture placement.\n\t *        dw - The width to draw the texture (defaults to texture width).\n\t *        dh - The height to draw the texture (defaults to texture height).\n\t * @returns The instance of the current Graphics for chaining.\n\t * @see {@link Texture} For texture creation\n\t * @see {@link FillPattern} For pattern fills\n\t */\n\ttexture(texture: Texture): this;\n\ttexture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n\t/**\n\t * Resets the current path. Any previous path and its commands are discarded and a new path is\n\t * started. This is typically called before beginning a new shape or series of drawing commands.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .circle(150, 150, 50)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .beginPath() // Starts a new path\n\t *     .circle(250, 150, 50)\n\t *     .fill({ color: 0x0000ff });\n\t * ```\n\t * @returns The Graphics instance for chaining\n\t * @see {@link Graphics#moveTo} For starting a new subpath\n\t * @see {@link Graphics#closePath} For closing the current path\n\t */\n\tbeginPath(): this;\n\t/**\n\t * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n\t * subtracting a path from the previously drawn path.\n\t *\n\t * If a hole is not completely in a shape, it will fail to cut correctly.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw outer circle\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *     .circle(100, 100, 25) // Inner circle\n\t *     .cut() // Cuts out the inner circle from the outer circle\n\t * ```\n\t */\n\tcut(): this;\n\t/**\n\t * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n\t * starting and ending angles, and direction.\n\t * @example\n\t * ```ts\n\t * // Draw a simple arc (quarter circle)\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .arc(100, 100, 50, 0, Math.PI/2)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Draw a full circle using an arc\n\t * graphics\n\t *     .arc(200, 200, 30, 0, Math.PI * 2)\n\t *     .stroke({ color: 0x00ff00 });\n\t *\n\t * // Draw a counterclockwise arc\n\t * graphics\n\t *     .arc(150, 150, 40, Math.PI, 0, true)\n\t *     .stroke({ width: 2, color: 0x0000ff });\n\t * ```\n\t * @param x - The x-coordinate of the arc's center\n\t * @param y - The y-coordinate of the arc's center\n\t * @param radius - The arc's radius (must be positive)\n\t * @param startAngle - The starting point of the arc, in radians\n\t * @param endAngle - The end point of the arc, in radians\n\t * @param counterclockwise - Optional. If true, draws the arc counterclockwise.\n\t *                          If false (default), draws clockwise.\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#circle} For drawing complete circles\n\t * @see {@link Graphics#arcTo} For drawing arcs between points\n\t * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n\t */\n\tarc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n\t/**\n\t * Adds an arc to the current path that connects two points using a radius.\n\t * The arc is drawn between the current point and the specified end point,\n\t * using the given control point to determine the curve of the arc.\n\t * @example\n\t * ```ts\n\t * // Draw a simple curved corner\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .arcTo(100, 50, 100, 100, 20) // Rounded corner with 20px radius\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Create a rounded rectangle using arcTo\n\t * graphics\n\t *     .moveTo(150, 150)\n\t *     .arcTo(250, 150, 250, 250, 30) // Top right corner\n\t *     .arcTo(250, 250, 150, 250, 30) // Bottom right corner\n\t *     .arcTo(150, 250, 150, 150, 30) // Bottom left corner\n\t *     .arcTo(150, 150, 250, 150, 30) // Top left corner\n\t *     .fill({ color: 0x00ff00 });\n\t * ```\n\t * @param x1 - The x-coordinate of the control point\n\t * @param y1 - The y-coordinate of the control point\n\t * @param x2 - The x-coordinate of the end point\n\t * @param y2 - The y-coordinate of the end point\n\t * @param radius - The radius of the arc in pixels (must be positive)\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#arc} For drawing arcs using center point and angles\n\t * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n\t * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n\t */\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n\t/**\n\t * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n\t * This is particularly useful when converting SVG paths to Graphics or creating complex curved shapes.\n\t * @example\n\t * ```ts\n\t * // Draw a simple elliptical arc\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(100, 100)\n\t *     .arcToSvg(50, 30, 0, 0, 1, 200, 100)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Create a complex path with rotated elliptical arc\n\t * graphics\n\t *     .moveTo(150, 150)\n\t *     .arcToSvg(\n\t *         60,    // rx\n\t *         30,    // ry\n\t *         45,    // x-axis rotation (45 degrees)\n\t *         1,     // large arc flag\n\t *         0,     // sweep flag\n\t *         250,   // end x\n\t *         200    // end y\n\t *     )\n\t *     .stroke({ width: 4, color: 0x00ff00 });\n\t *\n\t * // Chain multiple arcs for complex shapes\n\t * graphics\n\t *     .moveTo(300, 100)\n\t *     .arcToSvg(40, 20, 0, 0, 1, 350, 150)\n\t *     .arcToSvg(40, 20, 0, 0, 1, 300, 200)\n\t *     .fill({ color: 0x0000ff, alpha: 0.5 });\n\t * ```\n\t * @param rx - The x-radius of the ellipse (must be non-negative)\n\t * @param ry - The y-radius of the ellipse (must be non-negative)\n\t * @param xAxisRotation - The rotation of the ellipse's x-axis relative to the x-axis, in degrees\n\t * @param largeArcFlag - Either 0 or 1, determines if the larger of the two possible arcs is chosen (1) or not (0)\n\t * @param sweepFlag - Either 0 or 1, determines if the arc should be swept in\n\t *                    a positive angle direction (1) or negative (0)\n\t * @param x - The x-coordinate of the arc's end point\n\t * @param y - The y-coordinate of the arc's end point\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#arc} For simple circular arcs\n\t * @see {@link Graphics#arcTo} For connecting points with circular arcs\n\t * @see {@link Graphics#svg} For parsing complete SVG paths\n\t */\n\tarcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n\t/**\n\t * Adds a cubic Bzier curve to the path, from the current point to the specified end point.\n\t * The curve is influenced by two control points that define its shape and curvature.\n\t * @example\n\t * ```ts\n\t * // Draw a simple curved line\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .bezierCurveTo(\n\t *         100, 25,   // First control point\n\t *         150, 75,   // Second control point\n\t *         200, 50    // End point\n\t *     )\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Adjust curve smoothness\n\t * graphics\n\t *     .moveTo(50, 200)\n\t *     .bezierCurveTo(\n\t *         100, 150,\n\t *         200, 250,\n\t *         250, 200,\n\t *         0.5         // Smoothness factor\n\t *     )\n\t *     .stroke({ width: 4, color: 0x0000ff });\n\t * ```\n\t * @param cp1x - The x-coordinate of the first control point\n\t * @param cp1y - The y-coordinate of the first control point\n\t * @param cp2x - The x-coordinate of the second control point\n\t * @param cp2y - The y-coordinate of the second control point\n\t * @param x - The x-coordinate of the end point\n\t * @param y - The y-coordinate of the end point\n\t * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#quadraticCurveTo} For simpler curves with one control point\n\t * @see {@link Graphics#arc} For circular arcs\n\t * @see {@link Graphics#arcTo} For connecting points with circular arcs\n\t */\n\tbezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Closes the current path by drawing a straight line back to the start point.\n\t *\n\t * This is useful for completing shapes and ensuring they are properly closed for fills.\n\t * @example\n\t * ```ts\n\t * // Create a triangle with closed path\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(100, 100)\n\t *     .lineTo(0, 100)\n\t *     .closePath()\n\t * ```\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#beginPath} For starting a new path\n\t * @see {@link Graphics#fill} For filling closed paths\n\t * @see {@link Graphics#stroke} For stroking paths\n\t */\n\tclosePath(): this;\n\t/**\n\t * Draws an ellipse at the specified location and with the given x and y radii.\n\t * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic ellipse\n\t * graphics\n\t *     .ellipse(100, 100, 50, 30)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw an ellipse with stroke\n\t * graphics\n\t *     .ellipse(200, 100, 70, 40)\n\t *     .stroke({ width: 2, color: 0x00ff00 });\n\t * ```\n\t * @param x - The x-coordinate of the center of the ellipse\n\t * @param y - The y-coordinate of the center of the ellipse\n\t * @param radiusX - The horizontal radius of the ellipse\n\t * @param radiusY - The vertical radius of the ellipse\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#circle} For drawing perfect circles\n\t * @see {@link Graphics#arc} For drawing partial circular arcs\n\t */\n\tellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n\t/**\n\t * Draws a circle shape at the specified location with the given radius.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple filled circle\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a circle with gradient fill\n\t * const gradient = new FillGradient({\n\t *     end: { x: 1, y: 0 },\n\t *     colorStops: [\n\t *           { offset: 0, color: 0xff0000 }, // Red at start\n\t *           { offset: 0.5, color: 0x00ff00 }, // Green at middle\n\t *           { offset: 1, color: 0x0000ff }, // Blue at end\n\t *     ],\n\t * });\n\t *\n\t * graphics\n\t *     .circle(250, 100, 40)\n\t *     .fill({ fill: gradient });\n\t * ```\n\t * @param x - The x-coordinate of the center of the circle\n\t * @param y - The y-coordinate of the center of the circle\n\t * @param radius - The radius of the circle\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#ellipse} For drawing ellipses\n\t * @see {@link Graphics#arc} For drawing partial circles\n\t */\n\tcircle(x: number, y: number, radius: number): this;\n\t/**\n\t * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n\t * This allows for reuse of complex paths and shapes across different graphics instances.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t * // Create a reusable path\n\t * const heartPath = new GraphicsPath()\n\t *     .moveTo(0, 0)\n\t *     .bezierCurveTo(-50, -25, -50, -75, 0, -100)\n\t *     .bezierCurveTo(50, -75, 50, -25, 0, 0);\n\t *\n\t * // Use the path multiple times\n\t * graphics\n\t *     .path(heartPath)\n\t *     .fill({ color: 0xff0000 })\n\t *     .translateTransform(200, 200)\n\t *     .path(heartPath)\n\t *     .fill({ color: 0xff0000, alpha: 0.5 });\n\t * ```\n\t * @param path - The `GraphicsPath` to add to the current path\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link GraphicsPath} For creating reusable paths\n\t * @see {@link Matrix} For creating transformations\n\t * @see {@link Graphics#transform} For applying transformations\n\t */\n\tpath(path: GraphicsPath): this;\n\t/**\n\t * Connects the current point to a new point with a straight line.\n\t * Any subsequent drawing commands will start from this new point.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a triangle\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(100, 100)\n\t *     .lineTo(0, 100)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Create a complex shape with multiple lines\n\t * graphics\n\t *     .moveTo(200, 50)\n\t *     .lineTo(250, 50)\n\t *     .lineTo(250, 100)\n\t *     .lineTo(200, 100)\n\t *     .stroke({ width: 2, color: 0x00ff00 });\n\t * ```\n\t * @param x - The x-coordinate of the line's end point\n\t * @param y - The y-coordinate of the line's end point\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#moveTo} For starting a new sub-path\n\t */\n\tlineTo(x: number, y: number): this;\n\t/**\n\t * Sets the starting point for a new sub-path.\n\t *\n\t * Moves the \"pen\" to a new location without drawing a line.\n\t * Any subsequent drawing commands will start from this point.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Create multiple separate lines\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(100, 50)\n\t *     .moveTo(50, 100)    // Start a new line\n\t *     .lineTo(100, 100)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Create disconnected shapes\n\t * graphics\n\t *     .moveTo(150, 50)\n\t *     .rect(150, 50, 50, 50)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .moveTo(250, 50)    // Start a new shape\n\t *     .circle(250, 75, 25)\n\t *     .fill({ color: 0x0000ff });\n\t *\n\t * // Position before curved paths\n\t * graphics\n\t *     .moveTo(300, 50)\n\t *     .bezierCurveTo(\n\t *         350, 25,   // Control point 1\n\t *         400, 75,   // Control point 2\n\t *         450, 50    // End point\n\t *     )\n\t *     .stroke({ width: 3, color: 0xff00ff });\n\t * ```\n\t * @param x - The x-coordinate to move to\n\t * @param y - The y-coordinate to move to\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#lineTo} For drawing lines\n\t * @see {@link Graphics#beginPath} For starting a completely new path\n\t */\n\tmoveTo(x: number, y: number): this;\n\t/**\n\t * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n\t * The starting point is the last point in the current path.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple curve\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .quadraticCurveTo(100, 25, 150, 50)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Adjust curve smoothness\n\t * graphics\n\t *     .moveTo(50, 200)\n\t *     .quadraticCurveTo(\n\t *         150, 150,   // Control point\n\t *         250, 200,   // End point\n\t *         0.5         // Smoothness factor\n\t *     )\n\t *     .stroke({\n\t *         width: 4,\n\t *         color: 0x0000ff,\n\t *         alpha: 0.7\n\t *     });\n\t * ```\n\t * @param cpx - The x-coordinate of the control point\n\t * @param cpy - The y-coordinate of the control point\n\t * @param x - The x-coordinate of the end point\n\t * @param y - The y-coordinate of the end point\n\t * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#bezierCurveTo} For curves with two control points\n\t * @see {@link Graphics#arc} For circular arcs\n\t * @see {@link Graphics#arcTo} For connecting points with circular arcs\n\t */\n\tquadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Draws a rectangle shape.\n\t *\n\t * This method adds a new rectangle path to the current drawing.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple filled rectangle\n\t * graphics\n\t *     .rect(50, 50, 100, 75)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Rectangle with stroke\n\t * graphics\n\t *     .rect(200, 50, 100, 75)\n\t *     .stroke({ width: 2, color: 0x00ff00 });\n\t * ```\n\t * @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param w - The width of the rectangle\n\t * @param h - The height of the rectangle\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n\t * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n\t * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n\t */\n\trect(x: number, y: number, w: number, h: number): this;\n\t/**\n\t * Draws a rectangle with rounded corners. The corner radius can be specified to\n\t * determine how rounded the corners should be.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic rounded rectangle\n\t * graphics\n\t *     .roundRect(50, 50, 100, 75, 15)\n\t *     .fill({ color: 0xff0000 });\n\t * ```\n\t * @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param w - The width of the rectangle\n\t * @param h - The height of the rectangle\n\t * @param radius - The radius of the rectangle's corners (must be non-negative)\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#rect} For drawing rectangles with sharp corners\n\t * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n\t * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n\t */\n\troundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n\t/**\n\t * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n\t * which can be both open and closed.\n\t *\n\t * An optional transformation can be applied, enabling the polygon to be scaled,\n\t * rotated, or translated as needed.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a triangle using array of numbers [x1,y1, x2,y2, x3,y3]\n\t * graphics\n\t *     .poly([50,50, 100,100, 0,100], true)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a polygon using point objects\n\t * graphics\n\t *     .poly([\n\t *         { x: 200, y: 50 },\n\t *         { x: 250, y: 100 },\n\t *         { x: 200, y: 150 },\n\t *         { x: 150, y: 100 }\n\t *     ])\n\t *     .fill({ color: 0x00ff00 });\n\t *\n\t * // Draw an open polygon with stroke\n\t * graphics\n\t *     .poly([300,50, 350,50, 350,100, 300,100], false)\n\t *     .stroke({\n\t *         width: 2,\n\t *         color: 0x0000ff,\n\t *         join: 'round'\n\t *     });\n\t * ```\n\t * @param points - An array of numbers [x1,y1, x2,y2, ...] or an array of point objects [{x,y}, ...]\n\t *                representing the vertices of the polygon in sequence\n\t * @param close - Whether to close the polygon path by connecting the last point to the first.\n\t *               Default is true.\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#regularPoly} For drawing regular polygons\n\t * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n\t * @see {@link Graphics#star} For drawing star shapes\n\t */\n\tpoly(points: number[] | PointData[], close?: boolean): this;\n\t/**\n\t * Draws a regular polygon with a specified number of sides. All sides and angles are equal,\n\t * making shapes like triangles, squares, pentagons, etc.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple triangle (3 sides)\n\t * graphics\n\t *     .regularPoly(100, 100, 50, 3)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a hexagon (6 sides) with rotation\n\t * graphics\n\t *     .regularPoly(\n\t *         250, 100,    // center position\n\t *         40,          // radius\n\t *         6,           // sides\n\t *         Math.PI / 6  // rotation (30 degrees)\n\t *     )\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t *\n\t * // Draw an octagon (8 sides) with transform\n\t * const transform = new Matrix()\n\t *     .scale(1.5, 1)      // stretch horizontally\n\t *     .rotate(Math.PI/4); // rotate 45 degrees\n\t *\n\t * graphics\n\t *     .regularPoly(400, 100, 30, 8, 0, transform)\n\t *     .fill({ color: 0x0000ff, alpha: 0.5 });\n\t * ```\n\t * @param x - The x-coordinate of the center of the polygon\n\t * @param y - The y-coordinate of the center of the polygon\n\t * @param radius - The radius of the circumscribed circle of the polygon\n\t * @param sides - The number of sides of the polygon (must be 3 or more)\n\t * @param rotation - The rotation angle of the polygon in radians (default: 0)\n\t * @param transform - Optional Matrix to transform the polygon's shape\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#poly} For drawing custom polygons\n\t * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n\t * @see {@link Graphics#star} For drawing star shapes\n\t */\n\tregularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon with rounded corners.\n\t *\n\t * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic rounded triangle\n\t * graphics\n\t *     .roundPoly(100, 100, 50, 3, 10)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a rounded hexagon with rotation\n\t * graphics\n\t *     .roundPoly(\n\t *         250, 150,     // center position\n\t *         40,           // radius\n\t *         6,            // sides\n\t *         8,            // corner radius\n\t *         Math.PI / 6   // rotation (30 degrees)\n\t *     )\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ```\n\t * @param x - The x-coordinate of the center of the polygon\n\t * @param y - The y-coordinate of the center of the polygon\n\t * @param radius - The radius of the circumscribed circle of the polygon\n\t * @param sides - The number of sides of the polygon (must be 3 or more)\n\t * @param corner - The radius of the corner rounding (must be non-negative)\n\t * @param rotation - The rotation angle of the polygon in radians (default: 0)\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#regularPoly} For drawing polygons without rounded corners\n\t * @see {@link Graphics#poly} For drawing custom polygons\n\t * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n\t */\n\troundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n\t/**\n\t * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n\t * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a custom shape with rounded corners\n\t * graphics\n\t *     .roundShape([\n\t *         { x: 100, y: 100, radius: 20 },\n\t *         { x: 200, y: 100, radius: 10 },\n\t *         { x: 200, y: 200, radius: 15 },\n\t *         { x: 100, y: 200, radius: 5 }\n\t *     ], 10)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Using quadratic curves for corners\n\t * graphics\n\t *     .roundShape([\n\t *         { x: 250, y: 100 },\n\t *         { x: 350, y: 100 },\n\t *         { x: 350, y: 200 },\n\t *         { x: 250, y: 200 }\n\t *     ], 15, true, 0.5)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t *\n\t * // Shape with varying corner radii\n\t * graphics\n\t *     .roundShape([\n\t *         { x: 400, y: 100, radius: 30 },\n\t *         { x: 500, y: 100, radius: 5 },\n\t *         { x: 450, y: 200, radius: 15 }\n\t *     ], 10)\n\t *     .fill({ color: 0x0000ff, alpha: 0.5 });\n\t * ```\n\t * @param points - An array of `RoundedPoint` representing the corners of the shape.\n\t *                Each point can have its own radius or use the default.\n\t *                A minimum of 3 points is required.\n\t * @param radius - The default radius for corners without a specific radius defined.\n\t *                Applied to any point that doesn't specify its own radius.\n\t * @param useQuadratic - When true, corners are drawn using quadratic curves instead\n\t *                      of arcs, creating a different visual style. Defaults to false.\n\t * @param smoothness - Controls the smoothness of quadratic corners when useQuadratic\n\t *                    is true. Values range from 0-1, higher values create smoother curves.\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n\t * @see {@link Graphics#roundPoly} For drawing regular polygons with rounded corners\n\t */\n\troundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n\t/**\n\t * Draws a rectangle with fillet corners. Unlike rounded rectangles, this supports negative corner\n\t * radii which create external rounded corners rather than internal ones.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a rectangle with internal fillets\n\t * graphics\n\t *     .filletRect(50, 50, 100, 80, 15)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a rectangle with external fillets\n\t * graphics\n\t *     .filletRect(200, 50, 100, 80, -20)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ```\n\t * @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param width - The width of the rectangle\n\t * @param height - The height of the rectangle\n\t * @param fillet - The radius of the corner fillets (can be positive or negative)\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#roundRect} For standard rounded corners\n\t * @see {@link Graphics#chamferRect} For angled corners\n\t */\n\tfilletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n\t/**\n\t * Draws a rectangle with chamfered (angled) corners. Each corner is cut off at\n\t * a 45-degree angle based on the chamfer size.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic chamfered rectangle\n\t * graphics\n\t *     .chamferRect(50, 50, 100, 80, 15)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Add transform and stroke\n\t * const transform = new Matrix()\n\t *     .rotate(Math.PI / 4); // 45 degrees\n\t *\n\t * graphics\n\t *     .chamferRect(200, 50, 100, 80, 20, transform)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ```\n\t * @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param width - The width of the rectangle\n\t * @param height - The height of the rectangle\n\t * @param chamfer - The size of the corner chamfers (must be non-zero)\n\t * @param transform - Optional Matrix to transform the rectangle\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#roundRect} For rounded corners\n\t * @see {@link Graphics#filletRect} For rounded corners with negative radius support\n\t */\n\tchamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n\t/**\n\t * Draws a star shape centered at a specified location. This method allows for the creation\n\t * of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n\t *\n\t * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n\t * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic 5-pointed star\n\t * graphics\n\t *     .star(100, 100, 5, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Star with custom inner radius\n\t * graphics\n\t *     .star(250, 100, 6, 50, 20)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ```\n\t * @param x - The x-coordinate of the center of the star\n\t * @param y - The y-coordinate of the center of the star\n\t * @param points - The number of points on the star (must be >= 3)\n\t * @param radius - The outer radius of the star (distance from center to point tips)\n\t * @param innerRadius - Optional. The inner radius of the star (distance from center to inner vertices).\n\t *                     If not specified, defaults to half of the outer radius\n\t * @param rotation - Optional. The rotation of the star in radians. Default is 0,\n\t *                  which aligns one point straight up\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#regularPoly} For drawing regular polygons\n\t * @see {@link Graphics#poly} For drawing custom polygons\n\t * @see {@link Graphics#path} For creating custom shapes\n\t */\n\tstar(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n\t/**\n\t * Parses and renders an SVG string into the graphics context. This allows for complex shapes\n\t * and paths defined in SVG format to be drawn within the graphics context.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .svg(`\n\t *         <path d=\"M 50,50 L 100,50 L 100,100 L 50,100 Z\"\n\t *               fill=\"blue\" />\n\t *         <circle cx=\"150\" cy=\"75\" r=\"25\"\n\t *               fill=\"green\" />\n\t *     `)\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ```\n\t * @param svg - The SVG string to be parsed and rendered\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#path} For adding custom paths\n\t * @see {@link Graphics#fill} For filling shapes after SVG parsing\n\t * @see {@link Graphics#stroke} For stroking shapes after SVG parsing\n\t */\n\tsvg(svg: string): this;\n\t/**\n\t * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n\t * This includes transformations, fill styles, and stroke styles.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Save current state\n\t * graphics.save();\n\t *\n\t * // Make temporary changes\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .setFillStyle({ color: 0xff0000 })\n\t *     .circle(0, 0, 50)\n\t *     .fill();\n\t *\n\t * // Restore to previous state\n\t * graphics.restore();\n\t *\n\t * // Draw with original transform and styles\n\t * graphics\n\t *     .circle(50, 50, 30)\n\t *     .fill();\n\t * ```\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#save} For saving the current state\n\t */\n\trestore(): this;\n\t/**\n\t * Saves the current graphics state onto a stack. The state includes:\n\t * - Current transformation matrix\n\t * - Current fill style\n\t * - Current stroke style\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Save state before complex operations\n\t * graphics.save();\n\t *\n\t * // Create transformed and styled shape\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .rotateTransform(Math.PI / 4)\n\t *     .setFillStyle({\n\t *         color: 0xff0000,\n\t *         alpha: 0.5\n\t *     })\n\t *     .rect(-25, -25, 50, 50)\n\t *     .fill();\n\t *\n\t * // Restore to original state\n\t * graphics.restore();\n\t *\n\t * // Continue drawing with previous state\n\t * graphics\n\t *     .circle(50, 50, 25)\n\t *     .fill();\n\t * ```\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#restore} For restoring the saved state\n\t * @see {@link Graphics#setTransform} For setting transformations\n\t */\n\tsave(): this;\n\t/**\n\t * Returns the current transformation matrix of the graphics context.\n\t * This matrix represents all accumulated transformations including translate, scale, and rotate.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Apply some transformations\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .rotateTransform(Math.PI / 4);\n\t *\n\t * // Get the current transform matrix\n\t * const matrix = graphics.getTransform();\n\t * console.log(matrix.tx, matrix.ty); // 100, 100\n\t *\n\t * // Use the matrix for other operations\n\t * graphics\n\t *     .setTransform(matrix)\n\t *     .circle(0, 0, 50)\n\t *     .fill({ color: 0xff0000 });\n\t * ```\n\t * @returns The current transformation matrix.\n\t * @see {@link Graphics#setTransform} For setting the transform matrix\n\t * @see {@link Matrix} For matrix operations\n\t */\n\tgetTransform(): Matrix;\n\t/**\n\t * Resets the current transformation matrix to the identity matrix, effectively removing\n\t * any transformations (rotation, scaling, translation) previously applied.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Apply transformations\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .scaleTransform(2, 2)\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0xff0000 });\n\t * // Reset transform to default state\n\t * graphics\n\t *     .resetTransform()\n\t *     .circle(50, 50, 25) // Will draw at actual coordinates\n\t *     .fill({ color: 0x00ff00 });\n\t * ```\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#getTransform} For getting the current transform\n\t * @see {@link Graphics#setTransform} For setting a specific transform\n\t * @see {@link Graphics#save} For saving the current transform state\n\t * @see {@link Graphics#restore} For restoring a previous transform state\n\t */\n\tresetTransform(): this;\n\t/**\n\t * Applies a rotation transformation to the graphics context around the current origin.\n\t * Positive angles rotate clockwise, while negative angles rotate counterclockwise.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Rotate 45 degrees clockwise\n\t * graphics\n\t *     .rotateTransform(Math.PI / 4)\n\t *     .rect(-25, -25, 50, 50)\n\t *     .fill({ color: 0xff0000 });\n\t * ```\n\t * @param angle - The angle of rotation in radians\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#scaleTransform} For scaling transformations\n\t * @see {@link Graphics#translateTransform} For position transformations\n\t */\n\trotateTransform(angle: number): this;\n\t/**\n\t * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally\n\t * and by y vertically relative to the current origin.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Uniform scaling\n\t * graphics\n\t *     .scaleTransform(2)  // Scale both dimensions by 2\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Non-uniform scaling\n\t * graphics\n\t *     .scaleTransform(0.5, 2)  // Half width, double height\n\t *     .rect(100, 100, 50, 50)\n\t *     .fill({ color: 0x00ff00 });\n\t * ```\n\t * @param x - The scale factor in the horizontal direction\n\t * @param y - The scale factor in the vertical direction. If omitted, equals x\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#rotateTransform} For rotation transformations\n\t * @see {@link Graphics#translateTransform} For position transformations\n\t */\n\tscaleTransform(x: number, y?: number): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context.\n\t *\n\t * This method can either\n\t * take a Matrix object or individual transform values to create a new transformation matrix.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Using a Matrix object\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4);\n\t *\n\t * graphics\n\t *     .setTransform(matrix)\n\t *     .rect(0, 0, 50, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Using individual transform values\n\t * graphics\n\t *     .setTransform(\n\t *         2, 0,     // scale x by 2\n\t *         0, 1,     // no skew\n\t *         100, 100  // translate x,y by 100\n\t *     )\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0x00ff00 });\n\t * ```\n\t * @param transform - The matrix to set as the current transformation matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(transform: Matrix): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n\t * This replaces the current transformation matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\tsetTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n\t/**\n\t * Applies a transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix. This allows for complex transformations\n\t * combining multiple operations.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Using a Matrix object\n\t * const matrix = new Matrix()\n\t *     .scale(2, 1)      // Scale horizontally\n\t *     .rotate(Math.PI/6); // Rotate 30 degrees\n\t *\n\t * graphics\n\t *     .transform(matrix)\n\t *     .rect(0, 0, 50, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Using individual transform values\n\t * graphics\n\t *     .transform(\n\t *         1, 0.5,    // Skew horizontally\n\t *         0, 1,      // No vertical skew\n\t *         100, 100   // Translate\n\t *     )\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0x00ff00 });\n\t * ```\n\t * @param transform - The matrix to apply to the current transformation.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(transform: Matrix): this;\n\t/**\n\t * Applies the specified transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\ttransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n\t/**\n\t * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n\t * This affects all subsequent drawing operations.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic translation\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0xff0000 });\n\t * ```\n\t * @param x - The amount to translate in the horizontal direction\n\t * @param y - The amount to translate in the vertical direction. If omitted, equals x\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#setTransform} For setting absolute transformations\n\t * @see {@link Graphics#transform} For applying complex transformations\n\t * @see {@link Graphics#save} For saving the current transform state\n\t */\n\ttranslateTransform(x: number, y?: number): this;\n\t/**\n\t * Clears all drawing commands from the graphics context, effectively resetting it.\n\t * This includes clearing the current path, fill style, stroke style, and transformations.\n\t *\n\t * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n\t * > Instead, they are intended to be used for static or semi-static graphics that\n\t * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw some shapes\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 })\n\t *     .rect(200, 100, 100, 50)\n\t *     .fill({ color: 0x00ff00 });\n\t *\n\t * // Clear all graphics\n\t * graphics.clear();\n\t *\n\t * // Start fresh with new shapes\n\t * graphics\n\t *     .circle(150, 150, 30)\n\t *     .fill({ color: 0x0000ff });\n\t * ```\n\t * @returns The Graphics instance for method chaining\n\t * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n\t * @see {@link Graphics#save} For saving the current state\n\t * @see {@link Graphics#restore} For restoring a previous state\n\t */\n\tclear(): this;\n\t/**\n\t * Gets or sets the current fill style for the graphics context. The fill style determines\n\t * how shapes are filled when using the fill() method.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic color fill\n\t * graphics.fillStyle = {\n\t *     color: 0xff0000,  // Red\n\t *     alpha: 1\n\t * };\n\t *\n\t * // Using gradients\n\t * const gradient = new FillGradient({\n\t *     end: { x: 0, y: 1 }, // Vertical gradient\n\t *     stops: [\n\t *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n\t *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n\t *     ]\n\t * });\n\t *\n\t * graphics.fillStyle = {\n\t *     fill: gradient,\n\t *     alpha: 0.8\n\t * };\n\t *\n\t * // Using patterns\n\t * graphics.fillStyle = {\n\t *     texture: myTexture,\n\t *     alpha: 1,\n\t *     matrix: new Matrix()\n\t *         .scale(0.5, 0.5)\n\t *         .rotate(Math.PI / 4)\n\t * };\n\t * ```\n\t * @type {ConvertedFillStyle}\n\t * @see {@link FillStyle} For all available fill style options\n\t * @see {@link FillGradient} For creating gradient fills\n\t * @see {@link Graphics#fill} For applying the fill to paths\n\t */\n\tget fillStyle(): GraphicsContext[\"fillStyle\"];\n\tset fillStyle(value: FillInput);\n\t/**\n\t * Gets or sets the current stroke style for the graphics context. The stroke style determines\n\t * how paths are outlined when using the stroke() method.\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic stroke style\n\t * graphics.strokeStyle = {\n\t *     width: 2,\n\t *     color: 0xff0000,\n\t *     alpha: 1\n\t * };\n\t *\n\t * // Using with gradients\n\t * const gradient = new FillGradient({\n\t *   end: { x: 0, y: 1 },\n\t *   stops: [\n\t *       { offset: 0, color: 0xff0000, alpha: 1 },\n\t *       { offset: 1, color: 0x0000ff, alpha: 1 }\n\t *   ]\n\t * });\n\t *\n\t * graphics.strokeStyle = {\n\t *     width: 4,\n\t *     fill: gradient,\n\t *     alignment: 0.5,\n\t *     join: 'round',\n\t *     cap: 'round'\n\t * };\n\t *\n\t * // Complex stroke settings\n\t * graphics.strokeStyle = {\n\t *     width: 6,\n\t *     color: 0x00ff00,\n\t *     alpha: 0.5,\n\t *     join: 'miter',\n\t *     miterLimit: 10,\n\t * };\n\t * ```\n\t * @see {@link StrokeStyle} For all available stroke style options\n\t * @see {@link Graphics#stroke} For applying the stroke to paths\n\t */\n\tget strokeStyle(): GraphicsContext[\"strokeStyle\"];\n\tset strokeStyle(value: StrokeStyle);\n\t/**\n\t * Creates a new Graphics object that copies the current graphics content.\n\t * The clone can either share the same context (shallow clone) or have its own independent\n\t * context (deep clone).\n\t * @example\n\t * ```ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Create original graphics content\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Create a shallow clone (shared context)\n\t * const shallowClone = graphics.clone();\n\t *\n\t * // Changes to original affect the clone\n\t * graphics\n\t *     .circle(200, 100, 30)\n\t *     .fill({ color: 0x00ff00 });\n\t *\n\t * // Create a deep clone (independent context)\n\t * const deepClone = graphics.clone(true);\n\t *\n\t * // Modify deep clone independently\n\t * deepClone\n\t *     .translateTransform(100, 100)\n\t *     .circle(0, 0, 40)\n\t *     .fill({ color: 0x0000ff });\n\t * ```\n\t * @param deep - Whether to create a deep clone of the graphics object.\n\t *              If false (default), the context will be shared between objects.\n\t *              If true, creates an independent copy of the context.\n\t * @returns A new Graphics instance with either shared or copied context\n\t * @see {@link Graphics#context} For accessing the underlying graphics context\n\t * @see {@link GraphicsContext} For understanding the shared context behavior\n\t */\n\tclone(deep?: boolean): Graphics;\n\t/**\n\t * @param width\n\t * @param color\n\t * @param alpha\n\t * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n\t */\n\tlineStyle(width?: number, color?: ColorSource, alpha?: number): this;\n\t/**\n\t * @param color\n\t * @param alpha\n\t * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n\t */\n\tbeginFill(color: ColorSource, alpha?: number): this;\n\t/**\n\t * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n\t */\n\tendFill(): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n\t */\n\tdrawCircle(...args: Parameters<GraphicsContext[\"circle\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n\t */\n\tdrawEllipse(...args: Parameters<GraphicsContext[\"ellipse\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n\t */\n\tdrawPolygon(...args: Parameters<GraphicsContext[\"poly\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n\t */\n\tdrawRect(...args: Parameters<GraphicsContext[\"rect\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n\t */\n\tdrawRoundedRect(...args: Parameters<GraphicsContext[\"roundRect\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n\t */\n\tdrawStar(...args: Parameters<GraphicsContext[\"star\"]>): this;\n}\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements DefaultBatchableMeshElement {\n\treadonly packAsQuad = false;\n\tbatcherName: string;\n\ttexture: Texture;\n\ttopology: Topology;\n\trenderable: Graphics;\n\tindexOffset: number;\n\tindexSize: number;\n\tattributeOffset: number;\n\tattributeSize: number;\n\tbaseColor: number;\n\talpha: number;\n\tapplyTransform: boolean;\n\troundPixels: 0 | 1;\n\t_indexStart: number;\n\t_textureId: number;\n\t_attributeStart: number;\n\t_batcher: Batcher;\n\t_batch: Batch;\n\tgeometryData: {\n\t\tvertices: number[];\n\t\tuvs: number[];\n\t\tindices: number[];\n\t};\n\tget uvs(): number[];\n\tget positions(): number[];\n\tget indices(): number[];\n\tget blendMode(): BLEND_MODES;\n\tget color(): number;\n\tget transform(): Matrix;\n\tcopyTo(gpuBuffer: BatchableGraphics): void;\n\treset(): void;\n\tdestroy(): void;\n}\ninterface GeometryData {\n\tvertices: number[];\n\tuvs: number[];\n\tindices: number[];\n}\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsContext implements GPUData {\n\tisBatchable: boolean;\n\tcontext: GraphicsContext;\n\tbatches: BatchableGraphics[];\n\tgeometryData: GeometryData;\n\tgraphicsData: GraphicsContextRenderData;\n\treset(): void;\n\tdestroy(): void;\n}\n/**\n * A class that holds the render data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GraphicsContextRenderData {\n\tbatcher: DefaultBatcher;\n\tinstructions: InstructionSet;\n\tinit(options: BatcherOptions): void;\n\t/**\n\t * @deprecated since version 8.0.0\n\t * Use `batcher.geometry` instead.\n\t * @see {Batcher#geometry}\n\t */\n\tget geometry(): BatchGeometry;\n\tdestroy(): void;\n}\n/**\n * Options for the GraphicsContextSystem.\n * @category rendering\n * @advanced\n */\nexport interface GraphicsContextSystemOptions {\n\t/** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n\tbezierSmoothness?: number;\n}\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @category rendering\n * @advanced\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"graphicsContext\";\n\t};\n\t/** The default options for the GraphicsContextSystem. */\n\tstatic readonly defaultOptions: GraphicsContextSystemOptions;\n\tprivate readonly _renderer;\n\tprivate readonly _managedContexts;\n\tconstructor(renderer: Renderer);\n\t/**\n\t * Runner init called, update the default options\n\t * @ignore\n\t */\n\tinit(options?: GraphicsContextSystemOptions): void;\n\t/**\n\t * Returns the render data for a given GraphicsContext.\n\t * @param context - The GraphicsContext to get the render data for.\n\t * @internal\n\t */\n\tgetContextRenderData(context: GraphicsContext): GraphicsContextRenderData;\n\t/**\n\t * Updates the GPU context for a given GraphicsContext.\n\t * If the context is dirty, it will rebuild the batches and geometry data.\n\t * @param context - The GraphicsContext to update.\n\t * @returns The updated GpuGraphicsContext.\n\t * @internal\n\t */\n\tupdateGpuContext(context: GraphicsContext): GpuGraphicsContext;\n\t/**\n\t * Returns the GpuGraphicsContext for a given GraphicsContext.\n\t * If it does not exist, it will initialize a new one.\n\t * @param context - The GraphicsContext to get the GpuGraphicsContext for.\n\t * @returns The GpuGraphicsContext for the given GraphicsContext.\n\t * @internal\n\t */\n\tgetGpuContext(context: GraphicsContext): GpuGraphicsContext;\n\tprivate _initContextRenderData;\n\tprivate _initContext;\n\tdestroy(): void;\n}\n/**\n * The mode for batching graphics instructions.\n *\n * It can be:\n * - 'auto': Automatically determines whether to batch based on the number of instructions.\n * - 'batch': Forces batching of all instructions.\n * - 'no-batch': Disables batching, processing each instruction individually.\n * @category scene\n * @advanced\n */\nexport type BatchMode = \"auto\" | \"batch\" | \"no-batch\";\n/** @internal */\nexport interface FillInstruction {\n\taction: \"fill\" | \"cut\";\n\tdata: {\n\t\tstyle: ConvertedFillStyle;\n\t\tpath: GraphicsPath;\n\t\thole?: GraphicsPath;\n\t};\n}\n/** @internal */\nexport interface StrokeInstruction {\n\taction: \"stroke\";\n\tdata: {\n\t\tstyle: ConvertedStrokeStyle;\n\t\tpath: GraphicsPath;\n\t\thole?: GraphicsPath;\n\t};\n}\n/** @internal */\nexport interface TextureInstruction {\n\taction: \"texture\";\n\tdata: {\n\t\timage: Texture;\n\t\tdx: number;\n\t\tdy: number;\n\t\tdw: number;\n\t\tdh: number;\n\t\ttransform: Matrix;\n\t\talpha: number;\n\t\tstyle: number;\n\t};\n}\n/** @internal */\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @category scene\n * @standard\n */\nexport class GraphicsContext extends EventEmitter<{\n\tupdate: GraphicsContext;\n\tdestroy: GraphicsContext;\n\tunload: GraphicsContext;\n}> implements GCable {\n\t/** @internal */\n\t_gpuData: Record<number | string, GpuGraphicsContext>;\n\t/** @internal */\n\t_gcData?: GCData;\n\t/** If set to true, the resource will be garbage collected automatically when it is not used. */\n\tautoGarbageCollect: boolean;\n\t/** @internal */\n\t_gcLastUsed: number;\n\t/** The default fill style to use when none is provided. */\n\tstatic defaultFillStyle: ConvertedFillStyle;\n\t/** The default stroke style to use when none is provided. */\n\tstatic defaultStrokeStyle: ConvertedStrokeStyle;\n\t/**\n\t * unique id for this graphics context\n\t * @internal\n\t */\n\treadonly uid: number;\n\t/**\n\t * Indicates whether content is updated and have to be re-rendered.\n\t * @internal\n\t */\n\tdirty: boolean;\n\t/** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n\tbatchMode: BatchMode;\n\t/** @internal */\n\tinstructions: GraphicsInstructions[];\n\t/**\n\t * Custom shader to apply to the graphics when rendering.\n\t * @advanced\n\t */\n\tcustomShader?: Shader;\n\t/** Whether the graphics context has been destroyed. */\n\tdestroyed: boolean;\n\tprivate _activePath;\n\tprivate _transform;\n\tprivate _fillStyle;\n\tprivate _strokeStyle;\n\tprivate _stateStack;\n\tprivate _tick;\n\tprivate _bounds;\n\tprivate _boundsDirty;\n\t/**\n\t * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n\t * including the current drawing state, transformations, styles, and instructions.\n\t * @returns A new GraphicsContext instance with the same properties and state as this one.\n\t */\n\tclone(): GraphicsContext;\n\t/**\n\t * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n\t */\n\tget fillStyle(): ConvertedFillStyle;\n\tset fillStyle(value: FillInput);\n\t/**\n\t * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n\t */\n\tget strokeStyle(): ConvertedStrokeStyle;\n\tset strokeStyle(value: FillInput);\n\t/**\n\t * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n\t * pattern, or a more complex style defined by a FillStyle object.\n\t * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n\t *                or a FillStyle or ConvertedFillStyle object.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetFillStyle(style: FillInput): this;\n\t/**\n\t * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n\t * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n\t * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n\t *                or a StrokeStyle or ConvertedStrokeStyle object.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetStrokeStyle(style: StrokeInput): this;\n\t/**\n\t * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture.\n\t * If only a texture is provided, it uses the texture's width and height for drawing.\n\t * @param texture - The Texture object to use.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttexture(texture: Texture): this;\n\t/**\n\t * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n\t * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n\t * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n\t * @param texture - The Texture object to use.\n\t * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n\t * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n\t * the source image.\n\t * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n\t * the source image.\n\t * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n\t * If not provided, uses the texture's frame width.\n\t * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n\t * If not provided, uses the texture's frame height.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttexture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n\t/**\n\t * Resets the current path. Any previous path and its commands are discarded and a new path is\n\t * started. This is typically called before beginning a new shape or series of drawing commands.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tbeginPath(): this;\n\t/**\n\t * Fills the current or given path with the current fill style. This method can optionally take\n\t * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n\t * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tfill(style?: FillInput): this;\n\t/** @deprecated 8.0.0 */\n\tfill(color: ColorSource, alpha: number): this;\n\tprivate _initNextPathLocation;\n\t/**\n\t * Strokes the current path with the current stroke style. This method can take an optional\n\t * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n\t * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tstroke(style?: StrokeInput): this;\n\t/**\n\t * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n\t * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n\t * fail to cut correctly!\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tcut(): this;\n\t/**\n\t * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n\t * starting and ending angles, and direction.\n\t * @param x - The x-coordinate of the arc's center.\n\t * @param y - The y-coordinate of the arc's center.\n\t * @param radius - The arc's radius.\n\t * @param startAngle - The starting angle, in radians.\n\t * @param endAngle - The ending angle, in radians.\n\t * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tarc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n\t/**\n\t * Adds an arc to the current path with the given control points and radius, connected to the previous point\n\t * by a straight line if necessary.\n\t * @param x1 - The x-coordinate of the first control point.\n\t * @param y1 - The y-coordinate of the first control point.\n\t * @param x2 - The x-coordinate of the second control point.\n\t * @param y2 - The y-coordinate of the second control point.\n\t * @param radius - The arc's radius.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n\t/**\n\t * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n\t * @param rx - The x-radius of the ellipse.\n\t * @param ry - The y-radius of the ellipse.\n\t * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n\t * to the x-axis of the coordinate system, in degrees.\n\t * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n\t * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n\t * @param x - The x-coordinate of the arc's end point.\n\t * @param y - The y-coordinate of the arc's end point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n\t/**\n\t * Adds a cubic Bezier curve to the path.\n\t * It requires three points: the first two are control points and the third one is the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cp1x - The x-coordinate of the first control point.\n\t * @param cp1y - The y-coordinate of the first control point.\n\t * @param cp2x - The x-coordinate of the second control point.\n\t * @param cp2y - The y-coordinate of the second control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tbezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Closes the current path by drawing a straight line back to the start.\n\t * If the shape is already closed or there are no points in the path, this method does nothing.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tclosePath(): this;\n\t/**\n\t * Draws an ellipse at the specified location and with the given x and y radii.\n\t * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n\t * @param x - The x-coordinate of the center of the ellipse.\n\t * @param y - The y-coordinate of the center of the ellipse.\n\t * @param radiusX - The horizontal radius of the ellipse.\n\t * @param radiusY - The vertical radius of the ellipse.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n\t/**\n\t * Draws a circle shape. This method adds a new circle path to the current drawing.\n\t * @param x - The x-coordinate of the center of the circle.\n\t * @param y - The y-coordinate of the center of the circle.\n\t * @param radius - The radius of the circle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tcircle(x: number, y: number, radius: number): this;\n\t/**\n\t * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n\t * @param path - The `GraphicsPath` to add.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tpath(path: GraphicsPath): this;\n\t/**\n\t * Connects the current point to a new point with a straight line. This method updates the current path.\n\t * @param x - The x-coordinate of the new point to connect to.\n\t * @param y - The y-coordinate of the new point to connect to.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tlineTo(x: number, y: number): this;\n\t/**\n\t * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n\t * @param x - The x-coordinate for the starting point.\n\t * @param y - The y-coordinate for the starting point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tmoveTo(x: number, y: number): this;\n\t/**\n\t * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cpx - The x-coordinate of the control point.\n\t * @param cpy - The y-coordinate of the control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tquadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\trect(x: number, y: number, w: number, h: number): this;\n\t/**\n\t * Draws a rectangle with rounded corners.\n\t * The corner radius can be specified to determine how rounded the corners should be.\n\t * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n\t/**\n\t * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n\t * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n\t * rotated, or translated as needed.\n\t * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n\t * representing the x and y coordinates, of the polygon's vertices, in sequence.\n\t * @param close - A boolean indicating whether to close the polygon path. True by default.\n\t */\n\tpoly(points: number[] | PointData[], close?: boolean): this;\n\t/**\n\t * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tregularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon with rounded corners.\n\t * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param corner - The radius of the rounding of the corners.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n\t/**\n\t * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n\t * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n\t * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n\t * A minimum of 3 points is required.\n\t * @param radius - The default radius for the corners.\n\t * This radius is applied to all corners unless overridden in `points`.\n\t * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n\t *  method instead of an arc method. Defaults to false.\n\t * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n\t * Higher values make the curve smoother.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n\t/**\n\t * Draw Rectangle with fillet corners. This is much like rounded rectangle\n\t * however it support negative numbers as well for the corner radius.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param fillet - accept negative or positive values\n\t */\n\tfilletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n\t/**\n\t * Draw Rectangle with chamfer corners. These are angled corners.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param chamfer - non-zero real number, size of corner cutout\n\t * @param transform\n\t */\n\tchamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n\t/**\n\t * Draws a star shape centered at a specified location. This method allows for the creation\n\t *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n\t * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n\t * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n\t * @param x - The x-coordinate of the center of the star.\n\t * @param y - The y-coordinate of the center of the star.\n\t * @param points - The number of points of the star.\n\t * @param radius - The outer radius of the star (distance from the center to the outer points).\n\t * @param innerRadius - Optional. The inner radius of the star\n\t * (distance from the center to the inner points between the outer points).\n\t * If not provided, defaults to half of the `radius`.\n\t * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n\t * Defaults to 0, meaning one point is directly upward.\n\t * @returns The instance of the current object for chaining further drawing commands.\n\t */\n\tstar(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n\t/**\n\t * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n\t * defined in SVG format to be drawn within the graphics context.\n\t * @param svg - The SVG string to be parsed and rendered.\n\t */\n\tsvg(svg: string): this;\n\t/**\n\t * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n\t * This includes transformations, fill styles, and stroke styles.\n\t */\n\trestore(): this;\n\t/** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n\tsave(): this;\n\t/**\n\t * Returns the current transformation matrix of the graphics context.\n\t * @returns The current transformation matrix.\n\t */\n\tgetTransform(): Matrix;\n\t/**\n\t * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tresetTransform(): this;\n\t/**\n\t * Applies a rotation transformation to the graphics context around the current origin.\n\t * @param angle - The angle of rotation in radians.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\trotate(angle: number): this;\n\t/**\n\t * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n\t * @param x - The scale factor in the horizontal direction.\n\t * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tscale(x: number, y?: number): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n\t * This replaces the current transformation matrix.\n\t * @param transform - The matrix to set as the current transformation matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(transform: Matrix): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n\t * This replaces the current transformation matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\t/**\n\t * Applies the specified transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix.\n\t * @param transform - The matrix to apply to the current transformation.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(transform: Matrix): this;\n\t/**\n\t * Applies the specified transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\t/**\n\t * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n\t * @param x - The amount to translate in the horizontal direction.\n\t * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttranslate(x: number, y?: number): this;\n\t/**\n\t * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n\t * and optionally resetting transformations to the identity matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tclear(): this;\n\tprotected onUpdate(): void;\n\t/** The bounds of the graphic shape. */\n\tget bounds(): Bounds;\n\t/**\n\t * Check to see if a point is contained within this geometry.\n\t * @param point - Point to check if it's contained.\n\t * @returns {boolean} `true` if the point is contained within geometry.\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/** Unloads the GPU data from the graphics context. */\n\tunload(): void;\n\t/**\n\t * Destroys the GraphicsData object.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * context.destroy();\n\t * context.destroy(true);\n\t * context.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: TypeOrBool<TextureDestroyOptions>): void;\n}\n/**\n * The alignment of the text.\n *\n * - 'left': Aligns text to the left edge.\n * - 'center': Centers text horizontally.\n * - 'right': Aligns text to the right edge.\n * - 'justify': Justifies text, aligning both left and right edges.\n * @example\n * ```ts\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   align: 'center', // or 'left', 'right', 'justify'\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleAlign = \"left\" | \"center\" | \"right\" | \"justify\";\n/**\n * The fill style input for text styles.\n *\n * This can be:\n * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n * - A hex number like 0xff0000 for red\n * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n * - A FillGradient for gradient fills\n * - A FillPattern for pattern/texture fills\n * @example\n * ```ts\n * // Simple Fills\n * new TextStyle({ fill: 'red' }); // Color string\n * new TextStyle({ fill: 0x00ff00 }); // Hex color\n * new TextStyle({ fill: 'rgb(255,0,0)' }); // RGB string\n * // Gradients\n * new TextStyle({\n *     fill: new FillGradient({\n *         end: { x: 1, y: 1 },\n *         stops: [\n *             { color: 0xff0000, offset: 0 }, // Red at start\n *             { color: 0x0000ff, offset: 1 }, // Blue at end\n *         ]\n *     }),\n * });\n * // Patterns\n * new TextStyle({\n *    fill: new FillPattern(Assets.get('pattern.png'))\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\n/**\n * The font style input for text styles. Controls the slant or italicization of the text.\n * @example\n * ```ts\n * // Create text with normal font style\n * const normalText = new Text({\n *     text: 'Normal Style Text',\n *     style: {\n *         fontStyle: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create italic text\n * const italicText = new Text({\n *     text: 'Italic Style Text',\n *     style: {\n *         fontStyle: 'italic',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Create oblique text\n * const obliqueText = new Text({\n *     text: 'Oblique Style Text',\n *     style: {\n *         fontStyle: 'oblique',\n *         fontSize: 24,\n *         fontFamily: 'Times New Roman'\n *     }\n * });\n *\n * // Dynamic style changes\n * let isItalic = false;\n * text.style = {\n *     ...text.style,\n *     fontStyle: isItalic ? 'italic' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular upright text with no slant\n * - 'italic': True italics using specifically designed italic glyphs\n * - 'oblique': Slanted version of the regular glyphs\n * @remarks\n * - 'italic' uses specially designed glyphs with cursive characteristics\n * - 'oblique' is a mechanical slant of the normal glyphs\n * - Not all fonts include true italic designs; some may fall back to oblique\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style | MDN font-style}\n * @category text\n * @standard\n */\nexport type TextStyleFontStyle = \"normal\" | \"italic\" | \"oblique\";\n/**\n * The font variant input for text styles. Controls the capitalization and presentation of letters.\n * Used to enable special rendering like small caps.\n * @example\n * ```ts\n * // Create text with normal font variant\n * const normalText = new Text({\n *     text: 'Normal Text',\n *     style: {\n *         fontVariant: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create text with small-caps variant\n * const smallCapsText = new Text({\n *     text: 'Small Caps Text',\n *     style: {\n *         fontVariant: 'small-caps',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Use in a TextStyle instance\n * const style = new TextStyle({\n *     fontVariant: 'small-caps',\n *     fontSize: 32,\n *     fill: 0x4a4a4a\n * });\n *\n * // Update variant dynamically\n * text.style = {\n *     ...text.style,\n *     fontVariant: text.style.fontVariant === 'normal' ? 'small-caps' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular text rendering with standard capitalization\n * - 'small-caps': Renders lowercase letters as smaller versions of capital letters\n * @remarks\n * Small caps are only available if the font supports them.\n * Not all fonts include true small caps glyphs.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant | MDN font-variant}\n * @category text\n * @standard\n */\nexport type TextStyleFontVariant = \"normal\" | \"small-caps\";\n/**\n * The font weight input for text styles. Controls the thickness or boldness of the text.\n * @example\n * ```ts\n * // Create text with different font weights\n * const normalText = new Text({\n *     text: 'Normal Weight',\n *     style: { fontWeight: 'normal' }\n * });\n *\n * const boldText = new Text({\n *     text: 'Bold Weight',\n *     style: { fontWeight: 'bold' }\n * });\n *\n * // Using numeric weights\n * const lightText = new Text({\n *     text: 'Light Weight',\n *     style: { fontWeight: '300' }\n * });\n *\n * const mediumText = new Text({\n *     text: 'Medium Weight',\n *     style: { fontWeight: '500' }\n * });\n *\n * const heavyText = new Text({\n *     text: 'Heavy Weight',\n *     style: { fontWeight: '900' }\n * });\n *\n * // Responsive weight changes\n * const adaptiveText = new Text({\n *     text: 'Adaptive Weight',\n *     style: { fontWeight: window.innerWidth > 600 ? 'bold' : 'normal' }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Standard weight (equivalent to 400)\n * - 'bold': Bold weight (equivalent to 700)\n * - 'bolder': One weight darker than the parent element\n * - 'lighter': One weight lighter than the parent element\n * - '100': Thin (Hairline)\n * - '200': Extra Light (Ultra Light)\n * - '300': Light\n * - '400': Normal\n * - '500': Medium\n * - '600': Semi Bold (Demi Bold)\n * - '700': Bold\n * - '800': Extra Bold (Ultra Bold)\n * - '900': Heavy (Black)\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight | MDN font-weight}\n * @category text\n * @standard\n */\nexport type TextStyleFontWeight = \"normal\" | \"bold\" | \"bolder\" | \"lighter\" | \"100\" | \"200\" | \"300\" | \"400\" | \"500\" | \"600\" | \"700\" | \"800\" | \"900\";\n/**\n * The line join style for text strokes. Determines how lines connect at corners.\n * @example\n * ```ts\n * // Create text with miter joins (sharp corners)\n * const sharpText = new Text({\n *     text: 'Sharp Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'miter'  // Sharp corners\n *         }\n *     }\n * });\n *\n * // Create text with round joins\n * const roundText = new Text({\n *     text: 'Rounded Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'round'  // Smooth rounded corners\n *         }\n *     }\n * });\n *\n * // Create text with beveled joins\n * const bevelText = new Text({\n *     text: 'Beveled Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'bevel'  // Flattened corners\n *         }\n *     }\n * });\n * ```\n * Available values:\n * - 'miter': Creates sharp corners by extending the outer edges until they meet\n * - 'round': Creates smooth, rounded corners using a circular arc\n * - 'bevel': Creates flattened corners by filling an additional triangle between the outer edges\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin | MDN lineJoin}\n * @category text\n * @standard\n */\nexport type TextStyleLineJoin = \"miter\" | \"round\" | \"bevel\";\n/**\n * The text baseline for text styles.\n *\n * This can be:\n * - 'alphabetic': The alphabetic baseline\n * - 'top': The top of the text\n * - 'hanging': The hanging baseline\n * - 'middle': The middle of the text\n * - 'ideographic': The ideographic baseline\n * - 'bottom': The bottom of the text\n * @category text\n * @standard\n */\nexport type TextStyleTextBaseline = \"alphabetic\" | \"top\" | \"hanging\" | \"middle\" | \"ideographic\" | \"bottom\";\n/**\n * Controls how whitespace (spaces, tabs, and line breaks) is handled within the text.\n * This affects text wrapping and spacing behavior.\n * @example\n * ```ts\n * // Normal mode (collapse spaces and newlines)\n * const normalText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'normal',\n *         fontSize: 24\n *     }\n * }); // Renders as: \"Hello World New Line\"\n *\n * // Pre mode (preserve all whitespace)\n * const preText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre',\n *         fontSize: 24\n *     }\n * }); // Preserves spaces and line breaks exactly\n *\n * // Pre-line mode (preserve newlines, collapse spaces)\n * const preLineText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         fontSize: 24\n *     }\n * }); // Preserves line breaks, collapses multiple spaces\n *\n * // With word wrap enabled\n * const wrappedText = new Text({\n *     text: 'A long text with    multiple spaces\\nand line breaks',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         fontSize: 24\n *     }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Collapses all whitespace (spaces, tabs, line breaks) into a single space\n * - 'pre': Preserves all whitespace characters exactly as written\n * - 'pre-line': Preserves line breaks but collapses multiple spaces into a single space\n * @remarks\n * - 'normal' is best for single-line text or when you want to ignore formatting\n * - 'pre' is useful for code blocks or when exact spacing is important\n * - 'pre-line' is good for formatted text where you want to keep line breaks but clean up spaces\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space | MDN white-space}\n * @see {@link TextStyle#wordWrap} For controlling text wrapping\n * @category text\n * @standard\n */\nexport type TextStyleWhiteSpace = \"normal\" | \"pre\" | \"pre-line\";\n/**\n * Defines a drop shadow effect for text rendering.\n * Drop shadows add depth and emphasis to text by creating a shadow offset from the text.\n * @example\n * ```ts\n * // Create text with basic drop shadow\n * const text = new Text({\n *     text: 'Shadow Text',\n *     style: {\n *         fontSize: 48,\n *         dropShadow: {\n *             alpha: 0.5,         // 50% opacity shadow\n *             angle: Math.PI / 6, // 30 degrees\n *             blur: 4,            // Soft shadow edge\n *             color: '#000000',   // Black shadow\n *             distance: 6         // Shadow offset\n *         }\n *     }\n * });\n *\n * // Dynamic shadow updates\n * text.style.dropShadow = {\n *     alpha: Math.sin(Date.now() / 1000) * 0.5 + 0.5, // Pulsing opacity\n *     angle: Date.now() / 1000,                        // Rotating angle\n *     blur: 4,\n *     color: '#000000',\n *     distance: 6\n * };\n * ```\n * @category text\n * @standard\n */\nexport type TextDropShadow = {\n\t/**\n\t * The opacity of the drop shadow.\n\t * - Range: 0 to 1\n\t * - 0 = fully transparent\n\t * - 1 = fully opaque\n\t * @example\n\t * ```ts\n\t * // Set drop shadow opacity to 50%\n\t * dropShadow: {\n\t *    alpha: 0.5\n\t * }\n\t * ```\n\t * @default 1\n\t */\n\talpha: number;\n\t/**\n\t * The angle of the drop shadow in radians.\n\t * - 0 = right\n\t * - Math.PI/2 = down\n\t * - Math.PI = left\n\t * - Math.PI*1.5 = up\n\t * @example\n\t * ```ts\n\t * // Set drop shadow angle to 30 degrees\n\t * dropShadow: {\n\t *    angle: Math.PI / 6 // 30 degrees\n\t * }\n\t * ```\n\t * @default Math.PI/6 (30 degrees)\n\t */\n\tangle: number;\n\t/**\n\t * The blur radius of the shadow.\n\t * - 0 = sharp shadow\n\t * - Higher values = softer shadow\n\t * @example\n\t * ```ts\n\t * // Set drop shadow blur radius to 10 pixels\n\t * dropShadow: {\n\t *   blur: 10\n\t * }\n\t * ```\n\t * @default 0\n\t */\n\tblur: number;\n\t/**\n\t * The color of the drop shadow.\n\t * Accepts any valid CSS color string, hex number, or RGB/RGBA values.\n\t * @example '#000000', 'rgba(0,0,0,0.5)', 0x000000\n\t * @default 'black'\n\t */\n\tcolor: ColorSource;\n\t/**\n\t * The distance of the drop shadow from the text.\n\t * Measured in pixels.\n\t * @example\n\t * ```ts\n\t * // Set drop shadow distance to 5 pixels\n\t * dropShadow: {\n\t *   distance: 5\n\t * }\n\t * ```\n\t * @default 5\n\t */\n\tdistance: number;\n};\n/**\n * Constructor options used for `TextStyle` instances. Defines the visual appearance and layout of text.\n * @example\n * ```ts\n * // Basic text style\n * const basicStyle = new TextStyle({\n *     fontSize: 24,\n *     fill: 'black',\n *     fontFamily: 'Arial'\n * });\n *\n * // Rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: ['Arial', 'Helvetica', 'sans-serif'],\n *     fontSize: 36,\n *     fontWeight: 'bold',\n *     fill: 'red',\n *     stroke: { color: '#4a1850', width: 5 },\n *     align: 'center',\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     textBaseline: 'middle'\n * });\n * ```\n * @see {@link TextStyle} For the main style class\n * @category text\n * @standard\n */\nexport interface TextStyleOptions {\n\t/**\n\t * Alignment for multiline text, does not affect single line text\n\t * @default 'left'\n\t */\n\talign?: TextStyleAlign;\n\t/**\n\t * Whether to allow line breaks within words.\n\t * Requires wordWrap to be true.\n\t * @example\n\t * ```ts\n\t * // Enable word breaking\n\t * const style = new TextStyle({\n\t *    breakWords: true,\n\t *    wordWrap: true,\n\t *    wordWrapWidth: 200\n\t * });\n\t * ```\n\t * @default false\n\t */\n\tbreakWords?: boolean;\n\t/**\n\t * Drop shadow configuration for the text.\n\t * Can be boolean or a TextDropShadow object.\n\t * @default null\n\t */\n\tdropShadow?: boolean | Partial<TextDropShadow>;\n\t/**\n\t * Fill style for the text.\n\t * Can be a color, gradient, or pattern.\n\t * @default 'black'\n\t */\n\tfill?: FillInput;\n\t/**\n\t * Font family or families to use.\n\t * Can be single name or array of fallbacks.\n\t * @example\n\t * ```ts\n\t * // Single font family\n\t * fontFamily: 'Arial'\n\t * // Multiple font families\n\t * fontFamily: ['Helvetica', 'Arial', 'sans-serif']\n\t * ```\n\t * @default 'Arial'\n\t */\n\tfontFamily?: string | string[];\n\t/**\n\t * Font size in pixels or as string.\n\t *\n\t * Equivalents are '26px','20pt','160%' or '1.6em')\n\t * @example\n\t * ```ts\n\t * // Numeric size\n\t * fontSize: 26\n\t * // String size\n\t * fontSize: '26px'\n\t * // Percentage size\n\t * fontSize: '160%' // 1.6 times the parent element's font size\n\t * // Em size\n\t * fontSize: '1.6em' // 1.6 times the parent element's font size\n\t * @default 26\n\t */\n\tfontSize?: number | string;\n\t/**\n\t * Font style (normal, italic, oblique).\n\t * @default 'normal'\n\t */\n\tfontStyle?: TextStyleFontStyle;\n\t/**\n\t * Font variant (normal, small-caps).\n\t * @default 'normal'\n\t */\n\tfontVariant?: TextStyleFontVariant;\n\t/**\n\t * Font weight (normal, bold, bolder, lighter, 100-900).\n\t * @default 'normal'\n\t */\n\tfontWeight?: TextStyleFontWeight;\n\t/** The height of the line, a number that represents the vertical space that a letter uses. */\n\tleading?: number;\n\t/** The amount of spacing between letters, default is 0 */\n\tletterSpacing?: number;\n\t/** The line height, a number that represents the vertical space that a letter uses */\n\tlineHeight?: number;\n\t/**\n\t * Padding around the text.\n\t *\n\t * Occasionally some fonts are cropped. Adding some padding will prevent this from\n\t * happening by adding padding to all sides of the text.\n\t */\n\tpadding?: number;\n\t/**\n\t * Stroke style for text outline.\n\t * @default null\n\t */\n\tstroke?: StrokeInput;\n\t/**\n\t * Vertical alignment baseline.\n\t * @default 'alphabetic'\n\t */\n\ttextBaseline?: TextStyleTextBaseline;\n\t/**\n\t * Whether to trim transparent edges.\n\t * > [!NOTE] This is an expensive operation and should only be used when necessary.\n\t * @default false\n\t */\n\ttrim?: boolean;\n\t/**\n\t * How to handle whitespace.\n\t *\n\t * It needs wordWrap to be set to true for this to have an effect.\n\t * @default 'pre'\n\t */\n\twhiteSpace?: TextStyleWhiteSpace;\n\t/** Indicates if word wrap should be used */\n\twordWrap?: boolean;\n\t/** The width at which text will wrap, it needs wordWrap to be set to true */\n\twordWrapWidth?: number;\n\t/**\n\t * Array of filters to apply to the text.\n\t *\n\t * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n\t * compared to applying the filter directly to the text object (which would be applied at run time).\n\t * @default undefined\n\t */\n\tfilters?: Filter[] | readonly Filter[];\n}\n/**\n * A TextStyle Object contains information to decorate Text objects.\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @example\n * ```ts\n * // Create a basic text style\n * const style = new TextStyle({\n *     fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *     fontSize: 36,\n *     fill: 0xff1010,\n *     align: 'center'\n * });\n *\n * // Create a rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 32,\n *     fill: 'white',\n *     stroke: {\n *         color: '#4a1850',\n *         width: 5\n *     },\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     align: 'center'\n * });\n *\n * // Share style between multiple text objects\n * const text1 = new Text({\n *     text: 'Hello',\n *     style: richStyle\n * });\n *\n * const text2 = new Text({\n *     text: 'World',\n *     style: richStyle\n * });\n *\n * // Update style dynamically - affects all text objects\n * richStyle.fontSize = 48;\n * richStyle.fill = 0x00ff00;\n * ```\n *\n * Key Features:\n * - Shared styling between multiple text objects\n * - Rich text formatting options\n * - Gradient and pattern fills\n * - Drop shadows and strokes\n * - Word wrapping and alignment\n * - Dynamic updates\n * @category text\n * @standard\n */\nexport class TextStyle extends EventEmitter<{\n\tupdate: TextDropShadow;\n}> {\n\t/**\n\t * Default drop shadow settings used when enabling drop shadows on text.\n\t * These values are used as the base configuration when drop shadows are enabled without specific settings.\n\t * @example\n\t * ```ts\n\t * // Customize default settings globally\n\t * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows\n\t * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows\n\t * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default\n\t * ```\n\t */\n\tstatic defaultDropShadow: TextDropShadow;\n\t/**\n\t * Unique identifier for the TextStyle class.\n\t * This is used to track instances and ensure uniqueness.\n\t * @internal\n\t */\n\tuid: number;\n\t/**\n\t * Internal tick counter used to track updates and changes.\n\t * This is incremented whenever the style is modified, allowing for efficient change detection.\n\t * @internal\n\t */\n\t_tick: number;\n\t/**\n\t * Default text style settings used when creating new text objects.\n\t * These values serve as the base configuration and can be customized globally.\n\t * @example\n\t * ```ts\n\t * // Customize default text style globally\n\t * TextStyle.defaultTextStyle.fontSize = 16;\n\t * TextStyle.defaultTextStyle.fill = 0x333333;\n\t * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];\n\t * ```\n\t */\n\tstatic defaultTextStyle: TextStyleOptions;\n\t/** @internal */\n\t_fill: ConvertedFillStyle;\n\tprivate _originalFill;\n\t/** @internal */\n\t_stroke: ConvertedStrokeStyle;\n\tprivate _originalStroke;\n\tprivate _dropShadow;\n\tprivate _fontFamily;\n\tprivate _fontSize;\n\tprivate _fontStyle;\n\tprivate _fontVariant;\n\tprivate _fontWeight;\n\tprivate _breakWords;\n\tprivate _align;\n\tprivate _leading;\n\tprivate _letterSpacing;\n\tprivate _lineHeight;\n\tprivate _textBaseline;\n\tprivate _whiteSpace;\n\tprivate _wordWrap;\n\tprivate _wordWrapWidth;\n\tprivate _filters;\n\tprivate _padding;\n\tprivate _trim;\n\tconstructor(style?: Partial<TextStyleOptions>);\n\t/**\n\t * Alignment for multiline text, does not affect single line text.\n\t * @type {'left'|'center'|'right'|'justify'}\n\t */\n\tget align(): TextStyleAlign;\n\tset align(value: TextStyleAlign);\n\t/** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n\tget breakWords(): boolean;\n\tset breakWords(value: boolean);\n\t/** Set a drop shadow for the text. */\n\tget dropShadow(): TextDropShadow;\n\tset dropShadow(value: boolean | TextDropShadow);\n\t/** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n\tget fontFamily(): string | string[];\n\tset fontFamily(value: string | string[]);\n\t/** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n\tget fontSize(): number;\n\tset fontSize(value: string | number);\n\t/**\n\t * The font style.\n\t * @type {'normal'|'italic'|'oblique'}\n\t */\n\tget fontStyle(): TextStyleFontStyle;\n\tset fontStyle(value: TextStyleFontStyle);\n\t/**\n\t * The font variant.\n\t * @type {'normal'|'small-caps'}\n\t */\n\tget fontVariant(): TextStyleFontVariant;\n\tset fontVariant(value: TextStyleFontVariant);\n\t/**\n\t * The font weight.\n\t * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n\t */\n\tget fontWeight(): TextStyleFontWeight;\n\tset fontWeight(value: TextStyleFontWeight);\n\t/** The space between lines. */\n\tget leading(): number;\n\tset leading(value: number);\n\t/** The amount of spacing between letters, default is 0. */\n\tget letterSpacing(): number;\n\tset letterSpacing(value: number);\n\t/** The line height, a number that represents the vertical space that a letter uses. */\n\tget lineHeight(): number;\n\tset lineHeight(value: number);\n\t/**\n\t * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n\t * by adding padding to all sides of the text.\n\t * > [!NOTE] This will NOT affect the positioning or bounds of the text.\n\t */\n\tget padding(): number;\n\tset padding(value: number);\n\t/**\n\t * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.\n\t * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n\t * compared to applying the filter directly to the text object (which would be applied at run time).\n\t * @default null\n\t */\n\tget filters(): readonly Filter[];\n\tset filters(value: Filter[]);\n\t/**\n\t * Trim transparent borders from the text texture.\n\t * > [!IMPORTANT] PERFORMANCE WARNING:\n\t * > This is a costly operation as it requires scanning pixel alpha values.\n\t * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.\n\t */\n\tget trim(): boolean;\n\tset trim(value: boolean);\n\t/**\n\t * The baseline of the text that is rendered.\n\t * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n\t */\n\tget textBaseline(): TextStyleTextBaseline;\n\tset textBaseline(value: TextStyleTextBaseline);\n\t/**\n\t * How newlines and spaces should be handled.\n\t * Default is 'pre' (preserve, preserve).\n\t *\n\t *  value       | New lines     |   Spaces\n\t *  ---         | ---           |   ---\n\t * 'normal'     | Collapse      |   Collapse\n\t * 'pre'        | Preserve      |   Preserve\n\t * 'pre-line'   | Preserve      |   Collapse\n\t * @type {'normal'|'pre'|'pre-line'}\n\t */\n\tget whiteSpace(): TextStyleWhiteSpace;\n\tset whiteSpace(value: TextStyleWhiteSpace);\n\t/** Indicates if word wrap should be used. */\n\tget wordWrap(): boolean;\n\tset wordWrap(value: boolean);\n\t/** The width at which text will wrap, it needs wordWrap to be set to true. */\n\tget wordWrapWidth(): number;\n\tset wordWrapWidth(value: number);\n\t/**\n\t * The fill style that will be used to color the text.\n\t * This can be:\n\t * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n\t * - A hex number like 0xff0000 for red\n\t * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n\t * - A FillGradient for gradient fills\n\t * - A FillPattern for pattern/texture fills\n\t *\n\t * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n\t * while gradients at any other angle are spread across the entire text body as a whole.\n\t * @example\n\t * // Vertical gradient applied per line\n\t * const verticalGradient = new FillGradient(0, 0, 0, 1)\n\t *     .addColorStop(0, 0xff0000)\n\t *     .addColorStop(1, 0x0000ff);\n\t *\n\t * const text = new Text({\n\t *     text: 'Line 1\\nLine 2',\n\t *     style: { fill: verticalGradient }\n\t * });\n\t *\n\t * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n\t * @type {string|number|FillStyle|FillGradient|FillPattern}\n\t */\n\tget fill(): FillInput;\n\tset fill(value: FillInput);\n\t/** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n\tget stroke(): StrokeInput;\n\tset stroke(value: StrokeInput);\n\tupdate(): void;\n\t/** Resets all properties to the default values */\n\treset(): void;\n\t/**\n\t * Returns a unique key for this instance.\n\t * This key is used for caching.\n\t * @returns {string} Unique key for the instance\n\t */\n\tget styleKey(): string;\n\t/**\n\t * Creates a new TextStyle object with the same values as this one.\n\t * @returns New cloned TextStyle object\n\t */\n\tclone(): TextStyle;\n\t/**\n\t * Returns the final padding for the text style, taking into account any filters applied.\n\t * Used internally for correct measurements\n\t * @internal\n\t * @returns {number} The final padding for the text style.\n\t */\n\t_getFinalPadding(): number;\n\t/**\n\t * Destroys this text style.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * // Destroy the text style and its textures\n\t * textStyle.destroy({ texture: true, textureSource: true });\n\t * textStyle.destroy(true);\n\t */\n\tdestroy(options?: TypeOrBool<TextureDestroyOptions>): void;\n\tprivate _createProxy;\n\tprivate _isFillStyle;\n}\n/**\n * Options for HTML text style, extends standard text styling with HTML-specific capabilities.\n * Omits certain base text properties that don't apply to HTML rendering.\n * @example\n * ```ts\n * // Basic HTML text style\n * const text = new HTMLText({\n *     text: '<p>Hello World</p>',\n *     style: {\n *         fontSize: 24,\n *         fill: '#ff0000',\n *         fontFamily: 'Arial',\n *         align: 'center'\n *     }\n * });\n *\n * // Custom tag styling\n * const taggedText = new HTMLText({\n *     text: '<custom>Custom Tag</custom>',\n *     style: {\n *         fontSize: 16,\n *         tagStyles: {\n *             custom: {\n *                 fontSize: 32,\n *                 fill: '#00ff00',\n *                 fontStyle: 'italic'\n *             }\n *         }\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, \"leading\" | \"textBaseline\" | \"trim\" | \"filters\"> {\n\t/**\n\t * List of CSS style overrides to apply to the HTML text.\n\t * These styles are added after the built-in styles and can override any default styling.\n\t * @advanced\n\t */\n\tcssOverrides?: string[];\n\t/**\n\t * Custom styles to apply to specific HTML tags.\n\t * Allows for consistent styling of custom elements without CSS overrides.\n\t * @example\n\t * ```ts\n\t * const text = new HTMLText({\n\t *     text: `\n\t *         <red>Main Title</red>\n\t *         <grey>The subtitle</grey>\n\t *         <blue>Regular content text</blue>\n\t *     `,\n\t *     style: {\n\t *         tagStyles: {\n\t *             red: {\n\t *                 fill: '#ff0000',\n\t *             },\n\t *             grey: {\n\t *                 fill: '#666666',\n\t *             },\n\t *             blue: {\n\t *                 fill: 'blue',\n\t *             }\n\t *         }\n\t *     }\n\t * });\n\t * ```\n\t * @standard\n\t */\n\ttagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @category text\n */\nexport class HTMLTextStyle extends TextStyle {\n\tprivate _cssOverrides;\n\tprivate _cssStyle;\n\t/**\n\t * Custom styles to apply to specific HTML tags.\n\t * Allows for consistent styling of custom elements without CSS overrides.\n\t * @example\n\t * new HTMLText({\n\t *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n\t *   style:{\n\t *       fontFamily: 'DM Sans',\n\t *       fill: 'white',\n\t *       fontSize:100,\n\t *       tagStyles:{\n\t *           red:{\n\t *               fill:'red',\n\t *           },\n\t *           blue:{\n\t *               fill:'blue',\n\t *           },\n\t *           green:{\n\t *               fill:'green',\n\t *           }\n\t *       }\n\t *   }\n\t * );\n\t * @standard\n\t */\n\ttagStyles: Record<string, HTMLTextStyleOptions>;\n\tconstructor(options?: HTMLTextStyleOptions);\n\t/**\n\t * List of CSS style overrides to apply to the HTML text.\n\t * These styles are added after the built-in styles and can override any default styling.\n\t * @advanced\n\t */\n\tset cssOverrides(value: string | string[]);\n\t/** @advanced */\n\tget cssOverrides(): string[];\n\t/**\n\t * Updates the text style and triggers a refresh of the CSS style cache.\n\t * This method is called automatically when style properties are changed.\n\t * @example\n\t * ```ts\n\t * // Update after multiple changes\n\t * const text = new HTMLText({\n\t *     text: 'Hello World',\n\t *     style\n\t * });\n\t *\n\t * style.fontSize = 32;\n\t * style.fill = '#00ff00';\n\t * style.fontFamily = 'Arial';\n\t * style.update(); // Apply all changes at once\n\t * ```\n\t * @advanced\n\t * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS\n\t * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides\n\t */\n\tupdate(): void;\n\t/**\n\t * Creates a new HTMLTextStyle object with the same values as this one.\n\t * This creates a deep copy of all style properties, including dropShadow and tag styles.\n\t * @example\n\t * ```ts\n\t * // Create original style\n\t * const originalStyle = new HTMLTextStyle({\n\t *     fontSize: 24,\n\t *     fill: '#ff0000',\n\t *     tagStyles: {\n\t *         header: { fontSize: 32, fill: '#00ff00' }\n\t *     }\n\t * });\n\t *\n\t * // Clone the style\n\t * const clonedStyle = originalStyle.clone();\n\t *\n\t * // Modify cloned style independently\n\t * clonedStyle.fontSize = 36;\n\t * clonedStyle.fill = '#0000ff';\n\t *\n\t * // Original style remains unchanged\n\t * console.log(originalStyle.fontSize); // Still 24\n\t * console.log(originalStyle.fill); // Still '#ff0000'\n\t * ```\n\t *\n\t * Properties that are cloned:\n\t * - Basic text properties (fontSize, fontFamily, etc.)\n\t * - Fill and stroke styles\n\t * - Drop shadow configuration\n\t * - CSS overrides\n\t * - Tag styles (deep copied)\n\t * - Word wrap settings\n\t * - Alignment and spacing\n\t * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties\n\t * @see {@link HTMLTextStyle} For available style properties\n\t * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling\n\t * @see {@link HTMLTextStyle#tagStyles} For tag style configuration\n\t * @standard\n\t */\n\tclone(): HTMLTextStyle;\n\t/**\n\t * The CSS style string that will be applied to the HTML text.\n\t * @advanced\n\t */\n\tget cssStyle(): string;\n\t/**\n\t * Add a style override, this can be any CSS property\n\t * it will override any built-in style. This is the\n\t * property and the value as a string (e.g., `color: red`).\n\t * This will override any other internal style.\n\t * @param {string} value - CSS style(s) to add.\n\t * @example\n\t * style.addOverride('background-color: red');\n\t * @advanced\n\t */\n\taddOverride(...value: string[]): void;\n\t/**\n\t * Remove any overrides that match the value.\n\t * @param {string} value - CSS style to remove.\n\t * @example\n\t * style.removeOverride('background-color: red');\n\t * @advanced\n\t */\n\tremoveOverride(...value: string[]): void;\n\t/**\n\t * Sets the fill style for the text. HTML text only supports color fills (string or number values).\n\t * Texture fills are not supported and will trigger a warning in debug mode.\n\t * @example\n\t * ```ts\n\t * // Using hex colors\n\t * const text = new HTMLText({\n\t *     text: 'Colored Text',\n\t *     style: {\n\t *         fill: 0xff0000 // Red color\n\t *     }\n\t * });\n\t *\n\t * // Using CSS color strings\n\t * text.style.fill = '#00ff00';     // Hex string (Green)\n\t * text.style.fill = 'blue';        // Named color\n\t * text.style.fill = 'rgb(255,0,0)' // RGB\n\t * text.style.fill = '#f0f';        // Short hex\n\t *\n\t * // Invalid usage (will trigger warning in debug)\n\t * text.style.fill = {\n\t *     type: 'pattern',\n\t *     texture: Texture.from('pattern.png')\n\t * }; // Not supported, falls back to default\n\t * ```\n\t * @param value - The fill color to use. Must be a string or number.\n\t * @throws {Warning} In debug mode when attempting to use unsupported fill types\n\t * @see {@link TextStyle#fill} For full fill options in canvas text\n\t * @standard\n\t */\n\tset fill(value: FillInput);\n\t/**\n\t * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).\n\t * Texture strokes are not supported and will trigger a warning in debug mode.\n\t * @example\n\t * ```ts\n\t * // Using hex colors\n\t * const text = new HTMLText({\n\t *     text: 'Outlined Text',\n\t *     style: {\n\t *         stroke: 0xff0000 // Red outline\n\t *     }\n\t * });\n\t *\n\t * // Using CSS color strings\n\t * text.style.stroke = '#00ff00';     // Hex string (Green)\n\t * text.style.stroke = 'blue';        // Named color\n\t * text.style.stroke = 'rgb(255,0,0)' // RGB\n\t * text.style.stroke = '#f0f';        // Short hex\n\t *\n\t * // Using stroke width\n\t * text.style = {\n\t *     stroke: {\n\t *         color: '#ff0000',\n\t *         width: 2\n\t *     }\n\t * };\n\t *\n\t * // Remove stroke\n\t * text.style.stroke = null;\n\t *\n\t * // Invalid usage (will trigger warning in debug)\n\t * text.style.stroke = {\n\t *     type: 'pattern',\n\t *     texture: Texture.from('pattern.png')\n\t * }; // Not supported, falls back to default\n\t * ```\n\t * @param value - The stroke style to use. Must be a string, number, or stroke configuration object\n\t * @throws {Warning} In debug mode when attempting to use unsupported stroke types\n\t * @see {@link TextStyle#stroke} For full stroke options in canvas text\n\t * @standard\n\t */\n\tset stroke(value: StrokeInput);\n}\n/**\n * A string or number that can be used as text.\n * @example\n * ```ts\n * const text: TextString = 'Hello Pixi!';\n * const text2: TextString = 12345;\n * const text3: TextString = { toString: () => 'Hello Pixi!' };\n * ```\n * @category text\n * @standard\n */\nexport type TextString = string | number | {\n\ttoString: () => string;\n};\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * This is used to allow for any text style to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyle, HTMLTextStyle } from 'pixi.js';\n * const style: AnyTextStyle = new TextStyle({ fontSize: 24 });\n * const htmlStyle: AnyTextStyle = new HTMLTextStyle({ fontSize: '24px' });\n * ```\n * @category text\n * @standard\n * @see TextStyle\n * @see HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * This is used to allow for any text style options to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyleOptions, HTMLTextStyleOptions } from 'pixi.js';\n * const styleOptions: AnyTextStyleOptions = { fontSize: 24 } as TextStyleOptions;\n * const htmlStyleOptions: AnyTextStyleOptions = { fontSize: '24px' } as HTMLTextStyleOptions;\n * ```\n * @category text\n * @standard\n * @see TextStyleOptions\n * @see HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n/**\n * Options for creating text objects in PixiJS. This interface defines the common properties\n * used across different text rendering implementations (Canvas, HTML, and Bitmap).\n * @example\n * ```ts\n * // Create basic text with minimal options\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010\n *     }\n * });\n *\n * // Create text with advanced styling\n * const styledText = new Text({\n *     text: 'Styled Text',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: new FillGradient({\n *             end: { x: 1, y: 1 },\n *             stops: [\n *                 { color: 0xff0000, offset: 0 }, // Red at start\n *                 { color: 0x0000ff, offset: 1 }, // Blue at end\n *             ]\n *         }),\n *         stroke: { color: '#4a1850', width: 5 },\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6\n *         },\n *         align: 'center'\n *     },\n *     anchor: 0.5,\n *     resolution: window.devicePixelRatio\n * });\n *\n * // Create multiline text with word wrap\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will wrap onto multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30\n *     },\n *     resolution: 2,\n *     roundPixels: true\n * });\n * ```\n * @category text\n * @standard\n * @noInheritDoc\n */\nexport interface TextOptions<TEXT_STYLE extends TextStyle = TextStyle, TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions> extends PixiMixins.TextOptions, ViewContainerOptions {\n\t/**\n\t * The anchor point of the text that controls the origin point for positioning and rotation.\n\t * Can be a number (same value for x/y) or a PointData object.\n\t * - (0,0) is top-left\n\t * - (0.5,0.5) is center\n\t * - (1,1) is bottom-right\n\t * ```ts\n\t * // Set anchor to center\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n\t * });\n\t * // Set anchor to top-left\n\t * const text2 = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: { x: 0, y: 0 } // Top-left corner\n\t * });\n\t * // Set anchor to bottom-right\n\t * const text3 = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: { x: 1, y: 1 } // Bottom-right corner\n\t * });\n\t * ```\n\t * @default { x: 0, y: 0 }\n\t */\n\tanchor?: PointData | number;\n\t/**\n\t * The text content to display. Use '\\n' for line breaks.\n\t * Accepts strings, numbers, or objects with toString() method.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t * });\n\t * const multilineText = new Text({\n\t *     text: 'Line 1\\nLine 2\\nLine 3',\n\t * });\n\t * const numberText = new Text({\n\t *     text: 12345, // Will be converted to '12345'\n\t * });\n\t * const objectText = new Text({\n\t *     text: { toString: () => 'Object Text' }, // Custom toString\n\t * });\n\t * ```\n\t * @default ''\n\t */\n\ttext?: TextString;\n\t/**\n\t * The resolution/device pixel ratio for rendering.\n\t * Higher values result in sharper text at the cost of performance.\n\t * Set to null for auto-resolution based on device.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     resolution: 2 // High DPI for sharper text\n\t * });\n\t * const autoResText = new Text({\n\t *     text: 'Auto Resolution',\n\t *     resolution: null // Use device's pixel ratio\n\t * });\n\t * ```\n\t * @default null\n\t */\n\tresolution?: number;\n\t/**\n\t * The style configuration for the text.\n\t * Can be a TextStyle instance or a configuration object.\n\t * Supports canvas text styles, HTML text styles, and bitmap text styles.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Styled Text',\n\t *     style: {\n\t *         fontSize: 24,\n\t *         fill: 0xff1010, // Red color\n\t *         fontFamily: 'Arial',\n\t *         align: 'center', // Center alignment\n\t *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n\t *         dropShadow: {\n\t *             color: '#000000', // Black shadow\n\t *             blur: 4, // Shadow blur\n\t *             distance: 6 // Shadow distance\n\t *         }\n\t *     }\n\t * });\n\t * const htmlText = new HTMLText({\n\t *     text: 'HTML Styled Text',\n\t *     style: {\n\t *         fontSize: '20px',\n\t *         fill: 'blue',\n\t *         fontFamily: 'Verdana',\n\t *     }\n\t * });\n\t * const bitmapText = new BitmapText({\n\t *     text: 'Bitmap Styled Text',\n\t *     style: {\n\t *         fontName: 'Arial',\n\t *         fontSize: 32,\n\t *     }\n\t * })\n\t */\n\tstyle?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n\t/**\n\t * Whether to round the x/y position to whole pixels.\n\t * Enabling can prevent anti-aliasing of text edges but may cause slight position shifting.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Rounded Text',\n\t *     roundPixels: true // Rounds position to whole pixels\n\t * });\n\t * @default false\n\t */\n\troundPixels?: boolean;\n}\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see Text\n * @see BitmapText\n * @see HTMLText\n * @category text\n * @advanced\n */\nexport abstract class AbstractText<TEXT_STYLE extends TextStyle = TextStyle, TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions, TEXT_OPTIONS extends TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS> = TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>, GPU_DATA extends {\n\tdestroy: () => void;\n} = any> extends ViewContainer<GPU_DATA> implements View {\n\t/** @internal */\n\tbatched: boolean;\n\t/** @internal */\n\t_anchor: ObservablePoint;\n\t/** @internal */\n\t_resolution: number;\n\t/** @internal */\n\t_autoResolution: boolean;\n\t/** @internal */\n\t_style: TEXT_STYLE;\n\t/** @internal */\n\t_didTextUpdate: boolean;\n\tprotected _text: string;\n\tprivate readonly _styleClass;\n\tconstructor(options: TEXT_OPTIONS, styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE);\n\t/**\n\t * The anchor point of the text that controls the origin point for positioning and rotation.\n\t * Can be a number (same value for x/y) or a PointData object.\n\t * - (0,0) is top-left\n\t * - (0.5,0.5) is center\n\t * - (1,1) is bottom-right\n\t * ```ts\n\t * // Set anchor to center\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n\t * });\n\t * // Set anchor to top-left\n\t * const text2 = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: { x: 0, y: 0 } // Top-left corner\n\t * });\n\t * // Set anchor to bottom-right\n\t * const text3 = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: { x: 1, y: 1 } // Bottom-right corner\n\t * });\n\t * ```\n\t * @default { x: 0, y: 0 }\n\t */\n\tget anchor(): ObservablePoint;\n\tset anchor(value: PointData | number);\n\t/**\n\t * The text content to display. Use '\\n' for line breaks.\n\t * Accepts strings, numbers, or objects with toString() method.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t * });\n\t * const multilineText = new Text({\n\t *     text: 'Line 1\\nLine 2\\nLine 3',\n\t * });\n\t * const numberText = new Text({\n\t *     text: 12345, // Will be converted to '12345'\n\t * });\n\t * const objectText = new Text({\n\t *     text: { toString: () => 'Object Text' }, // Custom toString\n\t * });\n\t *\n\t * // Update text dynamically\n\t * text.text = 'Updated Text'; // Re-renders with new text\n\t * text.text = 67890; // Updates to '67890'\n\t * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method\n\t * // Clear text\n\t * text.text = ''; // Clears the text\n\t * ```\n\t * @default ''\n\t */\n\tset text(value: TextString);\n\tget text(): string;\n\t/**\n\t * The resolution/device pixel ratio for rendering.\n\t * Higher values result in sharper text at the cost of performance.\n\t * Set to null for auto-resolution based on device.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     resolution: 2 // High DPI for sharper text\n\t * });\n\t * const autoResText = new Text({\n\t *     text: 'Auto Resolution',\n\t *     resolution: null // Use device's pixel ratio\n\t * });\n\t * ```\n\t * @default null\n\t */\n\tset resolution(value: number);\n\tget resolution(): number;\n\tget style(): TEXT_STYLE;\n\t/**\n\t * The style configuration for the text.\n\t * Can be a TextStyle instance or a configuration object.\n\t * Supports canvas text styles, HTML text styles, and bitmap text styles.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Styled Text',\n\t *     style: {\n\t *         fontSize: 24,\n\t *         fill: 0xff1010, // Red color\n\t *         fontFamily: 'Arial',\n\t *         align: 'center', // Center alignment\n\t *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n\t *         dropShadow: {\n\t *             color: '#000000', // Black shadow\n\t *             blur: 4, // Shadow blur\n\t *             distance: 6 // Shadow distance\n\t *         }\n\t *     }\n\t * });\n\t * const htmlText = new HTMLText({\n\t *     text: 'HTML Styled Text',\n\t *     style: {\n\t *         fontSize: '20px',\n\t *         fill: 'blue',\n\t *         fontFamily: 'Verdana',\n\t *     }\n\t * });\n\t * const bitmapText = new BitmapText({\n\t *     text: 'Bitmap Styled Text',\n\t *     style: {\n\t *         fontName: 'Arial',\n\t *         fontSize: 32,\n\t *     }\n\t * })\n\t *\n\t * // Update style dynamically\n\t * text.style = {\n\t *     fontSize: 30, // Change font size\n\t *     fill: 0x00ff00, // Change color to green\n\t *     align: 'right', // Change alignment to right\n\t *     stroke: { color: '#000000', width: 2 }, // Add black stroke\n\t * }\n\t */\n\tset style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS);\n\t/**\n\t * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n\t * @example\n\t * ```ts\n\t * // Set width directly\n\t * texture.width = 200;\n\t * console.log(texture.scale.x); // Scale adjusted to match width\n\t *\n\t * // For better performance when setting both width and height\n\t * texture.setSize(300, 400); // Avoids recalculating bounds twice\n\t * ```\n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n\t * @example\n\t * ```ts\n\t * // Set height directly\n\t * texture.height = 200;\n\t * console.log(texture.scale.y); // Scale adjusted to match height\n\t *\n\t * // For better performance when setting both width and height\n\t * texture.setSize(300, 400); // Avoids recalculating bounds twice\n\t * ```\n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.\n\t * This is faster than getting width and height separately as it only calculates the bounds once.\n\t * @example\n\t * ```ts\n\t * // Basic size retrieval\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     style: { fontSize: 24 }\n\t * });\n\t * const size = text.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * text.getSize(reuseSize);\n\t * ```\n\t * @param out - Optional object to store the size in, to avoid allocating a new object\n\t * @returns The size of the Sprite\n\t * @see {@link Text#width} For getting just the width\n\t * @see {@link Text#height} For getting just the height\n\t * @see {@link Text#setSize} For setting both width and height\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Sets the size of the Text to the specified width and height.\n\t * This is faster than setting width and height separately as it only recalculates bounds once.\n\t * @example\n\t * ```ts\n\t * // Basic size setting\n\t * const text = new Text({\n\t *    text: 'Hello Pixi!',\n\t *    style: { fontSize: 24 }\n\t * });\n\t * text.setSize(100, 200); // Width: 100, Height: 200\n\t *\n\t * // Set uniform size\n\t * text.setSize(100); // Sets both width and height to 100\n\t *\n\t * // Set size with object\n\t * text.setSize({\n\t *     width: 200,\n\t *     height: 300\n\t * });\n\t * ```\n\t * @param value - This can be either a number or a {@link Size} object\n\t * @param height - The height to set. Defaults to the value of `width` if not provided\n\t * @see {@link Text#width} For setting width only\n\t * @see {@link Text#height} For setting height only\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n\t/**\n\t * Checks if the object contains the given point in local coordinates.\n\t * Uses the text's bounds for hit testing.\n\t * @example\n\t * ```ts\n\t * // Basic point check\n\t * const localPoint = { x: 50, y: 25 };\n\t * const contains = text.containsPoint(localPoint);\n\t * console.log('Point is inside:', contains);\n\t * ```\n\t * @param point - The point to check in local coordinates\n\t * @returns True if the point is within the text's bounds\n\t * @see {@link Container#toLocal} For converting global coordinates to local\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/** @internal */\n\tonViewUpdate(): void;\n\t/**\n\t * Destroys this text renderable and optionally its style texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * // Destroys the text and its style\n\t * text.destroy({ style: true, texture: true, textureSource: true });\n\t * text.destroy(true);\n\t * text.destroy() // Destroys the text, but not its style\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * Returns a unique key for this instance.\n\t * This key is used for caching.\n\t * @returns {string} Unique key for the instance\n\t */\n\tget styleKey(): string;\n}\n/**\n * Helper function to ensure consistent handling of text options across different text classes.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureTextOptions([{\n *     text: \"Hello\",\n *     style: { fontSize: 20 }\n * }], \"Text\");\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureTextOptions([\"Hello\", { fontSize: 20 }], \"Text\");\n * @param args - Arguments passed to text constructor\n * @param name - Name of the text class (used in deprecation warning)\n * @returns Normalized text options object\n * @template TEXT_OPTIONS - The type of the text options\n * @internal\n */\nexport function ensureTextOptions<TEXT_OPTIONS extends TextOptions>(args: any[], name: string): TEXT_OPTIONS;\n/** @internal */\nexport class BatchableText extends BatchableSprite {\n\tcurrentKey: string;\n}\ninterface Text$1 extends PixiMixins.Text, AbstractText<TextStyle, TextStyleOptions, CanvasTextOptions, BatchableText> {\n}\n/**\n * Constructor options used for `Text` instances. These options extend TextOptions with\n * canvas-specific features like texture styling.\n * @example\n * ```ts\n * // Create basic canvas text\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010,\n *     }\n * });\n *\n * // Create text with custom texture style\n * const customText = new Text({\n *     text: 'Custom Text',\n *     style: {\n *         fontSize: 32,\n *         fill: 0x4a4a4a\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n * ```\n * @extends TextOptions\n * @category text\n * @standard\n */\nexport interface CanvasTextOptions extends TextOptions {\n\t/**\n\t * Optional texture style to use for the text texture. This allows fine control over\n\t * how the text is rendered to a texture before being displayed.\n\t *\n\t * The texture style can affect:\n\t * - Scale mode (nearest/linear)\n\t * - Resolution\n\t * - Format (rgb/rgba)\n\t * - Alpha handling\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Crisp Text',\n\t *     textureStyle: {\n\t *         scaleMode: 'nearest', // Pixel-perfect scaling\n\t *     }\n\t * });\n\t * ```\n\t * @advanced\n\t */\n\ttextureStyle?: TextureStyle | TextureStyleOptions;\n}\n/**\n * A powerful text rendering class that creates one or multiple lines of text using the Canvas API.\n * Provides rich text styling capabilities with runtime modifications.\n *\n * Key features:\n * - Dynamic text content and styling\n * - Multi-line text support\n * - Word wrapping\n * - Custom texture styling\n * - High-quality text rendering\n * @example\n * ```ts\n * import { Text } from 'pixi.js';\n *\n * // Basic text creation\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Rich text with multiple styles\n * const richText = new Text({\n *     text: 'Styled\\nMultiline\\nText',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 36,\n *         fill: 'red',\n *         stroke: { color: '#4a1850', width: 5 },\n *         align: 'center',\n *         lineHeight: 45,\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6,\n *         }\n *     },\n *     anchor: 0.5,\n * });\n *\n * // Text with custom texture settings\n * const crispText = new Text({\n *     text: 'High Quality Text',\n *     style: {\n *         fontSize: 24,\n *         fill: 0x4a4a4a,\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n *\n * // Word-wrapped text\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will automatically wrap to multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30,\n *     }\n * });\n * ```\n *\n * Performance Considerations:\n * - Each text instance creates its own texture\n * - Texture is regenerated when text or style changes\n * - Use BitmapText for better performance with static text\n * - Consider texture style options for quality vs performance tradeoffs\n * @category text\n * @standard\n * @see {@link TextStyle} For detailed style options\n * @see {@link BitmapText} For better performance with static text\n * @see {@link HTMLText} For HTML/CSS-based text rendering\n */\ndeclare class Text$1 extends AbstractText<TextStyle, TextStyleOptions, CanvasTextOptions, BatchableText> implements View {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/**\n\t * Optional texture style to use for the text.\n\t * > [!NOTE] Text is not updated when this property is updated,\n\t * > you must update the text manually by calling `text.onViewUpdate()`\n\t * @advanced\n\t */\n\ttextureStyle?: TextureStyle;\n\t/**\n\t * @param {CanvasTextOptions} options - The options of the text.\n\t */\n\tconstructor(options?: CanvasTextOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(text?: TextString, options?: Partial<TextStyle>);\n\t/** @private */\n\tprotected updateBounds(): void;\n}\n/**\n * The accepted types to pass to the prepare system\n * @category rendering\n * @advanced\n */\nexport type PrepareSourceItem = Container | TextureSource | Texture | GraphicsContext;\n/**\n * The valid types resolved to the queue ready for upload\n * @category rendering\n * @advanced\n */\nexport type PrepareQueueItem = TextureSource | Text$1 | GraphicsContext;\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class provides the base functionality and handles processing the queue asynchronously.\n * @category rendering\n * @advanced\n */\nexport abstract class PrepareBase {\n\t/** The number of uploads to process per frame */\n\tstatic uploadsPerFrame: number;\n\t/** Reference to the renderer */\n\tprotected renderer: Renderer;\n\t/** The queue to process over a async timer */\n\tprotected queue: PrepareQueueItem[];\n\t/** Collection of callbacks to call when the uploads are finished */\n\tprotected resolves: ((value: void | PromiseLike<void>) => void)[];\n\t/** Timeout id for next processing call */\n\tprotected timeout?: number;\n\tprivate _destroyed;\n\t/**\n\t * @param {Renderer} renderer - A reference to the current renderer\n\t */\n\tconstructor(renderer: Renderer);\n\t/** Resolve the given resource type and return an item for the queue */\n\tprotected abstract resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void;\n\tprotected abstract uploadQueueItem(item: PrepareQueueItem): void;\n\t/**\n\t * Return a copy of the queue\n\t * @returns {PrepareQueueItem[]} The queue\n\t */\n\tgetQueue(): PrepareQueueItem[];\n\t/**\n\t * Add a textures or graphics resource to the queue\n\t * @param {PrepareSourceItem | PrepareSourceItem[]} resource\n\t */\n\tadd(resource: PrepareSourceItem | PrepareSourceItem[]): this;\n\t/**\n\t * Recursively add a container and its children to the queue\n\t * @param {Container} container - The container to add to the queue\n\t */\n\tprivate _addContainer;\n\t/**\n\t * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)\n\t * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource\n\t */\n\tupload(resource?: PrepareSourceItem | PrepareSourceItem[]): Promise<void>;\n\t/** eliminate duplicates before processing */\n\tdedupeQueue(): void;\n\tdestroy(): void;\n\t/** called per frame by the ticker, defer processing to next tick */\n\tprivate readonly _tick;\n\t/** process the queue up to max item limit per frame */\n\tprivate readonly _processQueue;\n\t/** Call all the resolve callbacks */\n\tprivate _resolve;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\t/**\n\t\t\t * The prepare mixin provides methods to prepare display objects for rendering.\n\t\t\t * It is used to ensure that textures and other resources are ready before rendering.\n\t\t\t * @category rendering\n\t\t\t * @advanced\n\t\t\t */\n\t\t\tprepare: PrepareBase;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ICanvas {\n\t\t}\n\t\tinterface RendererOptions {\n\t\t\tresolution?: number;\n\t\t\tfailIfMajorPerformanceCaveat?: boolean;\n\t\t\troundPixels?: boolean;\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGLOptions {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGPUOptions {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface RendererSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGLSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGPUSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface CanvasSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface RendererPipes {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGLPipes {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGPUPipes {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface CanvasPipes {\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\tgraphicsContext: GraphicsContextSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\tgraphics: GraphicsPipe;\n\t\t}\n\t\tinterface RendererOptions {\n\t\t\t/**\n\t\t\t * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n\t\t\t * @default 0.5\n\t\t\t */\n\t\t\tbezierSmoothness: number;\n\t\t}\n\t}\n}\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions {\n\t/** The positions of the mesh. */\n\tpositions?: Float32Array;\n\t/** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n\tuvs?: Float32Array;\n\t/** The indices of the mesh. */\n\tindices?: Uint32Array;\n\t/** The topology of the mesh. */\n\ttopology?: Topology;\n\t/** Whether to shrink the buffers to fit the data. */\n\tshrinkBuffersToFit?: boolean;\n}\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry {\n\tstatic defaultOptions: MeshGeometryOptions;\n\tbatchMode: BatchMode;\n\t/**\n\t * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n\t */\n\tconstructor(options: MeshGeometryOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n\t/** The positions of the mesh. */\n\tget positions(): Float32Array;\n\t/**\n\t * Set the positions of the mesh.\n\t * When setting the positions, its important that the uvs array is at least as long as the positions array.\n\t * otherwise the geometry will not be valid.\n\t * @param {Float32Array} value - The positions of the mesh.\n\t */\n\tset positions(value: Float32Array);\n\t/** The UVs of the mesh. */\n\tget uvs(): Float32Array;\n\t/**\n\t * Set the UVs of the mesh.\n\t * Its important that the uvs array you set is at least as long as the positions array.\n\t * otherwise the geometry will not be valid.\n\t * @param {Float32Array} value - The UVs of the mesh.\n\t */\n\tset uvs(value: Float32Array);\n\t/** The indices of the mesh. */\n\tget indices(): Uint32Array;\n\tset indices(value: Uint32Array);\n}\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement {\n\tbatcherName: string;\n\t_topology: Topology;\n\treadonly packAsQuad = false;\n\tlocation: number;\n\trenderable: ViewContainer;\n\tindexOffset: number;\n\tattributeOffset: number;\n\ttexture: Texture;\n\tgeometry: MeshGeometry;\n\ttransform: Matrix;\n\troundPixels: 0 | 1;\n\t_attributeStart: number;\n\t_batcher: Batcher;\n\t_batch: Batch;\n\t_indexStart: number;\n\t_textureId: number;\n\t_textureMatrixUpdateId: number;\n\tprivate _transformedUvs;\n\tprivate _uvUpdateId;\n\tget blendMode(): BLEND_MODES;\n\tget topology(): Topology;\n\tset topology(value: Topology);\n\treset(): void;\n\t/**\n\t * Sets the texture for the batchable mesh.\n\t * As it does so, it resets the texture matrix update ID.\n\t * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n\t * @param value - The texture to set.\n\t */\n\tsetTexture(value: Texture): void;\n\tget uvs(): Float32Array;\n\tget positions(): Float32Array;\n\tget indices(): Uint32Array;\n\tget color(): number;\n\tget groupTransform(): Matrix;\n\tget attributeSize(): number;\n\tget indexSize(): number;\n}\n/**\n * Does exactly the same as getGlobalBounds, but does instead makes use of transforming AABBs\n * of the various children within the scene graph. This is much faster, but less accurate.\n *\n * Deprecated, use container.getFastGlobalBounds() instead.\n *\n * the result will never be smaller - only ever slightly larger (in most cases, it will be the same).\n * @param target - The target container to get the bounds from\n * @param bounds - The output bounds object.\n * @returns The bounds.\n * @deprecated since 8.7.0\n * @see container.getFastGlobalBounds\n * @internal\n */\nexport function getFastGlobalBounds(target: Container, bounds: Bounds): Bounds;\n/**\n * Gets the global bounds of a container, including all its children\n * @param target - The target container to get the bounds from\n * @param skipUpdateTransform - If true, the transform will not be updated before calculating bounds.\n * @param bounds - The output bounds object.\n * @returns The bounds.\n * @internal\n */\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds;\n/**\n * @param target\n * @param parentTransform\n * @internal\n */\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix): Matrix;\n/**\n * @param target\n * @param bounds\n * @param relativeMatrix\n * @internal\n */\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds;\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds;\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\n/** @internal */\nexport const matrixPool: Pool<MatrixPoolItem>;\n/** @internal */\nexport const boundsPool: Pool<BoundsPoolItem>;\n/** @ignore */\nexport interface CacheAsTextureMixinConstructor {\n\tcacheAsTexture?: (val: boolean | CacheAsTextureOptions) => void;\n}\n/**\n * The CacheAsTextureMixin interface provides methods and properties for caching a container as a texture.\n * This can improve rendering performance for complex static containers by allowing them to be rendered as a single texture.\n * It includes methods to enable or disable caching, update the cached texture, and check\n * 1if the container is currently cached.\n * @category scene\n * @advanced\n */\nexport interface CacheAsTextureMixin extends Required<CacheAsTextureMixinConstructor> {\n\t/**\n\t * Caches this container as a texture. This allows the container to be rendered as a single texture,\n\t * which can improve performance for complex static containers.\n\t * @example\n\t * ```ts\n\t * // Basic caching\n\t * container.cacheAsTexture(true);\n\t *\n\t * // With custom options\n\t * container.cacheAsTexture({\n\t *     resolution: 2,\n\t *     antialias: true,\n\t * });\n\t *\n\t * // Disable caching\n\t * container.cacheAsTexture(false);\n\t *\n\t * // Cache a complex UI\n\t * const ui = new Container();\n\t * // Add multiple children...\n\t * ui.cacheAsTexture(true);\n\t * ui.updateCacheTexture(); // Update if contents change\n\t * ```\n\t * @param val - If true, enables caching with default options.\n\t *             If false, disables caching.\n\t *             Can also pass options object to configure caching behavior.\n\t * @see {@link Container#updateCacheTexture} For updating cached content\n\t * @see {@link Container#isCachedAsTexture} For checking cache state\n\t */\n\tcacheAsTexture: (val: boolean | CacheAsTextureOptions) => void;\n\t/**\n\t * Updates the cached texture of this container. This will flag the container's cached texture\n\t * to be redrawn on the next render.\n\t * @example\n\t * ```ts\n\t * // Basic update after changes\n\t * container.updateCacheTexture();\n\t * ```\n\t */\n\tupdateCacheTexture: () => void;\n\t/**\n\t * Legacy property for backwards compatibility with PixiJS v7 and below.\n\t * Use `cacheAsTexture` instead.\n\t * @deprecated since 8.0.0\n\t */\n\tcacheAsBitmap: boolean;\n\t/**\n\t * Whether this container is currently cached as a texture.\n\t * @example\n\t * ```ts\n\t * // Check cache state\n\t * if (container.isCachedAsTexture) {\n\t *     console.log('Container is cached');\n\t * }\n\t * ```\n\t * @readonly\n\t * @see {@link Container#cacheAsTexture} For enabling caching\n\t * @see {@link Container#updateCacheTexture} For updating cache\n\t */\n\treadonly isCachedAsTexture: boolean;\n}\n/** @internal */\nexport const cacheAsTextureMixin: Partial<Container>;\n/**\n * Mixin interface for containers that allows them to manage children.\n * It provides methods for adding, removing, and manipulating child containers.\n * @category scene\n * @advanced\n */\nexport interface ChildrenHelperMixin<C = ContainerChild> {\n\t/** @internal */\n\tallowChildren: boolean;\n\taddChild<U extends C[]>(...children: U): U[0];\n\tremoveChild<U extends C[]>(...children: U): U[0];\n\t/**\n\t * Removes all children from this container that are within the begin and end indexes.\n\t * @example\n\t * ```ts\n\t * // Remove all children\n\t * container.removeChildren();\n\t *\n\t * // Remove first 3 children\n\t * const removed = container.removeChildren(0, 3);\n\t * console.log('Removed:', removed.length); // 3\n\t *\n\t * // Remove children from index 2 onwards\n\t * container.removeChildren(2);\n\t *\n\t * // Remove specific range\n\t * const middle = container.removeChildren(1, 4);\n\t * ```\n\t * @param {number} beginIndex - The beginning position\n\t * @param {number} endIndex - The ending position. Default is container size\n\t * @returns List of removed children\n\t * @throws {RangeError} If begin/end indexes are invalid\n\t * @see {@link Container#addChild} For adding children\n\t * @see {@link Container#removeChild} For removing specific children\n\t */\n\tremoveChildren(beginIndex?: number, endIndex?: number): C[];\n\t/**\n\t * Removes a child from the specified index position.\n\t * @example\n\t * ```ts\n\t * // Remove first child\n\t * const removed = container.removeChildAt(0);\n\t *\n\t * // type safe access\n\t * const sprite = container.removeChildAt<Sprite>(1);\n\t *\n\t * // With error handling\n\t * try {\n\t *     const child = container.removeChildAt(10);\n\t * } catch (e) {\n\t *     console.warn('Index out of bounds');\n\t * }\n\t * ```\n\t * @param {number} index - The index to remove the child from\n\t * @returns The child that was removed\n\t * @throws {Error} If index is out of bounds\n\t * @see {@link Container#removeChild} For removing specific children\n\t * @see {@link Container#removeChildren} For removing multiple children\n\t */\n\tremoveChildAt<U extends C>(index: number): U;\n\t/**\n\t * Returns the child at the specified index.\n\t * @example\n\t * ```ts\n\t * // Get first child\n\t * const first = container.getChildAt(0);\n\t *\n\t * // Type-safe access\n\t * const sprite = container.getChildAt<Sprite>(1);\n\t *\n\t * // With error handling\n\t * try {\n\t *     const child = container.getChildAt(10);\n\t * } catch (e) {\n\t *     console.warn('Index out of bounds');\n\t * }\n\t * ```\n\t * @param {number} index - The index to get the child from\n\t * @returns The child at the given index\n\t * @throws {Error} If index is out of bounds\n\t * @see {@link Container#children} For direct array access\n\t * @see {@link Container#getChildByLabel} For name-based lookup\n\t */\n\tgetChildAt<U extends C>(index: number): U;\n\t/**\n\t * Changes the position of an existing child in the container.\n\t * @example\n\t * ```ts\n\t * // Basic index change\n\t * container.setChildIndex(sprite, 0); // Move to front\n\t * container.setChildIndex(sprite, container.children.length - 1); // Move to back\n\t *\n\t * // With error handling\n\t * try {\n\t *     container.setChildIndex(sprite, 5);\n\t * } catch (e) {\n\t *     console.warn('Invalid index or child not found');\n\t * }\n\t * ```\n\t * @param {Container}child - The child Container instance to reposition\n\t * @param {number}index - The resulting index number for the child\n\t * @throws {Error} If index is out of bounds\n\t * @throws {Error} If child is not in container\n\t * @see {@link Container#getChildIndex} For getting current index\n\t * @see {@link Container#swapChildren} For swapping positions\n\t */\n\tsetChildIndex(child: C, index: number): void;\n\t/**\n\t * Returns the index position of a child Container instance.\n\t * @example\n\t * ```ts\n\t * // Basic index lookup\n\t * const index = container.getChildIndex(sprite);\n\t * console.log(`Sprite is at index ${index}`);\n\t *\n\t * // With error handling\n\t * try {\n\t *     const index = container.getChildIndex(sprite);\n\t * } catch (e) {\n\t *     console.warn('Child not found in container');\n\t * }\n\t * ```\n\t * @param {Container} child - The Container instance to identify\n\t * @returns The index position of the child container\n\t * @throws {Error} If child is not in this container\n\t * @see {@link Container#setChildIndex} For changing index\n\t * @see {@link Container#children} For direct array access\n\t */\n\tgetChildIndex(child: C): number;\n\t/**\n\t * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n\t * If the child is already in this container, it will be moved to the specified index.\n\t * @example\n\t * ```ts\n\t * // Add at specific index\n\t * container.addChildAt(sprite, 0); // Add to front\n\t *\n\t * // Move existing child\n\t * const index = container.children.length - 1;\n\t * container.addChildAt(existingChild, index); // Move to back\n\t *\n\t * // With error handling\n\t * try {\n\t *     container.addChildAt(sprite, 1000);\n\t * } catch (e) {\n\t *     console.warn('Index out of bounds');\n\t * }\n\t * ```\n\t * @param {Container} child - The child to add\n\t * @param {number} index - The index where the child will be placed\n\t * @returns The child that was added\n\t * @throws {Error} If index is out of bounds\n\t * @see {@link Container#addChild} For adding to the end\n\t * @see {@link Container#setChildIndex} For moving existing children\n\t */\n\taddChildAt<U extends C>(child: U, index: number): U;\n\t/**\n\t * Swaps the position of 2 Containers within this container.\n\t * @example\n\t * ```ts\n\t * // Basic swap\n\t * container.swapChildren(sprite1, sprite2);\n\t *\n\t * // With error handling\n\t * try {\n\t *     container.swapChildren(sprite1, sprite2);\n\t * } catch (e) {\n\t *     console.warn('One or both children not found in container');\n\t * }\n\t * ```\n\t * @remarks\n\t * - Updates render groups\n\t * - No effect if same child\n\t * - Triggers container changes\n\t * - Common in z-ordering\n\t * @param {Container} child - First container to swap\n\t * @param {Container} child2 - Second container to swap\n\t * @throws {Error} If either child is not in container\n\t * @see {@link Container#setChildIndex} For direct index placement\n\t * @see {@link Container#getChildIndex} For getting current positions\n\t */\n\tswapChildren<U extends C>(child: U, child2: U): void;\n\t/**\n\t * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n\t * @example\n\t * ```ts\n\t * // Basic removal\n\t * sprite.removeFromParent();\n\t *\n\t * // With validation\n\t * if (sprite.parent) {\n\t *     sprite.removeFromParent();\n\t * }\n\t * ```\n\t * @see {@link Container#addChild} For adding to a new parent\n\t * @see {@link Container#removeChild} For parent removing children\n\t */\n\tremoveFromParent(): void;\n\t/**\n\t * Reparent a child or multiple children to this container while preserving their world transform.\n\t * This ensures that the visual position and rotation of the children remain the same even when changing parents.\n\t * @example\n\t * ```ts\n\t * // Basic reparenting\n\t * const sprite = new Sprite(texture);\n\t * oldContainer.addChild(sprite);\n\t * // Move to new parent, keeping visual position\n\t * newContainer.reparentChild(sprite);\n\t *\n\t * // Reparent multiple children\n\t * const batch = [sprite1, sprite2, sprite3];\n\t * newContainer.reparentChild(...batch);\n\t * ```\n\t * @param {Container} child - The child or children to reparent\n\t * @returns The first child that was reparented\n\t * @see {@link Container#reparentChildAt} For index-specific reparenting\n\t * @see {@link Container#addChild} For simple parenting\n\t */\n\treparentChild<U extends C[]>(...child: U): U[0];\n\t/**\n\t * Reparent the child to this container at the specified index while preserving its world transform.\n\t * This ensures that the visual position and rotation of the child remain the same even when changing parents.\n\t * @example\n\t * ```ts\n\t * // Basic index-specific reparenting\n\t * const sprite = new Sprite(texture);\n\t * oldContainer.addChild(sprite);\n\t * // Move to new parent at index 0 (front)\n\t * newContainer.reparentChildAt(sprite, 0);\n\t * ```\n\t * @param {Container} child - The child to reparent\n\t * @param {number} index - The index to reparent the child to\n\t * @returns The reparented child\n\t * @throws {Error} If index is out of bounds\n\t * @see {@link Container#reparentChild} For appending reparented children\n\t * @see {@link Container#addChildAt} For simple indexed parenting\n\t */\n\treparentChildAt<U extends C>(child: U, index: number): U;\n\t/**\n\t * Replace a child in the container with a new child. Copying the local transform from the old child to the new one.\n\t * @param {Container} oldChild - The child to replace.\n\t * @param {Container} newChild - The new child to add.\n\t */\n\treplaceChild<U extends C, T extends C>(oldChild: U, newChild: T): void;\n}\n/** @internal */\nexport const childrenHelperMixin: ChildrenHelperMixin<ContainerChild>;\n/**\n * The CollectRenderablesMixin interface defines methods for collecting renderable objects\n * from a container and its children. These methods add the renderables to an instruction set,\n * which is used by the renderer to process and display the scene.\n * @category scene\n * @internal\n */\nexport interface CollectRenderablesMixin {\n\t/**\n\t * Collects all renderables from the container and its children, adding them to the instruction set.\n\t * This method decides whether to use a simple or advanced collection method based on the container's properties.\n\t * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n\t * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n\t * @param {RenderLayer} currentLayer - The current render layer being processed.\n\t * @internal\n\t */\n\tcollectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n\t/**\n\t * Collects renderables using a simple method, suitable for containers marked as simple.\n\t * This method iterates over the container's children and adds their renderables to the instruction set.\n\t * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n\t * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n\t * @param {RenderLayer} currentLayer - The current render layer being processed.\n\t * @internal\n\t */\n\tcollectRenderablesSimple(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n\t/**\n\t * Collects renderables using an advanced method, suitable for containers with complex processing needs.\n\t * This method handles additional effects and transformations that may be applied to the renderables.\n\t * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n\t * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n\t * @param {RenderLayer} currentLayer - The current render layer being processed.\n\t * @internal\n\t */\n\tcollectRenderablesWithEffects(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n}\n/**\n * The collectRenderablesMixin provides implementations for the methods defined in the CollectRenderablesMixin interface.\n * It includes logic to determine the appropriate method for collecting renderables based on the container's properties.\n * @internal\n */\nexport const collectRenderablesMixin: Partial<Container>;\n/** @ignore */\nexport interface EffectsMixinConstructor {\n\t/**\n\t * The mask to apply, which can be a Container or null.\n\t *\n\t * If null, it clears the existing mask.\n\t * @example\n\t * ```ts\n\t * // Set a mask\n\t * sprite.setMask({\n\t *     mask: graphics,\n\t *     inverse: false,\n\t * });\n\t */\n\tmask?: Mask;\n\tsetMask?: (options: Partial<MaskOptionsAndMask>) => void;\n\t/**\n\t * Sets the filters for the displayObject.\n\t * Filters are visual effects that can be applied to any display object and its children.\n\t *\n\t * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n\t * @example\n\t * ```ts\n\t * new Container({\n\t *     filters: [new BlurFilter(2), new ColorMatrixFilter()],\n\t * });\n\t * ```\n\t * @see {@link Filter} For filter base class\n\t */\n\tfilters?: Filter | readonly Filter[];\n}\n/**\n * The Mask type represents different ways to mask a display object.\n * - A number represents a mask ID.\n * - A Container represents a mask object, such as a Graphics or Sprite.\n * - null indicates that no mask is applied.\n * @example\n * ```ts\n * // Using a Container as a mask\n * const maskContainer: Mask = new Graphics();\n * // Using a mask ID\n * const maskId: Mask = 123;\n * // No mask applied\n * const noMask: Mask = null;\n * ```\n * @category scene\n * @standard\n */\nexport type Mask = number | Container | null;\n/**\n * Options for configuring mask behavior on a display object.\n * @example\n * ```ts\n * // Basic mask inversion\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true\n * });\n * ```\n * @see {@link Container#setMask} For applying masks with options\n * @see {@link Container#mask} For basic masking\n * @category scene\n * @standard\n */\nexport interface MaskOptions {\n\t/**\n\t * Whether the mask should be inverted.\n\t * When true, the masked area becomes transparent and the unmasked area becomes visible.\n\t * @default false\n\t * @example\n\t * ```ts\n\t * // Invert the mask\n\t * sprite.setMask({\n\t *     mask: graphics,\n\t *     inverse: true\n\t * });\n\t * ```\n\t */\n\tinverse: boolean;\n}\n/**\n * MaskOptionsAndMask combines MaskOptions with a Mask for configuring masking behavior.\n * Used when setting up complex masking effects with additional options.\n * @example\n * ```ts\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true,\n * });\n *\n * // Clear existing mask\n * sprite.setMask({\n *     mask: null,\n *     inverse: false,\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link Container#setMask} For applying masks\n * @see {@link MaskOptions} For base options\n */\nexport interface MaskOptionsAndMask extends MaskOptions {\n\t/**\n\t * The mask to apply, which can be a Container or null.\n\t *\n\t * If null, it clears the existing mask.\n\t * @example\n\t * ```ts\n\t * // Set a mask\n\t * sprite.setMask({\n\t *     mask: graphics,\n\t *     inverse: false,\n\t * });\n\t */\n\tmask: Mask;\n}\n/**\n * The EffectsMixin interface provides methods and properties for managing effects\n * such as masks and filters on a display object.\n * It allows for adding, removing, and configuring effects, as well as setting a mask for the display object.\n * @category scene\n * @advanced\n */\nexport interface EffectsMixin extends Required<EffectsMixinConstructor> {\n\t/** @private */\n\t_maskEffect?: MaskEffect;\n\t/** @private */\n\t_maskOptions?: MaskOptions;\n\t/** @private */\n\t_filterEffect?: FilterEffect;\n\t/** @private */\n\t_markStructureAsChanged(): void;\n\t/**\n\t * The area the filter is applied to. This is used as an optimization to define a specific region\n\t * for filter effects instead of calculating the display object bounds each frame.\n\t *\n\t * > [!NOTE]\n\t * > Setting this to a custom Rectangle allows you to define a specific area for filter effects,\n\t * > which can improve performance by avoiding expensive bounds calculations.\n\t * @example\n\t * ```ts\n\t * // Set specific filter area\n\t * container.filterArea = new Rectangle(0, 0, 100, 100);\n\t *\n\t * // Optimize filter region\n\t * const screen = app.screen;\n\t * container.filterArea = new Rectangle(\n\t *     screen.x,\n\t *     screen.y,\n\t *     screen.width,\n\t *     screen.height\n\t * );\n\t * ```\n\t * @see {@link Container#filters} For applying filters\n\t * @see {@link Rectangle} For area definition\n\t */\n\tfilterArea?: Rectangle;\n\t/**\n\t * todo Needs docs\n\t * @advanced\n\t */\n\teffects?: Effect[];\n\t/**\n\t * todo Needs docs.\n\t * @param {Effect} effect - The effect to add.\n\t * @ignore\n\t */\n\taddEffect(effect: Effect): void;\n\t/**\n\t * todo Needs docs.\n\t * @param {Effect} effect - The effect to remove.\n\t * @ignore\n\t */\n\tremoveEffect(effect: Effect): void;\n\t/**\n\t * Used to set mask and control mask options on a display object.\n\t * Allows for more detailed control over masking behavior compared to the mask property.\n\t * @example\n\t * ```ts\n\t * import { Graphics, Sprite } from 'pixi.js';\n\t *\n\t * // Create a circular mask\n\t * const graphics = new Graphics()\n\t *     .beginFill(0xFF3300)\n\t *     .drawCircle(100, 100, 50)\n\t *     .endFill();\n\t *\n\t * // Apply mask with options\n\t * sprite.setMask({\n\t *     mask: graphics,\n\t *     inverse: true, // Create a hole effect\n\t * });\n\t *\n\t * // Clear existing mask\n\t * sprite.setMask({ mask: null });\n\t * ```\n\t * @param {Partial<MaskOptionsAndMask>} options - Configuration options for the mask\n\t * @see {@link Container#mask} For simple masking\n\t * @see {@link MaskOptionsAndMask} For full options API\n\t */\n\tsetMask(options: Partial<MaskOptionsAndMask>): void;\n\t/**\n\t * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n\t * object to the shape of the mask applied to it.\n\t *\n\t * > [!IMPORTANT] In PixiJS a regular mask must be a {@link Graphics} or a {@link Sprite} object.\n\t * > This allows for much faster masking in canvas as it utilities shape clipping.\n\t * > Furthermore, a mask of an object must be in the subtree of its parent.\n\t * > Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n\t *\n\t * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n\t * @example\n\t * ```ts\n\t * // Apply mask to sprite\n\t * const sprite = new Sprite(texture);\n\t * sprite.mask = graphics;\n\t *\n\t * // Remove mask\n\t * sprite.mask = null;\n\t * ```\n\t * @see {@link Graphics} For creating mask shapes\n\t * @see {@link Sprite} For texture-based masks\n\t * @see {@link Container#setMask} For advanced mask options\n\t */\n\tmask: Mask;\n\t/**\n\t * Sets the filters for the displayObject.\n\t * Filters are visual effects that can be applied to any display object and its children.\n\t *\n\t * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n\t * @example\n\t * ```ts\n\t * // Add a single filter\n\t * sprite.filters = new BlurFilter(2);\n\t *\n\t * // Apply multiple filters\n\t * container.filters = [\n\t *     new BlurFilter(2),\n\t *     new ColorMatrixFilter(),\n\t * ];\n\t *\n\t * // Remove filters\n\t * sprite.filters = null;\n\t * ```\n\t * @see {@link Filter} For filter base class\n\t */\n\tset filters(value: Filter | Filter[] | null | undefined);\n\tget filters(): readonly Filter[];\n}\n/** @internal */\nexport const effectsMixin: Partial<Container>;\n/** @ignore */\nexport interface FindMixinConstructor {\n\t/**\n\t * The instance label of the object.\n\t * @default null\n\t */\n\tlabel?: string;\n}\n/**\n * The FindMixin interface provides methods for finding children within a container by their label.\n * It allows for searching for a single child or multiple children with a specific label,\n * either directly or recursively through the container's hierarchy.\n * @category scene\n * @advanced\n */\nexport interface FindMixin extends Required<FindMixinConstructor> {\n\t/**\n\t * The instance name of the object.\n\t * @deprecated since 8.0.0\n\t * @see Container#label\n\t * @default null\n\t */\n\tname: string;\n\t/**\n\t * @deprecated since 8.0.0\n\t * @param {string} label - Instance name.\n\t * @param {boolean}[deep=false] - Whether to search recursively\n\t * @returns {Container} The child with the specified name.\n\t * @see Container#getChildByLabel\n\t */\n\tgetChildByName(label: RegExp | string, deep?: boolean): Container | null;\n\t/**\n\t * Returns the first child in the container with the specified label.\n\t * Recursive searches are done in a pre-order traversal.\n\t * @example\n\t * ```ts\n\t * // Basic label search\n\t * const child = container.getChildByLabel('player');\n\t *\n\t * // Search with regular expression\n\t * const enemy = container.getChildByLabel(/enemy-\\d+/);\n\t *\n\t * // Deep search through children\n\t * const deepChild = container.getChildByLabel('powerup', true);\n\t * ```\n\t * @param {RegExp|string} label - Instance label to search for\n\t * @param {boolean} deep - Whether to search recursively through children\n\t * @returns The first child with the specified label, or null if none found\n\t * @see {@link Container#getChildrenByLabel} For finding all matches\n\t * @see {@link Container#label} For setting labels\n\t */\n\tgetChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n\t/**\n\t * Returns all children in the container with the specified label.\n\t * Recursive searches are done in a pre-order traversal.\n\t * @example\n\t * ```ts\n\t * // Basic label search\n\t * const enemies = container.getChildrenByLabel('enemy');\n\t * // Search with regular expression\n\t * const powerups = container.getChildrenByLabel(/powerup-\\d+/);\n\t * // Deep search with collection\n\t * const buttons = [];\n\t * container.getChildrenByLabel('button', true, buttons);\n\t * ```\n\t * @param {string|RegExp} label  - Instance label to search for\n\t * @param {boolean}[deep=false] - Whether to search recursively through children\n\t * @param {Container[]} [out=[]]  - Optional array to store matching children in\n\t * @returns An array of children with the specified label\n\t * @see {@link Container#getChildByLabel} For finding first match\n\t * @see {@link Container#label} For setting labels\n\t */\n\tgetChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n/** @internal */\nexport const findMixin: Partial<Container>;\n/**\n * Interface for the GetFastGlobalBoundsMixin, which provides methods to compute\n * an approximate global bounding box for a container and its children.\n * @category scene\n * @advanced\n */\nexport interface GetFastGlobalBoundsMixin {\n\t/**\n\t * Computes an approximate global bounding box for the container and its children.\n\t * This method is optimized for speed by using axis-aligned bounding boxes (AABBs),\n\t * and uses the last render results from when it updated the transforms. This function does not update them.\n\t * which may result in slightly larger bounds but never smaller than the actual bounds.\n\t *\n\t * for accurate (but less performant) results use `container.getGlobalBounds`\n\t * @param {boolean} [factorRenderLayers] - A flag indicating whether to consider render layers in the calculation.\n\t * @param {Bounds} [bounds] - The output bounds object to store the result. If not provided, a new one is created.\n\t * @returns {Bounds} The computed bounds.\n\t * @advanced\n\t */\n\tgetFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\t/**\n\t * Recursively calculates the global bounds for the container and its children.\n\t * This method is used internally by getFastGlobalBounds to traverse the scene graph.\n\t * @param {boolean} factorRenderLayers - A flag indicating whether to consider render layers in the calculation.\n\t * @param {Bounds} bounds - The bounds object to update with the calculated values.\n\t * @param {RenderLayer} currentLayer - The current render layer being processed.\n\t * @internal\n\t */\n\t_getGlobalBoundsRecursive(factorRenderLayers: boolean, bounds: Bounds, currentLayer: RenderLayer): void;\n}\n/**\n * Mixin providing the implementation of the GetFastGlobalBoundsMixin interface.\n * It includes methods to compute and recursively calculate global bounds for containers.\n * @internal\n */\nexport const getFastGlobalBoundsMixin: Partial<Container>;\n/**\n * Converts a color from BGR format to RGB format.\n * @param color - The color in BGR format (0xBBGGRR).\n * @returns The color in RGB format (0xRRGGBB).\n * @category utils\n * @internal\n */\nexport function bgr2rgb(color: number): number;\n/**\n * Interface for a mixin that provides methods to retrieve global properties of a container.\n * This mixin allows you to get the global alpha, transform matrix, and tint color of a container,\n * taking into account its parent containers and render groups.\n * It includes methods to optimize performance by using cached values when available.\n * @category scene\n * @advanced\n */\nexport interface GetGlobalMixin {\n\t/**\n\t * Returns the global (compound) alpha of the container within the scene.\n\t * @param {boolean} skipUpdate - Performance optimization flag:\n\t *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n\t *   - If true: Uses cached worldAlpha from the last render pass for better performance\n\t * @returns The resulting alpha value (between 0 and 1)\n\t * @example\n\t * ```ts\n\t * // Accurate but slower - recalculates entire alpha chain\n\t * const preciseAlpha = container.getGlobalAlpha();\n\t *\n\t * // Faster but may be outdated - uses cached alpha\n\t * const cachedAlpha = container.getGlobalAlpha(true);\n\t * ```\n\t */\n\tgetGlobalAlpha(skipUpdate?: boolean): number;\n\t/**\n\t * Returns the global transform matrix of the container within the scene.\n\t * @param {Matrix} matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n\t * @param {boolean} skipUpdate - Performance optimization flag:\n\t *   - If false (default): Recalculates the entire transform chain for accuracy\n\t *   - If true: Uses cached worldTransform from the last render pass for better performance\n\t * @returns The resulting transformation matrix (either the input matrix or a new one)\n\t * @example\n\t * ```ts\n\t * // Accurate but slower - recalculates entire transform chain\n\t * const preciseTransform = container.getGlobalTransform();\n\t *\n\t * // Faster but may be outdated - uses cached transform\n\t * const cachedTransform = container.getGlobalTransform(undefined, true);\n\t *\n\t * // Reuse existing matrix\n\t * const existingMatrix = new Matrix();\n\t * container.getGlobalTransform(existingMatrix);\n\t * ```\n\t */\n\tgetGlobalTransform(matrix?: Matrix, skipUpdate?: boolean): Matrix;\n\t/**\n\t * Returns the global (compound) tint color of the container within the scene.\n\t * @param {boolean} skipUpdate - Performance optimization flag:\n\t *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n\t *   - If true: Uses cached worldColor from the last render pass for better performance\n\t * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n\t * @example\n\t * ```ts\n\t * // Accurate but slower - recalculates entire tint chain\n\t * const preciseTint = container.getGlobalTint();\n\t *\n\t * // Faster but may be outdated - uses cached tint\n\t * const cachedTint = container.getGlobalTint(true);\n\t * ```\n\t */\n\tgetGlobalTint(skipUpdate?: boolean): number;\n}\n/** @internal */\nexport const getGlobalMixin: Partial<Container>;\n/** @internal */\nexport interface OnRenderMixinConstructor {\n\t/**\n\t * This callback is used when the container is rendered. It runs every frame during the render process,\n\t * making it ideal for per-frame updates and animations.\n\t *\n\t * > [!NOTE] In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n\t * > and \"updateTransform\" is no longer called every frame\n\t * @example\n\t * ```ts\n\t * // Basic rotation animation\n\t * const container = new Container();\n\t * container.onRender = () => {\n\t *     container.rotation += 0.01;\n\t * };\n\t *\n\t * // Cleanup when done\n\t * container.onRender = null; // Removes callback\n\t * ```\n\t * @param renderer - The renderer instance\n\t * @see {@link Renderer} For renderer capabilities\n\t */\n\tonRender?: ((renderer: Renderer) => void) | null;\n}\n/**\n * The OnRenderMixin interface provides a way to define a callback that is executed\n * every time the container is rendered. This is useful for adding custom rendering logic\n * or animations that need to be updated each frame.\n * @category scene\n * @advanced\n */\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor> {\n\t/** @private */\n\t_onRender: ((renderer: Renderer) => void) | null;\n}\n/** @internal */\nexport const onRenderMixin: Partial<Container>;\n/** @ignore */\nexport interface SortMixinConstructor {\n\t/**\n\t * The zIndex of the container.\n\t *\n\t * Controls the rendering order of children within their parent container.\n\t *\n\t * A higher value will mean it will be moved towards the front of the rendering order.\n\t * @example\n\t * ```ts\n\t * // Add in any order\n\t * container.addChild(character, background, foreground);\n\t *\n\t * // Adjust rendering order\n\t * background.zIndex = 0;\n\t * character.zIndex = 1;\n\t * foreground.zIndex = 2;\n\t * ```\n\t * @see {@link Container#sortableChildren} For enabling sorting\n\t * @see {@link Container#sortChildren} For manual sorting\n\t * @default 0\n\t */\n\tzIndex?: number;\n\t/**\n\t * Should children be sorted by zIndex at the next render call.\n\t *\n\t * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n\t * @default false\n\t * @internal\n\t */\n\tsortDirty?: boolean;\n\t/**\n\t * If set to true, the container will sort its children by `zIndex` value\n\t * when the next render is called, or manually if `sortChildren()` is called.\n\t *\n\t * This actually changes the order of elements in the array of children,\n\t * so it will affect the rendering order.\n\t *\n\t * > [!NOTE] Also be aware of that this may not work nicely with the `addChildAt()` function,\n\t * > as the `zIndex` sorting may cause the child to automatically sorted to another position.\n\t * @example\n\t * ```ts\n\t * container.sortableChildren = true;\n\t * ```\n\t * @default false\n\t */\n\tsortableChildren?: boolean;\n}\n/**\n * The SortMixin interface provides methods and properties for sorting children of a container\n * based on their `zIndex` values. It allows for automatic sorting of children when their `zIndex`\n * changes or when new children are added. The mixin includes properties to manage sorting state\n * and methods to sort children explicitly.\n * @category scene\n * @advanced\n */\nexport interface SortMixin extends Required<SortMixinConstructor> {\n\t/** @internal */\n\t_zIndex: number;\n\t/**\n\t * Sorts children by zIndex value. Only sorts if container is marked as dirty.\n\t * @example\n\t * ```ts\n\t * // Basic sorting\n\t * particles.zIndex = 2;     // Will mark as dirty\n\t * container.sortChildren();\n\t * ```\n\t * @see {@link Container#sortableChildren} For enabling automatic sorting\n\t * @see {@link Container#zIndex} For setting child order\n\t */\n\tsortChildren: () => void;\n\t/** @internal */\n\tdepthOfChildModified: () => void;\n}\n/** @internal */\nexport const sortMixin: Partial<Container>;\n/**\n * Interface for a mixin that provides methods to convert between local and global coordinates.\n * This mixin allows you to get the global position of a container,\n * convert a point from local to global coordinates,\n * and convert a point from global to local coordinates.\n *\n * It includes methods to optimize performance by using cached matrices when available.\n * @category scene\n * @advanced\n */\nexport interface ToLocalGlobalMixin {\n\t/**\n\t * Returns the global position of the container, taking into account the container hierarchy.\n\t * @example\n\t * ```ts\n\t * // Basic position check\n\t * const globalPos = sprite.getGlobalPosition();\n\t * console.log(`Global: (${globalPos.x}, ${globalPos.y})`);\n\t *\n\t * // Reuse point object\n\t * const point = new Point();\n\t * sprite.getGlobalPosition(point);\n\t *\n\t * // Skip transform update for performance\n\t * const fastPos = container.getGlobalPosition(undefined, true);\n\t * ```\n\t * @param {Point} point - The optional point to write the global value to\n\t * @param {boolean} skipUpdate - Should we skip the update transform\n\t * @returns The updated point\n\t * @see {@link Container#toGlobal} For converting specific points\n\t * @see {@link Container#toLocal} For converting to local space\n\t */\n\tgetGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n\t/**\n\t * Calculates the global position of a point relative to this container.\n\t * Takes into account the container hierarchy and transforms.\n\t * @example\n\t * ```ts\n\t * // Basic point conversion\n\t * const localPoint = { x: 10, y: 20 };\n\t * const globalPoint = container.toGlobal(localPoint);\n\t *\n\t * // With point reuse\n\t * const reusePoint = new Point();\n\t * container.toGlobal(localPoint, reusePoint);\n\t *\n\t * // Performance optimization\n\t * const fastPoint = container.toGlobal(\n\t *     { x: 50, y: 50 },\n\t *     undefined,\n\t *     true // Skip transform update\n\t * );\n\t * ```\n\t * @param {PointData} position - The local point to convert\n\t * @param {P} point - Optional point to store the result\n\t * @param {boolean} skipUpdate - Whether to skip transform updates\n\t * @returns The global position\n\t * @see {@link Container#toLocal} For reverse conversion\n\t * @see {@link Container#getGlobalPosition} For container position\n\t */\n\ttoGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n\t/**\n\t * Calculates the local position of the container relative to another point.\n\t * Converts coordinates from any coordinate space to this container's local coordinate space.\n\t * @example\n\t * ```ts\n\t * // Basic coordinate conversion\n\t * const worldPoint = { x: 100, y: 100 };\n\t * const localPos = container.toLocal(worldPoint);\n\t *\n\t * // Convert from another container\n\t * const fromSprite = new Sprite(texture);\n\t * fromSprite.position.set(50, 50);\n\t * const pointInSprite = { x: 10, y: 10 };\n\t * const localPoint = container.toLocal(pointInSprite, fromSprite);\n\t *\n\t * // With point reuse for performance\n\t * const reusePoint = new Point();\n\t * container.toLocal(worldPoint, undefined, reusePoint);\n\t *\n\t * // Skip transform update for static objects\n\t * const fastLocal = container.toLocal(\n\t *     worldPoint,\n\t *     undefined,\n\t *     undefined,\n\t *     true\n\t * );\n\t * ```\n\t * @param {PointData} position - The world origin to calculate from\n\t * @param {Container} from - The Container to calculate the global position from\n\t * @param {P} point - A Point object in which to store the value\n\t * @param {boolean} skipUpdate - Should we skip the update transform\n\t * @returns A point object representing the position in local space\n\t * @see {@link Container#toGlobal} For reverse conversion\n\t * @see {@link Container#getGlobalPosition} For container position\n\t */\n\ttoLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n/** @internal */\nexport const toLocalGlobalMixin: Partial<Container>;\n/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n * @category utils\n * @internal\n */\nexport function assignWithIgnore<T extends Record<string, any>>(target: T, options: T, ignore?: Record<string, boolean>): void;\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n * @internal\n */\nexport function checkChildrenDidChange(container: Container, previousData: {\n\tdata: number[];\n\tindex: number;\n\tdidChange: boolean;\n}): boolean;\n/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n * @category utils\n * @internal\n */\nexport function clearList(list: Array<unknown>, index?: number): void;\n/**\n * Deprecated, please use container.collectRenderables instead.\n * @param container - The container to collect renderables from.\n * @param instructionSet - The instruction set to add the renderables to.\n * @param rendererOrPipes - The renderer to collect the renderables from.\n * @deprecated since version 8.7.0\n * @see container.collectRenderables\n * @internal\n */\nexport function collectAllRenderables(container: Container, instructionSet: InstructionSet, rendererOrPipes: Renderer | RenderPipes): void;\n/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @category utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T;\n/**\n * @param renderGroup\n * @param renderer\n * @internal\n */\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes): void;\n/**\n * @param localBGRColor\n * @param parentBGRColor\n * @internal\n */\nexport function multiplyColors(localBGRColor: number, parentBGRColor: number): number;\n/**\n * @param color1\n * @param color2\n * @internal\n */\nexport function multiplyHexColors(color1: number, color2: number): number;\n/**\n * Updates the local transform of a container based on its properties.\n * @param lt - The matrix to update with the local transform values.\n * @param container - The container whose local transform is being updated.\n * @deprecated\n * @internal\n */\nexport function updateLocalTransform(lt: Matrix, container: Container): void;\n/**\n * @param renderGroup\n * @param updateChildRenderGroups\n * @internal\n */\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups?: boolean): void;\n/**\n * @param renderGroup\n * @internal\n */\nexport function updateRenderGroupTransform(renderGroup: RenderGroup): void;\n/**\n * @param container\n * @param updateTick\n * @param updateFlags\n * @internal\n */\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number): void;\n/**\n * @param local\n * @param parent\n * @param world\n * @deprecated\n * @internal\n */\nexport function updateWorldTransform(local: Matrix, parent: Matrix, world: Matrix): void;\n/**\n * @param renderGroup\n * @param renderPipes\n * @internal\n */\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean;\n/**\n * A GraphicsAdaptor that uses WebGL to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GlGraphicsAdaptor implements GraphicsAdaptor {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipesAdaptor\n\t\t];\n\t\treadonly name: \"graphics\";\n\t};\n\tshader: Shader;\n\tcontextChange(renderer: Renderer): void;\n\texecute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n\tdestroy(): void;\n}\n/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number): void;\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number): void;\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUPipesAdaptor\n\t\t];\n\t\treadonly name: \"graphics\";\n\t};\n\tshader: Shader;\n\tprivate _maxTextures;\n\tcontextChange(renderer: Renderer): void;\n\texecute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n\tdestroy(): void;\n}\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param cp2x\n * @param cp2y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveBezier(points: number[], sX: number, sY: number, cp1x: number, cp1y: number, cp2x: number, cp2y: number, eX: number, eY: number, smoothness?: number): number[];\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveQuadratic(points: number[], sX: number, sY: number, cp1x: number, cp1y: number, eX: number, eY: number, smoothness?: number): number[];\n/**\n * @param points\n * @param x\n * @param y\n * @param radius\n * @param start\n * @param end\n * @param clockwise\n * @param steps\n * @internal\n */\nexport function buildArc(points: number[], x: number, y: number, radius: number, start: number, end: number, clockwise: boolean, steps?: number): void;\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n * @internal\n */\nexport function buildArcTo(points: number[], x1: number, y1: number, x2: number, y2: number, radius: number): void;\n/**\n * @param points\n * @param px\n * @param py\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param xAxisRotation\n * @param largeArcFlag\n * @param sweepFlag\n * @internal\n */\nexport function buildArcToSvg(points: number[], px: number, py: number, cx: number, cy: number, rx: number, ry: number, xAxisRotation?: number, largeArcFlag?: number, sweepFlag?: number): void;\n/**\n * The Circle object represents a circle shape in a two-dimensional coordinate system.\n * Used for drawing graphics and specifying hit areas for containers.\n * @example\n * ```ts\n * // Basic circle creation\n * const circle = new Circle(100, 100, 50);\n *\n * // Use as hit area\n * container.hitArea = new Circle(0, 0, 100);\n *\n * // Check point containment\n * const isInside = circle.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = circle.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and radius\n * - Supports point containment tests\n * - Can check stroke intersections\n * @see {@link Rectangle} For rectangular shapes\n * @category maths\n * @standard\n */\nexport class Circle implements ShapePrimitive {\n\t/**\n\t * The X coordinate of the center of this circle\n\t * @example\n\t * ```ts\n\t * // Basic x position\n\t * const circle = new Circle();\n\t * circle.x = 100;\n\t *\n\t * // Center circle on point\n\t * circle.x = point.x;\n\t * ```\n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the center of this circle\n\t * @example\n\t * ```ts\n\t * // Basic y position\n\t * const circle = new Circle();\n\t * circle.y = 200;\n\t *\n\t * // Center circle on point\n\t * circle.y = point.y;\n\t * ```\n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The radius of the circle\n\t * @example\n\t * ```ts\n\t * // Basic radius setting\n\t * const circle = new Circle(100, 100);\n\t * circle.radius = 50;\n\t *\n\t * // Calculate area\n\t * const area = Math.PI * circle.radius * circle.radius;\n\t * ```\n\t * @default 0\n\t */\n\tradius: number;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks.\n\t * @example\n\t * ```ts\n\t * // Check shape type\n\t * const shape = new Circle(0, 0, 50);\n\t * console.log(shape.type); // 'circle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'circle') {\n\t *     console.log(shape.radius);\n\t * }\n\t * ```\n\t * @remarks\n\t * - Used for shape type checking\n\t * - More efficient than instanceof\n\t * - Read-only property\n\t * @readonly\n\t * @default 'circle'\n\t * @see {@link SHAPE_PRIMITIVE} For all shape types\n\t * @see {@link ShapePrimitive} For shape interface\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * @param x - The X coordinate of the center of this circle\n\t * @param y - The Y coordinate of the center of this circle\n\t * @param radius - The radius of the circle\n\t */\n\tconstructor(x?: number, y?: number, radius?: number);\n\t/**\n\t * Creates a clone of this Circle instance.\n\t * @example\n\t * ```ts\n\t * // Basic circle cloning\n\t * const original = new Circle(100, 100, 50);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.radius = 75;\n\t *\n\t * // Verify independence\n\t * console.log(original.radius); // 50\n\t * console.log(modified.radius); // 75\n\t * ```\n\t * @returns A copy of the Circle\n\t * @see {@link Circle.copyFrom} For copying into existing circle\n\t * @see {@link Circle.copyTo} For copying to another circle\n\t */\n\tclone(): Circle;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this circle.\n\t *\n\t * Uses the distance formula to determine if a point is inside the circle's radius.\n\t *\n\t * Commonly used for hit testing in PixiJS events and graphics.\n\t * @example\n\t * ```ts\n\t * // Basic containment check\n\t * const circle = new Circle(100, 100, 50);\n\t * const isInside = circle.contains(120, 120);\n\t *\n\t * // Check mouse position\n\t * const circle = new Circle(0, 0, 100);\n\t * container.hitArea = circle;\n\t * container.on('pointermove', (e) => {\n\t *     // only called if pointer is within circle\n\t * });\n\t * ```\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Circle\n\t * @see {@link Circle.strokeContains} For checking stroke intersection\n\t * @see {@link Circle.getBounds} For getting bounding box\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n\t * @example\n\t * ```ts\n\t * // Basic stroke check\n\t * const circle = new Circle(100, 100, 50);\n\t * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside\n\t * ```\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param width - The width of the line to check\n\t * @param alignment - The alignment of the stroke, 0.5 by default\n\t * @returns Whether the x/y coordinates are within this Circle's stroke\n\t * @see {@link Circle.contains} For checking fill containment\n\t * @see {@link Circle.getBounds} For getting stroke bounds\n\t */\n\tstrokeContains(x: number, y: number, width: number, alignment?: number): boolean;\n\t/**\n\t * Returns the framing rectangle of the circle as a Rectangle object.\n\t * @example\n\t * ```ts\n\t * // Basic bounds calculation\n\t * const circle = new Circle(100, 100, 50);\n\t * const bounds = circle.getBounds();\n\t * // bounds: x=50, y=50, width=100, height=100\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * circle.getBounds(rect);\n\t * ```\n\t * @param out - Optional Rectangle object to store the result\n\t * @returns The framing rectangle\n\t * @see {@link Rectangle} For rectangle properties\n\t * @see {@link Circle.contains} For point containment\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Copies another circle to this one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Circle(100, 100, 50);\n\t * const target = new Circle();\n\t * target.copyFrom(source);\n\t * ```\n\t * @param circle - The circle to copy from\n\t * @returns Returns itself\n\t * @see {@link Circle.copyTo} For copying to another circle\n\t * @see {@link Circle.clone} For creating new circle copy\n\t */\n\tcopyFrom(circle: Circle): this;\n\t/**\n\t * Copies this circle to another one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Circle(100, 100, 50);\n\t * const target = new Circle();\n\t * source.copyTo(target);\n\t * ```\n\t * @param circle - The circle to copy to\n\t * @returns Returns given parameter\n\t * @see {@link Circle.copyFrom} For copying from another circle\n\t * @see {@link Circle.clone} For creating new circle copy\n\t */\n\tcopyTo(circle: Circle): Circle;\n\ttoString(): string;\n}\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @example\n * ```ts\n * // Basic ellipse creation\n * const ellipse = new Ellipse(100, 100, 20, 10);\n *\n * // Use as a hit area\n * container.hitArea = new Ellipse(0, 0, 50, 25);\n *\n * // Check point containment\n * const isInside = ellipse.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = ellipse.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and half dimensions\n * - Total width = halfWidth * 2\n * - Total height = halfHeight * 2\n * @see {@link Rectangle} For rectangular shapes\n * @see {@link Circle} For circular shapes\n * @category maths\n * @standard\n */\nexport class Ellipse implements ShapePrimitive {\n\t/**\n\t * The X coordinate of the center of this ellipse\n\t * @example\n\t * ```ts\n\t * // Basic x position\n\t * const ellipse = new Ellipse();\n\t * ellipse.x = 100;\n\t * ```\n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the center of this ellipse\n\t * @example\n\t * ```ts\n\t * // Basic y position\n\t * const ellipse = new Ellipse();\n\t * ellipse.y = 200;\n\t * ```\n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The half width of this ellipse\n\t * @example\n\t * ```ts\n\t * // Set half width\n\t * const ellipse = new Ellipse(100, 100);\n\t * ellipse.halfWidth = 50; // Total width will be 100\n\t * ```\n\t * @default 0\n\t */\n\thalfWidth: number;\n\t/**\n\t * The half height of this ellipse\n\t * @example\n\t * ```ts\n\t * // Set half height\n\t * const ellipse = new Ellipse(100, 100);\n\t * ellipse.halfHeight = 25; // Total height will be 50\n\t * ```\n\t * @default 0\n\t */\n\thalfHeight: number;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * ```ts\n\t * // Check shape type\n\t * const shape = new Ellipse(0, 0, 50, 25);\n\t * console.log(shape.type); // 'ellipse'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'ellipse') {\n\t *     console.log(shape.halfWidth, shape.halfHeight);\n\t * }\n\t * ```\n\t * @readonly\n\t * @default 'ellipse'\n\t * @see {@link SHAPE_PRIMITIVE} For all shape types\n\t */\n\treadonly type = \"ellipse\";\n\t/**\n\t * @param x - The X coordinate of the center of this ellipse\n\t * @param y - The Y coordinate of the center of this ellipse\n\t * @param halfWidth - The half width of this ellipse\n\t * @param halfHeight - The half height of this ellipse\n\t */\n\tconstructor(x?: number, y?: number, halfWidth?: number, halfHeight?: number);\n\t/**\n\t * Creates a clone of this Ellipse instance.\n\t * @example\n\t * ```ts\n\t * // Basic cloning\n\t * const original = new Ellipse(100, 100, 50, 25);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.halfWidth *= 2;\n\t * modified.halfHeight *= 2;\n\t *\n\t * // Verify independence\n\t * console.log(original.halfWidth);  // 50\n\t * console.log(modified.halfWidth);  // 100\n\t * ```\n\t * @returns A copy of the ellipse\n\t * @see {@link Ellipse.copyFrom} For copying into existing ellipse\n\t * @see {@link Ellipse.copyTo} For copying to another ellipse\n\t */\n\tclone(): Ellipse;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this ellipse.\n\t * Uses normalized coordinates and the ellipse equation to determine containment.\n\t * @example\n\t * ```ts\n\t * // Basic containment check\n\t * const ellipse = new Ellipse(100, 100, 50, 25);\n\t * const isInside = ellipse.contains(120, 110);\n\t * ```\n\t * @remarks\n\t * - Uses ellipse equation (x/a + y/b  1)\n\t * - Returns false if dimensions are 0 or negative\n\t * - Normalized to center (0,0) for calculation\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coords are within this ellipse\n\t * @see {@link Ellipse.strokeContains} For checking stroke intersection\n\t * @see {@link Ellipse.getBounds} For getting containing rectangle\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this ellipse including stroke.\n\t * @example\n\t * ```ts\n\t * // Basic stroke check\n\t * const ellipse = new Ellipse(100, 100, 50, 25);\n\t * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside\n\t * ```\n\t * @remarks\n\t * - Uses normalized ellipse equations\n\t * - Considers stroke alignment\n\t * - Returns false if dimensions are 0\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coords are within this ellipse's stroke\n\t * @see {@link Ellipse.contains} For checking fill containment\n\t * @see {@link Ellipse.getBounds} For getting stroke bounds\n\t */\n\tstrokeContains(x: number, y: number, strokeWidth: number, alignment?: number): boolean;\n\t/**\n\t * Returns the framing rectangle of the ellipse as a Rectangle object.\n\t * @example\n\t * ```ts\n\t * // Basic bounds calculation\n\t * const ellipse = new Ellipse(100, 100, 50, 25);\n\t * const bounds = ellipse.getBounds();\n\t * // bounds: x=50, y=75, width=100, height=50\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * ellipse.getBounds(rect);\n\t * ```\n\t * @remarks\n\t * - Creates Rectangle if none provided\n\t * - Top-left is (x-halfWidth, y-halfHeight)\n\t * - Width is halfWidth * 2\n\t * - Height is halfHeight * 2\n\t * @param out - Optional Rectangle object to store the result\n\t * @returns The framing rectangle\n\t * @see {@link Rectangle} For rectangle properties\n\t * @see {@link Ellipse.contains} For checking if a point is inside\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Copies another ellipse to this one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Ellipse(100, 100, 50, 25);\n\t * const target = new Ellipse();\n\t * target.copyFrom(source);\n\t * ```\n\t * @param ellipse - The ellipse to copy from\n\t * @returns Returns itself\n\t * @see {@link Ellipse.copyTo} For copying to another ellipse\n\t * @see {@link Ellipse.clone} For creating new ellipse copy\n\t */\n\tcopyFrom(ellipse: Ellipse): this;\n\t/**\n\t * Copies this ellipse to another one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Ellipse(100, 100, 50, 25);\n\t * const target = new Ellipse();\n\t * source.copyTo(target);\n\t * ```\n\t * @param ellipse - The ellipse to copy to\n\t * @returns Returns given parameter\n\t * @see {@link Ellipse.copyFrom} For copying from another ellipse\n\t * @see {@link Ellipse.clone} For creating new ellipse copy\n\t */\n\tcopyTo(ellipse: Ellipse): Ellipse;\n\ttoString(): string;\n}\n/**\n * The `RoundedRectangle` object represents a rectangle with rounded corners.\n * Defined by position, dimensions and corner radius.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n * // Use as container hit area\n * container.hitArea = new RoundedRectangle(0, 0, 100, 100, 10);\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n * // Get bounds\n * const bounds = rect.getBounds();\n * ```\n * @remarks\n * - Position defined by top-left corner\n * - Radius clamped to half smallest dimension\n * - Common in UI elements\n * @see {@link Rectangle} For non-rounded rectangles\n * @category maths\n * @standard\n */\nexport class RoundedRectangle implements ShapePrimitive {\n\t/**\n\t * The X coordinate of the upper-left corner of the rounded rectangle\n\t * @example\n\t * ```ts\n\t * // Basic x position\n\t * const rect = new RoundedRectangle();\n\t * rect.x = 100;\n\t * ```\n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the upper-left corner of the rounded rectangle\n\t * @example\n\t * ```ts\n\t * // Basic y position\n\t * const rect = new RoundedRectangle();\n\t * rect.y = 100;\n\t * ```\n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The overall width of this rounded rectangle\n\t * @example\n\t * ```ts\n\t * // Basic width setting\n\t * const rect = new RoundedRectangle();\n\t * rect.width = 200; // Total width will be 200\n\t * ```\n\t * @default 0\n\t */\n\twidth: number;\n\t/**\n\t * The overall height of this rounded rectangle\n\t * @example\n\t * ```ts\n\t * // Basic height setting\n\t * const rect = new RoundedRectangle();\n\t * rect.height = 150; // Total height will be 150\n\t * ```\n\t * @default 0\n\t */\n\theight: number;\n\t/**\n\t * Controls the radius of the rounded corners\n\t * @example\n\t * ```ts\n\t * // Basic radius setting\n\t * const rect = new RoundedRectangle(0, 0, 200, 150);\n\t * rect.radius = 20;\n\t *\n\t * // Clamp to maximum safe radius\n\t * rect.radius = Math.min(rect.width, rect.height) / 2;\n\t *\n\t * // Create pill shape\n\t * rect.radius = rect.height / 2;\n\t * ```\n\t * @remarks\n\t * - Automatically clamped to half of smallest dimension\n\t * - Common values: 0-20 for UI elements\n\t * - Higher values create more rounded corners\n\t * @default 20\n\t */\n\tradius: number;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * ```ts\n\t * // Check shape type\n\t * const shape = new RoundedRectangle(0, 0, 100, 100, 20);\n\t * console.log(shape.type); // 'roundedRectangle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'roundedRectangle') {\n\t *     console.log(shape.radius);\n\t * }\n\t * ```\n\t * @readonly\n\t * @default 'roundedRectangle'\n\t * @see {@link SHAPE_PRIMITIVE} For all shape types\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n\t * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n\t * @param width - The overall width of this rounded rectangle\n\t * @param height - The overall height of this rounded rectangle\n\t * @param radius - Controls the radius of the rounded corners\n\t */\n\tconstructor(x?: number, y?: number, width?: number, height?: number, radius?: number);\n\t/**\n\t * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n\t * @example\n\t * ```ts\n\t * // Basic bounds calculation\n\t * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const bounds = rect.getBounds();\n\t * // bounds: x=100, y=100, width=200, height=150\n\t *\n\t * // Reuse existing rectangle\n\t * const out = new Rectangle();\n\t * rect.getBounds(out);\n\t * ```\n\t * @remarks\n\t * - Rectangle matches outer dimensions\n\t * - Ignores corner radius\n\t * @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t * @see {@link Rectangle} For rectangle properties\n\t * @see {@link RoundedRectangle.contains} For checking if a point is inside\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Creates a clone of this Rounded Rectangle.\n\t * @example\n\t * ```ts\n\t * // Basic cloning\n\t * const original = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.radius = 30;\n\t * modified.width *= 2;\n\t *\n\t * // Verify independence\n\t * console.log(original.radius);  // 20\n\t * console.log(modified.radius);  // 30\n\t * ```\n\t * @returns A copy of the rounded rectangle\n\t * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle\n\t * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n\t */\n\tclone(): RoundedRectangle;\n\t/**\n\t * Copies another rectangle to this one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const target = new RoundedRectangle();\n\t * target.copyFrom(source);\n\t *\n\t * // Chain with other operations\n\t * const rect = new RoundedRectangle()\n\t *     .copyFrom(source)\n\t *     .getBounds(rect);\n\t * ```\n\t * @param rectangle - The rectangle to copy from\n\t * @returns Returns itself\n\t * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n\t * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n\t */\n\tcopyFrom(rectangle: RoundedRectangle): this;\n\t/**\n\t * Copies this rectangle to another one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const target = new RoundedRectangle();\n\t * source.copyTo(target);\n\t *\n\t * // Chain with other operations\n\t * const result = source\n\t *     .copyTo(new RoundedRectangle())\n\t *     .getBounds();\n\t * ```\n\t * @param rectangle - The rectangle to copy to\n\t * @returns Returns given parameter\n\t * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle\n\t * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n\t */\n\tcopyTo(rectangle: RoundedRectangle): RoundedRectangle;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n\t * @example\n\t * ```ts\n\t * // Basic containment check\n\t * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const isInside = rect.contains(150, 125); // true\n\t * // Check corner radius\n\t * const corner = rect.contains(100, 100); // false if within corner curve\n\t * ```\n\t * @remarks\n\t * - Returns false if width/height is 0 or negative\n\t * - Handles rounded corners with radius check\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Rounded Rectangle\n\t * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection\n\t * @see {@link RoundedRectangle.getBounds} For getting containing rectangle\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n\t * @example\n\t * ```ts\n\t * // Basic stroke check\n\t * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n\t * ```\n\t * @param pX - The X coordinate of the point to test\n\t * @param pY - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this rectangle's stroke\n\t * @see {@link RoundedRectangle.contains} For checking fill containment\n\t * @see {@link RoundedRectangle.getBounds} For getting stroke bounds\n\t */\n\tstrokeContains(pX: number, pY: number, strokeWidth: number, alignment?: number): boolean;\n\ttoString(): string;\n}\n/** @internal */\nexport interface ShapeBuildCommand<T extends ShapePrimitive = ShapePrimitive> {\n\textension: ExtensionMetadataDetails;\n\tbuild(shape: T, points: number[]): boolean;\n\ttriangulate(points: number[], vertices: number[], verticesStride: number, verticesOffset: number, indices: number[], indicesOffset: number): void;\n}\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @internal\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape>;\n/** @internal */\nexport const buildEllipse: {\n\textension: {\n\t\tname: string;\n\t\ttype: ExtensionType | ExtensionType[];\n\t\tpriority?: number;\n\t};\n\tbuild(shape: RoundedShape, points: number[]): boolean;\n\ttriangulate(points: number[], vertices: number[], verticesStride: number, verticesOffset: number, indices: number[], indicesOffset: number): void;\n};\n/** @internal */\nexport const buildRoundedRectangle: {\n\textension: {\n\t\tname: string;\n\t\ttype: ExtensionType | ExtensionType[];\n\t\tpriority?: number;\n\t};\n\tbuild(shape: RoundedShape, points: number[]): boolean;\n\ttriangulate(points: number[], vertices: number[], verticesStride: number, verticesOffset: number, indices: number[], indicesOffset: number): void;\n};\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildLine(points: number[], lineStyle: StrokeAttributes, flipAlignment: boolean, closed: boolean, vertices: number[], indices: number[]): void;\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildPixelLine(points: number[], closed: boolean, vertices: number[], indices: number[]): void;\n/**\n * A class to define a shape via user defined coordinates.\n * Used for creating complex shapes and hit areas with custom points.\n * @example\n * ```ts\n * // Create polygon from array of points\n * const polygon1 = new Polygon([\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * ]);\n *\n * // Create from array of coordinates\n * const polygon2 = new Polygon([0, 0, 0, 100, 100, 100]);\n *\n * // Create from sequence of points\n * const polygon3 = new Polygon(\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * );\n *\n * // Create from sequence of coordinates\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n *\n * // Use as container hit area\n * container.hitArea = new Polygon([0, 0, 100, 0, 50, 100]);\n * ```\n * @see {@link Point} For point objects used in construction\n * @category maths\n * @standard\n */\nexport class Polygon implements ShapePrimitive {\n\t/**\n\t * An array of the points of this polygon stored as a flat array of numbers.\n\t * @example\n\t * ```ts\n\t * // Access points directly\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]\n\t *\n\t * // Modify points\n\t * polygon.points[0] = 10; // Move first x coordinate\n\t * polygon.points[1] = 10; // Move first y coordinate\n\t * ```\n\t * @remarks\n\t * - Stored as [x1, y1, x2, y2, ...]\n\t * - Each pair represents a vertex\n\t * - Length is always even\n\t * - Can be modified directly\n\t */\n\tpoints: number[];\n\t/**\n\t * Indicates if the polygon path is closed.\n\t * @example\n\t * ```ts\n\t * // Create open polygon\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * polygon.closePath = false;\n\t *\n\t * // Check path state\n\t * if (polygon.closePath) {\n\t *     // Last point connects to first\n\t * }\n\t * ```\n\t * @remarks\n\t * - True by default\n\t * - False after moveTo\n\t * - True after closePath\n\t * @default true\n\t */\n\tclosePath: boolean;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * ```ts\n\t * // Check shape type\n\t * const shape = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * console.log(shape.type); // 'polygon'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'polygon') {\n\t *     // TypeScript knows this is a Polygon\n\t *     console.log(shape.points.length);\n\t * }\n\t * ```\n\t * @readonly\n\t * @default 'polygon'\n\t * @see {@link SHAPE_PRIMITIVE} For all shape types\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\tconstructor(points: PointData[] | number[]);\n\tconstructor(...points: PointData[] | number[]);\n\t/**\n\t * Determines whether the polygon's points are arranged in a clockwise direction.\n\t * Uses the shoelace formula (surveyor's formula) to calculate the signed area.\n\t *\n\t * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n\t *\n\t * The formula sums up the cross products of adjacent vertices:\n\t * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n\t * The final sum divided by 2 gives the signed area - positive for clockwise.\n\t * @example\n\t * ```ts\n\t * // Check polygon winding\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * console.log(polygon.isClockwise()); // Check direction\n\t *\n\t * // Use in path construction\n\t * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);\n\t * if (hole.isClockwise() === shape.isClockwise()) {\n\t *     hole.points.reverse(); // Reverse for proper hole winding\n\t * }\n\t * ```\n\t * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n\t */\n\tisClockwise(): boolean;\n\t/**\n\t * Checks if this polygon completely contains another polygon.\n\t * Used for detecting holes in shapes, like when parsing SVG paths.\n\t * @example\n\t * ```ts\n\t * // Basic containment check\n\t * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n\t * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n\t *\n\t * outerSquare.containsPolygon(innerSquare); // Returns true\n\t * innerSquare.containsPolygon(outerSquare); // Returns false\n\t * ```\n\t * @remarks\n\t * - Uses bounds check for quick rejection\n\t * - Tests all points for containment\n\t * @param polygon - The polygon to test for containment\n\t * @returns True if this polygon completely contains the other polygon\n\t * @see {@link Polygon.contains} For single point testing\n\t * @see {@link Polygon.getBounds} For bounds calculation\n\t */\n\tcontainsPolygon(polygon: Polygon): boolean;\n\t/**\n\t * Creates a clone of this polygon.\n\t * @example\n\t * ```ts\n\t * // Basic cloning\n\t * const original = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.points[0] = 10; // Modify first x coordinate\n\t * ```\n\t * @returns A copy of the polygon\n\t * @see {@link Polygon.copyFrom} For copying into existing polygon\n\t * @see {@link Polygon.copyTo} For copying to another polygon\n\t */\n\tclone(): Polygon;\n\t/**\n\t * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n\t * Uses raycasting algorithm for point-in-polygon testing.\n\t * @example\n\t * ```ts\n\t * // Basic containment check\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const isInside = polygon.contains(25, 25); // true\n\t * ```\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this polygon\n\t * @see {@link Polygon.strokeContains} For checking stroke intersection\n\t * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n\t * @example\n\t * ```ts\n\t * // Basic stroke check\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside\n\t * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered\n\t * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside\n\t * ```\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this polygon's stroke\n\t * @see {@link Polygon.contains} For checking fill containment\n\t * @see {@link Polygon.getBounds} For getting stroke bounds\n\t */\n\tstrokeContains(x: number, y: number, strokeWidth: number, alignment?: number): boolean;\n\t/**\n\t * Returns the framing rectangle of the polygon as a Rectangle object.\n\t * @example\n\t * ```ts\n\t * // Basic bounds calculation\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const bounds = polygon.getBounds();\n\t * // bounds: x=0, y=0, width=100, height=100\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * polygon.getBounds(rect);\n\t * ```\n\t * @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t * @see {@link Rectangle} For rectangle properties\n\t * @see {@link Polygon.contains} For checking if a point is inside\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Copies another polygon to this one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const target = new Polygon();\n\t * target.copyFrom(source);\n\t * ```\n\t * @param polygon - The polygon to copy from\n\t * @returns Returns itself\n\t * @see {@link Polygon.copyTo} For copying to another polygon\n\t * @see {@link Polygon.clone} For creating new polygon copy\n\t */\n\tcopyFrom(polygon: Polygon): this;\n\t/**\n\t * Copies this polygon to another one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const target = new Polygon();\n\t * source.copyTo(target);\n\t * ```\n\t * @param polygon - The polygon to copy to\n\t * @returns Returns given parameter\n\t * @see {@link Polygon.copyFrom} For copying from another polygon\n\t * @see {@link Polygon.clone} For creating new polygon copy\n\t */\n\tcopyTo(polygon: Polygon): Polygon;\n\ttoString(): string;\n\t/**\n\t * Get the last X coordinate of the polygon.\n\t * @example\n\t * ```ts\n\t * // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.lastX); // 300\n\t * ```\n\t * @readonly\n\t * @returns The x-coordinate of the last vertex\n\t * @see {@link Polygon.lastY} For last Y coordinate\n\t * @see {@link Polygon.points} For raw points array\n\t */\n\tget lastX(): number;\n\t/**\n\t * Get the last Y coordinate of the polygon.\n\t * @example\n\t * ```ts\n\t * // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.lastY); // 400\n\t * ```\n\t * @readonly\n\t * @returns The y-coordinate of the last vertex\n\t * @see {@link Polygon.lastX} For last X coordinate\n\t * @see {@link Polygon.points} For raw points array\n\t */\n\tget lastY(): number;\n\t/**\n\t * Get the last X coordinate of the polygon.\n\t * @readonly\n\t * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.\n\t */\n\tget x(): number;\n\t/**\n\t * Get the last Y coordinate of the polygon.\n\t * @readonly\n\t * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.\n\t */\n\tget y(): number;\n\t/**\n\t * Get the first X coordinate of the polygon.\n\t * @example\n\t * ```ts\n\t * // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.x); // 0\n\t * ```\n\t * @readonly\n\t * @returns The x-coordinate of the first vertex\n\t * @see {@link Polygon.startY} For first Y coordinate\n\t * @see {@link Polygon.points} For raw points array\n\t */\n\tget startX(): number;\n\t/**\n\t * Get the first Y coordinate of the polygon.\n\t * @example\n\t * ```ts\n\t * // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.y); // 0\n\t * ```\n\t * @readonly\n\t * @returns The y-coordinate of the first vertex\n\t * @see {@link Polygon.startX} For first X coordinate\n\t * @see {@link Polygon.points} For raw points array\n\t */\n\tget startY(): number;\n}\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon>;\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle>;\n/**\n * A class to define a shape of a triangle via user defined coordinates.\n *\n * Used for creating triangular shapes and hit areas with three points (x,y), (x2,y2), (x3,y3).\n * Points are stored in counter-clockwise order.\n * @example\n * ```ts\n * // Basic triangle creation\n * const triangle = new Triangle(0, 0, 100, 0, 50, 50);\n * // Use as hit area\n * container.hitArea = new Triangle(0, 0, 100, 0, 50, 100);\n * // Check point containment\n * const isInside = triangle.contains(mouseX, mouseY);\n * // Get bounding box\n * const bounds = triangle.getBounds();\n * ```\n * @see {@link Rectangle} For rectangular shapes\n * @see {@link Circle} For circular shapes\n * @see {@link Polygon} For complex shapes\n * @category maths\n * @standard\n */\nexport class Triangle implements ShapePrimitive {\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * ```ts\n\t * // Check shape type\n\t * const shape = new Triangle(0, 0, 100, 0, 50, 100);\n\t * console.log(shape.type); // 'triangle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'triangle') {\n\t *     console.log(shape.x2, shape.y2);\n\t * }\n\t * ```\n\t * @readonly\n\t * @default 'triangle'\n\t * @see {@link SHAPE_PRIMITIVE} For all shape types\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * The X coordinate of the first point of the triangle.\n\t * @example\n\t * ```ts\n\t * // Set first point x position\n\t * const triangle = new Triangle();\n\t * triangle.x = 100;\n\t * ```\n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the first point of the triangle.\n\t * @example\n\t * ```ts\n\t * // Set first point y position\n\t * const triangle = new Triangle();\n\t * triangle.y = 100;\n\t * ```\n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The X coordinate of the second point of the triangle.\n\t * @example\n\t * ```ts\n\t * // Create horizontal line for second point\n\t * const triangle = new Triangle(0, 0);\n\t * triangle.x2 = triangle.x + 100; // 100 units to the right\n\t * ```\n\t * @default 0\n\t */\n\tx2: number;\n\t/**\n\t * The Y coordinate of the second point of the triangle.\n\t * @example\n\t * ```ts\n\t * // Create vertical line for second point\n\t * const triangle = new Triangle(0, 0);\n\t * triangle.y2 = triangle.y + 100; // 100 units down\n\t * ```\n\t * @default 0\n\t */\n\ty2: number;\n\t/**\n\t * The X coordinate of the third point of the triangle.\n\t * @example\n\t * ```ts\n\t * // Create equilateral triangle\n\t * const triangle = new Triangle(0, 0, 100, 0);\n\t * triangle.x3 = 50;  // Middle point x\n\t * triangle.y3 = 86.6; // Height using sin(60)\n\t * ```\n\t * @default 0\n\t */\n\tx3: number;\n\t/**\n\t * The Y coordinate of the third point of the triangle.\n\t * @example\n\t * ```ts\n\t * // Create right triangle\n\t * const triangle = new Triangle(0, 0, 100, 0);\n\t * triangle.x3 = 0;   // Align with first point\n\t * triangle.y3 = 100; // 100 units down\n\t * ```\n\t * @default 0\n\t */\n\ty3: number;\n\t/**\n\t * @param x - The X coord of the first point.\n\t * @param y - The Y coord of the first point.\n\t * @param x2 - The X coord of the second point.\n\t * @param y2 - The Y coord of the second point.\n\t * @param x3 - The X coord of the third point.\n\t * @param y3 - The Y coord of the third point.\n\t */\n\tconstructor(x?: number, y?: number, x2?: number, y2?: number, x3?: number, y3?: number);\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this triangle\n\t * @example\n\t * ```ts\n\t * // Basic containment check\n\t * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const isInside = triangle.contains(25, 25); // true\n\t * ```\n\t * @remarks\n\t * - Uses barycentric coordinate system\n\t * - Works with any triangle shape\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Triangle\n\t * @see {@link Triangle.strokeContains} For checking stroke intersection\n\t * @see {@link Triangle.getBounds} For getting containing rectangle\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this triangle including the stroke.\n\t * @example\n\t * ```ts\n\t * // Basic stroke check\n\t * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const isOnStroke = triangle.strokeContains(25, 25, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = triangle.strokeContains(25, 25, 4, 1);   // Inside\n\t * const centerStroke = triangle.strokeContains(25, 25, 4, 0.5); // Centered\n\t * const outerStroke = triangle.strokeContains(25, 25, 4, 0);   // Outside\n\t * ```\n\t * @param pointX - The X coordinate of the point to test\n\t * @param pointY - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param _alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this triangle's stroke\n\t * @see {@link Triangle.contains} For checking fill containment\n\t * @see {@link Triangle.getBounds} For getting stroke bounds\n\t */\n\tstrokeContains(pointX: number, pointY: number, strokeWidth: number, _alignment?: number): boolean;\n\t/**\n\t * Creates a clone of this Triangle\n\t * @example\n\t * ```ts\n\t * // Basic cloning\n\t * const original = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.x3 = 75;\n\t * modified.y3 = 150;\n\t *\n\t * // Verify independence\n\t * console.log(original.y3);  // 100\n\t * console.log(modified.y3);  // 150\n\t * ```\n\t * @returns A copy of the triangle\n\t * @see {@link Triangle.copyFrom} For copying into existing triangle\n\t * @see {@link Triangle.copyTo} For copying to another triangle\n\t */\n\tclone(): Triangle;\n\t/**\n\t * Copies another triangle to this one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const target = new Triangle();\n\t * target.copyFrom(source);\n\t *\n\t * // Chain with other operations\n\t * const triangle = new Triangle()\n\t *     .copyFrom(source)\n\t *     .getBounds(rect);\n\t * ```\n\t * @param triangle - The triangle to copy from\n\t * @returns Returns itself\n\t * @see {@link Triangle.copyTo} For copying to another triangle\n\t * @see {@link Triangle.clone} For creating new triangle copy\n\t */\n\tcopyFrom(triangle: Triangle): this;\n\t/**\n\t * Copies this triangle to another one.\n\t * @example\n\t * ```ts\n\t * // Basic copying\n\t * const source = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const target = new Triangle();\n\t * source.copyTo(target);\n\t *\n\t * // Chain with other operations\n\t * const result = source\n\t *     .copyTo(new Triangle())\n\t *     .getBounds();\n\t * ```\n\t * @remarks\n\t * - Updates target triangle values\n\t * - Copies all point coordinates\n\t * - Returns target for chaining\n\t * - More efficient than clone()\n\t * @param triangle - The triangle to copy to\n\t * @returns Returns given parameter\n\t * @see {@link Triangle.copyFrom} For copying from another triangle\n\t * @see {@link Triangle.clone} For creating new triangle copy\n\t */\n\tcopyTo(triangle: Triangle): Triangle;\n\t/**\n\t * Returns the framing rectangle of the triangle as a Rectangle object\n\t * @example\n\t * ```ts\n\t * // Basic bounds calculation\n\t * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const bounds = triangle.getBounds();\n\t * // bounds: x=0, y=0, width=100, height=100\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * triangle.getBounds(rect);\n\t * ```\n\t * @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t * @see {@link Rectangle} For rectangle properties\n\t * @see {@link Triangle.contains} For checking if a point is inside\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n}\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle>;\n/**\n * Represents a session for SVG parsing. Contains the current state and resources needed during parsing.\n * @internal\n */\nexport interface Session {\n\t/** The graphics context to render to */\n\tcontext: GraphicsContext;\n\t/** The current path being constructed */\n\tpath: GraphicsPath;\n\t/** Map of definitions by id */\n\tdefs: Record<string, FillGradient>;\n}\n/**\n * Parses an SVG element or string and renders it to a graphics context.\n * Handles both SVG strings and SVG DOM elements as input.\n * @param svg - The SVG content to parse, either as a string or element\n * @param graphicsContext - Optional graphics context to render to\n * @returns The graphics context with the SVG rendered into it\n * @internal\n */\nexport function SVGParser(svg: string | SVGElement | SVGSVGElement, graphicsContext?: GraphicsContext): GraphicsContext;\n/**\n * Parses SVG gradient definitions and stores them in the session for later use.\n * Currently supports linear gradients and has placeholder support for radial gradients.\n * @param svg - The root SVG element to parse definitions from\n * @param session - The parsing session to store definitions in\n * @internal\n */\nexport function parseSVGDefinitions(svg: SVGElement, session: Session): void;\n/**\n * Parses a float value from an SVG element's attribute.\n * This is commonly used for parsing numeric attributes like coordinates, dimensions,\n * and other measurements from SVG elements.\n * @param svg - The SVG element to get the attribute from\n * @param id - The name of the attribute to parse (e.g. 'x', 'y', 'width', etc)\n * @param defaultValue - The value to return if the attribute doesn't exist or can't be parsed\n * @returns The parsed float value, or the default value if parsing fails\n * @example\n * // For SVG: <rect x=\"10.5\" width=\"20\"/>\n * parseSVGFloatAttribute(rectElement, 'x', 0) // Returns 10.5\n * parseSVGFloatAttribute(rectElement, 'y', 0) // Returns 0 since y is not specified\n * @internal\n */\nexport function parseSVGFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number;\n/**\n * Parses an SVG path data string and builds a GraphicsPath object from the commands.\n * This function handles all standard SVG path commands including moves, lines, curves and arcs.\n * It maintains state for the current position and subpaths to properly handle relative commands\n * and path closures.\n *\n * Supported SVG commands:\n * - M/m: Move to absolute/relative\n * - L/l: Line to absolute/relative\n * - H/h: Horizontal line absolute/relative\n * - V/v: Vertical line absolute/relative\n * - C/c: Cubic bezier curve absolute/relative\n * - S/s: Smooth cubic bezier curve absolute/relative\n * - Q/q: Quadratic bezier curve absolute/relative\n * - T/t: Smooth quadratic bezier curve absolute/relative\n * - A/a: Arc absolute/relative\n * - Z/z: Close path\n * @param svgPath - The SVG path data string to parse (e.g. \"M0,0 L100,100\")\n * @param path - The GraphicsPath object to build the path into\n * @returns The input path object with the SVG commands applied\n * @internal\n */\nexport function parseSVGPath(svgPath: string, path: GraphicsPath): GraphicsPath;\n/**\n * A map of SVG style attributes and their default values.\n * Each attribute has a type and default value used for SVG parsing.\n * - 'paint' type can be a color or gradient\n * - 'number' type is a numeric value\n * - 'string' type is a text value\n * @category scene\n * @advanced\n */\nexport const styleAttributes: {\n\tfill: {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n\t\"fill-opacity\": {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n\tstroke: {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n\t\"stroke-width\": {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n\t\"stroke-opacity\": {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n\t\"stroke-linecap\": {\n\t\ttype: string;\n\t\tdefault: string;\n\t};\n\t\"stroke-linejoin\": {\n\t\ttype: string;\n\t\tdefault: string;\n\t};\n\t\"stroke-miterlimit\": {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n\t\"stroke-dasharray\": {\n\t\ttype: string;\n\t\tdefault: string;\n\t};\n\t\"stroke-dashoffset\": {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n\topacity: {\n\t\ttype: string;\n\t\tdefault: number;\n\t};\n};\n/**\n * Represents the result of parsing SVG style attributes\n * @internal\n */\nexport type StyleResult = {\n\t/** The stroke style properties */\n\tstrokeStyle: StrokeStyle;\n\t/** The fill style properties */\n\tfillStyle: FillStyle;\n\t/** Whether fill should be applied */\n\tuseFill: boolean;\n\t/** Whether stroke should be applied */\n\tuseStroke: boolean;\n};\n/**\n * Parses SVG style attributes and inline styles to determine fill and stroke properties.\n * Handles both direct attributes and CSS-style declarations in the style attribute.\n * @param svg - The SVG element to parse styles from\n * @param session - The current SVG parsing session containing definitions\n * @returns An object containing the parsed fill and stroke styles\n * @internal\n */\nexport function parseSVGStyle(svg: SVGElement, session: Session): StyleResult;\n/**\n * Extracts the ID from an SVG url() reference.\n *\n * This function handles all valid SVG url() formats including:\n * - url(#id)\n * - url('#id')\n * - url(\"#id\")\n * - url( #id )\n * - url( '#id' )\n * - url( \"#id\" )\n *\n * The regex pattern matches:\n * - url followed by optional whitespace\n * - opening parenthesis followed by optional whitespace\n * - optional single or double quotes with optional whitespace\n * - # followed by the ID (any chars except quotes, whitespace, or closing paren)\n * - optional single or double quotes with optional whitespace\n * - closing parenthesis\n * @param url - The SVG url() string to parse\n * @returns The extracted ID string, or empty string if no valid ID found\n * @internal\n */\nexport function extractSvgUrlId(url: string): string;\n/**\n * Determines if subpaths represent nested shapes or multiple holes pattern.\n * @param subpathsWithArea - Array of subpaths with their calculated areas\n * @returns True if nested pattern, false if multiple holes pattern\n * @internal\n */\nexport function checkForNestedPattern(subpathsWithArea: Array<{\n\tpath: string;\n\tarea: number;\n}>): boolean;\n/**\n * Gets fill instruction data from a graphics context.\n * @param context - The graphics context\n * @param index - Index of the fill instruction (default: 0)\n * @returns The fill instruction data\n * @throws Error if instruction at index is not a fill instruction\n * @internal\n */\nexport function getFillInstructionData(context: GraphicsContext, index?: number): {\n\tstyle: ConvertedFillStyle;\n\tpath: GraphicsPath;\n\thole?: GraphicsPath;\n};\n/**\n * Extracts individual subpaths from SVG path data by splitting on Move commands.\n * @param pathData - The SVG path data string\n * @returns Array of subpath strings\n * @internal\n */\nexport function extractSubpaths(pathData: string): string[];\n/**\n * Calculates the area of a path using bounding box estimation.\n * @param pathData - The SVG path data string\n * @returns The estimated area of the path\n * @internal\n */\nexport function calculatePathArea(pathData: string): number;\n/**\n * Parses SVG path data and appends instructions to a GraphicsPath.\n * @param pathData - The SVG path data string\n * @param graphicsPath - The GraphicsPath to append instructions to\n * @internal\n */\nexport function appendSVGPath(pathData: string, graphicsPath: GraphicsPath): void;\n/**\n * A record of shape builders, keyed by shape type.\n * @category scene\n * @advanced\n */\nexport const shapeBuilders: Record<string, ShapeBuildCommand>;\n/**\n * @param context\n * @param gpuContext\n * @internal\n */\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext): void;\n/**\n * Options for building geometry from a graphics path.\n * Provides a possibility to specify a transformation Matrix for the texture's UVs and output mesh geometry.\n * @example\n * ```ts\n * const options: GeometryPathOptions = {\n *     path: new GraphicsPath().rect(0, 0, 64, 64),\n *     textureMatrix: new Matrix()\n *         .scale(2, 2)\n *         .rotate(Math.PI / 4),\n *     out: meshGeometry\n * };\n * const geometry:MeshGeometry = buildGeometryFromPath(options);\n * const mesh = new Mesh({\n *     geometry: meshGeometry,\n *     texture: bunnyTexture\n * });\n * ```\n * @category scene\n * @advanced\n */\nexport interface GeometryPathOptions {\n\t/** the path to build the geometry from */\n\tpath: GraphicsPath;\n\t/** a `Matrix` that can be used to modify the texture UVs of the path being built */\n\ttextureMatrix?: Matrix;\n\t/** an optional `MeshGeometry` to write too instead of creating a new one*/\n\tout?: MeshGeometry;\n}\n/**\n * When building a mesh, it helps to leverage the simple API we have in `GraphicsPath` as it can often be easier to\n * define the geometry in a more human-readable way. This function takes a `GraphicsPath` and returns a `MeshGeometry`.\n * @example\n * ```ts\n *\n * const path = new GraphicsPath()\n *    .drawRect(0, 0, 100, 100)\n *\n * const geometry:MeshGeometry = buildGeometryFromPath(path);\n *\n * const mesh = new Mesh({geometry});\n *\n * ```\n * You can also pass in a Matrix to transform the uvs as by default you may want to control how they are set up.\n * @param options - either a `GraphicsPath` or `GeometryPathOptions`\n * @returns a new `MeshGeometry` instance build from the path\n * @category scene\n * @advanced\n */\nexport function buildGeometryFromPath(options: GraphicsPath | GeometryPathOptions): MeshGeometry;\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(value: T, defaultStyle: ConvertedFillStyle): ConvertedFillStyle;\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle;\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n * @internal\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix): Matrix;\n/**\n * @param points\n * @internal\n */\nexport function getOrientationOfPoints(points: number[]): number;\n/**\n * @param points\n * @param holes\n * @param vertices\n * @param verticesStride\n * @param verticesOffset\n * @param indices\n * @param indicesOffset\n * @internal\n */\nexport function triangulateWithHoles(points: number[], holes: number[], vertices: number[], verticesStride: number, verticesOffset: number, indices: number[], indicesOffset: number): void;\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions {\n\t/** Width of plane */\n\twidth?: number;\n\t/** Height of plane */\n\theight?: number;\n\t/** Number of vertices on x-axis */\n\tverticesX?: number;\n\t/** Number of vertices on y-axis */\n\tverticesY?: number;\n}\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry {\n\tstatic defaultOptions: PlaneGeometryOptions & MeshGeometryOptions;\n\t/** The number of vertices on x-axis */\n\tverticesX: number;\n\t/** The number of vertices on y-axis */\n\tverticesY: number;\n\t/** The width of plane */\n\twidth: number;\n\t/** The height of plane */\n\theight: number;\n\t/**\n\t * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n\t */\n\tconstructor(options: PlaneGeometryOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n\t/**\n\t * Refreshes plane coordinates\n\t * @param options - Options to be applied to plane geometry\n\t */\n\tbuild(options: PlaneGeometryOptions): void;\n}\n/**\n * Constructor options used for `PerspectivePlaneGeometry` instances.\n * @category scene\n * @advanced\n */\nexport interface PerspectivePlaneGeometryOptions extends PlaneGeometryOptions {\n\t/** The width of the plane */\n\twidth: number;\n\t/** The height of the plane */\n\theight: number;\n}\n/**\n * A PerspectivePlaneGeometry allows you to draw a 2d plane with perspective. Where ever you move the corners\n * the texture will be projected to look like it is in 3d space. Great for mapping a 2D mesh into a 3D scene.\n *\n * IMPORTANT: This is not a full 3D mesh, it is a 2D mesh with a perspective projection applied to it :)\n *\n * ```js\n * const perspectivePlaneGeometry = new PerspectivePlaneGeometry({\n *  width: 100,\n *  height: 100,\n *  verticesX: 10,\n *  verticesY: 10,\n * });\n * ```\n * @see {@link PerspectivePlaneGeometry}\n * @category scene\n * @advanced\n */\nexport class PerspectivePlaneGeometry extends PlaneGeometry {\n\t/** The corner points of the quad you can modify these directly, if you do make sure to call `updateProjection` */\n\tcorners: [\n\t\tnumber,\n\t\tnumber,\n\t\tnumber,\n\t\tnumber,\n\t\tnumber,\n\t\tnumber,\n\t\tnumber,\n\t\tnumber\n\t];\n\tprivate readonly _projectionMatrix;\n\t/**\n\t * @param options - Options to be applied to MeshPlane\n\t * @param options.width - The width of the plane\n\t * @param options.height - The height of the plane\n\t * @param options.verticesX - The amount of vertices on the x axis\n\t * @param options.verticesY - The amount of vertices on the y axis\n\t */\n\tconstructor(options: PerspectivePlaneGeometryOptions);\n\t/**\n\t * Will set the corners of the quad to the given coordinates\n\t * Calculating the perspective so it looks correct!\n\t * @param x0 - x coordinate of the first corner\n\t * @param y0 - y coordinate of the first corner\n\t * @param x1 - x coordinate of the second corner\n\t * @param y1 - y coordinate of the second corner\n\t * @param x2 - x coordinate of the third corner\n\t * @param y2 - y coordinate of the third corner\n\t * @param x3 - x coordinate of the fourth corner\n\t * @param y3 - y coordinate of the fourth corner\n\t */\n\tsetCorners(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;\n\t/** Update the projection matrix based on the corners */\n\tupdateProjection(): void;\n}\n/**\n * Constructor options used for `MeshPlane` instances. Defines how a texture is mapped\n * onto a plane with configurable vertex density.\n * @example\n * ```ts\n * // Basic plane with default vertex density\n * const plane = new MeshPlane({\n *     texture: Assets.get('background.png')\n * });\n *\n * // High-detail plane for complex deformations\n * const detailedPlane = new MeshPlane({\n *     texture: Assets.get('landscape.jpg'),\n *     verticesX: 20,\n *     verticesY: 20\n * });\n * ```\n * @see {@link MeshPlane} For the mesh implementation\n * @see {@link PlaneGeometry} For the underlying geometry\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface MeshPlaneOptions extends Omit<MeshOptions, \"geometry\"> {\n\t/** The texture to use on the plane. */\n\ttexture: Texture;\n\t/**\n\t * Number of vertices along the X axis. More vertices allow for more detailed deformations.\n\t * @default 10\n\t */\n\tverticesX?: number;\n\t/**\n\t * Number of vertices along the Y axis. More vertices allow for more detailed deformations.\n\t * @default 10\n\t */\n\tverticesY?: number;\n}\n/**\n * A mesh that renders a texture mapped to a plane with configurable vertex density.\n * Useful for creating distortion effects, bent surfaces, and animated deformations.\n * @example\n * ```ts\n * // Create a basic plane\n * const plane = new MeshPlane({\n *     texture: Assets.get('background.png'),\n *     verticesX: 10,\n *     verticesY: 10\n * });\n *\n * // Get the buffer for vertex positions.\n * const { buffer } = plane.geometry.getAttribute('aPosition');\n *\n * // Listen for animate update\n * let timer = 0;\n *\n * app.ticker.add(() =>\n * {\n *     // Randomize the vertices positions a bit to create movement.\n *     for (let i = 0; i < buffer.data.length; i++)\n *     {\n *         buffer.data[i] += Math.sin(timer / 10 + i) * 0.5;\n *     }\n *     buffer.update();\n *     timer++;\n * });\n *\n * // Change texture dynamically\n * plane.texture = Assets.get('newTexture.png');\n * ```\n * @category scene\n * @standard\n */\nexport class MeshPlane extends Mesh {\n\t/**\n\t * Controls whether the mesh geometry automatically updates when the texture dimensions change.\n\t * When true, the mesh will resize to match any texture updates. When false, the mesh maintains\n\t * its original dimensions regardless of texture changes.\n\t * @example\n\t * ```ts\n\t * // Create a plane that auto-resizes with texture changes\n\t * const plane = new MeshPlane({\n\t *     texture: Assets.get('small.png'),\n\t *     verticesX: 10,\n\t *     verticesY: 10\n\t * });\n\t *\n\t * // Plane will automatically resize to match new texture\n\t * plane.texture = Assets.get('large.png');\n\t *\n\t * // Disable auto-resizing to maintain original dimensions\n\t * plane.autoResize = false;\n\t *\n\t * // Plane keeps its size even with new texture\n\t * plane.texture = Assets.get('different.png');\n\t *\n\t * // Manually update geometry if needed\n\t * const geometry = plane.geometry as PlaneGeometry;\n\t * geometry.width = plane.texture.width;\n\t * geometry.height = plane.texture.height;\n\t * geometry.build();\n\t * ```\n\t * @default true\n\t * @see {@link MeshPlane#texture} For changing the texture\n\t * @see {@link PlaneGeometry} For manual geometry updates\n\t */\n\tautoResize: boolean;\n\tprotected _textureID: number;\n\t/**\n\t * @param options - Options to be applied to MeshPlane\n\t */\n\tconstructor(options: MeshPlaneOptions);\n\t/**\n\t * Method used for overrides, to do something in case texture frame was changed.\n\t * Meshes based on plane can override it and change more details based on texture.\n\t * @internal\n\t */\n\ttextureUpdated(): void;\n\tset texture(value: Texture);\n\t/**\n\t * The texture that the mesh plane uses for rendering. When changed, automatically updates\n\t * geometry dimensions if autoResize is true and manages texture update event listeners.\n\t * @example\n\t * ```ts\n\t * const plane = new MeshPlane({\n\t *     texture: Assets.get('initial.png'),\n\t *     verticesX: 10,\n\t *     verticesY: 10\n\t * });\n\t *\n\t * // Update texture and auto-resize geometry\n\t * plane.texture = Assets.get('larger.png');\n\t * ```\n\t * @see {@link MeshPlane#autoResize} For controlling automatic geometry updates\n\t * @see {@link PlaneGeometry} For manual geometry updates\n\t * @see {@link Texture} For texture creation and management\n\t */\n\tget texture(): Texture;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * meshPlane.destroy();\n\t * meshPlane.destroy(true);\n\t * meshPlane.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * Constructor options used for `PerspectiveMesh` instances. Defines the geometry and appearance\n * of a 2D mesh with perspective projection.\n * @example\n * ```ts\n * // Create a perspective mesh with a texture\n * const mesh = new PerspectiveMesh({\n *     texture: Texture.from('myImage.png'),\n *     verticesX: 20,\n *     verticesY: 20,\n *     // Define corners clockwise from top-left\n *     x0: 0,   y0: 0,    // Top-left\n *     x1: 100, y1: 20,   // Top-right (raised)\n *     x2: 100, y2: 100,  // Bottom-right\n *     x3: 0,   y3: 80    // Bottom-left (raised)\n * });\n *\n * // Create a skewed perspective\n * const skewedMesh = new PerspectiveMesh({\n *     texture: Texture.from('background.jpg'),\n *     verticesX: 15,     // More vertices for smoother perspective\n *     verticesY: 15,\n *     x0: 0,   y0: 30,   // Shifted top-left\n *     x1: 128, y1: 0,    // Raised top-right\n *     x2: 128, y2: 128,  // Normal bottom-right\n *     x3: 0,   y3: 98    // Shifted bottom-left\n * });\n * ```\n * @extends MeshPlaneOptions\n * @see {@link PerspectiveMesh} For the mesh implementation\n * @see {@link PerspectivePlaneGeometry} For the underlying geometry\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface PerspectivePlaneOptions extends MeshPlaneOptions {\n\t/** The x-coordinate of the top-left corner */\n\tx0?: number;\n\t/** The y-coordinate of the top-left corner */\n\ty0?: number;\n\t/** The x-coordinate of the top-right corner */\n\tx1?: number;\n\t/** The y-coordinate of the top-right corner */\n\ty1?: number;\n\t/** The x-coordinate of the bottom-right corner */\n\tx2?: number;\n\t/** The y-coordinate of the bottom-right corner */\n\ty2?: number;\n\t/** The x-coordinate of the bottom-left corner */\n\tx3?: number;\n\t/** The y-coordinate of the bottom-left corner */\n\ty3?: number;\n}\n/**\n * A perspective mesh that allows you to draw a 2d plane with perspective. Where ever you move the corners\n * the texture will be projected to look like it is in 3d space. Great for mapping a 2D mesh into a 3D scene.\n *\n * The calculations is done at the uv level. This means that the more vertices you have the more smooth\n * the perspective will be. If you have a low amount of vertices you may see the texture stretch. Too many vertices\n * could be slower. It is a balance between performance and quality! We leave that to you to decide.\n *\n * > [!IMPORTANT] This is not a full 3D mesh, it is a 2D mesh with a perspective projection applied to it.\n * @category scene\n * @standard\n * @see {@link PerspectiveMesh}\n * @example\n * ```ts\n * // Create a perspective mesh with a texture\n * const mesh = new PerspectiveMesh({\n *     texture: Texture.from('myImage.png'),\n *     verticesX: 20,\n *     verticesY: 20,\n *     // Define corners clockwise from top-left\n *     x0: 0,   y0: 0,    // Top-left\n *     x1: 100, y1: 20,   // Top-right (raised)\n *     x2: 100, y2: 100,  // Bottom-right\n *     x3: 0,   y3: 80    // Bottom-left (raised)\n * });\n * ```\n */\nexport class PerspectiveMesh extends Mesh<PerspectivePlaneGeometry> {\n\t/**\n\t * Default options for creating a PerspectiveMesh instance.\n\t *\n\t * Creates a 100x100 pixel square mesh\n\t * with a white texture and 10x10 vertex grid for the perspective calculations.\n\t * @example\n\t * ```ts\n\t * // Change defaults globally\n\t * PerspectiveMesh.defaultOptions = {\n\t *     ...PerspectiveMesh.defaultOptions,\n\t *     verticesX: 15,\n\t *     verticesY: 15,\n\t *     // Move top edge up for default skew\n\t *     y0: -20,\n\t *     y1: -20\n\t * };\n\t * ```\n\t * @see {@link PerspectivePlaneOptions} For all available options\n\t * @see {@link PerspectivePlaneGeometry} For how vertices affect perspective quality\n\t */\n\tstatic defaultOptions: PerspectivePlaneOptions;\n\t/**\n\t * @param options - Options to be applied to PerspectiveMesh\n\t */\n\tconstructor(options: PerspectivePlaneOptions);\n\t/** Update the geometry when the texture is updated */\n\tprotected textureUpdated(): void;\n\tset texture(value: Texture);\n\t/**\n\t * The texture that the mesh uses for rendering. When changed, automatically updates\n\t * the geometry to match the new texture dimensions.\n\t * @example\n\t * ```ts\n\t * const mesh = new PerspectiveMesh({\n\t *     texture: Texture.from('initial.png'),\n\t * });\n\t *\n\t * // Update texture and maintain perspective\n\t * mesh.texture = Texture.from('newImage.png');\n\t * ```\n\t * @see {@link Texture} For texture creation and management\n\t * @see {@link PerspectiveMesh#setCorners} For adjusting the mesh perspective\n\t */\n\tget texture(): Texture;\n\t/**\n\t * Sets the corners of the mesh to create a perspective transformation. The corners should be\n\t * specified in clockwise order starting from the top-left.\n\t *\n\t * The mesh automatically recalculates the UV coordinates to create the perspective effect.\n\t * @example\n\t * ```ts\n\t * const mesh = new PerspectiveMesh({\n\t *     texture: Texture.from('myImage.png'),\n\t * });\n\t *\n\t * // Create a basic perspective tilt\n\t * mesh.setCorners(\n\t *     0, 0,      // Top-left\n\t *     100, 20,   // Top-right (raised)\n\t *     100, 100,  // Bottom-right\n\t *     0, 80      // Bottom-left\n\t * );\n\t *\n\t * // Create a skewed billboard effect\n\t * mesh.setCorners(\n\t *     0, 30,     // Top-left (shifted down)\n\t *     128, 0,    // Top-right (raised)\n\t *     128, 128,  // Bottom-right\n\t *     0, 98      // Bottom-left (shifted up)\n\t * );\n\t *\n\t * // Animate perspective\n\t * app.ticker.add((delta) => {\n\t *     const time = performance.now() / 1000;\n\t *     const wave = Math.sin(time) * 20;\n\t *\n\t *     mesh.setCorners(\n\t *         0, wave,      // Top-left\n\t *         100, -wave,   // Top-right\n\t *         100, 100,     // Bottom-right\n\t *         0, 100        // Bottom-left\n\t *     );\n\t * });\n\t * ```\n\t * @param x0 - x-coordinate of the top-left corner\n\t * @param y0 - y-coordinate of the top-left corner\n\t * @param x1 - x-coordinate of the top-right corner\n\t * @param y1 - y-coordinate of the top-right corner\n\t * @param x2 - x-coordinate of the bottom-right corner\n\t * @param y2 - y-coordinate of the bottom-right corner\n\t * @param x3 - x-coordinate of the bottom-left corner\n\t * @param y3 - y-coordinate of the bottom-left corner\n\t * @returns The PerspectiveMesh instance for method chaining\n\t * @see {@link PerspectivePlaneGeometry} For the underlying geometry calculations\n\t */\n\tsetCorners(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;\n}\n/**\n * Apply a projective transformation to a plane geometry\n * @param width - The width of the plane\n * @param height - The height of the plane\n * @param geometry - The plane geometry to apply the transformation to\n * @param transformationMatrix - The transformation matrix to apply\n * @internal\n */\nexport function applyProjectiveTransformationToPlane(width: number, height: number, geometry: PlaneGeometry, transformationMatrix: ArrayFixed<number, 9>): void;\ntype Matrix3x3 = ArrayFixed<number, 9>;\n/**\n * Compute a 2D projection matrix\n * @param out - The matrix to store the result in\n * @param x1s - The x coordinate of the first source point\n * @param y1s - The y coordinate of the first source point\n * @param x1d - The x coordinate of the first destination point\n * @param y1d - The y coordinate of the first destination point\n * @param x2s - The x coordinate of the second source point\n * @param y2s - The y coordinate of the second source point\n * @param x2d - The x coordinate of the second destination point\n * @param y2d - The y coordinate of the second destination point\n * @param x3s - The x coordinate of the third source point\n * @param y3s - The y coordinate of the third source point\n * @param x3d - The x coordinate of the third destination point\n * @param y3d - The y coordinate of the third destination point\n * @param x4s - The x coordinate of the fourth source point\n * @param y4s - The y coordinate of the fourth source point\n * @param x4d - The x coordinate of the fourth destination point\n * @param y4d - The y coordinate of the fourth destination point\n * @returns - The computed 2D projection matrix\n * @private\n */\nexport function compute2DProjection(out: Matrix3x3, x1s: number, y1s: number, x1d: number, y1d: number, x2s: number, y2s: number, x2d: number, y2d: number, x3s: number, y3s: number, x3d: number, y3d: number, x4s: number, y4s: number, x4d: number, y4d: number): Matrix3x3;\n/**\n * Constructor options used for `MeshRope` instances. Allows configuration of a rope-like mesh\n * that follows a series of points with a texture applied.\n * @example\n * ```ts\n * // Create a basic rope with two points\n * const rope = new MeshRope({\n *     texture: Texture.from('snake.png'),\n *     points: [\n *         new Point(0, 0),\n *         new Point(100, 0)\n *     ]\n * });\n *\n * // Create a rope with high-quality texture scaling\n * const highQualityRope = new MeshRope({\n *     texture: Texture.from('rope-hd.png'),\n *     points: [\n *         new Point(0, 0),\n *         new Point(50, 25),\n *         new Point(100, 0)\n *     ],\n *     textureScale: 0.5  // Downscale HD texture for better quality\n * });\n * ```\n * @see {@link MeshRope} For the rope implementation\n * @see {@link RopeGeometry} For the underlying geometry\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface MeshRopeOptions extends Omit<MeshOptions, \"geometry\"> {\n\t/** The texture to use on the rope */\n\ttexture: Texture;\n\t/** An array of points that determine the rope's shape and path */\n\tpoints: PointData[];\n\t/**\n\t * Controls how the texture is scaled along the rope.\n\t * - If 0 (default), the texture stretches to fit between points\n\t * - If > 0, texture repeats with preserved aspect ratio\n\t * - Larger textures with textureScale < 1 can reduce artifacts\n\t * @default 0\n\t */\n\ttextureScale?: number;\n}\n/**\n * A specialized mesh that renders a texture along a path defined by points. Perfect for\n * creating snake-like animations, chains, ropes, and other flowing objects.\n * @example\n * ```ts\n * // Create a snake with multiple segments\n * const points = [];\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * }\n *\n * const snake = new MeshRope({\n *     texture: Texture.from('snake.png'),\n *     points,\n *     textureScale: 0.5\n * });\n *\n * // Animate the snake\n * app.ticker.add((delta) => {\n *     const time = performance.now() / 1000;\n *\n *     // Update points to create wave motion\n *     for (let i = 0; i < points.length; i++) {\n *         points[i].y = Math.sin(i * 0.5 + time) * 30;\n *         points[i].x = (i * 50) + Math.cos(i * 0.3 + time) * 20;\n *     }\n * });\n *\n * // Disable auto updates if manually updating\n * snake.autoUpdate = false;\n * ```\n * @category scene\n * @standard\n */\nexport class MeshRope extends Mesh {\n\t/**\n\t * Default options for creating a MeshRope instance. These values are used when specific\n\t * options aren't provided in the constructor.\n\t * @example\n\t * ```ts\n\t * // Use default options globally\n\t * MeshRope.defaultOptions = {\n\t *     textureScale: 0.5  // Set higher quality texture scaling\n\t * };\n\t *\n\t * // Create rope with modified defaults\n\t * const rope = new MeshRope({\n\t *     texture: Texture.from('rope.png'),\n\t *     points: [\n\t *         new Point(0, 0),\n\t *         new Point(100, 0)\n\t *     ]\n\t * }); // Will use textureScale: 0.5\n\t * ```\n\t * @property {number} textureScale - Controls texture scaling along the rope (0 = stretch)\n\t * @see {@link MeshRopeOptions} For all available options\n\t */\n\tstatic defaultOptions: Partial<MeshRopeOptions>;\n\t/**\n\t * Controls whether the rope's vertices are automatically recalculated each frame based on\n\t * its points. When true, the rope will update to follow point movements. When false,\n\t * manual updates are required.\n\t * @example\n\t * ```ts\n\t * const points = [];\n\t * for (let i = 0; i < 20; i++) {\n\t *     points.push(new Point(i * 50, 0));\n\t * }\n\t *\n\t * const rope = new MeshRope({\n\t *     texture: Texture.from('rope.png'),\n\t *     points\n\t * });\n\t *\n\t * // Auto-update (default)\n\t * app.ticker.add(() => {\n\t *     // Points will automatically update the rope\n\t *     for (let i = 0; i < points.length; i++) {\n\t *         points[i].y = Math.sin(i * 0.5 + performance.now() / 1000) * 30;\n\t *     }\n\t * });\n\t *\n\t * // Manual update\n\t * rope.autoUpdate = false;\n\t * app.ticker.add(() => {\n\t *     // Update points\n\t *     for (let i = 0; i < points.length; i++) {\n\t *         points[i].y = Math.sin(i * 0.5 + performance.now() / 1000) * 30;\n\t *     }\n\t *     // Manually trigger update\n\t *     (rope.geometry as RopeGeometry).update();\n\t * });\n\t * ```\n\t * @default true\n\t * @see {@link RopeGeometry#update} For manual geometry updates\n\t */\n\tautoUpdate: boolean;\n\t/**\n\t * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n\t * @param options\n\t * @param options.texture - The texture to use on the rope.\n\t * @param options.points - An array of {@link math.Point} objects to construct this rope.\n\t * @param {number} options.textureScale - Optional. Positive values scale rope texture\n\t * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n\t * and downsampling here. If set to zero, texture will be stretched instead.\n\t */\n\tconstructor(options: MeshRopeOptions);\n\tprivate _render;\n}\n/**\n * Options for creating a SimpleMesh instance. Defines the texture, geometry data, and rendering topology\n * for a basic mesh with direct vertex manipulation capabilities.\n * @example\n * ```ts\n * // Create a basic textured triangle\n * const mesh = new MeshSimple({\n *     texture: Texture.from('sprite.png'),\n *     vertices: new Float32Array([\n *         0, 0,      // Vertex 1\n *         100, 0,    // Vertex 2\n *         50, 100    // Vertex 3\n *     ]),\n *     uvs: new Float32Array([\n *         0, 0,    // UV 1\n *         1, 0,    // UV 2\n *         0.5, 1   // UV 3\n *     ])\n * });\n *\n * // Create an indexed quad with custom topology\n * const quadMesh = new MeshSimple({\n *     texture: Texture.from('square.png'),\n *     vertices: new Float32Array([\n *         0, 0,     // Top-left\n *         100, 0,   // Top-right\n *         100, 100, // Bottom-right\n *         0, 100    // Bottom-left\n *     ]),\n *     uvs: new Float32Array([\n *         0, 0,  // Top-left\n *         1, 0,  // Top-right\n *         1, 1,  // Bottom-right\n *         0, 1   // Bottom-left\n *     ]),\n *     indices: new Uint32Array([\n *         0, 1, 2,  // Triangle 1\n *         0, 2, 3   // Triangle 2\n *     ]),\n *     topology: 'triangle-list'\n * });\n * ```\n * @category scene\n * @advanced\n * @noInheritDoc\n */\nexport interface SimpleMeshOptions extends Omit<MeshOptions, \"geometry\"> {\n\t/** The texture to use */\n\ttexture: Texture;\n\t/** Array of vertex positions as x,y pairs. Each vertex is 2 floats - x, y */\n\tvertices?: Float32Array;\n\t/** Array of UV coordinates for texture mapping. Each UV is 2 floats - u, v */\n\tuvs?: Float32Array;\n\t/** Array of indices defining triangles. Each triangle is 3 indices into the vertices array. */\n\tindices?: Uint32Array;\n\t/**\n\t * How vertices are connected to form triangles.\n\t * - 'triangle-list': Individual triangles (default)\n\t * - 'triangle-strip': Connected triangle strip\n\t * - 'line-list': Lines between vertices\n\t * - 'line-strip': Connected line strip\n\t * - 'point-list': Points rendered individually\n\t * @default 'triangle-list'\n\t */\n\ttopology?: Topology;\n}\n/**\n * A simplified mesh class that provides an easy way to create and manipulate textured meshes\n * with direct vertex control. Perfect for creating custom shapes, deformable sprites, and\n * simple 2D effects.\n * @example\n * ```ts\n * // Create a basic triangle mesh\n * const triangleMesh = new MeshSimple({\n *     texture: Texture.from('sprite.png'),\n *     vertices: new Float32Array([\n *         0, 0,      // Top-left\n *         100, 0,    // Top-right\n *         50, 100    // Bottom-center\n *     ]),\n *     uvs: new Float32Array([\n *         0, 0,    // Map top-left of texture\n *         1, 0,    // Map top-right of texture\n *         0.5, 1   // Map bottom-center of texture\n *     ])\n * });\n *\n * // Animate vertices\n * app.ticker.add(() => {\n *     const time = performance.now() / 1000;\n *     const vertices = triangleMesh.vertices;\n *\n *     // Move the top vertex up and down\n *     vertices[1] = Math.sin(time) * 20;\n *     triangleMesh.vertices = vertices; // Update vertices\n *\n *     // Auto-updates by default\n * });\n *\n * // Create a line strip\n * const lineMesh = new MeshSimple({\n *     texture: Texture.from('line.png'),\n *     vertices: new Float32Array([\n *         0, 0,\n *         50, 50,\n *         100, 0,\n *         150, 50\n *     ]),\n *     topology: 'line-strip'\n * });\n *\n * // Manual vertex updates\n * lineMesh.autoUpdate = false;\n * const vertices = lineMesh.vertices;\n * vertices[0] += 10;\n * lineMesh.vertices = vertices; // Update vertices manually\n * // Update the vertices buffer manually\n * lineMesh.geometry.getBuffer('aPosition').update();\n * ```\n * @category scene\n * @advanced\n * @see {@link Mesh} For more advanced mesh customization\n * @see {@link MeshGeometry} For direct geometry manipulation\n */\nexport class MeshSimple extends Mesh {\n\t/**\n\t * Controls whether the mesh's vertex buffer is automatically updated each frame.\n\t * When true, vertex changes will be reflected immediately. When false, manual updates are required.\n\t * @example\n\t * ```ts\n\t * // Auto-update mode (default)\n\t * mesh.autoUpdate = true;\n\t * app.ticker.add(() => {\n\t *     // Vertices update automatically each frame\n\t *     const vertices = mesh.vertices;\n\t *     vertices[1] = Math.sin(performance.now() / 1000) * 20;\n\t *     mesh.vertices = vertices;\n\t * });\n\t *\n\t * // Manual update mode\n\t * mesh.autoUpdate = false;\n\t * app.ticker.add(() => {\n\t *     // Update vertices\n\t *     const vertices = mesh.vertices;\n\t *     vertices[1] = Math.sin(performance.now() / 1000) * 20;\n\t *     mesh.vertices = vertices;\n\t *\n\t *     // Manually trigger buffer update\n\t *     mesh.geometry.getBuffer('aPosition').update();\n\t * });\n\t * ```\n\t * @default true\n\t * @see {@link MeshGeometry#getBuffer} For manual buffer updates\n\t * @see {@link MeshSimple#vertices} For accessing vertex data\n\t */\n\tautoUpdate: boolean;\n\t/**\n\t * @param options - Options to be used for construction\n\t */\n\tconstructor(options: SimpleMeshOptions);\n\t/**\n\t * The vertex positions of the mesh as a TypedArray. Each vertex is represented by two\n\t * consecutive values (x, y) in the array. Changes to these values will update the mesh's shape.\n\t * @example\n\t * ```ts\n\t * // Read vertex positions\n\t * const vertices = mesh.vertices;\n\t * console.log('First vertex:', vertices[0], vertices[1]);\n\t *\n\t * // Modify vertices directly\n\t * vertices[0] += 10;  // Move first vertex right\n\t * vertices[1] -= 20;  // Move first vertex up\n\t *\n\t * // Animate vertices\n\t * app.ticker.add(() => {\n\t *     const time = performance.now() / 1000;\n\t *     const vertices = mesh.vertices;\n\t *\n\t *     // Wave motion\n\t *     for (let i = 0; i < vertices.length; i += 2) {\n\t *         vertices[i + 1] = Math.sin(time + i * 0.5) * 20;\n\t *     }\n\t * });\n\t * ```\n\t * @see {@link MeshSimple#autoUpdate} For controlling vertex buffer updates\n\t * @see {@link MeshGeometry#getBuffer} For direct buffer access\n\t */\n\tget vertices(): TypedArray;\n\tset vertices(value: TypedArray);\n\tprivate _render;\n}\n/**\n * Constructor options used for `RopeGeometry` instances.\n * ```js\n * const ropeGeometry = new RopeGeometry({\n *    points: [new Point(0, 0), new Point(100, 0)],\n *    width: 10,\n *    textureScale: 0,\n * });\n * ```\n * @see {@link RopeGeometry}\n * @category scene\n * @advanced\n */\nexport interface RopeGeometryOptions {\n\t/** The width (i.e., thickness) of the rope. */\n\twidth?: number;\n\t/** An array of points that determine the rope. */\n\tpoints?: PointData[];\n\t/**\n\t * Rope texture scale, if zero then the rope texture is stretched.\n\t * By default the rope texture will be stretched to match\n\t * rope length. If textureScale is positive this value will be treated as a scaling\n\t * factor and the texture will preserve its aspect ratio instead. To create a tiling rope\n\t * set baseTexture.wrapMode to 'repeat' and use a power of two texture,\n\t * then set textureScale=1 to keep the original texture pixel size.\n\t * In order to reduce alpha channel artifacts provide a larger texture and downsample -\n\t * i.e. set textureScale=0.5 to scale it down twice.\n\t */\n\ttextureScale?: number;\n}\n/**\n * RopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n * @example\n * import { Point, RopeGeometry } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * };\n * const rope = new RopeGeometry(100, points);\n * @category scene\n * @advanced\n */\nexport class RopeGeometry extends MeshGeometry {\n\t/** Default options for RopeGeometry constructor. */\n\tstatic defaultOptions: RopeGeometryOptions & MeshGeometryOptions;\n\t/** An array of points that determine the rope. */\n\tpoints: PointData[];\n\t/** Rope texture scale, if zero then the rope texture is stretched. */\n\treadonly textureScale: number;\n\t/**\n\t * The width (i.e., thickness) of the rope.\n\t * @readonly\n\t * @internal\n\t */\n\t_width: number;\n\t/**\n\t * @param options - Options to be applied to rope geometry\n\t */\n\tconstructor(options: RopeGeometryOptions);\n\t/**\n\t * The width (i.e., thickness) of the rope.\n\t * @readonly\n\t */\n\tget width(): number;\n\t/** Refreshes Rope indices and uvs */\n\tprivate _build;\n\t/** refreshes vertices of Rope mesh */\n\tupdateVertices(): void;\n\t/** Refreshes Rope indices and uvs */\n\tupdate(): void;\n}\n/**\n * A MeshAdaptor that uses the WebGL to render meshes.\n * @category rendering\n * @ignore\n */\nexport class GlMeshAdaptor implements MeshAdaptor {\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipesAdaptor\n\t\t];\n\t\treadonly name: \"mesh\";\n\t};\n\tprivate _shader;\n\tinit(): void;\n\texecute(meshPipe: MeshPipe, mesh: Mesh): void;\n\tdestroy(): void;\n}\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @category rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUPipesAdaptor\n\t\t];\n\t\treadonly name: \"mesh\";\n\t};\n\tprivate _shader;\n\tinit(): void;\n\texecute(meshPipe: MeshPipe, mesh: Mesh): void;\n\tdestroy(): void;\n}\n/**\n * @param texture\n * @param out\n * @internal\n */\nexport function getTextureDefaultMatrix(texture: Texture, out: Matrix): Matrix;\n/**\n * Represents a particle with properties for position, scale, rotation, color, and texture.\n * Particles are lightweight alternatives to sprites, optimized for use in particle systems.\n * @example\n * ```ts\n * // Create a basic particle\n * const particle = new Particle({\n *     texture: Texture.from('particle.png'),\n *     x: 100,\n *     y: 100,\n *     scaleX: 0.5,\n *     scaleY: 0.5,\n *     rotation: Math.PI / 4,  // 45 degrees\n *     tint: 0xff0000,        // Red tint\n *     alpha: 0.8             // Slightly transparent\n * });\n *\n * // Modify particle properties\n * particle.x += 10;          // Move right\n * particle.rotation += 0.1;   // Rotate slightly\n * particle.alpha = 0.5;      // Change transparency\n *\n * // Use anchor points (0-1 range)\n * particle.anchorX = 0.5;    // Center horizontally\n * particle.anchorY = 0.5;    // Center vertically\n * ```\n * @category scene\n * @standard\n */\nexport interface IParticle {\n\t/** The x-coordinate of the particle position */\n\tx: number;\n\t/** The y-coordinate of the particle position */\n\ty: number;\n\t/**\n\t * The horizontal scale factor of the particle\n\t * @default 1\n\t */\n\tscaleX: number;\n\t/**\n\t * The vertical scale factor of the particle\n\t * @default 1\n\t */\n\tscaleY: number;\n\t/**\n\t * The x-coordinate of the particle's anchor point (0-1 range)\n\t * @default 0\n\t */\n\tanchorX: number;\n\t/**\n\t * The y-coordinate of the particle's anchor point (0-1 range)\n\t * @default 0\n\t */\n\tanchorY: number;\n\t/**\n\t * The rotation of the particle in radians\n\t * @default 0\n\t */\n\trotation: number;\n\t/**\n\t * The color of the particle as a 32-bit RGBA value\n\t * @default 0xffffffff\n\t */\n\tcolor: number;\n\t/** The texture used to render this particle */\n\ttexture: Texture;\n}\n/**\n * Configuration options for creating a new particle. All properties except texture are optional\n * and will use default values if not specified.\n * @example\n * ```ts\n * // Create a basic red particle\n * const particle = new Particle({\n *     texture: Texture.from('particle.png'),\n *     tint: 0xff0000,\n *     alpha: 0.8\n * });\n *\n * // Create a scaled and rotated particle\n * const rotatedParticle = new Particle({\n *     texture: Texture.from('star.png'),\n *     x: 100,\n *     y: 100,\n *     scaleX: 2,\n *     scaleY: 2,\n *     rotation: Math.PI / 4,\n *     anchorX: 0.5,\n *     anchorY: 0.5\n * });\n *\n * // Use color strings for tint\n * const coloredParticle = new Particle({\n *     texture: Texture.from('circle.png'),\n *     tint: '#ff00ff',     // Magenta\n *     alpha: 0.5,          // Half transparent\n *     x: 200,\n *     y: 200\n * });\n * ```\n * @see {@link Particle} For the particle implementation\n * @see {@link IParticle} For the full particle interface\n * @category scene\n * @standard\n * @category scene\n * @standard\n */\nexport type ParticleOptions = Omit<Partial<IParticle>, \"color\"> & {\n\t/** The texture used to render this particle */\n\ttexture: Texture;\n\t/** The tint color as a hex number or CSS color string */\n\ttint?: ColorSource;\n\t/** The alpha transparency (0-1) */\n\talpha?: number;\n};\n/**\n * Represents a single particle within a particle container. This class implements the IParticle interface,\n * providing properties and methods to manage the particle's position, scale, rotation, color, and texture.\n *\n * The reason we use a particle over a sprite is that these are much lighter weight and we can create a lot of them\n * without taking on the overhead of a full sprite.\n * @example\n * ```javascript\n * const particle = new Particle({\n *   texture,\n *   x: 100,\n *   y: 100,\n *   scaleX: 0.5,\n *   scaleY: 0.5,\n *   rotation: Math.PI / 2,\n *   color: 0xff0000,\n * });\n * ```\n * @category scene\n * @standard\n */\nexport class Particle implements IParticle {\n\t/**\n\t * Default options used when creating new particles. These values are applied when specific\n\t * options aren't provided in the constructor.\n\t * @example\n\t * ```ts\n\t * // Override defaults globally\n\t * Particle.defaultOptions = {\n\t *     ...Particle.defaultOptions,\n\t *     anchorX: 0.5,\n\t *     anchorY: 0.5,\n\t *     alpha: 0.8\n\t * };\n\t *\n\t * // New particles use modified defaults\n\t * const centeredParticle = new Particle(texture);\n\t * console.log(centeredParticle.anchorX); // 0.5\n\t * console.log(centeredParticle.alpha); // 0.8\n\t * ```\n\t * @see {@link ParticleOptions} For all available options\n\t * @see {@link Particle} For the particle implementation\n\t */\n\tstatic defaultOptions: Partial<ParticleOptions>;\n\t/**\n\t * The x-coordinate of the anchor point (0-1).\n\t * Controls the origin point for rotation and scaling.\n\t * @example\n\t * ```ts\n\t * particle.anchorX = 0.5; // Center horizontally\n\t * ```\n\t * @default 0\n\t */\n\tanchorX: number;\n\t/**\n\t * The y-coordinate of the anchor point (0-1).\n\t * Controls the origin point for rotation and scaling.\n\t * @example\n\t * ```ts\n\t * particle.anchorY = 0.5; // Center vertically\n\t * ```\n\t * @default 0\n\t */\n\tanchorY: number;\n\t/**\n\t * The x-coordinate of the particle in world space.\n\t * @example\n\t * ```ts\n\t * particle.x = 100; // Move right\n\t * particle.x += Math.sin(time) * 10; // Oscillate horizontally\n\t * ```\n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The y-coordinate of the particle in world space.\n\t * @example\n\t * ```ts\n\t * particle.y = 100; // Move down\n\t * particle.y += Math.cos(time) * 10; // Oscillate vertically\n\t * ```\n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The horizontal scale factor of the particle.\n\t * Values greater than 1 increase size, less than 1 decrease size.\n\t * @example\n\t * ```ts\n\t * particle.scaleX = 2; // Double width\n\t * particle.scaleX *= 0.9; // Shrink over time\n\t * ```\n\t * @default 1\n\t */\n\tscaleX: number;\n\t/**\n\t * The vertical scale factor of the particle.\n\t * Values greater than 1 increase size, less than 1 decrease size.\n\t * @example\n\t * ```ts\n\t * particle.scaleY = 2; // Double height\n\t * particle.scaleY *= 0.9; // Shrink over time\n\t * ```\n\t * @default 1\n\t */\n\tscaleY: number;\n\t/**\n\t * The rotation of the particle in radians.\n\t * Positive values rotate clockwise.\n\t * @example\n\t * ```ts\n\t * particle.rotation = Math.PI; // 180 degrees\n\t * particle.rotation += 0.1; // Rotate slowly clockwise\n\t * ```\n\t * @default 0\n\t */\n\trotation: number;\n\t/**\n\t * The color of the particle as a 32-bit RGBA value.\n\t * Combines tint and alpha into a single value.\n\t * @example\n\t * ```ts\n\t * // Usually set via tint and alpha properties\n\t * particle.tint = 0xff0000; // Red\n\t * particle.alpha = 0.5; // Half transparent\n\t * console.log(particle.color); // Combined RGBA value\n\t * ```\n\t * @default 0xffffffff\n\t */\n\tcolor: number;\n\t/**\n\t * The texture used to render this particle.\n\t * All particles in a container should share the same base texture.\n\t * @example\n\t * ```ts\n\t * particle.texture = Texture.from('particle.png');\n\t * ```\n\t */\n\ttexture: Texture;\n\tprivate _alpha;\n\tprivate _tint;\n\tconstructor(options: Texture | ParticleOptions);\n\t/**\n\t * The transparency of the particle. Values range from 0 (fully transparent)\n\t * to 1 (fully opaque). Values outside this range are clamped.\n\t * @example\n\t * ```ts\n\t * // Create a semi-transparent particle\n\t * const particle = new Particle({\n\t *     texture: Texture.from('particle.png'),\n\t *     alpha: 0.5\n\t * });\n\t *\n\t * // Fade out\n\t * particle.alpha *= 0.9;\n\t *\n\t * // Fade in\n\t * particle.alpha = Math.min(particle.alpha + 0.1, 1);\n\t *\n\t * // Values are clamped to valid range\n\t * particle.alpha = 1.5; // Becomes 1.0\n\t * particle.alpha = -0.5; // Becomes 0.0\n\t *\n\t * // Animate transparency\n\t * app.ticker.add((delta) => {\n\t *     const time = performance.now() / 1000;\n\t *     particle.alpha = 0.5 + Math.sin(time) * 0.5; // Pulse between 0-1\n\t * });\n\t * ```\n\t * @default 1\n\t * @see {@link Particle#tint} For controlling particle color\n\t * @see {@link Particle#color} For the combined color and alpha value\n\t */\n\tget alpha(): number;\n\tset alpha(value: number);\n\t/**\n\t * The tint color of the particle. Can be set using hex numbers or CSS color strings.\n\t * The tint is multiplied with the texture color to create the final particle color.\n\t * @example\n\t * ```ts\n\t * // Create a red particle\n\t * const particle = new Particle({\n\t *     texture: Texture.from('particle.png'),\n\t *     tint: 0xff0000\n\t * });\n\t *\n\t * // Use CSS color strings\n\t * particle.tint = '#00ff00';  // Green\n\t * particle.tint = 'blue';     // Blue\n\t *\n\t * // Animate tint color\n\t * app.ticker.add(() => {\n\t *     const time = performance.now() / 1000;\n\t *\n\t *     // Cycle through hues\n\t *     const hue = (time * 50) % 360;\n\t *     particle.tint = `hsl(${hue}, 100%, 50%)`;\n\t * });\n\t *\n\t * // Reset to white (no tint)\n\t * particle.tint = 0xffffff;\n\t * ```\n\t * @type {ColorSource} Hex number or CSS color string\n\t * @default 0xffffff\n\t * @see {@link Particle#alpha} For controlling transparency\n\t * @see {@link Particle#color} For the combined color and alpha value\n\t * @see {@link Color} For supported color formats\n\t */\n\tget tint(): number;\n\tset tint(value: ColorSource);\n\tprivate _updateColor;\n}\n/** @internal */\nexport interface ParticleRendererProperty {\n\tattributeName: string;\n\tformat: VertexFormat;\n\tcode: string;\n\tdynamic: boolean;\n\tupdateFunction?: (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array, offset: number, stride: number) => void;\n}\n/** @internal */\nexport const particleData: Record<string, ParticleRendererProperty>;\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>): {\n\tdynamicUpdate: ParticleUpdateFunction;\n\tstaticUpdate: ParticleUpdateFunction;\n};\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions {\n\t/** The size of the particle buffer, defaults to 1000. */\n\tsize: number;\n\t/** A record of attributes that the particle container uses. */\n\tproperties: Record<string, ParticleRendererProperty>;\n}\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer implements GPUData {\n\t/** The buffer containing static attribute data for all elements in the batch. */\n\tstaticAttributeBuffer: ViewableBuffer;\n\t/** The buffer containing dynamic attribute data for all elements in the batch. */\n\tdynamicAttributeBuffer: ViewableBuffer;\n\tprivate readonly _staticBuffer;\n\tprivate readonly _dynamicBuffer;\n\t/** The buffer containing index data for all elements in the batch. */\n\tindexBuffer: IndexBufferArray;\n\tprivate readonly _dynamicStride;\n\tprivate readonly _staticStride;\n\t/** The geometry of the particle buffer. */\n\treadonly geometry: Geometry;\n\tprivate _size;\n\tprivate readonly _dynamicUpload;\n\tprivate readonly _staticUpload;\n\tprivate readonly _generateParticleUpdateCache;\n\tconstructor(options: ParticleBufferOptions);\n\tgetParticleUpdate(properties: Record<string, ParticleRendererProperty>): {\n\t\tdynamicUpdate: ParticleUpdateFunction;\n\t\tstaticUpdate: ParticleUpdateFunction;\n\t};\n\tgenerateParticleUpdate(properties: Record<string, ParticleRendererProperty>): {\n\t\tdynamicUpdate: ParticleUpdateFunction;\n\t\tstaticUpdate: ParticleUpdateFunction;\n\t};\n\tupdate(particles: IParticle[], uploadStatic: boolean): void;\n\tdestroy(): void;\n}\n/**\n * Represents the properties of a particle that can be dynamically updated each frame.\n * These properties control which aspects of particles are recalculated during rendering.\n * Setting a property to true enables per-frame updates, while false only updates when manually triggered.\n * @example\n * ```ts\n * // Create a particle container with dynamic position and rotation\n * const container = new ParticleContainer({\n *     dynamicProperties: {\n *         position: true,  // Update positions each frame\n *         rotation: true,  // Update rotations each frame\n *         vertex: false,   // Static vertices\n *         uvs: false,     // Static texture coordinates\n *         color: false     // Static colors\n *     }\n * });\n *\n * // Create a fully dynamic particle container\n * const dynamicContainer = new ParticleContainer({\n *     dynamicProperties: {\n *         vertex: true,    // Dynamic mesh deformation\n *         position: true,  // Dynamic movement\n *         rotation: true,  // Dynamic spinning\n *         uvs: true,      // Dynamic texture animation\n *         color: true     // Dynamic coloring\n *     }\n * });\n * ```\n * @see {@link ParticleContainer} For the main particle container class\n * @see {@link ParticleContainerOptions} For all container configuration options\n * @category scene\n * @standard\n */\nexport interface ParticleProperties {\n\t/**\n\t * When true, vertex positions are updated each frame.\n\t * Useful for mesh deformation effects.\n\t * @default false\n\t */\n\tvertex?: boolean;\n\t/**\n\t * When true, particle positions are updated each frame.\n\t * Essential for moving particles.\n\t * @default true\n\t */\n\tposition?: boolean;\n\t/**\n\t * When true, rotation values are updated each frame.\n\t * Needed for spinning particles.\n\t * @default false\n\t */\n\trotation?: boolean;\n\t/**\n\t * When true, texture coordinates are updated each frame.\n\t * Required for texture animation.\n\t * @default false\n\t */\n\tuvs?: boolean;\n\t/**\n\t * When true, color values are updated each frame.\n\t * Enables color transitions and alpha changes.\n\t * @default false\n\t */\n\tcolor?: boolean;\n}\n/**\n * Options for configuring a ParticleContainer. Controls how particles are rendered, updated, and managed.\n * @example\n * ```ts\n * // Create a basic particle container\n * const container = new ParticleContainer({\n *     texture: Texture.from('particle.png'),\n *     particles: [\n *         new Particle(texture),\n *         new Particle(texture)\n *     ],\n *     dynamicProperties: {\n *         position: true,  // Update positions each frame\n *         rotation: true   // Update rotations each frame\n *     }\n * });\n * ```\n * @see {@link ParticleContainer} For the main particle container class\n * @see {@link ParticleProperties} For dynamic property configuration\n * @template T The type of particles in the container. Must implement {@link IParticle}. * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface ParticleContainerOptions<T extends IParticle = IParticle> extends PixiMixins.ParticleContainerOptions, Omit<ViewContainerOptions, \"children\"> {\n\t/**\n\t * Specifies which particle properties should update each frame.\n\t * Set properties to true for per-frame updates, false for static values.\n\t * @default { position: true, rotation: false, vertex: false, uvs: false, color: false }\n\t */\n\tdynamicProperties?: ParticleProperties & Record<string, boolean>;\n\t/**\n\t * Custom shader for rendering particles. Allows for custom visual effects.\n\t * @advanced\n\t */\n\tshader?: Shader;\n\t/**\n\t * When true, particle positions are rounded to the nearest pixel.\n\t * Helps achieve crisp rendering at the cost of smooth motion.\n\t * @default false\n\t */\n\troundPixels?: boolean;\n\t/**\n\t * The texture used for all particles in this container.\n\t * If not provided, uses the texture of the first particle added.\n\t */\n\ttexture?: Texture;\n\t/** Initial array of particles to add to the container. All particles must share the same base texture. */\n\tparticles?: T[];\n}\nexport interface ParticleContainer extends PixiMixins.ParticleContainer, ViewContainer<ParticleBuffer> {\n}\n/**\n * The ParticleContainer class is a highly optimized container that can render 1000s or particles at great speed.\n *\n * A ParticleContainer is specialized in that it can only contain and render particles. Particles are\n * lightweight objects that use minimal memory, which helps boost performance.\n *\n * It can render particles EXTREMELY fast!\n *\n * The tradeoff of using a ParticleContainer is that most advanced functionality is unavailable. Particles are simple\n * and cannot have children, filters, masks, etc. They possess only the basic properties: position, scale, rotation,\n * and color.\n *\n * All particles must share the same texture source (using something like a sprite sheet works well here).\n *\n * When creating a ParticleContainer, a developer can specify which of these properties are static and which are dynamic.\n * - Static properties are only updated when you add or remove a child, or when the `update` function is called.\n * - Dynamic properties are updated every frame.\n *\n * It is up to the developer to specify which properties are static and which are dynamic. Generally, the more static\n * properties you have (i.e., those that do not change per frame), the faster the rendering.\n *\n * If the developer modifies the children order or any static properties of the particle, they must call the `update` method.\n *\n * By default, only the `position` property is set to dynamic, which makes rendering very fast!\n *\n * Developers can also provide a custom shader to the particle container, allowing them to render particles in a custom way.\n *\n * To help with performance, the particle containers bounds are not calculated.\n * It's up to the developer to set the boundsArea property.\n *\n * It's extremely easy to use. Below is an example of rendering thousands of sprites at lightning speed.\n *\n * --------- EXPERIMENTAL ---------\n *\n * This is a new API, things may change and it may not work as expected.\n * We want to hear your feedback as we go!\n *\n * --------------------------------\n * @example\n * ```ts\n * import { ParticleContainer, Particle } from 'pixi.js';\n *\n * const container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let particle = new Particle(texture);\n *     container.addParticle(particle);\n * }\n * ```\n * @template T The type of particles in the container. Must implement {@link IParticle}.\n * @category scene\n * @standard\n */\nexport class ParticleContainer<T extends IParticle = IParticle> extends ViewContainer<ParticleBuffer> implements Instruction {\n\t/**\n\t * Defines the default options for creating a ParticleContainer.\n\t * @example\n\t * ```ts\n\t * // Change defaults globally\n\t * ParticleContainer.defaultOptions = {\n\t *     dynamicProperties: {\n\t *         position: true,  // Update positions each frame\n\t *         rotation: true,  // Update rotations each frame\n\t *         vertex: false,   // Static vertices\n\t *         uvs: false,      // Static texture coordinates\n\t *         color: false     // Static colors\n\t *     },\n\t *     roundPixels: true // Enable pixel rounding for crisp rendering\n\t * };\n\t * ```\n\t * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n\t * @property {boolean} roundPixels - Indicates if pixels should be rounded.\n\t */\n\tstatic defaultOptions: Pick<ParticleContainerOptions, \"dynamicProperties\" | \"roundPixels\">;\n\t/**\n\t * The unique identifier for the render pipe of this ParticleContainer.\n\t * @internal\n\t */\n\treadonly renderPipeId: string;\n\t/** @internal */\n\tbatched: boolean;\n\t/**\n\t * A record of properties and their corresponding ParticleRendererProperty.\n\t * @internal\n\t */\n\t_properties: Record<string, ParticleRendererProperty>;\n\t/**\n\t * Indicates if the children of this ParticleContainer have changed and need to be updated.\n\t * @internal\n\t */\n\t_childrenDirty: boolean;\n\t/**\n\t * An array of particles that are children of this ParticleContainer.\n\t * This array can be modified directly for performance, but the 'update' method\n\t * must be called afterwards to ensure the container is rendered correctly.\n\t * @example\n\t * ```ts\n\t * const container = new ParticleContainer();\n\t *\n\t * // Add particles directly to the array\n\t * container.particleChildren.push(\n\t *     new Particle(texture),\n\t *     new Particle(texture)\n\t * );\n\t * container.update(); // Required after direct modification\n\t *\n\t * // Modify existing particles\n\t * container.particleChildren.forEach(particle => {\n\t *     particle.position.x += 10;\n\t * });\n\t *\n\t * // Remove particles\n\t * container.particleChildren.length = 0; // Clear all\n\t * container.update();\n\t * ```\n\t * @see {@link ParticleContainer#update} For updating after modifications\n\t * @see {@link ParticleContainer#addParticle} For a safer way to add particles\n\t * @see {@link ParticleContainer#removeParticle} For a safer way to remove particles\n\t */\n\tparticleChildren: T[];\n\t/**\n\t * The shader used for rendering particles in this ParticleContainer.\n\t * @advanced\n\t */\n\tshader: Shader;\n\t/**\n\t * The texture used for rendering particles in this ParticleContainer. All particles\n\t * must share the same base texture for optimal performance.\n\t *\n\t * > [!NOTE]\n\t * > If not set, the texture of the first particle added to this container will be used.\n\t * @example\n\t * ```ts\n\t * const container = new ParticleContainer();\n\t * // Set texture for all particles\n\t * container.texture = Texture.from('particle.png');\n\t *\n\t * // Create particles using container's texture\n\t * for (let i = 0; i < 100; i++) {\n\t *     const particle = new Particle(container.texture);\n\t *     container.addParticle(particle); // Will use the particles texture if not set\n\t * }\n\t * ```\n\t * @default null\n\t * @see {@link ParticleContainerOptions#texture} For setting texture via constructor\n\t * @see {@link Particle} For creating particles with textures\n\t */\n\ttexture: Texture;\n\t/**\n\t * @param options - The options for creating the sprite.\n\t */\n\tconstructor(options?: ParticleContainerOptions<T>);\n\t/**\n\t * Adds one or more particles to the container. The particles will be rendered using the container's shared texture\n\t * and properties. When adding multiple particles, they must all share the same base texture.\n\t * @example\n\t * ```ts\n\t * const container = new ParticleContainer();\n\t *\n\t * // Add a single particle\n\t * const particle = new Particle(Assets.get('particleTexture'));\n\t * container.addParticle(particle);\n\t *\n\t * // Add multiple particles at once\n\t * const particles = [\n\t *     new Particle(Assets.get('particleTexture')),\n\t *     new Particle(Assets.get('particleTexture')),\n\t *     new Particle(Assets.get('particleTexture'))\n\t * ];\n\t *\n\t * container.addParticle(...particles);\n\t * ```\n\t * @param children - The Particle(s) to add to the container\n\t * @returns The first particle that was added, for method chaining\n\t * @see {@link ParticleContainer#texture} For setting the shared texture\n\t * @see {@link ParticleContainer#update} For updating after modifications\n\t */\n\taddParticle(...children: T[]): T;\n\t/**\n\t * Removes one or more particles from the container. The particles must already be children\n\t * of this container to be removed.\n\t * @example\n\t * ```ts\n\t * // Remove a single particle\n\t * container.removeParticle(particle1);\n\t *\n\t * // Remove multiple particles at once\n\t * container.removeParticle(particle2, particle3);\n\t * ```\n\t * @param children - The Particle(s) to remove from the container\n\t * @returns The first particle that was removed, for method chaining\n\t * @see {@link ParticleContainer#particleChildren} For accessing all particles\n\t * @see {@link ParticleContainer#removeParticles} For removing particles by index\n\t * @see {@link ParticleContainer#removeParticleAt} For removing a particle at a specific index\n\t */\n\tremoveParticle(...children: T[]): T;\n\t/**\n\t * Updates the particle container's internal state. Call this method after manually modifying\n\t * the particleChildren array or when changing static properties of particles.\n\t * @example\n\t * ```ts\n\t * // Batch modify particles\n\t * container.particleChildren.push(...particles);\n\t * container.update(); // Required after direct array modification\n\t *\n\t * // Update static properties\n\t * container.particleChildren.forEach(particle => {\n\t *     particle.position.set(\n\t *         Math.random() * 800,\n\t *         Math.random() * 600\n\t *     );\n\t * });\n\t * container.update(); // Required after changing static positions\n\t * ```\n\t * @see {@link ParticleProperties} For configuring dynamic vs static properties\n\t * @see {@link ParticleContainer#particleChildren} For direct array access\n\t */\n\tupdate(): void;\n\tprotected onViewUpdate(): void;\n\t/**\n\t * Returns a static empty bounds object since ParticleContainer does not calculate bounds automatically\n\t * for performance reasons. Use the `boundsArea` property to manually set container bounds.\n\t * @example\n\t * ```ts\n\t * const container = new ParticleContainer({\n\t *     texture: Texture.from('particle.png')\n\t * });\n\t *\n\t * // Default bounds are empty\n\t * console.log(container.bounds); // Bounds(0, 0, 0, 0)\n\t *\n\t * // Set manual bounds for the particle area\n\t * container.boundsArea = {\n\t *     minX: 0,\n\t *     minY: 0,\n\t *     maxX: 800,\n\t *     maxY: 600\n\t * };\n\t * ```\n\t * @readonly\n\t * @returns {Bounds} An empty bounds object (0,0,0,0)\n\t * @see {@link Container#boundsArea} For manually setting container bounds\n\t * @see {@link Bounds} For bounds object structure\n\t */\n\tget bounds(): Bounds;\n\t/** @private */\n\tprotected updateBounds(): void;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * particleContainer.destroy();\n\t * particleContainer.destroy(true);\n\t * particleContainer.destroy({ texture: true, textureSource: true, children: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * Removes all particles from this container that are within the begin and end indexes.\n\t * @param beginIndex - The beginning position.\n\t * @param endIndex - The ending position. Default value is size of the container.\n\t * @returns - List of removed particles\n\t */\n\tremoveParticles(beginIndex?: number, endIndex?: number): T[];\n\t/**\n\t * Removes a particle from the specified index position.\n\t * @param index - The index to get the particle from\n\t * @returns The particle that was removed.\n\t */\n\tremoveParticleAt<U extends T = T>(index: number): U;\n\t/**\n\t * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.\n\t * If the particle is already in this container, it will be moved to the specified index.\n\t * @param {Container} child - The particle to add.\n\t * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.\n\t * @returns {Container} The particle that was added.\n\t */\n\taddParticleAt<U extends T = T>(child: U, index: number): U;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.\n\t * @param {...any} _children\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\taddChild<U extends ContainerChild[]>(..._children: U): U[0];\n\t/**\n\t * This method is not available in ParticleContainer.\n\t * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.\n\t * @param {...any} _children\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tremoveChild<U extends ContainerChild[]>(..._children: U): U[0];\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.\n\t * @param {number} [_beginIndex]\n\t * @param {number} [_endIndex]\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tremoveChildren(_beginIndex?: number, _endIndex?: number): ContainerChild[];\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tremoveChildAt<U extends ContainerChild>(_index: number): U;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tgetChildAt<U extends ContainerChild>(_index: number): U;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.\n\t * @param {ContainerChild} _child\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tsetChildIndex(_child: ContainerChild, _index: number): void;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.\n\t * @param {ContainerChild} _child\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\tgetChildIndex(_child: ContainerChild): number;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.\n\t * @param {ContainerChild} _child\n\t * @param {number} _index\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\taddChildAt<U extends ContainerChild>(_child: U, _index: number): U;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.\n\t * @param {ContainerChild} _child\n\t * @param {ContainerChild} _child2\n\t * @ignore\n\t */\n\tswapChildren<U extends ContainerChild>(_child: U, _child2: U): void;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param _child - The child to reparent\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\treparentChild(..._child: ContainerChild[]): any;\n\t/**\n\t * This method is not available in ParticleContainer.\n\t *\n\t * Calling this method will throw an error.\n\t * @param _child - The child to reparent\n\t * @param _index - The index to reparent the child to\n\t * @throws {Error} Always throws an error as this method is not available.\n\t * @ignore\n\t */\n\treparentChildAt(_child: ContainerChild, _index: number): any;\n}\n/** @internal */\nexport interface ParticleContainerAdaptor {\n\texecute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer> {\n\t/** The default shader that is used if a sprite doesn't have a more specific one. */\n\tdefaultShader: Shader;\n\t/** @internal */\n\tadaptor: ParticleContainerAdaptor;\n\t/** @internal */\n\treadonly state: State;\n\t/** @internal */\n\treadonly renderer: Renderer;\n\tprivate readonly _managedContainers;\n\t/** Local uniforms that are used for rendering particles. */\n\treadonly localUniforms: UniformGroup<{\n\t\tuTranslationMatrix: {\n\t\t\tvalue: Matrix;\n\t\t\ttype: \"mat3x3<f32>\";\n\t\t};\n\t\tuColor: {\n\t\t\tvalue: Float32Array;\n\t\t\ttype: \"vec4<f32>\";\n\t\t};\n\t\tuRound: {\n\t\t\tvalue: number;\n\t\t\ttype: \"f32\";\n\t\t};\n\t\tuResolution: {\n\t\t\tvalue: number[];\n\t\t\ttype: \"vec2<f32>\";\n\t\t};\n\t}>;\n\t/**\n\t * @param renderer - The renderer this sprite batch works for.\n\t * @param adaptor\n\t */\n\tconstructor(renderer: Renderer, adaptor: ParticleContainerAdaptor);\n\tvalidateRenderable(_renderable: ParticleContainer): boolean;\n\taddRenderable(renderable: ParticleContainer, instructionSet: InstructionSet): void;\n\tgetBuffers(renderable: ParticleContainer): ParticleBuffer;\n\tprivate _initBuffer;\n\tupdateRenderable(_renderable: ParticleContainer): void;\n\texecute(container: ParticleContainer): void;\n\t/** Destroys the ParticleRenderer. */\n\tdestroy(): void;\n}\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor {\n\texecute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer): void;\n}\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor {\n\texecute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer): void;\n}\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes\n\t\t];\n\t\treadonly name: \"particle\";\n\t};\n\tconstructor(renderer: WebGLRenderer);\n}\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGPUPipes\n\t\t];\n\t\treadonly name: \"particle\";\n\t};\n\tconstructor(renderer: WebGPURenderer);\n}\n/** @internal */\nexport class ParticleShader extends Shader {\n\tconstructor();\n}\n/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(size: number, outBuffer?: Uint16Array | Uint32Array | null): Uint16Array | Uint32Array;\n/**\n * A collection of textures or frame objects that can be used to create an `AnimatedSprite`.\n * @see {@link AnimatedSprite}\n * @category scene\n * @standard\n */\nexport type AnimatedSpriteFrames = Texture[] | FrameObject[];\n/**\n * Constructor options used for `AnimatedSprite` instances. Allows configuration of animation\n * playback, speed, and texture frames.\n * @example\n * ```ts\n * // Create a basic animated sprite\n * const sprite = new AnimatedSprite({\n *     textures: [\n *         Texture.from('walk1.png'),\n *         Texture.from('walk2.png'),\n *         Texture.from('walk3.png')\n *     ],\n *     animationSpeed: 0.1,\n *     loop: true\n * });\n *\n * // Create with spritesheet frames and callbacks\n * const sheet = await Assets.load('character.json');\n * const animatedSprite = new AnimatedSprite({\n *     textures: sheet.animations['walk'],\n *     autoPlay: true,\n *     updateAnchor: true,\n *     onComplete: () => console.log('Animation complete'),\n *     onFrameChange: (frame) => console.log('Current frame:', frame),\n *     onLoop: () => console.log('Animation looped')\n * });\n *\n * // Create with custom timing for each frame\n * const customTimingSprite = new AnimatedSprite({\n *     textures: [\n *         { texture: Texture.from('frame1.png'), time: 100 },\n *         { texture: Texture.from('frame2.png'), time: 200 },\n *         { texture: Texture.from('frame3.png'), time: 300 }\n *     ],\n *     autoUpdate: true\n * });\n * ```\n * @see {@link AnimatedSprite} For the main sprite class\n * @see {@link Spritesheet} For loading animations from spritesheets\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface AnimatedSpriteOptions extends PixiMixins.AnimatedSpriteOptions, Omit<SpriteOptions, \"texture\"> {\n\t/**\n\t * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n\t * @example\n\t * ```ts\n\t * // Create an AnimatedSprite with a slower animation speed\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     animationSpeed: 0.5 // Slower animation\n\t * });\n\t *\n\t * // Update the animation speed to make it faster\n\t * animation.animationSpeed = 2; // Faster animation\n\t * ```\n\t * @default 1\n\t */\n\tanimationSpeed?: number;\n\t/**\n\t * Whether to start the animation immediately on creation.\n\t * If set to `true`, the animation will start playing as soon as the\n\t * `AnimatedSprite` is created.\n\t * If set to `false`, you will need to call the `play` method to start the animation.\n\t * @example\n\t * ```ts\n\t * // Create an AnimatedSprite that starts playing immediately\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     autoPlay: true\n\t * });\n\t *\n\t * // Create an AnimatedSprite that does not start playing immediately\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     autoPlay: false\n\t * });\n\t * animation.play(); // Start the animation manually\n\t * ```\n\t * @default false\n\t */\n\tautoPlay?: boolean;\n\t/**\n\t * Whether to use Ticker.shared to auto update animation time.\n\t * This is useful for animations that need to be updated every frame.\n\t * If set to `false`, you will need to manually call the `update` method\n\t * to update the animation.\n\t * @example\n\t * ```ts\n\t * // Create an AnimatedSprite that does not auto update\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     autoUpdate: false\n\t * });\n\t *\n\t * // Manually update the animation in your game loop\n\t * ticker.add((ticker) => {\n\t *     animation.update(ticker);\n\t * }\n\t * ```\n\t * @default true\n\t */\n\tautoUpdate?: boolean;\n\t/**\n\t * Whether or not the animation repeats after playing.\n\t * @default true\n\t */\n\tloop?: boolean;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite finishes playing.\n\t * @example\n\t * ```ts\n\t * animation.onComplete = () => {\n\t *     // Finished!\n\t *     console.log('Animation complete');\n\t * };\n\t * ```\n\t * @default null\n\t * @see {@link AnimatedSprite#onFrameChange} For the callback when the frame changes\n\t * @see {@link AnimatedSprite#onLoop} For the callback when the animation loops\n\t * @see {@link AnimatedSprite#loop} For the loop behavior of the animation\n\t */\n\tonComplete?: () => void;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n\t * @example\n\t * ```ts\n\t * animation.onFrameChange = (currentFrame) => {\n\t *     // Updated!\n\t *     console.log('Current frame:', currentFrame);\n\t * };\n\t * ```\n\t * @see {@link AnimatedSprite#onComplete} For the callback when the animation finishes\n\t * @see {@link AnimatedSprite#onLoop} For the callback when the animation loops\n\t * @default null\n\t */\n\tonFrameChange?: (currentFrame: number) => void;\n\t/**\n\t * User-assigned function to call when `loop` is true,\n\t * and an AnimatedSprite is played and loops around to start again.\n\t * @example\n\t * ```ts\n\t * animation.onLoop = () => {\n\t *     // Looped!\n\t * };\n\t * ```\n\t * @see {@link AnimatedSprite#onComplete} For the callback when the animation finishes\n\t * @see {@link AnimatedSprite#onFrameChange} For the callback when the frame changes\n\t * @see {@link AnimatedSprite#loop} For the loop behavior of the animation\n\t * @default null\n\t */\n\tonLoop?: () => void;\n\t/**\n\t * An array of {@link Texture} or frame objects that make up the animation.\n\t * @example\n\t * ```ts\n\t * // Create an AnimatedSprite with an array of textures\n\t * const animation = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('frame1.png'),\n\t *         Texture.from('frame2.png'),\n\t *         Texture.from('frame3.png')\n\t *     ]\n\t * });\n\t * * // Create an AnimatedSprite with an array of frame objects\n\t * const animation = new AnimatedSprite({\n\t *     textures: [\n\t *         { texture: Texture.from('frame1.png'), time: 100 },\n\t *         { texture: Texture.from('frame2.png'), time: 200 },\n\t *         { texture: Texture.from('frame3.png'), time: 300 }\n\t *     ]\n\t * });\n\t * ```\n\t * @see {@link AnimatedSpriteFrames} For the type of the textures array\n\t */\n\ttextures: AnimatedSpriteFrames;\n\t/**\n\t * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n\t *\n\t * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n\t * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n\t * of the frame (e.g. left foot).\n\t * > [!NOTE] Enabling this will override any previously set `anchor` on each frame change.\n\t * @example\n\t * ```ts\n\t * // Create an AnimatedSprite with updateAnchor enabled\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     updateAnchor: true\n\t * });\n\t * ```\n\t * @see {@link Texture#defaultAnchor} For the default anchor of the texture\n\t * @default false\n\t */\n\tupdateAnchor?: boolean;\n}\nexport interface AnimatedSprite extends PixiMixins.AnimatedSprite, Sprite {\n}\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n * @example\n * ```js\n * import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet}\n * containing the animation definitions:\n * @example\n * ```js\n * import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n * ```\n * @category scene\n * @standard\n */\nexport class AnimatedSprite extends Sprite {\n\t/**\n\t * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n\t * @example\n\t * ```ts\n\t * // Create a sprite with normal speed animation\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ],\n\t *     animationSpeed: 1 // Default speed\n\t * });\n\t *\n\t * // Slow down the animation\n\t * sprite.animationSpeed = 0.5;\n\t *\n\t * // Speed up the animation\n\t * sprite.animationSpeed = 2;\n\t *\n\t * // Reverse the animation\n\t * sprite.animationSpeed = -1;\n\t *\n\t * // Stop the animation\n\t * sprite.animationSpeed = 0;\n\t * ```\n\t * @default 1\n\t * @see {@link AnimatedSprite#currentFrame} For the current frame index\n\t * @see {@link AnimatedSprite#totalFrames} For total number of frames\n\t */\n\tanimationSpeed: number;\n\t/**\n\t * Whether or not the animation repeats after playing.\n\t * When true, the animation will restart from the beginning after reaching the last frame.\n\t * When false, the animation will stop on the last frame.\n\t * @example\n\t * ```ts\n\t * // Create a looping animation\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ],\n\t *     loop: true // Will repeat\n\t * });\n\t *\n\t * // Play animation once\n\t * sprite.loop = false;\n\t * sprite.onComplete = () => console.log('Animation finished!');\n\t * sprite.play();\n\t *\n\t * // Toggle looping at runtime\n\t * sprite.loop = !sprite.loop;\n\t * ```\n\t * @default true\n\t * @see {@link AnimatedSprite#onComplete} Callback when non-looping animation completes\n\t * @see {@link AnimatedSprite#onLoop} Callback when animation loops\n\t */\n\tloop: boolean;\n\t/**\n\t * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n\t *\n\t * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n\t * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n\t * of the frame (e.g. left foot).\n\t *\n\t * > [!NOTE] Enabling this will override any previously set `anchor` on each frame change.\n\t * @default false\n\t */\n\tupdateAnchor: boolean;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite finishes playing.\n\t *\n\t * This function is called when the animation reaches the end and stops playing.\n\t * If the animation is set to loop, this function will not be called.\n\t * @example\n\t * ```ts\n\t * animation.onComplete = () => {\n\t *     // Finished!\n\t * };\n\t * ```\n\t */\n\tonComplete?: () => void;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n\t *\n\t * This function is called every time the current frame changes during playback.\n\t * It receives the current frame index as an argument.\n\t * @example\n\t * animation.onFrameChange = () => {\n\t *     // Updated!\n\t * };\n\t */\n\tonFrameChange?: (currentFrame: number) => void;\n\t/**\n\t * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n\t * loops around to start again.\n\t * @example\n\t * animation.onLoop = () => {\n\t *     // Looped!\n\t * };\n\t */\n\tonLoop?: () => void;\n\tprivate _playing;\n\tprivate _textures;\n\tprivate _durations;\n\t/**\n\t * `true` uses Ticker.shared to auto update animation time.\n\t * @default true\n\t */\n\tprivate _autoUpdate;\n\t/**\n\t * `true` if the instance is currently connected to Ticker.shared to auto update animation time.\n\t * @default false\n\t */\n\tprivate _isConnectedToTicker;\n\t/** Elapsed time since animation has been started, used internally to display current texture. */\n\tprivate _currentTime;\n\t/** The texture index that was displayed last time. */\n\tprivate _previousFrame;\n\t/**\n\t * @param frames - Collection of textures or frames to use.\n\t * @param autoUpdate - Whether to use Ticker.shared to auto update animation time.\n\t */\n\tconstructor(frames: AnimatedSpriteFrames, autoUpdate?: boolean);\n\t/**\n\t * @param options - The options for the AnimatedSprite.\n\t */\n\tconstructor(options: AnimatedSpriteOptions);\n\t/**\n\t * Stops the animation playback and freezes the current frame.\n\t * Does not reset the current frame or animation progress.\n\t * @example\n\t * ```ts\n\t * // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ],\n\t *     autoPlay: true\n\t * });\n\t *\n\t * // Stop at current frame\n\t * sprite.stop();\n\t *\n\t * // Stop at specific frame\n\t * sprite.gotoAndStop(1); // Stops at second frame\n\t *\n\t * // Stop and reset\n\t * sprite.stop();\n\t * sprite.currentFrame = 0;\n\t *\n\t * // Stop with completion check\n\t * if (sprite.playing) {\n\t *     sprite.stop();\n\t *     sprite.onComplete?.();\n\t * }\n\t * ```\n\t * @see {@link AnimatedSprite#play} For starting playback\n\t * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame\n\t * @see {@link AnimatedSprite#playing} For checking play state\n\t */\n\tstop(): void;\n\t/**\n\t * Starts or resumes the animation playback.\n\t * If the animation was previously stopped, it will continue from where it left off.\n\t * @example\n\t * ```ts\n\t * // Basic playback\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *     ],\n\t *     autoPlay: false\n\t * });\n\t * sprite.play();\n\t *\n\t * // Play after stopping\n\t * sprite.stop();\n\t * sprite.currentFrame = 0; // Reset to start\n\t * sprite.play(); // Play from beginning\n\t *\n\t * // Play with auto-update disabled\n\t * sprite.autoUpdate = false;\n\t * sprite.play();\n\t * app.ticker.add(() => {\n\t *     sprite.update(app.ticker); // Manual updates\n\t * });\n\t * ```\n\t * @see {@link AnimatedSprite#stop} For stopping playback\n\t * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame\n\t * @see {@link AnimatedSprite#playing} For checking play state\n\t */\n\tplay(): void;\n\t/**\n\t * Stops the AnimatedSprite and sets it to a specific frame.\n\t * @example\n\t * ```ts\n\t * // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png'),\n\t *     ]\n\t * });\n\t *\n\t * // Go to specific frames\n\t * sprite.gotoAndStop(0);  // First frame\n\t * sprite.gotoAndStop(2);  // Third frame\n\t *\n\t * // Jump to last frame\n\t * sprite.gotoAndStop(sprite.totalFrames - 1);\n\t * ```\n\t * @param frameNumber - Frame index to stop at (0-based)\n\t * @throws {Error} If frameNumber is out of bounds\n\t * @see {@link AnimatedSprite#gotoAndPlay} For going to a frame and playing\n\t * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame\n\t * @see {@link AnimatedSprite#totalFrames} For total number of frames\n\t */\n\tgotoAndStop(frameNumber: number): void;\n\t/**\n\t * Goes to a specific frame and begins playing the AnimatedSprite from that point.\n\t * Combines frame navigation and playback start in one operation.\n\t * @example\n\t * ```ts\n\t * // Start from specific frame\n\t * sprite.gotoAndPlay(1); // Starts playing from second frame\n\t * ```\n\t * @param frameNumber - Frame index to start playing from (0-based)\n\t * @throws {Error} If frameNumber is out of bounds\n\t * @see {@link AnimatedSprite#gotoAndStop} For going to a frame without playing\n\t * @see {@link AnimatedSprite#play} For playing from current frame\n\t * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame\n\t */\n\tgotoAndPlay(frameNumber: number): void;\n\t/**\n\t * Updates the object transform for rendering. This method handles animation timing, frame updates,\n\t * and manages looping behavior.\n\t * @example\n\t * ```ts\n\t * // Create an animated sprite with manual updates\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('frame1.png'),\n\t *         Texture.from('frame2.png'),\n\t *         Texture.from('frame3.png')\n\t *     ],\n\t *     autoUpdate: false // Disable automatic updates\n\t * });\n\t *\n\t * // Manual update with app ticker\n\t * app.ticker.add((ticker) => {\n\t *     sprite.update(ticker);\n\t * });\n\t * ```\n\t * @param ticker - The ticker to use for updating the animation timing\n\t * @see {@link AnimatedSprite#autoUpdate} For controlling automatic updates\n\t * @see {@link AnimatedSprite#animationSpeed} For controlling animation speed\n\t * @see {@link Ticker} For timing system details\n\t */\n\tupdate(ticker: Ticker): void;\n\t/** Updates the displayed texture to match the current frame index. */\n\tprivate _updateTexture;\n\t/**\n\t * Stops the AnimatedSprite and destroys it.\n\t * This method stops the animation playback, removes it from the ticker,\n\t * and cleans up any resources associated with the sprite.\n\t * @param options - Options for destroying the sprite, such as whether to remove from parent\n\t * @example\n\t * ```ts\n\t * // Destroy the sprite when done\n\t * sprite.destroy();\n\t * // Or with options\n\t * sprite.destroy({ children: true, texture: true, textureSource: true });\n\t * ```\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * A short hand way of creating an AnimatedSprite from an array of frame ids.\n\t * Uses texture frames from the cache to create an animation sequence.\n\t * @example\n\t * ```ts\n\t * // Create from frame IDs\n\t * const frameIds = [\n\t *     'walk_001.png',\n\t *     'walk_002.png',\n\t *     'walk_003.png'\n\t * ];\n\t *\n\t * const walkingAnimation = AnimatedSprite.fromFrames(frameIds);\n\t * walkingAnimation.play();\n\t * ```\n\t * @param frames - The array of frame ids to use for the animation\n\t * @returns A new animated sprite using the frames\n\t * @see {@link Texture.from} For texture creation from frames\n\t * @see {@link Spritesheet} For loading spritesheets\n\t */\n\tstatic fromFrames(frames: string[]): AnimatedSprite;\n\t/**\n\t * A short hand way of creating an AnimatedSprite from an array of image urls.\n\t * Each image will be used as a frame in the animation.\n\t * @example\n\t * ```ts\n\t * // Create from image URLs\n\t * const images = [\n\t *     'assets/walk1.png',\n\t *     'assets/walk2.png',\n\t *     'assets/walk3.png'\n\t * ];\n\t *\n\t * const walkingSprite = AnimatedSprite.fromImages(images);\n\t * walkingSprite.play();\n\t * ```\n\t * @param images - The array of image urls to use as frames\n\t * @returns A new animated sprite using the images as frames\n\t * @see {@link Assets} For asset loading and management\n\t * @see {@link Texture.from} For texture creation from images\n\t */\n\tstatic fromImages(images: string[]): AnimatedSprite;\n\t/**\n\t * The total number of frames in the AnimatedSprite. This is the same as number of textures\n\t * assigned to the AnimatedSprite.\n\t * @example\n\t * ```ts\n\t * // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('frame1.png'),\n\t *         Texture.from('frame2.png'),\n\t *         Texture.from('frame3.png')\n\t *     ]\n\t * });\n\t *\n\t * // Get total frames\n\t * console.log(sprite.totalFrames); // Outputs: 3\n\t *\n\t * // Use with frame navigation\n\t * sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame\n\t * ```\n\t * @readonly\n\t * @see {@link AnimatedSprite#currentFrame} For the current frame index\n\t * @see {@link AnimatedSprite#textures} For the array of textures\n\t * @returns {number} The total number of frames\n\t */\n\tget totalFrames(): number;\n\t/**\n\t * The array of textures or frame objects used for the animation sequence.\n\t * Can be set to either an array of Textures or an array of FrameObjects with custom timing.\n\t * @example\n\t * ```ts\n\t * // Update textures at runtime\n\t * sprite.textures = [\n\t *     Texture.from('run1.png'),\n\t *     Texture.from('run2.png')\n\t * ];\n\t *\n\t * // Use custom frame timing\n\t * sprite.textures = [\n\t *     { texture: Texture.from('explosion1.png'), time: 100 },\n\t *     { texture: Texture.from('explosion2.png'), time: 200 },\n\t *     { texture: Texture.from('explosion3.png'), time: 300 }\n\t * ];\n\t *\n\t * // Use with spritesheet\n\t * const sheet = await Assets.load('animations.json');\n\t * sprite.textures = sheet.animations['walk'];\n\t * ```\n\t * @type {AnimatedSpriteFrames}\n\t * @see {@link FrameObject} For frame timing options\n\t * @see {@link Spritesheet} For loading from spritesheets\n\t */\n\tget textures(): AnimatedSpriteFrames;\n\tset textures(value: AnimatedSpriteFrames);\n\t/**\n\t * Gets or sets the current frame index of the animation.\n\t * When setting, the value will be clamped between 0 and totalFrames - 1.\n\t * @example\n\t * ```ts\n\t * // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ]\n\t * });\n\t *\n\t * // Get current frame\n\t * console.log(sprite.currentFrame); // 0\n\t *\n\t * // Set specific frame\n\t * sprite.currentFrame = 1; // Show second frame\n\t *\n\t * // Use with frame callbacks\n\t * sprite.onFrameChange = (frame) => {\n\t *     console.log(`Now showing frame: ${frame}`);\n\t * };\n\t * sprite.currentFrame = 2;\n\t * ```\n\t * @throws {Error} If attempting to set a frame index out of bounds\n\t * @see {@link AnimatedSprite#totalFrames} For the total number of frames\n\t * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame\n\t * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame\n\t */\n\tget currentFrame(): number;\n\tset currentFrame(value: number);\n\t/**\n\t * Indicates if the AnimatedSprite is currently playing.\n\t * This is a read-only property that reflects the current playback state.\n\t * @example\n\t * ```ts\n\t * // Check if animation is playing\n\t * console.log('Playing:', sprite.playing); // true\n\t *\n\t * // Use with play control\n\t * if (!sprite.playing) {\n\t *     sprite.play();\n\t * }\n\t * ```\n\t * @readonly\n\t * @returns {boolean} True if the animation is currently playing\n\t * @see {@link AnimatedSprite#play} For starting playback\n\t * @see {@link AnimatedSprite#stop} For stopping playback\n\t * @see {@link AnimatedSprite#loop} For controlling looping behavior\n\t */\n\tget playing(): boolean;\n\t/**\n\t * Controls whether the animation automatically updates using the shared ticker.\n\t * When enabled, the animation will update on each frame. When disabled, you must\n\t * manually call update() to advance the animation.\n\t * @example\n\t * ```ts\n\t * // Create sprite with auto-update disabled\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [],\n\t *     autoUpdate: false\n\t * });\n\t *\n\t * // Manual update with app ticker\n\t * app.ticker.add((ticker) => {\n\t *     sprite.update(ticker);\n\t * });\n\t *\n\t * // Enable auto-update later\n\t * sprite.autoUpdate = true;\n\t * ```\n\t * @default true\n\t * @see {@link AnimatedSprite#update} For manual animation updates\n\t * @see {@link Ticker} For the timing system\n\t */\n\tget autoUpdate(): boolean;\n\tset autoUpdate(value: boolean);\n}\n/**\n * A reference to a frame in an {@link AnimatedSprite}\n * @category scene\n * @advanced\n */\nexport interface FrameObject {\n\t/** The {@link Texture} of the frame. */\n\ttexture: Texture;\n\t/** The duration of the frame, in milliseconds. */\n\ttime: number;\n}\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions {\n\t/** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n\twidth?: number;\n\t/** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n\theight?: number;\n\t/** The original width of the texture */\n\toriginalWidth?: number;\n\t/** The original height of the texture */\n\toriginalHeight?: number;\n\t/** The width of the left column. */\n\tleftWidth?: number;\n\t/** The height of the top row. */\n\ttopHeight?: number;\n\t/** The width of the right column. */\n\trightWidth?: number;\n\t/** The height of the bottom row. */\n\tbottomHeight?: number;\n\t/** The anchor point of the NineSliceSprite. */\n\tanchor?: PointData;\n}\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry {\n\t/** The default options for the NineSliceGeometry. */\n\tstatic defaultOptions: NineSliceGeometryOptions;\n\t/** @internal */\n\t_leftWidth: number;\n\t/** @internal */\n\t_rightWidth: number;\n\t/** @internal */\n\t_topHeight: number;\n\t/** @internal */\n\t_bottomHeight: number;\n\tprivate _originalWidth;\n\tprivate _originalHeight;\n\tprivate _anchorX;\n\tprivate _anchorY;\n\tconstructor(options?: NineSliceGeometryOptions);\n\t/**\n\t * Updates the NineSliceGeometry with the options.\n\t * @param options - The options of the NineSliceGeometry.\n\t */\n\tupdate(options: NineSliceGeometryOptions): void;\n\t/** Updates the positions of the vertices. */\n\tupdatePositions(): void;\n\t/** Updates the UVs of the vertices. */\n\tupdateUvs(): void;\n}\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh implements GPUData {\n\tconstructor();\n\tdestroy(): void;\n}\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"nineSliceSprite\";\n\t};\n\tprivate readonly _renderer;\n\tprivate readonly _managedSprites;\n\tconstructor(renderer: Renderer);\n\taddRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet): void;\n\tupdateRenderable(sprite: NineSliceSprite): void;\n\tvalidateRenderable(sprite: NineSliceSprite): boolean;\n\tprivate _updateBatchableSprite;\n\tprivate _getGpuSprite;\n\tprivate _initGPUSprite;\n\tdestroy(): void;\n}\n/**\n * Constructor options used for `NineSliceSprite` instances.\n * Defines how the sprite's texture is divided and scaled in nine sections.\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * ```ts\n * // Create a basic nine-slice sprite\n * const button = new NineSliceSprite({\n *     texture: Texture.from('button.png'),\n *     leftWidth: 20, // Left border (A)\n *     rightWidth: 20, // Right border (B)\n *     topHeight: 20, // Top border (C)\n *     bottomHeight: 20, // Bottom border (D)\n *     width: 100, // Initial width\n *     height: 50, // Initial height\n *     anchor: 0.5, // Center anchor point\n * });\n * ```\n * @see {@link NineSliceSprite} For the main sprite class\n * @see {@link Texture#defaultBorders} For texture-level border settings\n * @category scene\n * @standard\n */\nexport interface NineSliceSpriteOptions extends PixiMixins.NineSliceSpriteOptions, ViewContainerOptions {\n\t/**\n\t * The texture to use on the NineSliceSprite.\n\t * ```ts\n\t * // Create a sprite with a texture\n\t * const sprite = new NineSliceSprite({\n\t *     texture: Texture.from('path/to/image.png')\n\t * });\n\t * // Update the texture later\n\t * sprite.texture = Texture.from('path/to/another-image.png');\n\t * ```\n\t * @default Texture.EMPTY\n\t */\n\ttexture: Texture;\n\t/**\n\t * Width of the left vertical bar (A).\n\t * Controls the size of the left edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., leftWidth: 20 });\n\t * sprite.leftWidth = 20; // Set left border width\n\t * ```\n\t * @default 10\n\t */\n\tleftWidth?: number;\n\t/**\n\t * Height of the top horizontal bar (C).\n\t * Controls the size of the top edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., topHeight: 20 });\n\t * sprite.topHeight = 20; // Set top border height\n\t * ```\n\t * @default 10\n\t */\n\ttopHeight?: number;\n\t/**\n\t * Width of the right vertical bar (B).\n\t * Controls the size of the right edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., rightWidth: 20 });\n\t * sprite.rightWidth = 20; // Set right border width\n\t * ```\n\t * @default 10\n\t */\n\trightWidth?: number;\n\t/**\n\t * Height of the bottom horizontal bar (D).\n\t * Controls the size of the bottom edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., bottomHeight: 20 });\n\t * sprite.bottomHeight = 20; // Set bottom border height\n\t * ```\n\t * @default 10\n\t */\n\tbottomHeight?: number;\n\t/**\n\t * Width of the NineSliceSprite.\n\t * Modifies the vertices directly rather than UV coordinates\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., width: 200 });\n\t * sprite.width = 200; // Set the width of the sprite\n\t * ```\n\t * @default 100\n\t */\n\twidth?: number;\n\t/**\n\t * Height of the NineSliceSprite.\n\t * Modifies the vertices directly rather than UV coordinates\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., height: 100 });\n\t * sprite.height = 100; // Set the height of the sprite\n\t * ```\n\t * @default 100\n\t */\n\theight?: number;\n\t/**\n\t * Whether to round the x/y position to whole pixels\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., roundPixels: true });\n\t * ```\n\t * @default false\n\t */\n\troundPixels?: boolean;\n\t/**\n\t * The anchor point of the NineSliceSprite (0-1 range)\n\t *\n\t * Controls the origin point for rotation, scaling, and positioning.\n\t * Can be a number for uniform anchor or a PointData for separate x/y values.\n\t * @default 0\n\t * @example\n\t * ```ts\n\t * // Centered anchor\n\t * const sprite = new NineSliceSprite({ ..., anchor: 0.5 });\n\t * sprite.anchor = 0.5;\n\t * // Separate x/y anchor\n\t * sprite.anchor = { x: 0.5, y: 0.5 };\n\t * // Right-aligned anchor\n\t * sprite.anchor = { x: 1, y: 0 };\n\t * // Update anchor directly\n\t * sprite.anchor.set(0.5, 0.5);\n\t * ```\n\t */\n\tanchor?: PointData | number;\n}\nexport interface NineSliceSprite extends PixiMixins.NineSliceSprite, ViewContainer<NineSliceSpriteGpuData> {\n}\n/**\n * The NineSliceSprite allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * ```ts\n * import { NineSliceSprite, Texture } from 'pixi.js';\n *\n * const plane9 = new NineSliceSprite({\n *   texture: Texture.from('BoxWithRoundedCorners.png'),\n *   leftWidth: 15,\n *   topHeight: 15,\n *   rightWidth: 15,\n *   bottomHeight: 15,\n *   width: 200,\n *   height: 100,\n * });\n * ```\n * @category scene\n * @standard\n */\nexport class NineSliceSprite extends ViewContainer<NineSliceSpriteGpuData> implements View {\n\t/**\n\t * The default options used to override initial values of any options passed in the constructor.\n\t * These values are used as fallbacks when specific options are not provided.\n\t * @example\n\t * ```ts\n\t * // Override default options globally\n\t * NineSliceSprite.defaultOptions.texture = Texture.from('defaultButton.png');\n\t * // Create sprite with default texture\n\t * const sprite = new NineSliceSprite({...});\n\t * // sprite will use 'defaultButton.png' as its texture\n\t *\n\t * // Reset to empty texture\n\t * NineSliceSprite.defaultOptions.texture = Texture.EMPTY;\n\t * ```\n\t * @type {NineSliceSpriteOptions}\n\t * @see {@link NineSliceSpriteOptions} For all available options\n\t * @see {@link Texture#defaultBorders} For texture-level border settings\n\t */\n\tstatic defaultOptions: NineSliceSpriteOptions;\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/** @internal */\n\t_texture: Texture;\n\t/** @internal */\n\t_anchor: ObservablePoint;\n\t/** @internal */\n\tbatched: boolean;\n\tprivate _leftWidth;\n\tprivate _topHeight;\n\tprivate _rightWidth;\n\tprivate _bottomHeight;\n\tprivate _width;\n\tprivate _height;\n\tconstructor(options: NineSliceSpriteOptions | Texture);\n\t/**\n\t * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n\t * and passed to the constructor.\n\t *\n\t * - The default is `(0,0)`, this means the sprite's origin is the top left.\n\t * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n\t * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n\t *\n\t * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n\t * @example\n\t * ```ts\n\t * // Center the anchor point\n\t * sprite.anchor = 0.5; // Sets both x and y to 0.5\n\t * sprite.position.set(400, 300); // Sprite will be centered at this position\n\t *\n\t * // Set specific x/y anchor points\n\t * sprite.anchor = {\n\t *     x: 1, // Right edge\n\t *     y: 0  // Top edge\n\t * };\n\t *\n\t * // Using individual coordinates\n\t * sprite.anchor.set(0.5, 1); // Center-bottom\n\t *\n\t * // For rotation around center\n\t * sprite.anchor.set(0.5);\n\t * sprite.rotation = Math.PI / 4; // 45 degrees around center\n\t *\n\t * // For scaling from center\n\t * sprite.anchor.set(0.5);\n\t * sprite.scale.set(2); // Scales from center point\n\t * ```\n\t */\n\tget anchor(): ObservablePoint;\n\tset anchor(value: PointData | number);\n\t/**\n\t * The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.\n\t * The width affects how the middle sections are scaled.\n\t * @example\n\t * ```ts\n\t * // Create a nine-slice sprite with fixed width\n\t * const panel = new NineSliceSprite({\n\t *     texture: Texture.from('panel.png'),\n\t *     width: 200  // Sets initial width\n\t * });\n\t *\n\t * // Adjust width dynamically\n\t * panel.width = 300;  // Stretches middle sections\n\t * ```\n\t * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently\n\t * @see {@link NineSliceSprite#height} For setting height\n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.\n\t * The height affects how the middle sections are scaled.\n\t * @example\n\t * ```ts\n\t * // Create a nine-slice sprite with fixed height\n\t * const panel = new NineSliceSprite({\n\t *     texture: Texture.from('panel.png'),\n\t *     height: 150  // Sets initial height\n\t * });\n\t *\n\t * // Adjust height dynamically\n\t * panel.height = 200;  // Stretches middle sections\n\t *\n\t * // Create responsive UI element\n\t * const dialog = new NineSliceSprite({\n\t *     texture: Texture.from('dialog.png'),\n\t *     topHeight: 30,\n\t *     bottomHeight: 30,\n\t *     height: parent.height * 0.5  // 50% of parent height\n\t * });\n\t * ```\n\t * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently\n\t * @see {@link NineSliceSprite#width} For setting width\n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * Sets the size of the NineSliceSprite to the specified width and height.\n\t * This method directly modifies the vertices and UV coordinates of the sprite.\n\t *\n\t * Using this is more efficient than setting width and height separately as it only triggers one update.\n\t * @example\n\t * ```ts\n\t * // Set to specific dimensions\n\t * panel.setSize(300, 200); // Width: 300, Height: 200\n\t *\n\t * // Set uniform size\n\t * panel.setSize(200); // Makes a square 200x200\n\t *\n\t * // Set size using object\n\t * panel.setSize({\n\t *     width: 400,\n\t *     height: 300\n\t * });\n\t * ```\n\t * @param value - This can be either a number or a Size object with width/height properties\n\t * @param height - The height to set. Defaults to the value of `width` if not provided\n\t * @see {@link NineSliceSprite#width} For setting width only\n\t * @see {@link NineSliceSprite#height} For setting height only\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n\t/**\n\t * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.\n\t * This method is more efficient than getting width and height separately.\n\t * @example\n\t * ```ts\n\t * // Get basic size\n\t * const size = panel.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * panel.getSize(reuseSize);\n\t * ```\n\t * @param out - Optional object to store the size in, to avoid allocating a new object\n\t * @returns The size of the NineSliceSprite\n\t * @see {@link NineSliceSprite#width} For getting just the width\n\t * @see {@link NineSliceSprite#height} For getting just the height\n\t * @see {@link NineSliceSprite#setSize} For setting both width and height efficiently\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Width of the left vertical bar (A).\n\t * Controls the size of the left edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., leftWidth: 20 });\n\t * sprite.leftWidth = 20; // Set left border width\n\t * ```\n\t * @default 10\n\t */\n\tget leftWidth(): number;\n\tset leftWidth(value: number);\n\t/**\n\t * Height of the top horizontal bar (C).\n\t * Controls the size of the top edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., topHeight: 20 });\n\t * sprite.topHeight = 20; // Set top border height\n\t * ```\n\t * @default 10\n\t */\n\tget topHeight(): number;\n\tset topHeight(value: number);\n\t/**\n\t * Width of the right vertical bar (B).\n\t * Controls the size of the right edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., rightWidth: 20 });\n\t * sprite.rightWidth = 20; // Set right border width\n\t * ```\n\t * @default 10\n\t */\n\tget rightWidth(): number;\n\tset rightWidth(value: number);\n\t/**\n\t * Height of the bottom horizontal bar (D).\n\t * Controls the size of the bottom edge that remains unscaled\n\t * @example\n\t * ```ts\n\t * const sprite = new NineSliceSprite({ ..., bottomHeight: 20 });\n\t * sprite.bottomHeight = 20; // Set bottom border height\n\t * ```\n\t * @default 10\n\t */\n\tget bottomHeight(): number;\n\tset bottomHeight(value: number);\n\t/**\n\t * The texture to use on the NineSliceSprite.\n\t * ```ts\n\t * // Create a sprite with a texture\n\t * const sprite = new NineSliceSprite({\n\t *     texture: Texture.from('path/to/image.png')\n\t * });\n\t * // Update the texture later\n\t * sprite.texture = Texture.from('path/to/another-image.png');\n\t * ```\n\t * @default Texture.EMPTY\n\t */\n\tget texture(): Texture;\n\tset texture(value: Texture);\n\t/**\n\t * The original width of the texture before any nine-slice scaling.\n\t * This is the width of the source texture used to create the nine-slice sprite.\n\t * @example\n\t * ```ts\n\t * // Get original dimensions\n\t * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);\n\t *\n\t * // Use for relative scaling\n\t * sprite.width = sprite.originalWidth * 2; // Double the original width\n\t *\n\t * // Reset to original size\n\t * sprite.setSize(sprite.originalWidth, sprite.originalHeight);\n\t * ```\n\t * @readonly\n\t * @see {@link NineSliceSprite#width} For the current displayed width\n\t * @see {@link Texture#width} For direct texture width access\n\t * @returns The original width of the texture\n\t */\n\tget originalWidth(): number;\n\t/**\n\t * The original height of the texture before any nine-slice scaling.\n\t * This is the height of the source texture used to create the nine-slice sprite.\n\t * @example\n\t * ```ts\n\t * // Get original dimensions\n\t * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);\n\t *\n\t * // Use for relative scaling\n\t * sprite.height = sprite.originalHeight * 2; // Double the original height\n\t *\n\t * // Reset to original size\n\t * sprite.setSize(sprite.originalWidth, sprite.originalHeight);\n\t * ```\n\t * @readonly\n\t * @see {@link NineSliceSprite#height} For the current displayed height\n\t * @see {@link Texture#height} For direct texture height access\n\t * @returns The original height of the texture\n\t */\n\tget originalHeight(): number;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * nineSliceSprite.destroy();\n\t * nineSliceSprite.destroy(true);\n\t * nineSliceSprite.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/** @private */\n\tprotected updateBounds(): void;\n}\n/**\n * Please use the {@link NineSliceSprite} class instead.\n * The NineSlicePlane is deprecated and will be removed in future versions.\n * @deprecated since 8.0.0\n * @category scene\n */\nexport class NineSlicePlane extends NineSliceSprite {\n\tconstructor(options: NineSliceSpriteOptions | Texture);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(texture: Texture, leftWidth: number, topHeight: number, rightWidth: number, bottomHeight: number);\n}\n/** @internal */\nexport const tilingBit: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n\tfragment: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/** @internal */\nexport const tilingBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n\tfragment: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader {\n\tconstructor();\n\tupdateUniforms(width: number, height: number, matrix: Matrix, anchorX: number, anchorY: number, texture: Texture): void;\n}\n/**\n * Options for the {@link Transform} constructor.\n * @category utils\n * @advanced\n */\nexport interface TransformOptions {\n\t/** The matrix to use. */\n\tmatrix?: Matrix;\n\t/**\n\t * The observer to use.\n\t * @advanced\n\t */\n\tobserver?: {\n\t\t_onUpdate: (transform: Transform) => void;\n\t};\n}\n/**\n * The Transform class facilitates the manipulation of a 2D transformation matrix through\n * user-friendly properties: position, scale, rotation, skew, and pivot.\n * @example\n * ```ts\n * // Basic transform usage\n * const transform = new Transform();\n * transform.position.set(100, 100);\n * transform.rotation = Math.PI / 4; // 45 degrees\n * transform.scale.set(2, 2);\n *\n * // With pivot point\n * transform.pivot.set(50, 50);\n * transform.rotation = Math.PI; // Rotate around pivot\n *\n * // Matrix manipulation\n * const matrix = transform.matrix;\n * const position = { x: 0, y: 0 };\n * matrix.apply(position); // Transform point\n * ```\n * @remarks\n * - Manages 2D transformation properties\n * - Auto-updates matrix on changes\n * - Supports observable changes\n * - Common in display objects\n * @category utils\n * @standard\n * @see {@link Matrix} For direct matrix operations\n * @see {@link ObservablePoint} For point properties\n */\nexport class Transform {\n\t/**\n\t * The local transformation matrix.\n\t * @internal\n\t */\n\t_matrix: Matrix;\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t * @example\n\t * ```ts\n\t * // Basic position setting\n\t * transform.position.set(100, 100);\n\t *\n\t * // Individual coordinate access\n\t * transform.position.x = 50;\n\t * transform.position.y = 75;\n\t * ```\n\t */\n\tposition: ObservablePoint;\n\t/**\n\t * The scale factor of the object.\n\t * @example\n\t * ```ts\n\t * // Uniform scaling\n\t * transform.scale.set(2, 2);\n\t *\n\t * // Non-uniform scaling\n\t * transform.scale.x = 2; // Stretch horizontally\n\t * transform.scale.y = 0.5; // Compress vertically\n\t * ```\n\t */\n\tscale: ObservablePoint;\n\t/**\n\t * The pivot point of the container that it rotates around.\n\t * @example\n\t * ```ts\n\t * // Center pivot\n\t * transform.pivot.set(sprite.width / 2, sprite.height / 2);\n\t *\n\t * // Corner rotation\n\t * transform.pivot.set(0, 0);\n\t * transform.rotation = Math.PI / 4; // 45 degrees\n\t * ```\n\t */\n\tpivot: ObservablePoint;\n\t/**\n\t * The skew amount, on the x and y axis.\n\t * @example\n\t * ```ts\n\t * // Apply horizontal skew\n\t * transform.skew.x = Math.PI / 6; // 30 degrees\n\t *\n\t * // Apply both skews\n\t * transform.skew.set(Math.PI / 6, Math.PI / 8);\n\t * ```\n\t */\n\tskew: ObservablePoint;\n\t/** The rotation amount. */\n\tprotected _rotation: number;\n\t/**\n\t * The X-coordinate value of the normalized local X axis,\n\t * the first column of the local transformation matrix without a scale.\n\t */\n\tprotected _cx: number;\n\t/**\n\t * The Y-coordinate value of the normalized local X axis,\n\t * the first column of the local transformation matrix without a scale.\n\t */\n\tprotected _sx: number;\n\t/**\n\t * The X-coordinate value of the normalized local Y axis,\n\t * the second column of the local transformation matrix without a scale.\n\t */\n\tprotected _cy: number;\n\t/**\n\t * The Y-coordinate value of the normalized local Y axis,\n\t * the second column of the local transformation matrix without a scale.\n\t */\n\tprotected _sy: number;\n\tprotected dirty: boolean;\n\tprotected observer: Observer<Transform>;\n\t/**\n\t * @param options - Options for the transform.\n\t * @param options.matrix - The matrix to use.\n\t * @param options.observer - The observer to use.\n\t */\n\tconstructor({ matrix, observer }?: TransformOptions);\n\t/**\n\t * The transformation matrix computed from the transform's properties.\n\t * Combines position, scale, rotation, skew, and pivot into a single matrix.\n\t * @example\n\t * ```ts\n\t * // Get current matrix\n\t * const matrix = transform.matrix;\n\t * console.log(matrix.toString());\n\t * ```\n\t * @readonly\n\t * @see {@link Matrix} For matrix operations\n\t * @see {@link Transform.setFromMatrix} For setting transform from matrix\n\t */\n\tget matrix(): Matrix;\n\t/**\n\t * Called when a value changes.\n\t * @param point\n\t * @internal\n\t */\n\t_onUpdate(point?: ObservablePoint): void;\n\t/** Called when the skew or the rotation changes. */\n\tprotected updateSkew(): void;\n\ttoString(): string;\n\t/**\n\t * Decomposes a matrix and sets the transforms properties based on it.\n\t * @example\n\t * ```ts\n\t * // Basic matrix decomposition\n\t * const transform = new Transform();\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4)\n\t *     .scale(2, 2);\n\t *\n\t * transform.setFromMatrix(matrix);\n\t * console.log(transform.position.x); // 100\n\t * console.log(transform.rotation); // ~0.785 (/4)\n\t * ```\n\t * @param matrix - The matrix to decompose\n\t * @see {@link Matrix#decompose} For the decomposition logic\n\t * @see {@link Transform#matrix} For getting the current matrix\n\t */\n\tsetFromMatrix(matrix: Matrix): void;\n\t/**\n\t * The rotation of the object in radians.\n\t * @example\n\t * ```ts\n\t * // Basic rotation\n\t * transform.rotation = Math.PI / 4; // 45 degrees\n\t *\n\t * // Rotate around pivot point\n\t * transform.pivot.set(50, 50);\n\t * transform.rotation = Math.PI; // 180 degrees around pivot\n\t *\n\t * // Animate rotation\n\t * app.ticker.add(() => {\n\t *     transform.rotation += 0.1;\n\t * });\n\t * ```\n\t * @see {@link Transform#pivot} For rotation point\n\t * @see {@link Transform#skew} For skew effects\n\t */\n\tget rotation(): number;\n\tset rotation(value: number);\n}\n/** @internal */\nexport class TilingSpriteGpuData implements GPUData {\n\tcanBatch: boolean;\n\trenderable: TilingSprite;\n\tbatchableMesh?: BatchableMesh;\n\tgeometry?: MeshGeometry;\n\tshader?: TilingSpriteShader;\n\tconstructor();\n\tdestroy(): void;\n}\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"tilingSprite\";\n\t};\n\tprivate _renderer;\n\tprivate readonly _state;\n\tprivate readonly _managedTilingSprites;\n\tconstructor(renderer: Renderer);\n\tvalidateRenderable(renderable: TilingSprite): boolean;\n\taddRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet): void;\n\texecute(tilingSprite: TilingSprite): void;\n\tupdateRenderable(tilingSprite: TilingSprite): void;\n\tprivate _getTilingSpriteData;\n\tprivate _initTilingSpriteData;\n\tprivate _updateBatchableMesh;\n\tdestroy(): void;\n\tprivate _updateCanBatch;\n}\n/**\n * Constructor options used for creating a TilingSprite instance.\n * Defines the texture, tiling behavior, and rendering properties of the sprite.\n * @example\n * ```ts\n * // Create a basic tiling sprite with repeating texture\n * const tilingSprite = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 800,     // Width of the tiling area\n *     height: 600     // Height of the tiling area\n * });\n *\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tilePosition: { x: 0, y: 0 },\n *     tileScale: { x: 1.5, y: 1.5 }  // Scale up the texture\n *     anchor: 0.5,                    // Center anchor point\n *     roundPixels: true,              // Crisp pixel rendering\n * });\n * ```\n * @see {@link TilingSprite} For the main sprite class\n * @see {@link Texture} For texture management\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface TilingSpriteOptions extends PixiMixins.TilingSpriteOptions, ViewContainerOptions {\n\t/**\n\t * The anchor point of the TilingSprite (0-1 range)\n\t *\n\t * Controls the origin point for rotation, scaling, and positioning.\n\t * Can be a number for uniform anchor or a PointData for separate x/y values.\n\t * @example\n\t * ```ts\n\t * // Centered anchor\n\t * const sprite = new TilingSprite({ ..., anchor: 0.5 });\n\t * sprite.anchor = 0.5;\n\t * // Separate x/y anchor\n\t * sprite.anchor = { x: 0.5, y: 0.5 };\n\t * // Right-aligned anchor\n\t * sprite.anchor = { x: 1, y: 0 };\n\t * // Update anchor directly\n\t * sprite.anchor.set(0.5, 0.5);\n\t * ```\n\t * @default 0\n\t */\n\tanchor?: PointData | number;\n\t/**\n\t * The offset of the tiling texture.\n\t * Used to scroll or position the repeated pattern.\n\t * @example\n\t * ```ts\n\t * // Offset the tiling pattern by 100 pixels in both x and y directions\n\t * tilingSprite.tilePosition = { x: 100, y: 100 };\n\t * ```\n\t * @default {x: 0, y: 0}\n\t */\n\ttilePosition?: PointData;\n\t/**\n\t * Scale of the tiling texture.\n\t * Affects the size of each repeated instance of the texture.\n\t * @example\n\t * ```ts\n\t * // Scale the texture by 1.5 in both x and y directions\n\t * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n\t * ```\n\t * @default {x: 1, y: 1}\n\t */\n\ttileScale?: PointData;\n\t/**\n\t * Rotation of the tiling texture in radians.\n\t * This controls the rotation applied to the texture before tiling.\n\t * @example\n\t * ```ts\n\t * // Rotate the texture by 45 degrees (in radians)\n\t * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n\t * ```\n\t * @default 0\n\t */\n\ttileRotation?: number;\n\t/**\n\t * The texture to use for tiling.\n\t * This is the image that will be repeated across the sprite.\n\t * @example\n\t * ```ts\n\t * // Use a texture from the asset cache\n\t * tilingSprite.texture = Texture.from('assets/pattern.png');\n\t * ```\n\t * @default Texture.WHITE\n\t */\n\ttexture?: Texture;\n\t/**\n\t * The width of the tiling area.\n\t * This defines how wide the tiling sprite will be.\n\t * @example\n\t * ```ts\n\t * // Set the width of the tiling sprite to 800 pixels\n\t * tilingSprite.width = 800;\n\t * ```\n\t * @default 256\n\t */\n\twidth?: number;\n\t/**\n\t * The height of the tiling area.\n\t * This defines how tall the tiling sprite will be.\n\t * @example\n\t * ```ts\n\t * // Set the height of the tiling sprite to 600 pixels\n\t * tilingSprite.height = 600;\n\t * ```\n\t * @default 256\n\t */\n\theight?: number;\n\t/**\n\t * Whether the tiling pattern should originate from the anchor point.\n\t * When true, tiling starts from the origin instead of top-left.\n\t *\n\t * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n\t * this, the top-left corner always gets the (0, 0) texture coordinate.\n\t * @example\n\t * ```ts\n\t * // Enable anchor-based tiling\n\t * tilingSprite.applyAnchorToTexture = true;\n\t * ```\n\t * @default false\n\t */\n\tapplyAnchorToTexture?: boolean;\n\t/**\n\t * Whether to round the sprite's position to whole pixels.\n\t * This can help with crisp rendering, especially for pixel art.\n\t * When true, the sprite's position will be rounded to the nearest pixel.\n\t * @example\n\t * ```ts\n\t * // Enable pixel rounding for crisp rendering\n\t * tilingSprite.roundPixels = true;\n\t * ```\n\t * @default false\n\t */\n\troundPixels?: boolean;\n}\nexport interface TilingSprite extends PixiMixins.TilingSprite, ViewContainer<TilingSpriteGpuData> {\n}\n/**\n * A TilingSprite is a fast and efficient way to render a repeating texture across a given area.\n * The texture can be scrolled, scaled, and rotated independently of the sprite itself.\n * @example\n * ```ts\n * // Create a simple tiling background\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n * });\n * app.stage.addChild(background);\n *\n * // Create a scrolling parallax background\n * const parallax = new TilingSprite({\n *     texture: Texture.from('clouds.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tileScale: { x: 0.5, y: 0.5 }\n * });\n *\n * // Animate the tiling position\n * app.ticker.add(() => {\n *     parallax.tilePosition.x -= 1; // Scroll left\n *     parallax.tilePosition.y -= 0.5; // Scroll up slowly\n * });\n *\n * // Create a repeating pattern with rotation\n * const pattern = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 300,\n *     height: 200,\n *     tileRotation: Math.PI / 4, // 45 degree rotation\n *     anchor: 0.5 // Center anchor point\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link TilingSpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class TilingSprite extends ViewContainer<TilingSpriteGpuData> implements View, Instruction {\n\t/**\n\t * Creates a new tiling sprite based on a source texture or image path.\n\t * This is a convenience method that automatically creates and manages textures.\n\t * @example\n\t * ```ts\n\t * // Create a new tiling sprite from an image path\n\t * const pattern = TilingSprite.from('pattern.png');\n\t * pattern.width = 300; // Set the width of the tiling area\n\t * pattern.height = 200; // Set the height of the tiling area\n\t *\n\t * // Create from options\n\t * const texture = Texture.from('pattern.png');\n\t * const pattern = TilingSprite.from(texture, {\n\t *     width: 300,\n\t *     height: 200,\n\t *     tileScale: { x: 0.5, y: 0.5 }\n\t * });\n\t * ```\n\t * @param source - The source to create the sprite from. Can be a path to an image or a texture\n\t * @param options - Additional options for the tiling sprite\n\t * @returns A new tiling sprite based on the source\n\t * @see {@link Texture.from} For texture creation details\n\t * @see {@link Assets} For asset loading and management\n\t */\n\tstatic from(source: Texture | string, options?: TilingSpriteOptions): TilingSprite;\n\t/**\n\t * Default options used when creating a TilingSprite instance.\n\t * These values are used as fallbacks when specific options are not provided.\n\t * @example\n\t * ```ts\n\t * // Override default options globally\n\t * TilingSprite.defaultOptions.texture = Texture.from('defaultPattern.png');\n\t * TilingSprite.defaultOptions.tileScale = { x: 2, y: 2 };\n\t *\n\t * // Create sprite using default options\n\t * const sprite = new TilingSprite();\n\t * // Will use defaultPattern.png and scale 2x\n\t * ```\n\t * @type {TilingSpriteOptions}\n\t * @see {@link TilingSpriteOptions} For all available options\n\t * @see {@link TilingSprite.from} For creating sprites with custom options\n\t * @see {@link Texture.EMPTY} For the default empty texture\n\t */\n\tstatic defaultOptions: TilingSpriteOptions;\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/** @advanced */\n\treadonly batched = true;\n\t/**\n\t * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n\t * local space.\n\t *\n\t * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n\t * this, the top-left corner always gets the (0, 0) texture coordinate.\n\t * @example\n\t * ```ts\n\t * // Enable anchor-based tiling\n\t * tilingSprite.applyAnchorToTexture = true;\n\t * ```\n\t * @default false\n\t */\n\tapplyAnchorToTexture: boolean;\n\t/**\n\t * @see {@link TilingSpriteOptions.applyAnchorToTexture}\n\t * @deprecated since 8.0.0\n\t * @advanced\n\t */\n\tget uvRespectAnchor(): boolean;\n\t/** @advanced */\n\tset uvRespectAnchor(value: boolean);\n\t/** @internal */\n\t_anchor: ObservablePoint;\n\t/** @internal */\n\t_tileTransform: Transform;\n\t/** @internal */\n\t_texture: Texture;\n\tprivate _width;\n\tprivate _height;\n\t/**\n\t * @param {Texture | TilingSpriteOptions} options - The options for creating the tiling sprite.\n\t */\n\tconstructor(options?: Texture | TilingSpriteOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(texture: Texture, width: number, height: number);\n\t/**\n\t * Changes frame clamping in corresponding textureMatrix\n\t * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n\t * @default 0.5\n\t * @type {number}\n\t * @advanced\n\t */\n\tget clampMargin(): number;\n\t/** @advanced */\n\tset clampMargin(value: number);\n\t/**\n\t * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n\t * and passed to the constructor.\n\t *\n\t * - The default is `(0,0)`, this means the sprite's origin is the top left.\n\t * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n\t * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n\t *\n\t * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n\t * @example\n\t * ```ts\n\t * // Center the anchor point\n\t * sprite.anchor = 0.5; // Sets both x and y to 0.5\n\t * sprite.position.set(400, 300); // Sprite will be centered at this position\n\t *\n\t * // Set specific x/y anchor points\n\t * sprite.anchor = {\n\t *     x: 1, // Right edge\n\t *     y: 0  // Top edge\n\t * };\n\t *\n\t * // Using individual coordinates\n\t * sprite.anchor.set(0.5, 1); // Center-bottom\n\t *\n\t * // For rotation around center\n\t * sprite.anchor.set(0.5);\n\t * sprite.rotation = Math.PI / 4; // 45 degrees around center\n\t *\n\t * // For scaling from center\n\t * sprite.anchor.set(0.5);\n\t * sprite.scale.set(2); // Scales from center point\n\t * ```\n\t */\n\tget anchor(): ObservablePoint;\n\tset anchor(value: PointData | number);\n\t/**\n\t * The offset of the tiling texture.\n\t * Used to scroll or position the repeated pattern.\n\t * @example\n\t * ```ts\n\t * // Offset the tiling pattern by 100 pixels in both x and y directions\n\t * tilingSprite.tilePosition = { x: 100, y: 100 };\n\t * ```\n\t * @default {x: 0, y: 0}\n\t */\n\tget tilePosition(): ObservablePoint;\n\tset tilePosition(value: PointData);\n\t/**\n\t * Scale of the tiling texture.\n\t * Affects the size of each repeated instance of the texture.\n\t * @example\n\t * ```ts\n\t * // Scale the texture by 1.5 in both x and y directions\n\t * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n\t * ```\n\t * @default {x: 1, y: 1}\n\t */\n\tget tileScale(): ObservablePoint;\n\tset tileScale(value: PointData | number);\n\tset tileRotation(value: number);\n\t/**\n\t * Rotation of the tiling texture in radians.\n\t * This controls the rotation applied to the texture before tiling.\n\t * @example\n\t * ```ts\n\t * // Rotate the texture by 45 degrees (in radians)\n\t * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n\t * ```\n\t * @default 0\n\t */\n\tget tileRotation(): number;\n\t/**\n\t * The transform object that controls the tiling texture's position, scale, and rotation.\n\t * This transform is independent of the sprite's own transform properties.\n\t * @example\n\t * ```ts\n\t * // Access transform properties directly\n\t * sprite.tileTransform.position.set(100, 50);\n\t * sprite.tileTransform.scale.set(2);\n\t * sprite.tileTransform.rotation = Math.PI / 4;\n\t *\n\t * // Create smooth scrolling animation\n\t * app.ticker.add(() => {\n\t *     sprite.tileTransform.position.x += 1;\n\t *     sprite.tileTransform.rotation += 0.01;\n\t * });\n\t *\n\t * // Reset transform\n\t * sprite.tileTransform.position.set(0);\n\t * sprite.tileTransform.scale.set(1);\n\t * sprite.tileTransform.rotation = 0;\n\t * ```\n\t * @returns {Transform} The transform object for the tiling texture\n\t * @see {@link Transform} For transform operations\n\t * @see {@link TilingSprite#tilePosition} For position control\n\t * @see {@link TilingSprite#tileScale} For scale control\n\t * @see {@link TilingSprite#tileRotation} For rotation control\n\t * @advanced\n\t */\n\tget tileTransform(): Transform;\n\tset texture(value: Texture);\n\t/**\n\t * The texture to use for tiling.\n\t * This is the image that will be repeated across the sprite.\n\t * @example\n\t * ```ts\n\t * // Use a texture from the asset cache\n\t * tilingSprite.texture = Texture.from('assets/pattern.png');\n\t * ```\n\t * @default Texture.WHITE\n\t */\n\tget texture(): Texture;\n\t/**\n\t * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.\n\t * @example\n\t * ```ts\n\t * // Create a tiling sprite\n\t * const sprite = new TilingSprite({\n\t *     texture: Texture.from('pattern.png'),\n\t *     width: 500,\n\t *     height: 300\n\t * });\n\t *\n\t * // Adjust width dynamically\n\t * sprite.width = 800; // Expands tiling area\n\t *\n\t * // Update on resize\n\t * window.addEventListener('resize', () => {\n\t *     sprite.width = app.screen.width;\n\t * });\n\t * ```\n\t * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n\t * @see {@link TilingSprite#height} For setting height\n\t */\n\tset width(value: number);\n\tget width(): number;\n\tset height(value: number);\n\t/**\n\t * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.\n\t * @example\n\t * ```ts\n\t * // Create a tiling sprite\n\t * const sprite = new TilingSprite({\n\t *     texture: Texture.from('pattern.png'),\n\t *     width: 500,\n\t *     height: 300\n\t * });\n\t *\n\t * // Adjust width dynamically\n\t * sprite.height = 800; // Expands tiling area\n\t *\n\t * // Update on resize\n\t * window.addEventListener('resize', () => {\n\t *     sprite.height = app.screen.height;\n\t * });\n\t * ```\n\t * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n\t * @see {@link TilingSprite#width} For setting width\n\t */\n\tget height(): number;\n\t/**\n\t * Sets the size of the TilingSprite to the specified width and height.\n\t * This is faster than setting width and height separately as it only triggers one update.\n\t * @example\n\t * ```ts\n\t * // Set specific dimensions\n\t * sprite.setSize(300, 200); // Width: 300, Height: 200\n\t *\n\t * // Set uniform size (square)\n\t * sprite.setSize(400); // Width: 400, Height: 400\n\t *\n\t * // Set size using object\n\t * sprite.setSize({\n\t *     width: 500,\n\t *     height: 300\n\t * });\n\t * ```\n\t * @param value - This can be either a number for uniform sizing or a Size object with width/height properties\n\t * @param height - The height to set. Defaults to the value of `width` if not provided\n\t * @see {@link TilingSprite#width} For setting width only\n\t * @see {@link TilingSprite#height} For setting height only\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n\t/**\n\t * Retrieves the size of the TilingSprite as a {@link Size} object.\n\t * This method is more efficient than getting width and height separately as it only allocates one object.\n\t * @example\n\t * ```ts\n\t * // Get basic size\n\t * const size = sprite.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * sprite.getSize(reuseSize);\n\t * ```\n\t * @param out - Optional object to store the size in, to avoid allocating a new object\n\t * @returns The size of the TilingSprite\n\t * @see {@link TilingSprite#width} For getting just the width\n\t * @see {@link TilingSprite#height} For getting just the height\n\t * @see {@link TilingSprite#setSize} For setting both width and height efficiently\n\t */\n\tgetSize(out?: Size): Size;\n\t/** @private */\n\tprotected updateBounds(): void;\n\t/**\n\t * Checks if the object contains the given point in local coordinates.\n\t * Takes into account the anchor offset when determining boundaries.\n\t * @example\n\t * ```ts\n\t * // Create a tiling sprite\n\t * const sprite = new TilingSprite({\n\t *     texture: Texture.from('pattern.png'),\n\t *     width: 200,\n\t *     height: 100,\n\t *     anchor: 0.5 // Center anchor\n\t * });\n\t *\n\t * // Basic point check\n\t * const contains = sprite.containsPoint({ x: 50, y: 25 });\n\t * console.log('Point is inside:', contains);\n\t *\n\t * // Check with different anchors\n\t * sprite.anchor.set(0); // Top-left anchor\n\t * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));\n\t * ```\n\t * @param point - The point to check in local coordinates\n\t * @returns True if the point is within the sprite's bounds\n\t * @see {@link TilingSprite#toLocal} For converting global coordinates to local\n\t * @see {@link TilingSprite#anchor} For understanding boundary calculations\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * tilingSprite.destroy();\n\t * tilingSprite.destroy(true);\n\t * tilingSprite.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix): void;\n/** @internal */\nexport class QuadGeometry extends MeshGeometry {\n\tconstructor();\n}\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array): void;\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array): void;\n/**\n * A number, or a string containing a number.\n * @category text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n * @advanced\n */\nexport interface FontMetrics {\n\tascent: number;\n\tdescent: number;\n\tfontSize: number;\n}\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { CanvasTextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = CanvasTextMetrics.measureText('Your text', style);\n * @category text\n * @advanced\n */\nexport class CanvasTextMetrics {\n\t/** The text that was measured. */\n\ttext: string;\n\t/** The style that was measured. */\n\tstyle: TextStyle;\n\t/** The measured width of the text. */\n\twidth: number;\n\t/** The measured height of the text. */\n\theight: number;\n\t/** An array of lines of the text broken by new lines and wrapping is specified in style. */\n\tlines: string[];\n\t/** An array of the line widths for each line matched to `lines`. */\n\tlineWidths: number[];\n\t/** The measured line height for this style. */\n\tlineHeight: number;\n\t/** The maximum line width for all measured lines. */\n\tmaxLineWidth: number;\n\t/** The font properties object from TextMetrics.measureFont. */\n\tfontProperties: FontMetrics;\n\t/**\n\t * String used for calculate font metrics.\n\t * These characters are all tall to help calculate the height required for text.\n\t */\n\tstatic METRICS_STRING: string;\n\t/** Baseline symbol for calculate font metrics. */\n\tstatic BASELINE_SYMBOL: string;\n\t/** Baseline multiplier for calculate font metrics. */\n\tstatic BASELINE_MULTIPLIER: number;\n\t/** Height multiplier for setting height of canvas to calculate font metrics. */\n\tstatic HEIGHT_MULTIPLIER: number;\n\t/**\n\t * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n\t * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n\t * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n\t * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n\t * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n\t * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n\t * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n\t * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n\t * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n\t */\n\tstatic graphemeSegmenter: (s: string) => string[];\n\tstatic _experimentalLetterSpacingSupported?: boolean;\n\t/**\n\t * Checking that we can use modern canvas 2D API.\n\t *\n\t * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n\t * @see TextMetrics.experimentalLetterSpacing\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n\t * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n\t */\n\tstatic get experimentalLetterSpacingSupported(): boolean;\n\t/**\n\t * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n\t * lead to more accurate letter-spacing results because it does not try to manually draw\n\t * each character. However, this Chrome API is experimental and may not serve all cases yet.\n\t * @see TextMetrics.experimentalLetterSpacingSupported\n\t */\n\tstatic experimentalLetterSpacing: boolean;\n\t/** Cache of {@link TextMetrics.FontMetrics} objects. */\n\tprivate static _fonts;\n\t/** Cache of new line chars. */\n\tprivate static readonly _newlines;\n\t/** Cache of breaking spaces. */\n\tprivate static readonly _breakingSpaces;\n\tprivate static __canvas;\n\tprivate static __context;\n\t/** Cache for measured text metrics */\n\tprivate static readonly _measurementCache;\n\t/**\n\t * @param text - the text that was measured\n\t * @param style - the style that was measured\n\t * @param width - the measured width of the text\n\t * @param height - the measured height of the text\n\t * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n\t * @param lineWidths - an array of the line widths for each line matched to `lines`\n\t * @param lineHeight - the measured line height for this style\n\t * @param maxLineWidth - the maximum line width for all measured lines\n\t * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n\t */\n\tconstructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[], lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics);\n\t/**\n\t * Measures the supplied string of text and returns a Rectangle.\n\t * @param text - The text to measure.\n\t * @param style - The text style to use for measuring\n\t * @param canvas - optional specification of the canvas to use for measuring.\n\t * @param wordWrap\n\t * @returns Measured width and height of the text.\n\t */\n\tstatic measureText(text: string, style: TextStyle, canvas?: ICanvas, wordWrap?: boolean): CanvasTextMetrics;\n\tprivate static _measureText;\n\t/**\n\t * Applies newlines to a string to have it optimally fit into the horizontal\n\t * bounds set by the Text object's wordWrapWidth property.\n\t * @param text - String to apply word wrapping to\n\t * @param style - the style to use when wrapping\n\t * @param canvas - optional specification of the canvas to use for measuring.\n\t * @returns New string with new lines applied where required\n\t */\n\tprivate static _wordWrap;\n\t/**\n\t * Convenience function for logging each line added during the wordWrap method.\n\t * @param line    - The line of text to add\n\t * @param newLine - Add new line character to end\n\t * @returns A formatted line\n\t */\n\tprivate static _addLine;\n\t/**\n\t * Gets & sets the widths of calculated characters in a cache object\n\t * @param key            - The key\n\t * @param letterSpacing  - The letter spacing\n\t * @param cache          - The cache\n\t * @param context        - The canvas context\n\t * @returns The from cache.\n\t */\n\tprivate static _getFromCache;\n\t/**\n\t * Determines whether we should collapse breaking spaces.\n\t * @param whiteSpace - The TextStyle property whiteSpace\n\t * @returns Should collapse\n\t */\n\tprivate static _collapseSpaces;\n\t/**\n\t * Determines whether we should collapse newLine chars.\n\t * @param whiteSpace - The white space\n\t * @returns should collapse\n\t */\n\tprivate static _collapseNewlines;\n\t/**\n\t * Trims breaking whitespaces from string.\n\t * @param text - The text\n\t * @returns Trimmed string\n\t */\n\tprivate static _trimRight;\n\t/**\n\t * Determines if char is a newline.\n\t * @param char - The character\n\t * @returns True if newline, False otherwise.\n\t */\n\tprivate static _isNewline;\n\t/**\n\t * Determines if char is a breaking whitespace.\n\t *\n\t * It allows one to determine whether char should be a breaking whitespace\n\t * For example certain characters in CJK langs or numbers.\n\t * It must return a boolean.\n\t * @param char - The character\n\t * @param [_nextChar] - The next character\n\t * @returns True if whitespace, False otherwise.\n\t */\n\tstatic isBreakingSpace(char: string, _nextChar?: string): boolean;\n\t/**\n\t * Splits a string into words, breaking-spaces and newLine characters\n\t * @param text - The text\n\t * @returns A tokenized array\n\t */\n\tprivate static _tokenize;\n\t/**\n\t * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n\t *\n\t * It allows one to customise which words should break\n\t * Examples are if the token is CJK or numbers.\n\t * It must return a boolean.\n\t * @param _token - The token\n\t * @param breakWords - The style attr break words\n\t * @returns Whether to break word or not\n\t */\n\tstatic canBreakWords(_token: string, breakWords: boolean): boolean;\n\t/**\n\t * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n\t *\n\t * It allows one to determine whether a pair of characters\n\t * should be broken by newlines\n\t * For example certain characters in CJK langs or numbers.\n\t * It must return a boolean.\n\t * @param _char - The character\n\t * @param _nextChar - The next character\n\t * @param _token - The token/word the characters are from\n\t * @param _index - The index in the token of the char\n\t * @param _breakWords - The style attr break words\n\t * @returns whether to break word or not\n\t */\n\tstatic canBreakChars(_char: string, _nextChar: string, _token: string, _index: number, _breakWords: boolean): boolean;\n\t/**\n\t * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n\t *\n\t * It is called when a token (usually a word) has to be split into separate pieces\n\t * in order to determine the point to break a word.\n\t * It must return an array of characters.\n\t * @param token - The token to split\n\t * @returns The characters of the token\n\t * @see CanvasTextMetrics.graphemeSegmenter\n\t */\n\tstatic wordWrapSplit(token: string): string[];\n\t/**\n\t * Calculates the ascent, descent and fontSize of a given font-style\n\t * @param font - String representing the style of the font\n\t * @returns Font properties object\n\t */\n\tstatic measureFont(font: string): FontMetrics;\n\t/**\n\t * Clear font metrics in metrics cache.\n\t * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n\t */\n\tstatic clearMetrics(font?: string): void;\n\t/**\n\t * Cached canvas element for measuring text\n\t * TODO: this should be private, but isn't because of backward compat, will fix later.\n\t * @ignore\n\t */\n\tstatic get _canvas(): ICanvas;\n\t/**\n\t * TODO: this should be private, but isn't because of backward compat, will fix later.\n\t * @ignore\n\t */\n\tstatic get _context(): ICanvasRenderingContext2D;\n}\n/**\n * @category text\n * @advanced\n */\nexport interface CharData {\n\t/** Unique id of character */\n\tid: number;\n\t/** x-offset to apply when rendering character */\n\txOffset: number;\n\t/** y-offset to apply when rendering character. */\n\tyOffset: number;\n\t/** Advancement to apply to next character. */\n\txAdvance: number;\n\t/** The kerning values for this character. */\n\tkerning: Record<string, number>;\n\t/** The texture of the character. */\n\ttexture?: Texture;\n}\n/**\n * The raw data of a character in a bitmap font.\n * @category text\n * @advanced\n */\nexport interface RawCharData extends Omit<CharData, \"texture\"> {\n\t/** The page of the font texture that the character is on. */\n\tpage: number;\n\t/** The x position of the character in the page. */\n\tx: number;\n\t/** The y position of the character in the page. */\n\ty: number;\n\t/** The width of the character in the page. */\n\twidth: number;\n\t/** The height of the character in the page. */\n\theight: number;\n\t/** The letter of the character. */\n\tletter: string;\n}\n/**\n * The raw data of a bitmap font.\n * @category text\n * @advanced\n */\nexport interface BitmapFontData {\n\t/** The offset of the font face from the baseline. */\n\tbaseLineOffset: number;\n\t/** The map of characters by character code. */\n\tchars: Record<string, RawCharData>;\n\t/** The map of base page textures (i.e., sheets of glyphs). */\n\tpages: {\n\t\t/** Unique id for bitmap texture */\n\t\tid: number;\n\t\t/** File name */\n\t\tfile: string;\n\t}[];\n\t/** The line-height of the font face in pixels. */\n\tlineHeight: number;\n\t/** The size of the font face in pixels. */\n\tfontSize: number;\n\t/** The name of the font face. */\n\tfontFamily: string;\n\t/** The range and type of the distance field for this font. */\n\tdistanceField?: {\n\t\t/** Type of distance field */\n\t\ttype: \"sdf\" | \"msdf\" | \"none\";\n\t\t/** Range of the distance field in pixels */\n\t\trange: number;\n\t};\n}\ninterface BitmapFontEvents<Type> {\n\tdestroy: [\n\t\tType\n\t];\n}\n/**\n * An abstract representation of a bitmap font.\n * @category text\n * @advanced\n */\nexport abstract class AbstractBitmapFont<FontType> extends EventEmitter<BitmapFontEvents<FontType>> implements Omit<BitmapFontData, \"chars\" | \"pages\" | \"fontSize\"> {\n\t/** The map of characters by character code. */\n\treadonly chars: Record<string, CharData>;\n\t/**\n\t * The line-height of the font face in pixels.\n\t * @type {number}\n\t */\n\treadonly lineHeight: BitmapFontData[\"lineHeight\"];\n\t/**\n\t * The name of the font face\n\t * @type {string}\n\t */\n\treadonly fontFamily: BitmapFontData[\"fontFamily\"];\n\t/** The metrics of the font face. */\n\treadonly fontMetrics: FontMetrics;\n\t/**\n\t * The offset of the font face from the baseline.\n\t * @type {number}\n\t */\n\treadonly baseLineOffset: BitmapFontData[\"baseLineOffset\"];\n\t/** The range and type of the distance field for this font. */\n\treadonly distanceField: BitmapFontData[\"distanceField\"];\n\t/** The map of base page textures (i.e., sheets of glyphs). */\n\treadonly pages: {\n\t\ttexture: Texture;\n\t}[];\n\t/** should the fill for this font be applied as a tint to the text. */\n\tapplyFillAsTint: boolean;\n\t/** The size of the font face in pixels. */\n\treadonly baseMeasurementFontSize: number;\n\tprotected baseRenderedFontSize: number;\n\t/**\n\t * The name of the font face.\n\t * @deprecated since 8.0.0 Use `fontFamily` instead.\n\t */\n\tget font(): BitmapFontData[\"fontFamily\"];\n\t/**\n\t * The map of base page textures (i.e., sheets of glyphs).\n\t * @deprecated since 8.0.0 Use `pages` instead.\n\t */\n\tget pageTextures(): AbstractBitmapFont<FontType>[\"pages\"];\n\t/**\n\t * The size of the font face in pixels.\n\t * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n\t */\n\tget size(): BitmapFontData[\"fontSize\"];\n\t/**\n\t * The kind of distance field for this font or \"none\".\n\t * @deprecated since 8.0.0 Use `distanceField.type` instead.\n\t */\n\tget distanceFieldRange(): NonNullable<BitmapFontData[\"distanceField\"]>[\"range\"];\n\t/**\n\t * The range of the distance field in pixels.\n\t * @deprecated since 8.0.0 Use `distanceField.range` instead.\n\t */\n\tget distanceFieldType(): NonNullable<BitmapFontData[\"distanceField\"]>[\"type\"];\n\tdestroy(destroyTextures?: boolean): void;\n}\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData {\n\tinfo: {\n\t\tface: string;\n\t\tsize: string;\n\t}[];\n\tcommon: {\n\t\tlineHeight: string;\n\t\tbase: string;\n\t}[];\n\tpage: {\n\t\tid: string;\n\t\tfile: string;\n\t}[];\n\tchars: {\n\t\tcount: number;\n\t}[];\n\tchar: {\n\t\tid: string;\n\t\tpage: string;\n\t\txoffset: string;\n\t\tyoffset: string;\n\t\txadvance: string;\n\t\tx: string;\n\t\ty: string;\n\t\twidth: string;\n\t\theight: string;\n\t\tletter?: string;\n\t\tchar?: string;\n\t}[];\n\tkernings?: {\n\t\tcount: number;\n\t}[];\n\tkerning?: {\n\t\tfirst: string;\n\t\tsecond: string;\n\t\tamount: string;\n\t}[];\n\tdistanceField?: {\n\t\tfieldType: \"sdf\" | \"msdf\" | \"none\";\n\t\tdistanceRange: string;\n\t}[];\n}\n/** @internal */\nexport const bitmapFontTextParser: {\n\ttest(data: string | XMLDocument | BitmapFontData): boolean;\n\tparse(txt: string): BitmapFontData;\n};\n/** @internal */\nexport const bitmapFontXMLParser: {\n\ttest(data: string | XMLDocument | BitmapFontData): boolean;\n\tparse(xml: Document): BitmapFontData;\n};\n/** @internal */\nexport const bitmapFontXMLStringParser: {\n\ttest(data: string | XMLDocument | BitmapFontData): boolean;\n\tparse(data: string): BitmapFontData;\n};\n/**\n * A utility type that allows a value to be either a single item of type T or an array of items of type T.\n * @category utils\n * @advanced\n */\nexport type ArrayOr<T> = T | T[];\n/**\n * @deprecated Use {@link AssetParser} instead.\n * @category assets\n * @advanced\n */\nexport type LoadParserName = \"loadJson\" | \"loadSvg\" | \"loadTextures\" | \"loadTxt\" | \"loadVideo\" | \"loadWebFont\" | (string & {});\n/**\n * Names of the parsers that are built into PixiJS.\n * @example\n * ```ts\n * Assets.load({\n *     src: assetToLoad,\n *     parser: 'json' // Use the built-in JSON parser\n * });\n * ```\n * @category assets\n * @advanced\n */\nexport type AssetParser = \"json\" | \"svg\" | \"text\" | \"video\" | \"web-font\" | \"bitmap-font\" | \"spritesheet\" | \"texture\" | \"basis\" | \"dds\" | \"ktx2\" | \"ktx\" | (string & {});\n/**\n * A fully resolved asset, with all the information needed to load it.\n * This represents an asset that has been processed by the resolver and is ready to be loaded.\n * @example\n * ```ts\n * // Basic resolved asset\n * const asset: ResolvedAsset = {\n *     alias: ['hero'],\n *     src: 'hero.png',\n *     format: 'png'\n * };\n *\n * // Resolved asset with multiple aliases\n * const asset: ResolvedAsset = {\n *     alias: ['character', 'player'],\n *     src: 'character@2x.webp',\n *     format: 'webp',\n * };\n *\n * // Resolved asset with specific parser\n * const asset: ResolvedAsset = {\n *     alias: ['config'],\n *     src: 'data.txt',\n *     format: 'txt',\n *     parser: 'text'\n * };\n * ```\n * @category assets\n * @standard\n */\nexport interface ResolvedAsset<T = any> {\n\t/** Array of alternative names for this asset. Used for looking up the same asset by different keys. */\n\talias?: string[];\n\t/** The URL or relative path to the asset. This is the final, resolved path that will be used for loading. */\n\tsrc?: string;\n\t/**\n\t * Optional data passed to the asset loader.\n\t * Can include texture settings, parser options, or other asset-specific data.\n\t */\n\tdata?: T;\n\t/** File format of the asset, usually the file extension. Used to determine which loader parser to use. */\n\tformat?: string;\n\t/**\n\t * @deprecated Use `parser` instead.\n\t */\n\tloadParser?: LoadParserName;\n\t/** Override to specify which parser should load this asset. Useful when file extensions don't match the content type. */\n\tparser?: AssetParser;\n\t/**\n\t * The amount of progress an asset will contribute to the onProgress event when loading.\n\t * This can be any arbitrary value but typically represents the file size.\n\t * @default 1\n\t */\n\tprogressSize?: number;\n}\n/**\n * A fully resolved src specification after pattern resolution and format detection.\n * Unlike raw asset sources, this type represents the final, concrete source path and format.\n * @example\n * ```ts\n * // Basic resolved source\n * const src: ResolvedSrc = {\n *     src: 'images/sprite.png',\n *     format: 'png'\n * };\n *\n * // With resolution and format preferences\n * const src: ResolvedSrc = {\n *     src: 'images/sprite@2x.webp',\n *     format: 'webp',\n *     data: { resolution: 2 }\n * };\n *\n * // With specific loader\n * const src: ResolvedSrc = {\n *     src: 'data/config.txt',\n *     format: 'txt',\n *     parser: 'text',\n * };\n * ```\n * @remarks\n * - Pattern strings like `{png,webp}` are resolved to specific formats\n * - Resolution and format are determined based on browser support\n * - Used internally by the Assets system after resolution\n * - Data property can contain format-specific options\n * @see {@link AssetSrc} For unresolved source format\n * @see {@link ResolvedAsset} For complete resolved asset specification\n * @category assets\n * @advanced\n * @interface\n */\nexport type ResolvedSrc = Pick<ResolvedAsset, \"src\" | \"format\" | \"loadParser\" | \"parser\" | \"data\">;\n/**\n * A valid asset source specification. This can be a URL string, a {@link ResolvedSrc},\n * or an array of either. The source defines where and how to load an asset.\n * @example\n * ```ts\n * // Single URL string\n * const src: AssetSrc = 'images/sprite.png';\n *\n * // Multiple format options\n * const src: AssetSrc = ['sprite.webp', 'sprite.png'];\n *\n * // With format pattern\n * const src: AssetSrc = 'sprite.{webp,png}';\n *\n * // Resolved source with options\n * const src: AssetSrc = {\n *     src: 'sprite.png',\n *     format: 'png',\n *     parser: 'texture',\n *     data: {\n *         scaleMode: 'nearest',\n *     }\n * };\n *\n * // Array of resolved sources\n * const src: AssetSrc = [\n *     {\n *         src: 'sprite@2x.webp',\n *         format: 'webp',\n *     },\n *     {\n *         src: 'sprite.png',\n *         format: 'png',\n *     }\n * ];\n * ```\n * @remarks\n * When specifying multiple formats:\n * - The format that is selected will depend on {@link AssetInitOptions.texturePreference}\n * - Resolution is parsed from file names\n * - Custom data can be passed to loaders\n * @see {@link ResolvedSrc} For resolved source format\n * @see {@link Assets.add} For adding assets with sources\n * @category assets\n * @standard\n */\nexport type AssetSrc = ArrayOr<string> | (ArrayOr<ResolvedSrc> & {\n\t[key: string]: any;\n});\n/**\n * An asset that has not been resolved yet. This is the initial format used when adding assets\n * to the Assets system before they are processed into a {@link ResolvedAsset}.\n * @example\n * ```ts\n * // Basic unresolved asset\n * const asset: UnresolvedAsset = {\n *     alias: 'hero',\n *     src: 'hero.png'\n * };\n *\n * // Multiple aliases and formats\n * const asset: UnresolvedAsset = {\n *     alias: ['hero', 'player'],\n *     src: 'hero.{webp,png}',\n *     data: {\n *         scaleMode: 'nearest',\n *     }\n * };\n *\n * // Asset with multiple sources and formats\n * const asset: UnresolvedAsset = {\n *     alias: 'background',\n *     src: [\n *         'bg@2x.webp',\n *         'bg@1x.webp',\n *         'bg@2x.png',\n *         'bg@1x.png',\n *     ]\n * };\n *\n * // With specific loader\n * const asset: UnresolvedAsset = {\n *     alias: 'config',\n *     src: 'data.txt',\n *     parser: 'text'\n * };\n * ```\n * @remarks\n * - Used as input format when adding assets to the system\n * - Can specify multiple aliases for the same asset\n * - Supports format patterns for browser compatibility\n * - Can include loader-specific data and options\n * @see {@link ResolvedAsset} For the resolved asset format\n * @see {@link Assets.add} For adding unresolved assets\n * @category assets\n * @standard\n * @interface\n */\nexport type UnresolvedAsset<T = any> = Pick<ResolvedAsset<T>, \"data\" | \"format\" | \"loadParser\" | \"parser\"> & {\n\t/** Aliases associated with asset */\n\talias?: ArrayOr<string>;\n\t/** The URL or relative path to the asset */\n\tsrc?: AssetSrc;\n\t[key: string]: any;\n};\n/**\n * Structure of a bundle found in a {@link AssetsManifest} file. Bundles allow you to\n * group related assets together for easier management and loading.\n * @example\n * ```ts\n * // Basic bundle structure\n * const bundle: AssetsBundle = {\n *     name: 'level-1',\n *     assets: [\n *         {\n *             alias: 'background',\n *             src: 'level1/bg.{webp,png}'\n *         },\n *         {\n *             alias: 'sprites',\n *             src: 'level1/sprites.json'\n *         }\n *     ]\n * };\n *\n * // Using object format for assets\n * const bundle: AssetsBundle = {\n *     name: 'ui',\n *     assets: {\n *         button: 'ui/button.png',\n *         panel: 'ui/panel.png',\n *         icons: ['ui/icons.webp', 'ui/icons.png']\n *     }\n * };\n * ```\n * @see {@link Assets.addBundle} For adding bundles programmatically\n * @see {@link Assets.loadBundle} For loading bundles\n * @category assets\n * @standard\n */\nexport interface AssetsBundle {\n\t/** Unique identifier for the bundle */\n\tname: string;\n\t/** Assets contained in the bundle. Can be an array of assets or a record mapping aliases to sources. */\n\tassets: UnresolvedAsset[] | Record<string, ArrayOr<string> | UnresolvedAsset>;\n}\n/**\n * The manifest format for defining all assets in your application. Manifests provide a\n * structured way to organize and manage your assets through bundles.\n * @example\n * ```ts\n * const manifest: AssetsManifest = {\n *     bundles: [\n *         {\n *             name: 'loading',\n *             assets: [\n *                 {\n *                     alias: 'logo',\n *                     src: 'logo.{webp,png}',\n *                     data: { scaleMode: 'nearest' }\n *                 },\n *                 {\n *                     alias: 'progress-bar',\n *                     src: 'progress.png'\n *                 }\n *             ]\n *         },\n *         {\n *             name: 'game',\n *             assets: {\n *                 background: ['bg.webp', 'bg.png'],\n *                 character: 'hero.json',\n *                 music: 'theme.mp3'\n *             }\n *         }\n *     ]\n * };\n *\n * // Initialize with manifest\n * await Assets.init({ manifest });\n *\n * // Load bundles as needed\n * await Assets.loadBundle('loading');\n * await Assets.loadBundle('game');\n * ```\n * @see {@link Assets.init} For initializing with a manifest\n * @see {@link AssetsBundle} For bundle structure details\n * @category assets\n * @standard\n */\nexport interface AssetsManifest {\n\t/** Array of asset bundles that make up the manifest */\n\tbundles: AssetsBundle[];\n}\n/**\n * For every asset that is cached, it will call the parsers test function\n * the flow is as follows:\n *\n * 1. `cacheParser.test()`: Test the asset.\n * 2. `cacheParser.getCacheableAssets()`: If the test passes call the getCacheableAssets function with the asset\n *\n * Useful if you want to add more than just a raw asset to the cache\n * (for example a spritesheet will want to make all its sub textures easily accessible in the cache)\n * @category assets\n * @advanced\n */\nexport interface CacheParser<T = any> {\n\t/** The extension type of this cache parser */\n\textension?: ExtensionMetadata;\n\t/** A config to adjust the parser */\n\tconfig?: Record<string, any>;\n\t/**\n\t * Gets called by the cache when a dev caches an asset\n\t * @param asset - the asset to test\n\t */\n\ttest: (asset: T) => boolean;\n\t/**\n\t * If the test passes, this function is called to get the cacheable assets\n\t * an example may be that a spritesheet object will return all the sub textures it has so they can\n\t * be cached.\n\t * @param keys - The keys to cache the assets under\n\t * @param asset - The asset to get the cacheable assets from\n\t * @returns A key-value pair of cacheable assets\n\t */\n\tgetCacheableAssets: (keys: string[], asset: T) => Record<string, any>;\n}\ndeclare class CacheClass {\n\tprivate readonly _parsers;\n\tprivate readonly _cache;\n\tprivate readonly _cacheMap;\n\t/** Clear all entries. */\n\treset(): void;\n\t/**\n\t * Check if the key exists\n\t * @param key - The key to check\n\t */\n\thas(key: any): boolean;\n\t/**\n\t * Fetch entry by key\n\t * @param key - The key of the entry to get\n\t */\n\tget<T = any>(key: any): T;\n\t/**\n\t * Set a value by key or keys name\n\t * @param key - The key or keys to set\n\t * @param value - The value to store in the cache or from which cacheable assets will be derived.\n\t */\n\tset<T = any>(key: any | any[], value: T): void;\n\t/**\n\t * Remove entry by key\n\t *\n\t * This function will also remove any associated alias from the cache also.\n\t * @param key - The key of the entry to remove\n\t */\n\tremove(key: any): void;\n\t/**\n\t * All loader parsers registered\n\t * @advanced\n\t */\n\tget parsers(): CacheParser[];\n}\n/**\n * A global cache for all assets in your PixiJS application. The cache system provides fast\n * access to loaded assets and prevents duplicate loading.\n *\n * Key Features:\n * - Automatic caching of loaded assets\n * - Support for custom cache parsers\n * - Automatic parsing of complex assets (e.g., spritesheets)\n * - Memory management utilities\n * > [!IMPORTANT] You typically do not need to use this class directly.\n * > Use the main {@link Assets} class for high-level asset management.\n * > `Assets.get(key)` will automatically use the cache.\n * @example\n * ```ts\n * import { Cache } from 'pixi.js';\n *\n * // Store an asset in the cache\n * Cache.set('myTexture', texture);\n *\n * // Retrieve an asset\n * const texture = Cache.get('myTexture');\n *\n * // Check if an asset exists\n * if (Cache.has('myTexture')) {\n *     // Use the cached asset\n *     const sprite = new Sprite(Cache.get('myTexture'));\n * }\n *\n * // Remove an asset from cache\n * Cache.remove('myTexture');\n *\n * // Clear all cached assets\n * Cache.reset();\n * ```\n * @remarks\n * The Cache is a core component of PixiJS' asset management system:\n * - Used internally by the {@link Assets} class\n * - Supports automatic parsing via {@link CacheParser}\n * - Handles complex asset types like spritesheets\n * - Manages memory through asset removal\n *\n * > [!IMPORTANT]\n * > This is a singleton class and should not be instantiated directly.\n * > Use the exported `Cache` instance instead.\n * @see {@link Assets} For high-level asset management\n * @see {@link CacheParser} For custom cache parsing\n * @category assets\n * @class\n * @advanced\n */\ndeclare const Cache$1: CacheClass;\n/**\n * Configuration for the [loadTextures]{@link loadTextures} plugin.\n * @see loadTextures\n * @category assets\n * @advanced\n */\nexport interface LoadTextureConfig {\n\t/**\n\t * When set to `true`, loading and decoding images will happen with Worker thread,\n\t * if available on the browser. This is much more performant as network requests\n\t * and decoding can be expensive on the CPU. However, not all environments support\n\t * Workers, in some cases it can be helpful to disable by setting to `false`.\n\t * @default true\n\t */\n\tpreferWorkers: boolean;\n\t/**\n\t * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n\t * otherwise it will use `new Image()`.\n\t * @default true\n\t */\n\tpreferCreateImageBitmap: boolean;\n\t/**\n\t * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n\t * @default 'anonymous'\n\t */\n\tcrossOrigin: ImageLike[\"crossOrigin\"];\n}\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport function loadImageBitmap(url: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>;\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @category assets\n * @advanced\n */\nexport const loadTextures: LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig>;\n/**\n * A prefer order lets the resolver know which assets to prefer depending on the various parameters passed to it.\n * @category assets\n * @standard\n */\nexport interface PreferOrder {\n\t/** the importance order of the params */\n\tpriority?: string[];\n\tparams: {\n\t\t[key: string]: any;\n\t};\n}\n/**\n * Format for url parser, will test a string and if it pass will then parse it, turning it into an ResolvedAsset\n * @category assets\n * @advanced\n */\nexport interface ResolveURLParser {\n\textension?: ExtensionMetadata;\n\t/** A config to adjust the parser */\n\tconfig?: Record<string, any>;\n\t/** the test to perform on the url to determine if it should be parsed */\n\ttest: (url: string) => boolean;\n\t/** the function that will convert the url into an object */\n\tparse: (value: string) => ResolvedAsset & {\n\t\t[key: string]: any;\n\t};\n}\n/**\n * Options for how the resolver deals with generating bundle ids\n * @category assets\n * @advanced\n */\nexport interface BundleIdentifierOptions {\n\t/** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n\tconnector?: string;\n\t/**\n\t * A function that generates a bundle asset id key from a bundleId and an assetId\n\t * @param bundleId - the bundleId\n\t * @param assetId  - the assetId\n\t * @returns the bundle asset id key\n\t */\n\tcreateBundleAssetId?: (bundleId: string, assetId: string) => string;\n\t/**\n\t * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n\t * @param bundleId - the bundleId\n\t * @param assetBundleId - the bundle asset id key\n\t * @returns the assetId\n\t */\n\textractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Resolver {\n\t/**\n\t * The prefix that denotes a URL is for a retina asset.\n\t * @default /@([0-9\\.]+)x/\n\t * @example `@2x`\n\t */\n\tstatic RETINA_PREFIX: RegExp;\n\tprivate readonly _defaultBundleIdentifierOptions;\n\t/** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n\tprivate _bundleIdConnector;\n\t/**\n\t * A function that generates a bundle asset id key from a bundleId and an assetId\n\t * @param bundleId - the bundleId\n\t * @param assetId  - the assetId\n\t * @returns the bundle asset id key\n\t */\n\tprivate _createBundleAssetId;\n\t/**\n\t * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n\t * @param bundleId - the bundleId\n\t * @param assetBundleId - the bundle asset id key\n\t * @returns the assetId\n\t */\n\tprivate _extractAssetIdFromBundle;\n\tprivate _assetMap;\n\tprivate _preferredOrder;\n\tprivate readonly _parsers;\n\tprivate _resolverHash;\n\tprivate _rootPath;\n\tprivate _basePath;\n\tprivate _manifest;\n\tprivate _bundles;\n\tprivate _defaultSearchParams;\n\t/**\n\t * Override how the resolver deals with generating bundle ids.\n\t * must be called before any bundles are added\n\t * @param bundleIdentifier - the bundle identifier options\n\t */\n\tsetBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void;\n\t/**\n\t * Let the resolver know which assets you prefer to use when resolving assets.\n\t * Multiple prefer user defined rules can be added.\n\t * @example\n\t * resolver.prefer({\n\t *     // first look for something with the correct format, and then then correct resolution\n\t *     priority: ['format', 'resolution'],\n\t *     params:{\n\t *         format:'webp', // prefer webp images\n\t *         resolution: 2, // prefer a resolution of 2\n\t *     }\n\t * })\n\t * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n\t * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n\t * @param preferOrders - the prefer options\n\t */\n\tprefer(...preferOrders: PreferOrder[]): void;\n\t/**\n\t * Set the base path to prepend to all urls when resolving\n\t * @example\n\t * resolver.basePath = 'https://home.com/';\n\t * resolver.add('foo', 'bar.ong');\n\t * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n\t * @param basePath - the base path to use\n\t */\n\tset basePath(basePath: string);\n\tget basePath(): string;\n\t/**\n\t * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n\t * default value for browsers is `window.location.origin`\n\t * @example\n\t * // Application hosted on https://home.com/some-path/index.html\n\t * resolver.basePath = 'https://home.com/some-path/';\n\t * resolver.rootPath = 'https://home.com/';\n\t * resolver.add('foo', '/bar.png');\n\t * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n\t * @param rootPath - the root path to use\n\t */\n\tset rootPath(rootPath: string);\n\tget rootPath(): string;\n\t/**\n\t * All the active URL parsers that help the parser to extract information and create\n\t * an asset object-based on parsing the URL itself.\n\t *\n\t * Can be added using the extensions API\n\t * @example\n\t * resolver.add('foo', [\n\t *     {\n\t *         resolution: 2,\n\t *         format: 'png',\n\t *         src: 'image@2x.png',\n\t *     },\n\t *     {\n\t *         resolution:1,\n\t *         format:'png',\n\t *         src: 'image.png',\n\t *     },\n\t * ]);\n\t *\n\t * // With a url parser the information such as resolution and file format could extracted from the url itself:\n\t * extensions.add({\n\t *     extension: ExtensionType.ResolveParser,\n\t *     test: loadTextures.test, // test if url ends in an image\n\t *     parse: (value: string) =>\n\t *     ({\n\t *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n\t *         format: value.split('.').pop(),\n\t *         src: value,\n\t *     }),\n\t * });\n\t *\n\t * // Now resolution and format can be extracted from the url\n\t * resolver.add('foo', [\n\t *     'image@2x.png',\n\t *     'image.png',\n\t * ]);\n\t */\n\tget parsers(): ResolveURLParser[];\n\t/** Used for testing, this resets the resolver to its initial state */\n\treset(): void;\n\t/**\n\t * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n\t * @param searchParams - the default url parameters to append when resolving urls\n\t */\n\tsetDefaultSearchParams(searchParams: string | Record<string, unknown>): void;\n\t/**\n\t * Returns the aliases for a given asset\n\t * @param asset - the asset to get the aliases for\n\t */\n\tgetAlias(asset: UnresolvedAsset): string[];\n\t/**\n\t * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n\t * generally a manifest would be built using a tool.\n\t * @param manifest - the manifest to add to the resolver\n\t */\n\taddManifest(manifest: AssetsManifest): void;\n\t/**\n\t * This adds a bundle of assets in one go so that you can resolve them as a group.\n\t * For example you could add a bundle for each screen in you pixi app\n\t * @example\n\t * resolver.addBundle('animals', [\n\t *  { alias: 'bunny', src: 'bunny.png' },\n\t *  { alias: 'chicken', src: 'chicken.png' },\n\t *  { alias: 'thumper', src: 'thumper.png' },\n\t * ]);\n\t * // or\n\t * resolver.addBundle('animals', {\n\t *     bunny: 'bunny.png',\n\t *     chicken: 'chicken.png',\n\t *     thumper: 'thumper.png',\n\t * });\n\t *\n\t * const resolvedAssets = await resolver.resolveBundle('animals');\n\t * @param bundleId - The id of the bundle to add\n\t * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n\t */\n\taddBundle(bundleId: string, assets: AssetsBundle[\"assets\"]): void;\n\t/**\n\t * Tells the resolver what keys are associated with witch asset.\n\t * The most important thing the resolver does\n\t * @example\n\t * // Single key, single asset:\n\t * resolver.add({alias: 'foo', src: 'bar.png');\n\t * resolver.resolveUrl('foo') // => 'bar.png'\n\t *\n\t * // Multiple keys, single asset:\n\t * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n\t * resolver.resolveUrl('foo') // => 'bar.png'\n\t * resolver.resolveUrl('boo') // => 'bar.png'\n\t *\n\t * // Multiple keys, multiple assets:\n\t * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n\t * resolver.resolveUrl('foo') // => 'bar.png'\n\t *\n\t * // Add custom data attached to the resolver\n\t * Resolver.add({\n\t *     alias: 'bunnyBooBooSmooth',\n\t *     src: 'bunny{png,webp}',\n\t *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n\t * });\n\t *\n\t * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n\t * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n\t */\n\tadd(aliases: ArrayOr<UnresolvedAsset>): void;\n\t/**\n\t * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n\t * a given bundleId or bundleIds.\n\t * @example\n\t * // Manifest Example\n\t * const manifest = {\n\t *     bundles: [\n\t *         {\n\t *             name: 'load-screen',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'background',\n\t *                     src: 'sunset.png',\n\t *                 },\n\t *                 {\n\t *                     alias: 'bar',\n\t *                     src: 'load-bar.{png,webp}',\n\t *                 },\n\t *             ],\n\t *         },\n\t *         {\n\t *             name: 'game-screen',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'character',\n\t *                     src: 'robot.png',\n\t *                 },\n\t *                 {\n\t *                     alias: 'enemy',\n\t *                     src: 'bad-guy.png',\n\t *                 },\n\t *             ],\n\t *         },\n\t *     ]\n\t * };\n\t *\n\t * resolver.setManifest(manifest);\n\t * const resolved = resolver.resolveBundle('load-screen');\n\t * @param bundleIds - The bundle ids to resolve\n\t * @returns All the bundles assets or a hash of assets for each bundle specified\n\t */\n\tresolveBundle(bundleIds: ArrayOr<string>): Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>;\n\t/**\n\t * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n\t * @param key - The key or keys to resolve\n\t * @returns - The URLs associated with the key(s)\n\t */\n\tresolveUrl(key: ArrayOr<string>): string | Record<string, string>;\n\t/**\n\t * Resolves each key in the list to an asset object.\n\t * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n\t * of finding which asset to return based on any preferences set using the `prefer` function\n\t * by default the same key passed in will be returned if nothing is matched by the resolver.\n\t * @example\n\t * resolver.add('boo', 'bunny.png');\n\t *\n\t * resolver.resolve('boo') // => { src: 'bunny.png' }\n\t *\n\t * // Will return the same string as no key was added for this value..\n\t * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n\t * @param keys - key or keys to resolve\n\t * @returns - the resolve asset or a hash of resolve assets for each key specified\n\t */\n\tresolve(keys: string): ResolvedAsset;\n\tresolve(keys: string[]): Record<string, ResolvedAsset>;\n\t/**\n\t * Checks if an asset with a given key exists in the resolver\n\t * @param key - The key of the asset\n\t */\n\thasKey(key: string): boolean;\n\t/**\n\t * Checks if a bundle with the given key exists in the resolver\n\t * @param key - The key of the bundle\n\t */\n\thasBundle(key: string): boolean;\n\t/**\n\t * Internal function for figuring out what prefer criteria an asset should use.\n\t * @param assets\n\t */\n\tprivate _getPreferredOrder;\n\t/**\n\t * Appends the default url parameters to the url\n\t * @param url - The url to append the default parameters to\n\t * @returns - The url with the default parameters appended\n\t */\n\tprivate _appendDefaultSearchParams;\n\tprivate _buildResolvedAsset;\n}\n/**\n * @param url\n * @internal\n */\nexport function getUrlExtension(url: string): string;\n/**\n * Format detection is useful for detecting feature support on the current platform.\n * @category assets\n * @advanced\n */\nexport interface FormatDetectionParser {\n\t/** Should be ExtensionType.DetectionParser */\n\textension?: ExtensionMetadata;\n\t/** Browser/platform feature detection supported if return true  */\n\ttest: () => Promise<boolean>;\n\t/**\n\t * Add formats (file extensions) to the existing list of formats.\n\t * Return an new array with added formats, do not mutate the formats argument.\n\t * @returns {Promise<string[]>} - Promise that resolves to the new formats array.\n\t */\n\tadd: (formats: string[]) => Promise<string[]>;\n\t/**\n\t * Remove formats (file extensions) from the list of supported formats.\n\t * This is used when uninstalling this DetectionParser.\n\t * Return an new array with filtered formats, do not mutate the formats argument.\n\t * @returns {Promise<string[]>} - Promise that resolves to the new formats array.\n\t */\n\tremove: (formats: string[]) => Promise<string[]>;\n}\n/**\n * Configuration for the {@link loadSvg} plugin.\n * @see loadSvg\n * @category assets\n * @advanced\n */\nexport interface LoadSVGConfig {\n\t/**\n\t * The crossOrigin value to use for loading the SVG as an image.\n\t * @default 'anonymous'\n\t */\n\tcrossOrigin: ImageLike[\"crossOrigin\"];\n\t/**\n\t * When set to `true`, loading and decoding images will happen with `new Image()`,\n\t * @default false\n\t */\n\tparseAsGraphicsContext: boolean;\n}\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadSvg: LoaderParser<Texture | GraphicsContext, TextureSourceOptions & LoadSVGConfig, LoadSVGConfig>;\n/**\n * Callback function for tracking asset loading progress. The function is called repeatedly\n * during the loading process with a progress value between 0.0 and 1.0.\n * @param progress - The loading progress from 0.0 (started) to 1.0 (complete)\n * @returns void\n * @example\n * ```ts\n * // Basic progress logging\n * const onProgress = (progress: number) => {\n *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n * };\n *\n * // Update loading bar\n * const onProgress = (progress: number) => {\n *     loadingBar.width = progress * 100;\n *     loadingText.text = `${Math.round(progress * 100)}%`;\n * };\n *\n * // Load assets with progress tracking\n * await Assets.load(['sprite1.png', 'sprite2.png'], onProgress);\n *\n * // Load bundle with progress tracking\n * await Assets.loadBundle('levelAssets', (progress) => {\n *     // Progress is normalized (0.0 - 1.0)\n *     updateLoadingScreen(progress);\n * });\n * ```\n * > [!IMPORTANT] Do not rely on the progress callback to determine when all assets are loaded.\n * > Use the returned promise from `Assets.load()` or `Assets.loadBundle()` to know when loading is complete.\n * @category assets\n * @standard\n */\nexport type ProgressCallback = (progress: number) => void;\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @advanced\n * @category assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {\n}\n/**\n * Options for initializing the Assets class. These options configure how assets are loaded,\n * resolved, and managed in your PixiJS application.\n * @category assets\n * @standard\n */\nexport interface AssetInitOptions {\n\t/**\n\t * Base path prepended to all asset URLs. Useful for CDN hosting.\n\t * @example\n\t * ```ts\n\t * await Assets.init({\n\t *     basePath: 'https://my-cdn.com/assets/'\n\t * });\n\t *\n\t * // Now you can load assets like this:\n\t * // Will load from: https://my-cdn.com/assets/images/sprite.png\n\t * const texture = await Assets.load('images/sprite.png');\n\t * ```\n\t */\n\tbasePath?: string;\n\t/**\n\t * URL parameters to append to all asset URLs.\n\t * Useful for cache-busting or version control.\n\t * @example\n\t * ```ts\n\t * // As a string\n\t * await Assets.init({\n\t *     defaultSearchParams: 'version=1.0.0'\n\t * });\n\t *\n\t * // As an object\n\t * await Assets.init({\n\t *     defaultSearchParams: {\n\t *         version: '1.0.0',\n\t *         t: Date.now()\n\t *     }\n\t * });\n\t * ```\n\t * @advanced\n\t */\n\tdefaultSearchParams?: string | Record<string, any>;\n\t/**\n\t * A manifest defining all your application's assets.\n\t * Can be a URL to a JSON file or a manifest object.\n\t * @example\n\t * ```ts\n\t * // Using a manifest object\n\t * await Assets.init({\n\t *     manifest: {\n\t *         bundles: [{\n\t *             name: 'game-screen',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'hero',\n\t *                     src: 'hero.{png,webp}'\n\t *                 },\n\t *                 {\n\t *                     alias: 'map',\n\t *                     src: 'map.json'\n\t *                 }\n\t *             ]\n\t *         }]\n\t *     }\n\t * });\n\t *\n\t * // Using a URL to manifest\n\t * await Assets.init({\n\t *     manifest: 'assets/manifest.json'\n\t * });\n\t *\n\t * // loading a bundle from the manifest\n\t * await Assets.loadBundle('game-screen');\n\t *\n\t * // load individual assets from the manifest\n\t * const heroTexture = await Assets.load('hero');\n\t * ```\n\t */\n\tmanifest?: string | AssetsManifest;\n\t/**\n\t * Configure texture loading preferences.\n\t * Useful for optimizing asset delivery based on device capabilities.\n\t * @example\n\t * ```ts\n\t * await Assets.init({\n\t *     texturePreference: {\n\t *         // Prefer high-res textures on retina displays\n\t *         resolution: window.devicePixelRatio,\n\t *\n\t *         // Prefer modern formats, fallback to traditional\n\t *         format: ['avif', 'webp', 'png']\n\t *     }\n\t * });\n\t * ```\n\t */\n\ttexturePreference?: {\n\t\t/** Preferred texture resolution(s). Can be a single number or array of resolutions in order of preference. */\n\t\tresolution?: number | number[];\n\t\t/** Preferred texture formats in order of preference. Default: ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n\t\tformat?: ArrayOr<string>;\n\t};\n\t/**\n\t * Skip browser format detection for faster initialization.\n\t * Only use if you know exactly what formats your target browsers support.\n\t * @example\n\t * ```ts\n\t * await Assets.init({\n\t *     skipDetections: true,\n\t *     texturePreference: {\n\t *         format: ['webp', 'png'] // Must explicitly set formats\n\t *     }\n\t * });\n\t * ```\n\t * @advanced\n\t */\n\tskipDetections?: boolean;\n\t/**\n\t * Override how bundle IDs are generated and resolved.\n\t *\n\t * This allows you to customize how assets are grouped and accessed via bundles and allow for\n\t * multiple bundles to share the same asset keys.\n\t * @advanced\n\t * @example\n\t * ```ts\n\t * const manifest = {\n\t *     bundles: [\n\t *         {\n\t *             name: 'bunny1',\n\t *             assets: [\n\t *                 {\n\t *                     alias: ['character', 'character2'],\n\t *                     src: 'textures/bunny.png',\n\t *                 },\n\t *             ],\n\t *         },\n\t *         {\n\t *             name: 'bunny2',\n\t *             assets: [\n\t *                 {\n\t *                     alias: ['character', 'character2'],\n\t *                     src: 'textures/bunny-2.png',\n\t *                 },\n\t *             ],\n\t *         },\n\t *     ]\n\t * };\n\t *\n\t * const bundleIdentifier: BundleIdentifierOptions = {\n\t *     connector: ':',\n\t * };\n\t *\n\t * await Assets.init({ manifest, basePath, bundleIdentifier });\n\t *\n\t * const resources = await Assets.loadBundle('bunny1');\n\t * const resources2 = await Assets.loadBundle('bunny2');\n\t *\n\t * console.log(resources.character === resources2.character); // false\n\t * ```\n\t */\n\tbundleIdentifier?: BundleIdentifierOptions;\n\t/**\n\t * Optional preferences for asset loading behavior.\n\t * @example\n\t * ```ts\n\t * await Assets.init({\n\t *     preferences: {\n\t *         crossOrigin: 'anonymous',\n\t *         parseAsGraphicsContext: false\n\t *     }\n\t * });\n\t * ```\n\t */\n\tpreferences?: Partial<AssetsPreferences>;\n\t/**\n\t * Options for defining the loading behavior of assets.\n\t * @example\n\t * ```ts\n\t * await Assets.init({\n\t *    loadOptions: {\n\t *       onProgress: (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`),\n\t *       onError: (error, asset) => console.error(`Error loading ${asset.src}: ${error.message}`),\n\t *       strategy: 'retry',\n\t *       retryCount: 5,\n\t *       retryDelay: 500,\n\t *   }\n\t * });\n\t * ```\n\t * @remarks\n\t * - `onProgress` callback receives values from 0.0 to 1.0\n\t * - `onError` callback is invoked for individual asset load failures\n\t * - `strategy` can be 'throw' (default), 'retry', or 'skip'\n\t * - `retryCount` sets how many times to retry failed assets (default 3)\n\t * - `retryDelay` sets the delay between retries in milliseconds (default 250ms)\n\t * @see {@link LoadOptions} For all available load options\n\t */\n\tloadOptions?: Partial<LoadOptions>;\n}\n/** @internal */\nexport class AssetsClass {\n\t/**\n\t * The URL resolver for assets. Maps various asset keys and URLs to their final loadable form.\n\t * @advanced\n\t */\n\tresolver: Resolver;\n\t/**\n\t *  The loader responsible for loading all assets. Handles different file types\n\t * and transformations.\n\t * @advanced\n\t */\n\tloader: Loader;\n\t/**\n\t * The global cache for all loaded assets. Manages storage and retrieval of\n\t * processed assets.\n\t * @example\n\t * ```ts\n\t * // Check if an asset is cached\n\t * if (Assets.cache.has('myTexture')) {\n\t *     const texture = Assets.cache.get('myTexture');\n\t * }\n\t * ```\n\t * @see {@link Cache} For detailed cache documentation\n\t */\n\tcache: typeof Cache$1;\n\t/** takes care of loading assets in the background */\n\tprivate readonly _backgroundLoader;\n\tprivate readonly _detections;\n\tprivate _initialized;\n\tconstructor();\n\t/**\n\t * Initializes the Assets class with configuration options. While not required,\n\t * calling this before loading assets is recommended to set up default behaviors.\n\t * @param options - Configuration options for the Assets system\n\t * @example\n\t * ```ts\n\t * // Basic initialization (optional as Assets.load will call this automatically)\n\t * await Assets.init();\n\t *\n\t * // With CDN configuration\n\t * await Assets.init({\n\t *     basePath: 'https://my-cdn.com/assets/',\n\t *     defaultSearchParams: { version: '1.0.0' }\n\t * });\n\t *\n\t * // With manifest and preferences\n\t * await Assets.init({\n\t *     manifest: {\n\t *         bundles: [{\n\t *             name: 'game-screen',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'hero',\n\t *                     src: 'hero.{png,webp}',\n\t *                     data: { scaleMode: SCALE_MODES.NEAREST }\n\t *                 },\n\t *                 {\n\t *                     alias: 'map',\n\t *                     src: 'map.json'\n\t *                 }\n\t *             ]\n\t *         }]\n\t *     },\n\t *     // Optimize for device capabilities\n\t *     texturePreference: {\n\t *         resolution: window.devicePixelRatio,\n\t *         format: ['webp', 'png']\n\t *     },\n\t *     // Set global preferences\n\t *     preferences: {\n\t *         crossOrigin: 'anonymous',\n\t *     }\n\t * });\n\t *\n\t * // Load assets after initialization\n\t * const heroTexture = await Assets.load('hero');\n\t * ```\n\t * @remarks\n\t * - Can be called only once; subsequent calls will be ignored with a warning\n\t * - Format detection runs automatically unless `skipDetections` is true\n\t * - The manifest can be a URL to a JSON file or an inline object\n\t * @see {@link AssetInitOptions} For all available initialization options\n\t * @see {@link AssetsManifest} For manifest format details\n\t */\n\tinit(options?: AssetInitOptions): Promise<void>;\n\t/**\n\t * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,\n\t * allowing you to load assets using friendly names instead of direct URLs.\n\t * @param assets - The unresolved assets to add to the resolver\n\t * @example\n\t * ```ts\n\t * // Basic usage - single asset\n\t * Assets.add({\n\t *     alias: 'myTexture',\n\t *     src: 'assets/texture.png'\n\t * });\n\t * const texture = await Assets.load('myTexture');\n\t *\n\t * // Multiple aliases for the same asset\n\t * Assets.add({\n\t *     alias: ['hero', 'player'],\n\t *     src: 'hero.png'\n\t * });\n\t * const hero1 = await Assets.load('hero');\n\t * const hero2 = await Assets.load('player'); // Same texture\n\t *\n\t * // Multiple format support\n\t * Assets.add({\n\t *     alias: 'character',\n\t *     src: 'character.{webp,png}' // Will choose best format\n\t * });\n\t * Assets.add({\n\t *     alias: 'character',\n\t *     src: ['character.webp', 'character.png'], // Explicitly specify formats\n\t * });\n\t *\n\t * // With texture options\n\t * Assets.add({\n\t *     alias: 'sprite',\n\t *     src: 'sprite.png',\n\t *     data: { scaleMode: 'nearest' }\n\t * });\n\t *\n\t * // Multiple assets at once\n\t * Assets.add([\n\t *     { alias: 'bg', src: 'background.png' },\n\t *     { alias: 'music', src: 'music.mp3' },\n\t *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }\n\t * ]);\n\t * ```\n\t * @remarks\n\t * - Assets are resolved when loaded, not when added\n\t * - Multiple formats use the best available format for the browser\n\t * - Adding with same alias overwrites previous definition\n\t * - The `data` property is passed to the asset loader\n\t * @see {@link Resolver} For details on asset resolution\n\t * @see {@link LoaderParser} For asset-specific data options\n\t * @advanced\n\t */\n\tadd(assets: (ArrayOr<UnresolvedAsset>)): void;\n\t/**\n\t * Loads one or more assets and returns a promise that resolves with the loaded content.\n\t * Assets are cached, so subsequent loads will return the same instance of the asset without re-fetching.\n\t * @param urls - Single URL/alias or array of URLs/aliases to load\n\t * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n\t * @returns Promise that resolves with loaded asset(s)\n\t * @example\n\t * ```ts\n\t * // Load a single asset\n\t * const texture = await Assets.load('images/sprite.png');\n\t *\n\t * // Load using an alias\n\t * const heroTexture = await Assets.load({ alias: 'hero', src: 'images/hero.png' });\n\t *\n\t * // Load multiple assets\n\t * const assets = await Assets.load([\n\t *     'images/background.png',\n\t *     'images/character.png',\n\t *     'fonts/game.fnt'\n\t * ]);\n\t * console.log(assets['images/background.png']); // Access by URL\n\t *\n\t * // Load with progress tracking\n\t * const textures = await Assets.load(['sprite1.png', 'sprite2.png'],\n\t *     (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`)\n\t * );\n\t *\n\t * // Load with format preference\n\t * const characterTexture = await Assets.load({\n\t *     alias: 'character',\n\t *     src: 'character.{webp,png}' // Will choose best format\n\t * });\n\t *\n\t * // Load with custom options\n\t * const spriteTexture = await Assets.load({\n\t *     alias: 'sprite',\n\t *     src: 'sprite.png',\n\t *     data: {\n\t *         scaleMode: SCALE_MODES.NEAREST,\n\t *         mipmap: MIPMAP_MODES.ON\n\t *     }\n\t * });\n\t *\n\t * // Load with a specific loader, can be useful if your asset does not have an extension\n\t * const image = await Assets.load({\n\t *    alias: 'imageWithoutExtension',\n\t *    src: 'images/imageWithoutExtension',\n\t *    parser: 'texture' // Use the JSON loader\n\t * });\n\t * ```\n\t * @remarks\n\t * - Assets are cached automatically to prevent duplicate loading\n\t * - URLs are resolved to the best format for the current browser\n\t * - Asset types are detected automatically based on file extension\n\t * - Progress callback receives values from 0.0 to 1.0\n\t * - You can define with loader to use for an asset by specifying the `parser` property, which is useful for assets that do not have a file extension.\n\t * @throws {Error} If the asset cannot be loaded or parsed\n\t * @see {@link Assets.add} For registering assets with aliases\n\t * @see {@link Assets.backgroundLoad} For loading assets in the background\n\t * @see {@link Assets.unload} For releasing loaded assets\n\t */\n\tload<T = any>(urls: string | UnresolvedAsset, onProgress?: ProgressCallback | LoadOptions): Promise<T>;\n\tload<T = any>(urls: string[] | UnresolvedAsset[], onProgress?: ProgressCallback | LoadOptions): Promise<Record<string, T>>;\n\t/**\n\t * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing\n\t * assets into logical groups, such as game levels or UI screens.\n\t * @param bundleId - Unique identifier for the bundle\n\t * @param assets - Assets to include in the bundle\n\t * @example\n\t * ```ts\n\t * // Add a bundle using array format\n\t * Assets.addBundle('animals', [\n\t *     { alias: 'bunny', src: 'bunny.png' },\n\t *     { alias: 'chicken', src: 'chicken.png' },\n\t *     { alias: 'thumper', src: 'thumper.png' },\n\t * ]);\n\t *\n\t * // Add a bundle using object format\n\t * Assets.addBundle('animals', {\n\t *     bunny: 'bunny.png',\n\t *     chicken: 'chicken.png',\n\t *     thumper: 'thumper.png',\n\t * });\n\t *\n\t * // Add a bundle with advanced options\n\t * Assets.addBundle('ui', [\n\t *     {\n\t *         alias: 'button',\n\t *         src: 'button.{webp,png}',\n\t *         data: { scaleMode: 'nearest' }\n\t *     },\n\t *     {\n\t *         alias: ['logo', 'brand'],  // Multiple aliases\n\t *         src: 'logo.svg',\n\t *         data: { resolution: 2 }\n\t *     }\n\t * ]);\n\t *\n\t * // Load the bundle\n\t * await Assets.loadBundle('animals');\n\t *\n\t * // Use the loaded assets\n\t * const bunny = Sprite.from('bunny');\n\t * const chicken = Sprite.from('chicken');\n\t * ```\n\t * @remarks\n\t * - Bundle IDs must be unique\n\t * - Assets in bundles are not loaded until `loadBundle` is called\n\t * - Bundles can be background loaded using `backgroundLoadBundle`\n\t * - Assets in bundles can be loaded individually using their aliases\n\t * @see {@link Assets.loadBundle} For loading bundles\n\t * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n\t * @see {@link Assets.unloadBundle} For unloading bundles\n\t * @see {@link AssetsManifest} For manifest format details\n\t */\n\taddBundle(bundleId: string, assets: AssetsBundle[\"assets\"]): void;\n\t/**\n\t * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets\n\t * that can be loaded together.\n\t * @param bundleIds - Single bundle ID or array of bundle IDs to load\n\t * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n\t * @returns Promise that resolves with the loaded bundle assets\n\t * @example\n\t * ```ts\n\t * // Define bundles in your manifest\n\t * const manifest = {\n\t *     bundles: [\n\t *         {\n\t *             name: 'load-screen',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'background',\n\t *                     src: 'sunset.png',\n\t *                 },\n\t *                 {\n\t *                     alias: 'bar',\n\t *                     src: 'load-bar.{png,webp}', // use an array of individual assets\n\t *                 },\n\t *             ],\n\t *         },\n\t *         {\n\t *             name: 'game-screen',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'character',\n\t *                     src: 'robot.png',\n\t *                 },\n\t *                 {\n\t *                     alias: 'enemy',\n\t *                     src: 'bad-guy.png',\n\t *                 },\n\t *             ],\n\t *         },\n\t *     ]\n\t * };\n\t *\n\t * // Initialize with manifest\n\t * await Assets.init({ manifest });\n\t *\n\t * // Or add bundles programmatically\n\t * Assets.addBundle('load-screen', [...]);\n\t * Assets.loadBundle('load-screen');\n\t *\n\t * // Load a single bundle\n\t * await Assets.loadBundle('load-screen');\n\t * const bg = Sprite.from('background'); // Uses alias from bundle\n\t *\n\t * // Load multiple bundles\n\t * await Assets.loadBundle([\n\t *     'load-screen',\n\t *     'game-screen'\n\t * ]);\n\t *\n\t * // Load with progress tracking\n\t * await Assets.loadBundle('game-screen', (progress) => {\n\t *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n\t * });\n\t * ```\n\t * @remarks\n\t * - Bundle assets are cached automatically\n\t * - Bundles can be pre-loaded using `backgroundLoadBundle`\n\t * - Assets in bundles can be accessed by their aliases\n\t * - Progress callback receives values from 0.0 to 1.0\n\t * @throws {Error} If the bundle ID doesn't exist in the manifest\n\t * @see {@link Assets.addBundle} For adding bundles programmatically\n\t * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n\t * @see {@link Assets.unloadBundle} For unloading bundles\n\t * @see {@link AssetsManifest} For manifest format details\n\t */\n\tloadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>;\n\t/**\n\t * Initiates background loading of assets. This allows assets to be loaded passively while other operations\n\t * continue, making them instantly available when needed later.\n\t *\n\t * Background loading is useful for:\n\t * - Preloading game levels while in a menu\n\t * - Loading non-critical assets during gameplay\n\t * - Reducing visible loading screens\n\t * @param urls - Single URL/alias or array of URLs/aliases to load in the background\n\t * @example\n\t * ```ts\n\t * // Basic background loading\n\t * Assets.backgroundLoad('images/level2-assets.png');\n\t *\n\t * // Background load multiple assets\n\t * Assets.backgroundLoad([\n\t *     'images/sprite1.png',\n\t *     'images/sprite2.png',\n\t *     'images/background.png'\n\t * ]);\n\t *\n\t * // Later, when you need the assets\n\t * const textures = await Assets.load([\n\t *     'images/sprite1.png',\n\t *     'images/sprite2.png'\n\t * ]); // Resolves immediately if background loading completed\n\t * ```\n\t * @remarks\n\t * - Background loading happens one asset at a time to avoid blocking the main thread\n\t * - Loading can be interrupted safely by calling `Assets.load()`\n\t * - Assets are cached as they complete loading\n\t * - No progress tracking is available for background loading\n\t */\n\tbackgroundLoad(urls: ArrayOr<string>): Promise<void>;\n\t/**\n\t * Initiates background loading of asset bundles. Similar to backgroundLoad but works with\n\t * predefined bundles of assets.\n\t *\n\t * Perfect for:\n\t * - Preloading level bundles during gameplay\n\t * - Loading UI assets during splash screens\n\t * - Preparing assets for upcoming game states\n\t * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background\n\t * @example\n\t * ```ts\n\t * // Define bundles in your manifest\n\t * await Assets.init({\n\t *     manifest: {\n\t *         bundles: [\n\t *             {\n\t *               name: 'home',\n\t *               assets: [\n\t *                 {\n\t *                     alias: 'background',\n\t *                     src: 'images/home-bg.png',\n\t *                 },\n\t *                 {\n\t *                     alias: 'logo',\n\t *                     src: 'images/logo.png',\n\t *                 }\n\t *              ]\n\t *            },\n\t *            {\n\t *             name: 'level-1',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'background',\n\t *                     src: 'images/level1/bg.png',\n\t *                 },\n\t *                 {\n\t *                     alias: 'sprites',\n\t *                     src: 'images/level1/sprites.json'\n\t *                 }\n\t *             ]\n\t *         }]\n\t *     }\n\t * });\n\t *\n\t * // Load the home screen assets right away\n\t * await Assets.loadBundle('home');\n\t * showHomeScreen();\n\t *\n\t * // Start background loading while showing home screen\n\t * Assets.backgroundLoadBundle('level-1');\n\t *\n\t * // When player starts level, load completes faster\n\t * await Assets.loadBundle('level-1');\n\t * hideHomeScreen();\n\t * startLevel();\n\t * ```\n\t * @remarks\n\t * - Bundle assets are loaded one at a time\n\t * - Loading can be interrupted safely by calling `Assets.loadBundle()`\n\t * - Assets are cached as they complete loading\n\t * - Requires bundles to be registered via manifest or `addBundle`\n\t * @see {@link Assets.addBundle} For adding bundles programmatically\n\t * @see {@link Assets.loadBundle} For immediate bundle loading\n\t * @see {@link AssetsManifest} For manifest format details\n\t */\n\tbackgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>;\n\t/**\n\t * Only intended for development purposes.\n\t * This will wipe the resolver and caches.\n\t * You will need to reinitialize the Asset\n\t * @internal\n\t */\n\treset(): void;\n\t/**\n\t * Instantly gets an asset already loaded from the cache. Returns undefined if the asset hasn't been loaded yet.\n\t * @param keys - The key or keys for the assets to retrieve\n\t * @returns The cached asset(s) or undefined if not loaded\n\t * @example\n\t * ```ts\n\t * // Get a single cached asset\n\t * const texture = Assets.get('hero');\n\t * if (texture) {\n\t *     const sprite = new Sprite(texture);\n\t * }\n\t *\n\t * // Get multiple cached assets\n\t * const textures = Assets.get([\n\t *     'hero',\n\t *     'background',\n\t *     'enemy'\n\t * ]);\n\t *\n\t * // Safe pattern with loading fallback\n\t * let texture = Assets.get('hero');\n\t * if (!texture) {\n\t *     texture = await Assets.load('hero');\n\t * }\n\t *\n\t * // Working with bundles\n\t * await Assets.loadBundle('game-ui');\n\t * const uiAssets = Assets.get([\n\t *     'button',\n\t *     'panel',\n\t *     'icons'\n\t * ]);\n\t * ```\n\t * @remarks\n\t * - Returns undefined if asset isn't loaded\n\t * - No automatic loading - use `Assets.load()` for that\n\t * - Cached assets are shared instances\n\t * - Faster than `load()` for already cached assets\n\t *\n\t * > [!TIP]\n\t * > When in doubt, use `Assets.load()` instead. It will return cached\n\t * > assets instantly if they're already loaded.\n\t * @see {@link Assets.load} For loading assets that aren't cached\n\t * @see {@link Assets.cache} For direct cache access\n\t */\n\tget<T = any>(keys: string): T;\n\tget<T = any>(keys: string[]): Record<string, T>;\n\t/**\n\t * helper function to map resolved assets back to loaded assets\n\t * @param resolveResults - the resolve results from the resolver\n\t * @param progressOrLoadOptions - the progress callback or load options\n\t */\n\tprivate _mapLoadToResolve;\n\t/**\n\t * Unloads assets and releases them from memory. This method ensures proper cleanup of\n\t * loaded assets when they're no longer needed.\n\t * @param urls - Single URL/alias or array of URLs/aliases to unload\n\t * @example\n\t * ```ts\n\t * // Unload a single asset\n\t * await Assets.unload('images/sprite.png');\n\t *\n\t * // Unload using an alias\n\t * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias\n\t *\n\t * // Unload multiple assets\n\t * await Assets.unload([\n\t *     'images/background.png',\n\t *     'images/character.png',\n\t *     'hero'\n\t * ]);\n\t *\n\t * // Unload and handle creation of new instances\n\t * await Assets.unload('hero');\n\t * const newHero = await Assets.load('hero'); // Will load fresh from source\n\t * ```\n\t * @remarks\n\t * > [!WARNING]\n\t * > Make sure assets aren't being used before unloading:\n\t * > - Remove sprites using the texture\n\t * > - Clear any references to the asset\n\t * > - Textures will be destroyed and can't be used after unloading\n\t * @throws {Error} If the asset is not found in cache\n\t */\n\tunload(urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]): Promise<void>;\n\t/**\n\t * Unloads all assets in a bundle. Use this to free memory when a bundle's assets\n\t * are no longer needed, such as when switching game levels.\n\t * @param bundleIds - Single bundle ID or array of bundle IDs to unload\n\t * @example\n\t * ```ts\n\t * // Define and load a bundle\n\t * Assets.addBundle('level-1', {\n\t *     background: 'level1/bg.png',\n\t *     sprites: 'level1/sprites.json',\n\t *     music: 'level1/music.mp3'\n\t * });\n\t *\n\t * // Load the bundle\n\t * const level1 = await Assets.loadBundle('level-1');\n\t *\n\t * // Use the assets\n\t * const background = Sprite.from(level1.background);\n\t *\n\t * // When done with the level, unload everything\n\t * await Assets.unloadBundle('level-1');\n\t * // background sprite is now invalid!\n\t *\n\t * // Unload multiple bundles\n\t * await Assets.unloadBundle([\n\t *     'level-1',\n\t *     'level-2',\n\t *     'ui-elements'\n\t * ]);\n\t * ```\n\t * @remarks\n\t * > [!WARNING]\n\t * > - All assets in the bundle will be destroyed\n\t * > - Bundle needs to be reloaded to use assets again\n\t * > - Make sure no sprites or other objects are using the assets\n\t * @throws {Error} If the bundle is not found\n\t * @see {@link Assets.addBundle} For adding bundles\n\t * @see {@link Assets.loadBundle} For loading bundles\n\t */\n\tunloadBundle(bundleIds: ArrayOr<string>): Promise<void>;\n\tprivate _unloadFromResolved;\n\t/**\n\t * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n\t * the users preferred formats order.\n\t * @param options - the options to use when detecting formats\n\t * @param options.preferredFormats - the preferred formats to use\n\t * @param options.skipDetections - if we should skip the detections altogether\n\t * @param options.detections - the detections to use\n\t * @returns - the detected formats\n\t */\n\tprivate _detectFormats;\n\t/**\n\t * All the detection parsers currently added to the Assets class.\n\t * @advanced\n\t */\n\tget detections(): FormatDetectionParser[];\n\t/**\n\t * Sets global preferences for asset loading behavior. This method configures how assets\n\t * are loaded and processed across all parsers.\n\t * @param preferences - Asset loading preferences\n\t * @example\n\t * ```ts\n\t * // Basic preferences\n\t * Assets.setPreferences({\n\t *     crossOrigin: 'anonymous',\n\t *     parseAsGraphicsContext: false\n\t * });\n\t * ```\n\t * @remarks\n\t * Preferences are applied to all compatible parsers and affect future asset loading.\n\t * Common preferences include:\n\t * - `crossOrigin`: CORS setting for loaded assets\n\t * - `preferWorkers`: Whether to use web workers for loading textures\n\t * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.\n\t * @see {@link AssetsPreferences} For all available preferences\n\t */\n\tsetPreferences(preferences: Partial<AssetsPreferences>): void;\n}\n/**\n * The global Assets class is a singleton that manages loading, caching, and unloading of all resources\n * in your PixiJS application.\n *\n * Key responsibilities:\n * - **URL Resolution**: Maps URLs/keys to browser-compatible resources\n * - **Resource Loading**: Handles loading and transformation of assets\n * - **Asset Caching**: Manages a global cache to prevent duplicate loads\n * - **Memory Management**: Provides unloading capabilities to free memory\n *\n * Advanced Features:\n * - **Asset Bundles**: Group and manage related assets together\n * - **Background Loading**: Load assets before they're needed over time\n * - **Format Detection**: Automatically select optimal asset formats\n *\n * Supported Asset Types:\n * | Type                | Extensions                                                       | Loaders                                                               |\n * | ------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |\n * | Textures            | `.png`, `.jpg`, `.gif`, `.webp`, `.avif`, `.svg`                 | {@link loadTextures}, {@link loadSvg}                                 |\n * | Video Textures      | `.mp4`, `.m4v`, `.webm`, `.ogg`, `.ogv`, `.h264`, `.avi`, `.mov` | {@link loadVideoTextures}                                             |\n * | Sprite Sheets       | `.json`                                                          | {@link spritesheetAsset}                                              |\n * | Bitmap Fonts        | `.fnt`, `.xml`, `.txt`                                           | {@link loadBitmapFont}                                                |\n * | Web Fonts           | `.ttf`, `.otf`, `.woff`, `.woff2`                                | {@link loadWebFont}                                                   |\n * | JSON                | `.json`                                                          | {@link loadJson}                                                      |\n * | Text                | `.txt`                                                           | {@link loadTxt}                                                       |\n * | Compressed Textures | `.basis`, `.dds`, `.ktx`, `.ktx2`                                | {@link loadBasis}, {@link loadDDS}, {@link loadKTX}, {@link loadKTX2} |\n * > [!NOTE] Some loaders allow for custom configuration, please refer to the specific loader documentation for details.\n * @example\n * ```typescript\n * import { Assets } from 'pixi.js';\n *\n * // Initialize with options (optional). You can call Assets.load directly without init.\n * await Assets.init({\n *     // Base path for all asset URLs\n *     basePath: 'https://my-cdn.com/assets/',\n *     // Manifest object that defines all assets\n *     manifest: {\n *        bundles: [{ name: 'gameAssets', assets: [] }, ...],\n *     }, *\n *     // Preferred texture settings\n *     texturePreference: {\n *         resolution: window.devicePixelRatio,\n *         format: ['avif', 'webp', 'png']\n *     }\n * });\n *\n * // Basic loading\n * const texture = await Assets.load('images/sprite.png');\n *\n * // Load multiple assets\n * const assets = await Assets.load([\n *     'images/bg.png',\n *     'images/character.png',\n *     'fonts/game.fnt'\n * ]);\n *\n * // Using aliases + multiple formats\n * await Assets.load({ alias: 'hero', src: 'images/hero.{webp,png}' });\n * const sprite = Sprite.from('hero'); // Uses the best available format\n *\n * // background loading\n * Assets.backgroundLoad(['images/level1.json', 'images/level2.json']); // Loads in the background one at a time\n *\n * // Load a bundle of assets from the manifest\n * const levelAssets = await Assets.loadBundle('gameAssets');\n * // Background loading of a bundle. This will load assets in the background one at a time.\n * // Can be interrupted at any time by calling Assets.loadBundle('gameAssets') again.\n * Assets.backgroundLoadBundle('resultsAssets');\n *\n * // Memory management\n * await Assets.unload('hero');\n * await Assets.unloadBundle('levelOne');\n * ```\n * @remarks\n * - Assets are cached automatically and only loaded once\n * - Background loading helps eliminate loading screens\n * - Format detection ensures optimal asset delivery\n * - Bundle management simplifies resource organization\n *\n * > [!IMPORTANT]\n * > When unloading assets, ensure they aren't being used elsewhere\n * > in your application to prevent missing texture references.\n * @see {@link AssetInitOptions} For initialization options\n * @see {@link AssetsPreferences} For advanced preferences\n * @see {@link BackgroundLoader} For background loading capabilities\n * @see {@link AssetsManifest} For manifest-based asset management\n * @see {@link Loader} For the underlying loading system\n * @see {@link Cache} For the caching system\n * @see {@link Resolver} For URL resolution details\n * @category assets\n * @class\n * @standard\n */\nexport const Assets: AssetsClass;\n/**\n * A promise and parser pair\n * @category assets\n * @advanced\n */\nexport interface PromiseAndParser {\n\t/** the promise that is loading the asset */\n\tpromise: Promise<any>;\n\t/** the parser that is loading the asset */\n\tparser: LoaderParser;\n}\n/**\n * Options for loading assets with the Loader\n * @example\n * ```ts\n * await Assets.load(['file1.png', 'file2.png'], {\n *   onProgress: (progress) => console.log(`Progress: ${progress * 100}%`),\n *   onError: (error, url) => console.error(`Error loading ${url}: ${error.message}`),\n *   strategy: 'retry', // 'throw' | 'skip' | 'retry'\n *   retryCount: 5, // Number of retry attempts if strategy is 'retry'\n *   retryDelay: 500, // Delay in ms between retries\n * });\n * ```\n * @category assets\n * @standard\n */\nexport interface LoadOptions {\n\t/**\n\t * Callback for progress updates during loading\n\t * @param progress - A number between 0 and 1 indicating the load progress\n\t * @example\n\t * ```ts\n\t * const options: LoadOptions = {\n\t *   onProgress: (progress) => {\n\t *     console.log(`Loading progress: ${progress * 100}%`);\n\t *   },\n\t * };\n\t * await Assets.load('image.png', options);\n\t * ```\n\t */\n\tonProgress?: (progress: number) => void;\n\t/**\n\t * Callback for handling errors during loading\n\t * @param error - The error that occurred\n\t * @param url - The URL of the asset that failed to load\n\t * @example\n\t * ```ts\n\t * const options: LoadOptions = {\n\t *   onError: (error, url) => {\n\t *     console.error(`Failed to load ${url}: ${error.message}`);\n\t *   },\n\t * };\n\t * await Assets.load('missing-file.png', options);\n\t * ```\n\t */\n\tonError?: (error: Error, url: string | ResolvedAsset) => void;\n\t/**\n\t * Strategy to handle load failures\n\t * - 'throw': Immediately throw an error and stop loading (default)\n\t * - 'skip': Skip the failed asset and continue loading others\n\t * - 'retry': Retry loading the asset a specified number of times\n\t * @default 'throw'\n\t * @example\n\t * ```ts\n\t * const options: LoadOptions = {\n\t *   strategy: 'skip',\n\t * };\n\t * await Assets.load('sometimes-fails.png', options);\n\t * ```\n\t */\n\tstrategy?: \"throw\" | \"skip\" | \"retry\";\n\t/**\n\t * Number of retry attempts if strategy is 'retry'\n\t * @default 3\n\t * @example\n\t * ```ts\n\t * const options: LoadOptions = {\n\t *   strategy: 'retry',\n\t *   retryCount: 5, // Retry up to 5 times\n\t * };\n\t * await Assets.load('unstable-asset.png', options);\n\t * ```\n\t */\n\tretryCount?: number;\n\t/**\n\t * Delay in milliseconds between retry attempts\n\t * @default 250\n\t * @example\n\t * ```ts\n\t * const options: LoadOptions = {\n\t *   strategy: 'retry',\n\t *   retryDelay: 1000, // Wait 1 second between retries\n\t * };\n\t * await Assets.load('sometimes-fails.png', options);\n\t * ```\n\t */\n\tretryDelay?: number;\n}\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Loader {\n\t/**\n\t * Default options for loading assets\n\t * @example\n\t * ```ts\n\t * // Change default load options globally\n\t * Loader.defaultOptions = {\n\t *   strategy: 'skip', // Change default strategy to 'skip'\n\t *   retryCount: 5,   // Change default retry count to 5\n\t *   retryDelay: 500, // Change default retry delay to 500ms\n\t * };\n\t * ```\n\t */\n\tstatic defaultOptions: LoadOptions;\n\t/**\n\t * Options for loading assets with the loader.\n\t * These options will be used as defaults for all load calls made with this loader instance.\n\t * They can be overridden by passing options directly to the load method.\n\t * @example\n\t * ```ts\n\t * // Create a loader with custom default options\n\t * const loader = new Loader();\n\t * loader.loadOptions = {\n\t *   strategy: 'skip', // Default strategy to 'skip'\n\t *   retryCount: 5,   // Default retry count to 5\n\t *   retryDelay: 500, // Default retry delay to 500ms\n\t * };\n\t *\n\t * // This load call will use the loader's default options\n\t * await loader.load('image1.png');\n\t */\n\tloadOptions: LoadOptions;\n\tprivate readonly _parsers;\n\tprivate _parserHash;\n\tprivate _parsersValidated;\n\t/**\n\t * All loader parsers registered\n\t * @type {assets.LoaderParser[]}\n\t */\n\tparsers: LoaderParser<any, any, Record<string, any>>[];\n\t/** Cache loading promises that ae currently active */\n\tpromiseCache: Record<string, PromiseAndParser>;\n\t/** function used for testing */\n\treset(): void;\n\t/**\n\t * Used internally to generate a promise for the asset to be loaded.\n\t * @param url - The URL to be loaded\n\t * @param data - any custom additional information relevant to the asset being loaded\n\t * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n\t */\n\tprivate _getLoadPromiseAndParser;\n\t/**\n\t * Loads one or more assets using the parsers added to the Loader.\n\t * @example\n\t * // Single asset:\n\t * const asset = await Loader.load('cool.png');\n\t * console.log(asset);\n\t *\n\t * // Multiple assets:\n\t * const assets = await Loader.load(['cool.png', 'cooler.png']);\n\t * console.log(assets);\n\t * @param assetsToLoadIn - urls that you want to load, or a single one!\n\t * @param onProgress - For multiple asset loading only, an optional function that is called\n\t * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n\t * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n\t * to detect when assets are complete and available, instead use the Promise returned by this function.\n\t */\n\tload<T = any>(assetsToLoadIn: string | ResolvedAsset, onProgress?: ProgressCallback | LoadOptions): Promise<T>;\n\tload<T = any>(assetsToLoadIn: string[] | ResolvedAsset[], onProgress?: ProgressCallback | LoadOptions): Promise<Record<string, T>>;\n\t/**\n\t * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n\t * The parser that created the asset, will be the one that unloads it.\n\t * @example\n\t * // Single asset:\n\t * const asset = await Loader.load('cool.png');\n\t *\n\t * await Loader.unload('cool.png');\n\t *\n\t * console.log(asset.destroyed); // true\n\t * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n\t */\n\tunload(assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[]): Promise<void>;\n\t/** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n\tprivate _validateParsers;\n\tprivate _loadAssetWithRetry;\n}\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @category assets\n * @advanced\n */\nexport enum LoaderParserPriority {\n\t/** Generic parsers: txt, json, webfonts */\n\tLow = 0,\n\t/** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n\tNormal = 1,\n\t/** Specific texture types: svg, png, ktx, dds, basis */\n\tHigh = 2\n}\n/**\n * A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately\n * @category assets\n * @advanced\n */\nexport interface LoaderParserAdvanced<ASSET = any, PARSED_ASSET = ASSET, UNLOAD_ASSET = ASSET, META_DATA = any, CONFIG = Record<string, any>> {\n\t/** Should be ExtensionType.LoaderParser */\n\textension?: ExtensionMetadata;\n\t/** A config to adjust the parser */\n\tconfig?: CONFIG;\n\t/**\n\t * @deprecated Use `id` instead.\n\t */\n\tname?: string;\n\t/** The name of the parser (this can be used when specifying parser in a ResolvedAsset) */\n\tid: string;\n\t/**\n\t * Each URL to load will be tested here,\n\t * if the test is passed the assets are loaded using the load function below.\n\t * Good place to test for things like file extensions!\n\t * @param url - The URL to test\n\t * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n\t * @param loader - The loader instance\n\t */\n\ttest?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\t/**\n\t * This is the promise that loads the URL provided\n\t * resolves with a loaded asset if returned by the parser.\n\t * @param url - The URL to load\n\t * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n\t * @param loader - The loader instance\n\t */\n\tload?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\t/**\n\t * This function is used to test if the parse function should be run on the asset\n\t * If this returns true then parse is called with the asset\n\t * @param asset - The loaded asset data\n\t * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n\t * @param loader - The loader instance\n\t */\n\ttestParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\t/**\n\t * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n\t * @param asset - The loaded asset data\n\t * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n\t * @param loader - The loader instance\n\t */\n\tparse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\t/**\n\t * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n\t * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n\t * @param asset - The asset to unload/destroy\n\t * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n\t * @param loader - The loader instance\n\t */\n\tunload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @category assets\n * @advanced\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>> extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {\n}\n/**\n * The layout data for a bitmap text.\n * This contains the width, height, scale, offsetY and lines of text.\n * Each line contains its width, character positions, characters, space width and spaces index.\n * @category text\n * @internal\n */\nexport interface BitmapTextLayoutData {\n\twidth: number;\n\theight: number;\n\tscale: number;\n\toffsetY: number;\n\tlines: {\n\t\twidth: number;\n\t\tcharPositions: number[];\n\t\tchars: string[];\n\t\tspaceWidth: number;\n\t\tspacesIndex: number[];\n\t}[];\n}\n/**\n * @param chars\n * @param style\n * @param font\n * @param trimEnd\n * @internal\n */\nexport function getBitmapTextLayout(chars: string[], style: TextStyle, font: AbstractBitmapFont<any>, trimEnd: boolean): BitmapTextLayoutData;\n/**\n * The options for installing a new BitmapFont. Once installed, the font will be available\n * for use in BitmapText objects through the fontFamily property of TextStyle.\n * @example\n * ```ts\n * import { BitmapFont, BitmapText } from 'pixi.js';\n *\n * // Basic font installation\n * BitmapFont.install({\n *     name: 'BasicFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: '#ffffff'\n *     }\n * });\n *\n * // Advanced font installation\n * BitmapFont.install({\n *     name: 'AdvancedFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ff0000',\n *         stroke: { color: '#000000', width: 2 }\n *     },\n *     // Include specific character ranges\n *     chars: [\n *         ['a', 'z'],           // lowercase letters\n *         ['A', 'Z'],           // uppercase letters\n *         ['0', '9'],           // numbers\n *         '!@#$%^&*()_+-=[]{}' // symbols\n *     ],\n *     resolution: 2,            // High-DPI support\n *     padding: 4,              // Glyph padding\n *     skipKerning: false,      // Enable kerning\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n *\n * // Using the installed font\n * const text = new BitmapText({\n *     text: 'Hello World',\n *     style: {\n *         fontFamily: 'AdvancedFont',\n *         fontSize: 48\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontInstallOptions {\n\t/**\n\t * The name of the font. This will be used as the fontFamily in text styles to access this font.\n\t * Must be unique across all installed bitmap fonts.\n\t * @example\n\t * ```ts\n\t * BitmapFont.install({\n\t *     name: 'MyCustomFont',\n\t *     style: { fontFamily: 'Arial' }\n\t * });\n\t * ```\n\t */\n\tname?: string;\n\t/**\n\t * Characters included in the font set. You can specify individual characters or ranges.\n\t * Don't forget to include spaces ' ' in your character set!\n\t * @default BitmapFont.ALPHANUMERIC\n\t * @example\n\t * ```ts\n\t * // Different ways to specify characters\n\t * BitmapFont.install({\n\t *     name: 'RangeFont',\n\t *     chars: [\n\t *         ['a', 'z'],              // Range of characters\n\t *         '0123456789',            // String of characters\n\t *         [['0', '9'], ['A', 'Z']] // Multiple ranges\n\t *     ]\n\t * });\n\t * ```\n\t */\n\tchars?: string | (string | string[])[];\n\t/**\n\t * Render resolution for glyphs. Higher values create sharper text at the cost of memory.\n\t * Useful for supporting high-DPI displays.\n\t * @default 1\n\t * @example\n\t * ```ts\n\t * BitmapFont.install({\n\t *     name: 'HiDPIFont',\n\t *     resolution: window.devicePixelRatio || 2\n\t * });\n\t * ```\n\t */\n\tresolution?: number;\n\t/**\n\t * Padding between glyphs on texture atlas. Balances visual quality with texture space.\n\t * - Lower values: More compact, but may have visual artifacts\n\t * - Higher values: Better quality, but uses more texture space\n\t * @default 4\n\t * @example\n\t * ```ts\n\t * BitmapFont.install({\n\t *     name: 'PaddedFont',\n\t *     padding: 8 // More padding for better quality\n\t * });\n\t * ```\n\t */\n\tpadding?: number;\n\t/**\n\t * Skip generation of kerning information for the BitmapFont.\n\t * - true: Faster generation, but text may have inconsistent spacing\n\t * - false: Better text appearance, but slower generation\n\t * @default false\n\t * @example\n\t * ```ts\n\t * BitmapFont.install({\n\t *     name: 'FastFont',\n\t *     skipKerning: true // Prioritize performance\n\t * });\n\t * ```\n\t */\n\tskipKerning?: boolean;\n\t/**\n\t * Style options to render the BitmapFont with.\n\t * Supports all TextStyle properties including fill, stroke, and shadow effects.\n\t * @example\n\t * ```ts\n\t * BitmapFont.install({\n\t *     name: 'StyledFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 32,\n\t *         fill: 'white',\n\t *         stroke: { color: '#000000', width: 2 },\n\t *         dropShadow: {\n\t *             color: '#000000',\n\t *             blur: 2,\n\t *             distance: 3\n\t *         }\n\t *     }\n\t * });\n\t * ```\n\t */\n\tstyle?: TextStyle | TextStyleOptions;\n\t/**\n\t * Optional texture style to use when creating the font textures.\n\t * Controls how the font textures are rendered and filtered.\n\t * @example\n\t * ```ts\n\t * BitmapFont.install({\n\t *     name: 'CrispFont',\n\t *     textureStyle: {\n\t *         scaleMode: 'nearest',\n\t *     }\n\t * });\n\t * ```\n\t */\n\ttextureStyle?: TextureStyle | TextureStyleOptions;\n\t/**\n\t * Whether to allow overriding the fill color with a tint at runtime.\n\t *\n\t * When enabled, the font can be dynamically tinted using the `tint` property of BitmapText,\n\t * allowing a single font to display multiple colors without creating separate font textures.\n\t * This is memory efficient but requires the font to be rendered with white fill color.\n\t *\n\t * When disabled, the fill color is permanently baked into the font texture. This allows\n\t * any fill color but prevents runtime tinting - each color variation requires a separate font.\n\t * @default false (automatically determined based on style)\n\t *\n\t * **Requirements for tinting:**\n\t * - Fill color must be white (`0xFFFFFF` or `'#ffffff'`)\n\t * - No stroke effects\n\t * - No drop shadows (or only black shadows)\n\t * - No gradient or pattern fills\n\t *\n\t * **Performance considerations:**\n\t * -  Enabled: One font texture, multiple colors via tinting (memory efficient)\n\t * -  Disabled: Separate font texture per color (higher memory usage)\n\t * @example\n\t * ```ts\n\t * // Correct usage - white fill with tinting enabled\n\t * BitmapFont.install({\n\t *     name: 'TintableFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: 0xFFFFFF  // Must be white for tinting\n\t *     },\n\t *     dynamicFill: true\n\t * });\n\t *\n\t * // Use the font with different colors via tinting\n\t * const redText = new BitmapText({\n\t *     text: 'Red Text',\n\t *     style: { fontFamily: 'TintableFont', fill: 'red }, // Red tint\n\t * });\n\t *\n\t * const blueText = new BitmapText({\n\t *     text: 'Blue Text',\n\t *     style: { fontFamily: 'TintableFont', fill: 'blue' }, // Blue tint\n\t * });\n\t * ```\n\t * @example\n\t * ```ts\n\t * // Incorrect usage - colored fill with tinting enabled\n\t * BitmapFont.install({\n\t *     name: 'BadTintFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: 0xFF0000  //  Red fill won't tint properly\n\t *     },\n\t *     dynamicFill: true  //  Will not work as expected\n\t * });\n\t * ```\n\t * @example\n\t * ```ts\n\t * // Alternative - baked colors (no tinting)\n\t * BitmapFont.install({\n\t *     name: 'BakedColorFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: 0xFF0000,  // Any color works\n\t *         stroke: { color: 0x000000, width: 2 }  // Strokes allowed\n\t *     },\n\t *     dynamicFill: false  // Color is baked in\n\t * });\n\t * ```\n\t */\n\tdynamicFill?: boolean;\n}\ndeclare class BitmapFontManagerClass {\n\t/**\n\t * This character set includes all the letters in the alphabet (both lower- and upper- case).\n\t * @type {string[][]}\n\t * @example\n\t * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n\t */\n\treadonly ALPHA: (string | string[])[];\n\t/**\n\t * This character set includes all decimal digits (from 0 to 9).\n\t * @type {string[][]}\n\t * @example\n\t * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n\t */\n\treadonly NUMERIC: string[][];\n\t/**\n\t * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n\t * @type {string[][]}\n\t */\n\treadonly ALPHANUMERIC: (string | string[])[];\n\t/**\n\t * This character set consists of all the ASCII table.\n\t * @type {string[][]}\n\t * @see http://www.asciitable.com/\n\t */\n\treadonly ASCII: string[][];\n\t/** Default options for installing a new BitmapFont. */\n\tdefaultOptions: Omit<BitmapFontInstallOptions, \"style\">;\n\t/** Cache for measured text layouts to avoid recalculating them multiple times. */\n\treadonly measureCache: import(\"tiny-lru\").LRU<BitmapTextLayoutData>;\n\t/**\n\t * Get a font for the specified text and style.\n\t * @param text - The text to get the font for\n\t * @param style - The style to use\n\t */\n\tgetFont(text: string, style: TextStyle): BitmapFont;\n\t/**\n\t * Get the layout of a text for the specified style.\n\t * @param text - The text to get the layout for\n\t * @param style - The style to use\n\t * @param trimEnd - Whether to ignore whitespaces at the end of each line\n\t */\n\tgetLayout(text: string, style: TextStyle, trimEnd?: boolean): BitmapTextLayoutData;\n\t/**\n\t * Measure the text using the specified style.\n\t * @param text - The text to measure\n\t * @param style - The style to use\n\t * @param trimEnd - Whether to ignore whitespaces at the end of each line\n\t */\n\tmeasureText(text: string, style: TextStyle, trimEnd?: boolean): {\n\t\twidth: number;\n\t\theight: number;\n\t\tscale: number;\n\t\toffsetY: number;\n\t};\n\t/**\n\t * Generates a bitmap-font for the given style and character set\n\t * @param options - Setup options for font generation.\n\t * @returns Font generated by style options.\n\t * @example\n\t * import { BitmapFontManager, BitmapText } from 'pixi.js';\n\t *\n\t * BitmapFontManager.install('TitleFont', {\n\t *     fontFamily: 'Arial',\n\t *     fontSize: 12,\n\t *     strokeThickness: 2,\n\t *     fill: 'purple',\n\t * });\n\t *\n\t * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n\t */\n\tinstall(options: BitmapFontInstallOptions): BitmapFont;\n\t/** @deprecated since 7.0.0 */\n\tinstall(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n\t/**\n\t * Uninstalls a bitmap font from the cache.\n\t * @param {string} name - The name of the bitmap font to uninstall.\n\t */\n\tuninstall(name: string): void;\n\t/**\n\t * Determines if a style can use tinting instead of baking colors into the bitmap.\n\t * Tinting is more efficient as it allows reusing the same bitmap with different colors.\n\t * @param style - The text style to evaluate\n\t * @returns true if the style can use tinting, false if colors must be baked in\n\t * @private\n\t */\n\tprivate _canUseTintForStyle;\n}\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @category text\n * @advanced\n * @class\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nexport const BitmapFontManager: BitmapFontManagerClass;\n/**\n * Options for creating a BitmapFont. Used when loading or creating bitmap fonts from existing textures and data.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     // Font data containing character metrics and layout info\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *             // ... other characters\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         // Optional distance field info for MSDF/SDF fonts\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     // Array of textures containing the font glyphs\n *     textures: [\n *         Texture.from('font.png')\n *     ]\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontOptions {\n\t/**\n\t * The bitmap font data containing character metrics, layout information,\n\t * and font properties. This includes character positions, dimensions,\n\t * kerning data, and general font settings.\n\t */\n\tdata: BitmapFontData;\n\t/**\n\t * Array of textures containing the font glyphs. Each texture corresponds\n\t * to a page in the font data. For simple fonts this is typically just\n\t * one texture, but complex fonts may split glyphs across multiple textures.\n\t */\n\ttextures: Texture[];\n}\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * This class handles both pre-loaded bitmap fonts and dynamically generated ones.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     textures: [Texture.from('font.png')]\n * });\n *\n * // Install a font for global use\n * BitmapFont.install({\n *     name: 'MyCustomFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ffffff',\n *         stroke: { color: '#000000', width: 2 }\n *     }\n * });\n *\n * // Uninstall when no longer needed\n * BitmapFont.uninstall('MyCustomFont');\n * ```\n * @category text\n * @standard\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont> {\n\t/**\n\t * The URL from which the font was loaded, if applicable.\n\t * This is useful for tracking font sources and reloading.\n\t * @example\n\t * ```ts\n\t * console.log(font.url); // 'fonts/myFont.fnt'\n\t * ```\n\t */\n\turl?: string;\n\tconstructor(options: BitmapFontOptions, url?: string);\n\t/** Destroys the BitmapFont object. */\n\tdestroy(): void;\n\t/**\n\t * Generates and installs a bitmap font with the specified options.\n\t * The font will be cached and available for use in BitmapText objects.\n\t * @param options - Setup options for font generation\n\t * @returns Installed font instance\n\t * @example\n\t * ```ts\n\t * // Install a basic font\n\t * BitmapFont.install({\n\t *     name: 'Title',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 32,\n\t *         fill: '#ffffff'\n\t *     }\n\t * });\n\t *\n\t * // Install with advanced options\n\t * BitmapFont.install({\n\t *     name: 'Custom',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: '#00ff00',\n\t *         stroke: { color: '#000000', width: 2 }\n\t *     },\n\t *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],\n\t *     resolution: 2,\n\t *     padding: 4,\n\t *     textureStyle: {\n\t *         scaleMode: 'nearest'\n\t *     }\n\t * });\n\t * ```\n\t */\n\tstatic install(options: BitmapFontInstallOptions): void;\n\t/**\n\t * Uninstalls a bitmap font from the cache.\n\t * This frees up memory and resources associated with the font.\n\t * @param name - The name of the bitmap font to uninstall\n\t * @example\n\t * ```ts\n\t * // Remove a font when it's no longer needed\n\t * BitmapFont.uninstall('MyCustomFont');\n\t *\n\t * // Clear multiple fonts\n\t * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);\n\t * ```\n\t */\n\tstatic uninstall(name: string): void;\n}\n/**\n * simple loader plugin for loading in bitmap fonts!\n * @category assets\n * @internal\n */\nexport const bitmapFontCachePlugin: {\n\textension: {\n\t\ttype: ExtensionType.CacheParser;\n\t\tname: string;\n\t};\n\ttest: (asset: BitmapFont) => boolean;\n\tgetCacheableAssets(keys: string[], asset: BitmapFont): Record<string, BitmapFont>;\n};\n/**\n * Loader plugin for loading bitmap fonts.\n * It supports both XML and text formats, and can handle distance field fonts.\n * @category assets\n * @advanced\n */\nexport const loadBitmapFont: {\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t};\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\ttest(url: string): boolean;\n\ttestParse(data: string): Promise<boolean>;\n\tparse<T>(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>;\n\tload<T_1>(url: string, _options: ResolvedAsset): Promise<string>;\n\tunload(bitmapFont: BitmapFont, _resolvedAsset: ResolvedAsset<any>, loader: Loader): Promise<void>;\n};\n/** @internal */\nexport class BitmapTextGraphics extends Graphics implements GPUData {\n\tdestroy(): void;\n}\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"bitmapText\";\n\t};\n\tprivate _renderer;\n\tprivate readonly _managedBitmapTexts;\n\tconstructor(renderer: Renderer);\n\tvalidateRenderable(bitmapText: BitmapText): boolean;\n\taddRenderable(bitmapText: BitmapText, instructionSet: InstructionSet): void;\n\tupdateRenderable(bitmapText: BitmapText): void;\n\tprivate _updateContext;\n\tprivate _getGpuBitmapText;\n\tinitGpuText(bitmapText: BitmapText): BitmapTextGraphics;\n\tprivate _updateDistanceField;\n\tdestroy(): void;\n}\nexport interface BitmapText extends PixiMixins.BitmapText, AbstractText<TextStyle, TextStyleOptions, TextOptions, BitmapTextGraphics> {\n}\n/**\n * A BitmapText object creates text using pre-rendered bitmap fonts.\n * It supports both loaded bitmap fonts (XML/FNT) and dynamically generated ones.\n *\n * To split a line you can use '\\n' in your text string, or use the `wordWrap` and\n * `wordWrapWidth` style properties.\n *\n * Key Features:\n * - High-performance text rendering using pre-generated textures\n * - Support for both pre-loaded and dynamic bitmap fonts\n * - Compatible with MSDF/SDF fonts for crisp scaling\n * - Automatic font reuse and optimization\n *\n * Performance Benefits:\n * - Faster rendering compared to Canvas/HTML text\n * - Lower memory usage for repeated characters\n * - More efficient text changes\n * - Better batching capabilities\n *\n * Limitations:\n * - Full character set support is impractical due to the number of chars (mainly affects CJK languages)\n * - Initial font generation/loading overhead\n * - Less flexible styling compared to Canvas/HTML text\n * @example\n * ```ts\n * import { BitmapText, BitmapFont } from 'pixi.js';\n *\n * // Dynamic font generation\n * const dynamicText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Pre-installed font usage\n * BitmapFont.install({\n *    name: 'myFont',\n *    style: {\n *        fontFamily: 'Arial',\n *    }\n * });\n *\n * const preinstalledText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myFont',\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * });\n *\n * // Load and use external bitmap font, if the font supports MSDF/SDF then it will be used\n * const font = await Assets.load('fonts/myFont.fnt');\n *\n * const loadedFontText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myLoadedFont', // Name from .fnt file\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * });\n *\n * // Multiline text with word wrap\n * const wrappedText = new BitmapText({\n *     text: 'This is a long text that will wrap automatically',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *     }\n * });\n * ```\n *\n * Font Types:\n * 1. Pre-loaded Bitmap Fonts:\n *    - Load via Asset Manager (XML/FNT formats)\n *    - Support for MSDF/SDF fonts\n *    - Create using tools like https://msdf-bmfont.donmccurdy.com/\n *\n * 2. Dynamic Bitmap Fonts:\n *    - Generated at runtime from system fonts\n *    - Automatic font reuse and optimization\n *    - Smart scaling for similar font sizes\n *\n * Font Management:\n * - Automatic font generation when needed\n * - Manual pre-installation via `BitmapFont.install`\n * - Smart font reuse to optimize memory\n * - Scale existing fonts instead of generating new ones when possible\n * @category text\n * @standard\n * @see {@link BitmapFont} For font installation and management\n * @see {@link Text} For canvas-based text rendering\n * @see {@link HTMLText} For HTML/CSS-based text rendering\n */\nexport class BitmapText extends AbstractText<TextStyle, TextStyleOptions, TextOptions, BitmapTextGraphics> implements View {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/**\n\t * **Note:** Our docs parser struggles to properly understand the constructor signature.\n\t * This is the correct signature.\n\t * ```ts\n\t * new BitmapText(options?: TextOptions);\n\t * ```\n\t * @param { TextOptions } options - The options of the bitmap text.\n\t */\n\tconstructor(options?: TextOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(text?: TextString, options?: Partial<TextStyle>);\n\t/**\n\t * @param now - The current time in milliseconds.\n\t * @internal\n\t */\n\t_onTouch(now: number): void;\n\t/** @private */\n\tprotected updateBounds(): void;\n\t/**\n\t * The resolution / device pixel ratio for text rendering.\n\t * Unlike other text types, BitmapText resolution is managed by the BitmapFont.\n\t * Individual resolution changes are not supported.\n\t * @example\n\t * ```ts\n\t * //  Incorrect: Setting resolution directly (will trigger warning)\n\t * const text = new BitmapText({\n\t *     text: 'Hello',\n\t *     resolution: 2 // This will be ignored\n\t * });\n\t *\n\t * //  Correct: Set resolution when installing the font\n\t * BitmapFont.install({\n\t *     name: 'MyFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *     },\n\t *     resolution: 2 // Resolution is set here\n\t * });\n\t *\n\t * const text = new BitmapText({\n\t *     text: 'Hello',\n\t *     style: {\n\t *         fontFamily: 'MyFont' // Uses font's resolution\n\t *     }\n\t * });\n\t * ```\n\t * @default 1\n\t * @see {@link BitmapFont.install} For setting font resolution\n\t * @throws {Warning} When attempting to change resolution directly\n\t * @readonly\n\t */\n\tset resolution(value: number);\n\tget resolution(): number;\n}\n/** @internal */\nexport interface DynamicBitmapFontOptions {\n\tstyle: TextStyle;\n\tskipKerning?: boolean;\n\tresolution?: number;\n\tpadding?: number;\n\toverrideFill?: boolean;\n\toverrideSize?: boolean;\n\ttextureSize?: number;\n\tmipmap?: boolean;\n\ttextureStyle?: TextureStyle | TextureStyleOptions;\n}\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @category text\n * @internal\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont> {\n\tstatic defaultOptions: DynamicBitmapFontOptions;\n\t/**\n\t * this is a resolution modifier for the font size..\n\t * texture resolution will also be used to scale texture according to its font size also\n\t */\n\tresolution: number;\n\t/** The pages of the font. */\n\treadonly pages: {\n\t\tcanvasAndContext?: CanvasAndContext;\n\t\ttexture: Texture;\n\t}[];\n\tprivate readonly _padding;\n\tprivate readonly _measureCache;\n\tprivate _currentChars;\n\tprivate _currentX;\n\tprivate _currentY;\n\tprivate _currentMaxCharHeight;\n\tprivate _currentPageIndex;\n\tprivate readonly _style;\n\tprivate readonly _skipKerning;\n\tprivate readonly _textureSize;\n\tprivate readonly _mipmap;\n\tprivate readonly _textureStyle?;\n\t/**\n\t * @param options - The options for the dynamic bitmap font.\n\t */\n\tconstructor(options: DynamicBitmapFontOptions);\n\tensureCharacters(chars: string): void;\n\t/**\n\t * @deprecated since 8.0.0\n\t * The map of base page textures (i.e., sheets of glyphs).\n\t */\n\tget pageTextures(): DynamicBitmapFont[\"pages\"];\n\tprivate _applyKerning;\n\tprivate _nextPage;\n\tprivate _setupContext;\n\tprivate _drawGlyph;\n\tdestroy(): void;\n}\n/**\n * Types of text objects that can be split into characters, words, and lines.\n * Currently supports Text and BitmapText instances.\n * @internal\n */\nexport type SplitableTextObject = Text$1 | BitmapText;\n/**\n * Contains the output elements from a text split operation.\n * Provides access to the hierarchical structure of split text elements.\n * @example\n * ```ts\n * const splitResult = Text.split(myText);\n *\n * // Access individual characters\n * splitResult.chars.forEach(char => {\n *     char.alpha = 0;\n *     gsap.to(char, { alpha: 1, duration: 0.5 });\n * });\n *\n * // Access words (groups of characters)\n * splitResult.words.forEach(word => {\n *     word.scale.set(0);\n *     gsap.to(word.scale, { x: 1, y: 1, duration: 0.5 });\n * });\n *\n * // Access lines (groups of words)\n * splitResult.lines.forEach(line => {\n *     line.x = -200;\n *     gsap.to(line, { x: 0, duration: 0.5 });\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface TextSplitOutput<T extends SplitableTextObject> {\n\t/** Array of individual character Text objects */\n\tchars: T[];\n\t/** Array of word containers, each containing character objects */\n\twords: Container[];\n\t/** Array of line containers, each containing word containers */\n\tlines: Container[];\n}\n/**\n * Configuration options for text splitting.\n * @category text\n * @standard\n */\nexport interface AbstractSplitOptions {\n\t/** Text content to be split */\n\ttext: string;\n\t/** Text styling - accepts TextStyle instance or style object */\n\tstyle: TextStyle | Partial<TextStyleOptions>;\n\t/**\n\t * Enables automatic splitting on text/style changes\n\t * @default true\n\t */\n\tautoSplit?: boolean;\n\t/**\n\t * Transform origin for line segments. Range: [0-1]\n\t * @example\n\t * ```ts\n\t * lineAnchor: 0.5        // Center horizontally and vertically\n\t * lineAnchor: { x: 0, y: 0.5 }  // Left-center alignment\n\t *\n\t * ```\n\t * @default 0\n\t */\n\tlineAnchor?: number | PointData;\n\t/**\n\t * Transform origin for word segments. Range: [0-1]\n\t * @example\n\t * ```ts\n\t * wordAnchor: { x: 1, y: 0 }  // Top-right alignment\n\t * wordAnchor: 0.5  // Center alignment\n\t * ```\n\t * @default 0\n\t */\n\twordAnchor?: number | PointData;\n\t/**\n\t * Transform origin for character segments. Range: [0-1]\n\t * @example\n\t * ```ts\n\t * charAnchor: { x: 0.5, y: 1 }  // Bottom-center alignment\n\t * charAnchor: 0.5  // Center alignment\n\t * ```\n\t * @default 0\n\t */\n\tcharAnchor?: number | PointData;\n}\n/**\n * Configuration options for SplitText, combining container properties with text splitting settings.\n * @example Basic Usage\n * ```ts\n * const options: SplitTextOptions = {\n *   text: 'Hello World',\n *   style: { fontSize: 32, fill: 0xffffff },\n *   // Transform origins\n *   lineAnchor: 0.5,                // Center each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center each char\n * };\n * ```\n * @example Advanced Configuration\n * ```ts\n * const options: SplitTextOptions = {\n *   // Text content and style\n *   text: 'Multi\\nLine Text',\n *   style: new TextStyle({\n *     fontSize: 24,\n *     fill: 'white',\n *     strokeThickness: 2,\n *   }),\n *\n *   // Container properties\n *   x: 100,\n *   y: 100,\n *   alpha: 0.8,\n *\n *   // Splitting settings\n *   autoSplit: true,\n *\n *   // Transform origins (normalized 0-1)\n *   lineAnchor: { x: 1, y: 0 },    // Top-right\n *   wordAnchor: 0.5,               // Center\n *   charAnchor: { x: 0, y: 1 },    // Bottom-left\n * };\n * ```\n *\n * Properties:\n * - Container options from {@link ContainerOptions}\n * - Text split options from {@link AbstractSplitOptions}\n * @see {@link AbstractSplitText} For the main implementation\n * @see {@link ContainerOptions} For base container properties\n * @see {@link AbstractSplitOptions} For text splitting options\n * @category text\n * @standard\n */\nexport interface AbstractSplitTextOptions extends ContainerOptions, AbstractSplitOptions {\n}\n/**\n * @experimental\n * A container that splits text into individually manipulatable segments (lines, words, and characters)\n * for advanced text effects and animations.\n * @example Basic Usage\n * ```ts\n * const text = new SplitText({\n *   text: \"Hello World\",\n *   style: { fontSize: 24 },\n *   // Origin points for transformations (0-1 range)\n *   lineAnchor: 0.5,  // Center of each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center of each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center of each character\n *   autoSplit: true  // Auto-update segments on text/style changes\n * });\n * ```\n *\n * Features:\n * - Hierarchical text splitting (lines  words  characters)\n * - Independent transformation origins for each segment level\n * - Automatic or manual segment updates\n * - Support for both canvas text and bitmap text\n * @example Animation Example\n * ```ts\n * // Character fade-in sequence\n * text.chars.forEach((char, i) => {\n *   gsap.from(char, {\n *     alpha: 0,\n *     delay: i * 0.1\n *   });\n * });\n *\n * // Word scale animation\n * text.words.forEach((word, i) => {\n *   gsap.to(word.scale, {\n *     x: 1.2, y: 1.2,\n *     yoyo: true,\n *     repeat: -1,\n *     delay: i * 0.2\n *   });\n * });\n *\n * // Line slide-in effect\n * text.lines.forEach((line, i) => {\n *   gsap.from(line, {\n *     x: -200,\n *     delay: i * 0.3\n *   });\n * });\n * ```\n *\n * Configuration Options:\n * - `text`: The string to render and segment\n * - `style`: TextStyle instance or configuration object\n * - `autoSplit`: Automatically update segments on changes (default: true)\n * - `lineAnchor`: Transform origin for lines (default: 0)\n * - `wordAnchor`: Transform origin for words (default: 0)\n * - `charAnchor`: Transform origin for characters (default: 0)\n *\n * > [!NOTE] Anchor points are normalized (0-1):\n * > - 0,0: Top-left\n * > - 0.5,0.5: Center\n * > - 1,1: Bottom-right\n *\n * > [!WARNING] Limitations\n * > - Character spacing may differ slightly from standard text due to browser\n * >   kerning being lost when characters are separated\n * @category text\n * @standard\n */\nexport abstract class AbstractSplitText<T extends SplitableTextObject> extends Container {\n\t/**\n\t * Individual character segments of the text.\n\t * @example\n\t * ```ts\n\t * // Fade in characters sequentially\n\t * text.chars.forEach((char, i) => {\n\t *   char.alpha = 0;\n\t *   gsap.to(char, {\n\t *     alpha: 1,\n\t *     delay: i * 0.1\n\t *   });\n\t * });\n\t * ```\n\t */\n\tchars: T[];\n\t/**\n\t * Word segments of the text, each containing one or more characters.\n\t * @example\n\t * ```ts\n\t * // Scale words on hover\n\t * text.words.forEach(word => {\n\t *   word.interactive = true;\n\t *   word.on('pointerover', () => {\n\t *     gsap.to(word.scale, { x: 1.2, y: 1.2 });\n\t *   });\n\t *   word.on('pointerout', () => {\n\t *     gsap.to(word.scale, { x: 1, y: 1 });\n\t *   });\n\t * });\n\t * ```\n\t */\n\twords: Container[];\n\t/**\n\t * Line segments of the text, each containing one or more words.\n\t * @example\n\t * ```ts\n\t * // Stagger line entrance animations\n\t * text.lines.forEach((line, i) => {\n\t *   line.x = -200;\n\t *   gsap.to(line, {\n\t *     x: 0,\n\t *     duration: 0.5,\n\t *     delay: i * 0.2,\n\t *     ease: 'back.out'\n\t *   });\n\t * });\n\t * ```\n\t */\n\tlines: Container[];\n\tprotected _originalText: string;\n\tprotected _lineAnchor: number | PointData;\n\tprotected _wordAnchor: number | PointData;\n\tprotected _charAnchor: number | PointData;\n\tprotected _autoSplit: boolean;\n\tprotected _style: TextStyle;\n\tprotected _dirty: boolean;\n\tprotected _canReuseChars: boolean;\n\tconstructor(config: AbstractSplitTextOptions);\n\tprotected abstract splitFn(): TextSplitOutput<T>;\n\t/**\n\t * Splits the text into lines, words, and characters.\n\t * Call this manually when autoSplit is false.\n\t * @example Manual Splitting\n\t * ```ts\n\t * const text = new SplitText({\n\t *   text: 'Manual Update',\n\t *   autoSplit: false\n\t * });\n\t *\n\t * text.text = 'New Content';\n\t * text.style = { fontSize: 32 };\n\t * text.split(); // Apply changes\n\t * ```\n\t */\n\tsplit(): void;\n\tget text(): string;\n\t/**\n\t * Gets or sets the text content.\n\t * Setting new text triggers splitting if autoSplit is true.\n\t * > [!NOTE] Setting this frequently can have a performance impact, especially with large texts and canvas text.\n\t * @example Dynamic Text Updates\n\t * ```ts\n\t * const text = new SplitText({\n\t *   text: 'Original',\n\t *   autoSplit: true\n\t * });\n\t *\n\t * // Auto-splits on change\n\t * text.text = 'Updated Content';\n\t *\n\t * // Manual update\n\t * text.autoSplit = false;\n\t * text.text = 'Manual Update';\n\t * text.split();\n\t * ```\n\t */\n\tset text(value: string);\n\tprivate _setOrigin;\n\t/**\n\t * Gets or sets the transform anchor for line segments.\n\t * The anchor point determines the center of rotation and scaling for each line.\n\t * @example Setting Line Anchors\n\t * ```ts\n\t * // Center rotation/scaling\n\t * text.lineAnchor = 0.5;\n\t *\n\t * // Rotate/scale from top-right corner\n\t * text.lineAnchor = { x: 1, y: 0 };\n\t *\n\t * // Custom anchor point\n\t * text.lineAnchor = {\n\t *   x: 0.2, // 20% from left\n\t *   y: 0.8  // 80% from top\n\t * };\n\t * ```\n\t */\n\tget lineAnchor(): number | PointData;\n\tset lineAnchor(value: number | PointData);\n\t/**\n\t * Gets or sets the transform anchor for word segments.\n\t * The anchor point determines the center of rotation and scaling for each word.\n\t * @example\n\t * ```ts\n\t * // Center each word\n\t * text.wordAnchor = 0.5;\n\t *\n\t * // Scale from bottom-left\n\t * text.wordAnchor = { x: 0, y: 1 };\n\t *\n\t * // Rotate around custom point\n\t * text.wordAnchor = {\n\t *   x: 0.75,  // 75% from left\n\t *   y: 0.5    // Middle vertically\n\t * };\n\t * ```\n\t */\n\tget wordAnchor(): number | PointData;\n\tset wordAnchor(value: number | PointData);\n\t/**\n\t * Gets or sets the transform anchor for character segments.\n\t * The anchor point determines the center of rotation and scaling for each character.\n\t * @example Setting Character Anchors\n\t * ```ts\n\t * // Center each character\n\t * text.charAnchor = 0.5;\n\t *\n\t * // Rotate from top-center\n\t * text.charAnchor = { x: 0.5, y: 0 };\n\t *\n\t * // Scale from bottom-right\n\t * text.charAnchor = { x: 1, y: 1 };\n\t * ```\n\t * @example Animation with Anchors\n\t * ```ts\n\t * // Rotate characters around their centers\n\t * text.charAnchor = 0.5;\n\t * text.chars.forEach((char, i) => {\n\t *   gsap.to(char, {\n\t *     rotation: Math.PI * 2,\n\t *     duration: 1,\n\t *     delay: i * 0.1,\n\t *     repeat: -1\n\t *   });\n\t * });\n\t * ```\n\t */\n\tget charAnchor(): number | PointData;\n\tset charAnchor(value: number | PointData);\n\tget style(): TextStyle;\n\t/**\n\t * The style configuration for the text.\n\t * Can be a TextStyle instance or a configuration object.\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *     text: 'Styled Text',\n\t *     style: {\n\t *         fontSize: 24,\n\t *         fill: 0xff1010, // Red color\n\t *         fontFamily: 'Arial',\n\t *         align: 'center', // Center alignment\n\t *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n\t *         dropShadow: {\n\t *             color: '#000000', // Black shadow\n\t *             blur: 4, // Shadow blur\n\t *             distance: 6 // Shadow distance\n\t *         }\n\t *     }\n\t * });\n\t * // Update style dynamically\n\t * text.style = {\n\t *     fontSize: 30, // Change font size\n\t *     fill: 0x00ff00, // Change color to green\n\t *     align: 'right', // Change alignment to right\n\t *     stroke: { color: '#000000', width: 2 }, // Add black stroke\n\t * }\n\t */\n\tset style(style: TextStyle | Partial<TextStyle> | TextStyleOptions);\n\tprotected onTextUpdate(): void;\n\t/**\n\t * Destroys the SplitText instance and all its resources.\n\t * Cleans up all segment arrays, event listeners, and optionally the text style.\n\t * @param options - Destroy configuration options\n\t * @example\n\t * ```ts\n\t * // Clean up everything\n\t * text.destroy({ children: true, texture: true, style: true });\n\t *\n\t * // Remove from parent but keep style\n\t * text.destroy({ children: true, style: false });\n\t * ```\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * Configuration options for Text splitting.\n * @category text\n * @standard\n * @interface\n */\nexport interface SplitOptions extends AbstractSplitOptions {\n}\n/**\n * Configuration options for SplitText, combining container properties with text splitting settings.\n * @example Basic Usage\n * ```ts\n * const options: SplitTextOptions = {\n *   text: 'Hello World',\n *   style: { fontSize: 32, fill: 0xffffff },\n *   // Transform origins\n *   lineAnchor: 0.5,                // Center each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center each char\n * };\n * ```\n * @example Advanced Configuration\n * ```ts\n * const options: SplitTextOptions = {\n *   // Text content and style\n *   text: 'Multi\\nLine Text',\n *   style: new TextStyle({\n *     fontSize: 24,\n *     fill: 'white',\n *     strokeThickness: 2,\n *   }),\n *\n *   // Container properties\n *   x: 100,\n *   y: 100,\n *   alpha: 0.8,\n *\n *   // Splitting settings\n *   autoSplit: true,\n *\n *   // Transform origins (normalized 0-1)\n *   lineAnchor: { x: 1, y: 0 },    // Top-right\n *   wordAnchor: 0.5,               // Center\n *   charAnchor: { x: 0, y: 1 },    // Bottom-left\n * };\n * ```\n *\n * Properties:\n * - Container options from {@link ContainerOptions}\n * - Text splitting options from {@link SplitOptions}\n * - Additional PixiJS-specific options from PixiMixins.SplitText\n * @see {@link SplitText} For the main implementation\n * @see {@link ContainerOptions} For base container properties\n * @see {@link SplitOptions} For text splitting options\n * @category text\n * @standard\n */\nexport interface SplitTextOptions extends PixiMixins.SplitText, ContainerOptions, SplitOptions {\n}\n/**\n * @experimental\n * A container that splits text into individually manipulatable segments (lines, words, and characters)\n * for advanced text effects and animations.\n * Converts each segment into a separate Text object.\n * @example Basic Usage\n * ```ts\n * const text = new SplitText({\n *   text: \"Hello World\",\n *   style: { fontSize: 24 },\n *   // Origin points for transformations (0-1 range)\n *   lineAnchor: 0.5,  // Center of each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center of each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center of each character\n *   autoSplit: true  // Auto-update segments on text/style changes\n * });\n * ```\n *\n * Features:\n * - Hierarchical text segmentation (lines  words  characters)\n * - Independent transformation origins for each segment level\n * - Automatic or manual segment updates\n * @example Animation Example\n * ```ts\n * // Character fade-in sequence\n * text.chars.forEach((char, i) => {\n *   gsap.from(char, {\n *     alpha: 0,\n *     delay: i * 0.1\n *   });\n * });\n *\n * // Word scale animation\n * text.words.forEach((word, i) => {\n *   gsap.to(word.scale, {\n *     x: 1.2, y: 1.2,\n *     yoyo: true,\n *     repeat: -1,\n *     delay: i * 0.2\n *   });\n * });\n *\n * // Line slide-in effect\n * text.lines.forEach((line, i) => {\n *   gsap.from(line, {\n *     x: -200,\n *     delay: i * 0.3\n *   });\n * });\n * ```\n *\n * Configuration Options:\n * - `text`: The string to render and segment\n * - `style`: TextStyle instance or configuration object\n * - `autoSplit`: Automatically update segments on changes (default: true)\n * - `lineAnchor`: Transform origin for lines (default: 0)\n * - `wordAnchor`: Transform origin for words (default: 0)\n * - `charAnchor`: Transform origin for characters (default: 0)\n *\n * > [!NOTE] Anchor points are normalized (0-1):\n * > - 0,0: Top-left\n * > - 0.5,0.5: Center\n * > - 1,1: Bottom-right\n *\n * > [!WARNING] Limitations\n * > - Character spacing may differ slightly from standard text due to browser\n * >   kerning being lost when characters are separated\n * @category text\n * @standard\n */\nexport class SplitText extends AbstractSplitText<Text$1> {\n\t/**\n\t * Default configuration options for SplitText instances.\n\t * @example\n\t * ```ts\n\t * // Override defaults globally\n\t * SplitText.defaultOptions = {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,  // Center alignment\n\t *   wordAnchor: { x: 0, y: 0.5 },  // Left-center\n\t *   charAnchor: { x: 0.5, y: 1 }   // Bottom-center\n\t * };\n\t * ```\n\t */\n\tstatic defaultOptions: Partial<SplitTextOptions>;\n\tconstructor(config: SplitTextOptions);\n\t/**\n\t * Creates a SplitText instance from an existing text object.\n\t * Useful for converting standard Text or Text objects into segmented versions.\n\t * @param text - The source text object to convert\n\t * @param options - Additional splitting options\n\t * @returns A new SplitText instance\n\t * @example\n\t * ```ts\n\t * const text = new Text({\n\t *   text: 'Bitmap Text',\n\t *   style: { fontFamily: 'Arial' }\n\t * });\n\t *\n\t * const segmented = SplitText.from(text);\n\t *\n\t * // with additional options\n\t * const segmentedWithOptions = SplitText.from(text, {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,\n\t *   wordAnchor: { x: 0, y: 0.5 },\n\t * })\n\t * ```\n\t */\n\tstatic from(text: Text$1, options?: Omit<SplitTextOptions, \"text\" | \"style\">): SplitText;\n\tprotected splitFn(): TextSplitOutput<Text$1>;\n}\n/**\n * Splits a Text object into segments based on the text's layout and style,\n * and adds these segments as individual Text objects to a specified container.\n *\n * This function handles word wrapping, alignment, and letter spacing,\n * ensuring that each segment is rendered correctly according to the original text's style.\n * @param options - Configuration options for the text split operation.\n * @returns An array of Text objects representing the split segments.\n * @internal\n */\nexport function bitmapTextSplit(options: Pick<SplitOptions, \"text\" | \"style\"> & {\n\tchars: BitmapText[];\n}): TextSplitOutput<BitmapText>;\n/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\nexport function resolveCharacters(chars: string | (string | string[])[]): string[];\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite {\n\ttexturePromise: Promise<Texture>;\n\tgeneratingTexture: boolean;\n\tcurrentKey: string;\n\t/** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n\tdestroy(): void;\n}\n/**\n * Constructor options used for `HTMLText` instances. Extends the base text options\n * with HTML-specific features and texture styling capabilities.\n * @example\n * ```ts\n * // Basic HTML text\n * const basicText = new HTMLText({\n *     text: '<b>Bold</b> and <i>Italic</i> text',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010\n *     }\n * });\n *\n * // Rich HTML text with styling\n * const richText = new HTMLText({\n *     text: '<custom>Custom Tag</custom>',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: 0x4a4a4a,\n *         align: 'center',\n *         tagStyles: {\n *             custom: {\n *                 fontSize: 32,\n *                 fill: '#00ff00',\n *                 fontStyle: 'italic'\n *             }\n *         }\n *     }\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface HTMLTextOptions extends TextOptions<HTMLTextStyle, HTMLTextStyleOptions>, PixiMixins.HTMLTextOptions {\n\t/**\n\t * Optional texture style to use for the text texture. This allows fine control over\n\t * how the text is rendered to a texture before being displayed.\n\t *\n\t * The texture style can affect:\n\t * - Scale mode (nearest/linear)\n\t * - Resolution\n\t * - Format (rgb/rgba)\n\t * - Alpha handling\n\t * @example\n\t * ```ts\n\t * const text = new HTMLText({\n\t *     text: 'Crisp Text',\n\t *     textureStyle: {\n\t *         scaleMode: 'nearest', // Pixel-perfect scaling\n\t *     }\n\t * });\n\t * ```\n\t * @advanced\n\t */\n\ttextureStyle?: TextureStyle | TextureStyleOptions;\n}\nexport interface HTMLText extends PixiMixins.HTMLText, AbstractText<HTMLTextStyle, HTMLTextStyleOptions, HTMLTextOptions, BatchableHTMLText> {\n}\n/**\n * A HTMLText object creates text using HTML/CSS rendering with SVG foreignObject.\n * This allows for rich text formatting using standard HTML tags and CSS styling.\n *\n * Key features:\n * - HTML tag support (&lt;strong&gt;, &lt;em&gt;, etc.)\n * - CSS styling and custom style overrides\n * - Emoji and special character support\n * - Line breaking and word wrapping\n * - SVG-based rendering\n * @example\n * ```ts\n * import { HTMLText } from 'pixi.js';\n *\n * // Basic HTML text with tags\n * const text = new HTMLText({\n *     text: '<h1>Title</h1><p>This is a <strong>bold</strong> and <em>italic</em> text.</p>',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Rich HTML text with custom styling\n * const richText = new HTMLText({\n *     text: `\n *         <div class=\"title\">Welcome</div>\n *         <div class=\"content\">\n *             This text supports:\n *             <ul>\n *                 <li> Emojis</li>\n *                 <li> Custom CSS</li>\n *                 <li> Auto-sizing</li>\n *             </ul>\n *         </div>\n *     `,\n *     style: {\n *         fontSize: 24,\n *         fill: '#334455',\n *         cssOverrides: [\n *             '.title { font-size: 32px; color: red; }',\n *             '.content { line-height: 1.5; }'\n *         ],\n *         wordWrap: true,\n *         wordWrapWidth: 300,\n *     }\n * });\n *\n * // Text with custom texture settings\n * const crispText = new HTMLText({\n *     text: '<div style=\"padding: 10px\">High Quality Text</div>',\n *     style: {\n *         fontSize: 24,\n *         fill: '#4a4a4a',\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n * ```\n *\n * Platform Considerations:\n * - Rendering may vary slightly between browsers\n * - Requires browser support for foreignObject\n * - Performance similar to Canvas text\n * - Memory usage comparable to Canvas text\n * @category text\n * @standard\n * @see {@link HTMLTextStyle} For detailed style options\n * @see {@link Text} For canvas-based text rendering\n * @see {@link BitmapText} For high-performance static text\n */\nexport class HTMLText extends AbstractText<HTMLTextStyle, HTMLTextStyleOptions, HTMLTextOptions, BatchableHTMLText> implements View {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\t/**\n\t * Optional texture style to use for the text.\n\t * > [!NOTE] HTMLText is not updated when this property is updated,\n\t * > you must update the text manually by calling `text.onViewUpdate()`\n\t * @advanced\n\t */\n\ttextureStyle?: TextureStyle;\n\t/**\n\t * @param {HTMLTextOptions} options - The options of the html text.\n\t */\n\tconstructor(options?: HTMLTextOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(text?: TextString, options?: Partial<HTMLTextStyle>);\n\t/** @private */\n\tprotected updateBounds(): void;\n\tget text(): string;\n\t/**\n\t * The text content to display. Use '\\n' for line breaks.\n\t * Accepts strings, numbers, or objects with toString() method.\n\t * @example\n\t * ```ts\n\t * const text = new HTMLText({\n\t *     text: 'Hello Pixi!',\n\t * });\n\t * const multilineText = new HTMLText({\n\t *     text: 'Line 1\\nLine 2\\nLine 3',\n\t * });\n\t * const numberText = new HTMLText({\n\t *     text: 12345, // Will be converted to '12345'\n\t * });\n\t * const objectText = new HTMLText({\n\t *     text: { toString: () => 'Object Text' }, // Custom toString\n\t * });\n\t *\n\t * // Update text dynamically\n\t * text.text = 'Updated Text'; // Re-renders with new text\n\t * text.text = 67890; // Updates to '67890'\n\t * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method\n\t * // Clear text\n\t * text.text = ''; // Clears the text\n\t * ```\n\t * @default ''\n\t */\n\tset text(text: TextString);\n\t/**\n\t * Sanitise text - replace `<br>` with `<br/>`, `&nbsp;` with `&#160;`\n\t * @param text\n\t * @see https://www.sitepoint.com/community/t/xhtml-1-0-transitional-xml-parsing-error-entity-nbsp-not-defined/3392/3\n\t */\n\tprivate _sanitiseText;\n\tprivate _removeInvalidHtmlTags;\n}\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"htmlText\";\n\t};\n\tprivate _renderer;\n\tprivate readonly _managedTexts;\n\tconstructor(renderer: Renderer);\n\tprotected resolutionChange(): void;\n\tvalidateRenderable(htmlText: HTMLText): boolean;\n\taddRenderable(htmlText: HTMLText, instructionSet: InstructionSet): void;\n\tupdateRenderable(htmlText: HTMLText): void;\n\tprivate _updateGpuText;\n\tprivate _getGpuText;\n\tinitGpuText(htmlText: HTMLText): BatchableHTMLText;\n\tprotected onTextUnload(text: HTMLText): void;\n\tdestroy(): void;\n}\n/** @internal */\nexport class HTMLTextRenderData {\n\tsvgRoot: SVGSVGElement;\n\tforeignObject: SVGForeignObjectElement;\n\tdomElement: HTMLElement;\n\tstyleElement: HTMLElement;\n\timage: ImageLike;\n\tcanvasAndContext?: CanvasAndContext;\n\tconstructor();\n\tdestroy(): void;\n}\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"htmlText\";\n\t};\n\t/**\n\t * WebGPU has a cors issue when uploading an image that is an SVGImage\n\t * To get around this we need to create a canvas draw the image to it and upload that instead.\n\t * Bit of a shame.. but no other work around just yet!\n\t */\n\tprivate readonly _createCanvas;\n\tprivate readonly _renderer;\n\tprivate readonly _activeTextures;\n\tconstructor(renderer: Renderer);\n\t/**\n\t * @param options\n\t * @deprecated Use getTexturePromise instead\n\t */\n\tgetTexture(options: HTMLTextOptions): Promise<Texture>;\n\t/**\n\t * Increases the reference count for a texture.\n\t * @param text - The HTMLText instance associated with the texture.\n\t */\n\tgetManagedTexture(text: HTMLText): Promise<Texture>;\n\t/**\n\t * Gets the current reference count for a texture associated with a text key.\n\t * @param textKey - The unique key identifying the text style configuration\n\t * @returns The number of Text instances currently using this texture\n\t */\n\tgetReferenceCount(textKey: string): number;\n\tprivate _increaseReferenceCount;\n\t/**\n\t * Decreases the reference count for a texture.\n\t * If the count reaches zero, the texture is cleaned up.\n\t * @param textKey - The key associated with the HTMLText instance.\n\t */\n\tdecreaseReferenceCount(textKey: string): void;\n\t/**\n\t * Returns a promise that resolves to a texture for the given HTMLText options.\n\t * @param options - The options for the HTMLText.\n\t * @returns A promise that resolves to a Texture.\n\t */\n\tgetTexturePromise(options: HTMLTextOptions): Promise<Texture>;\n\tprivate _buildTexturePromise;\n\treturnTexturePromise(texturePromise: Promise<Texture>): void;\n\tprivate _cleanUp;\n\tdestroy(): void;\n}\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[];\n/** @internal */\nexport const FontStylePromiseCache: Map<string, Promise<string>>;\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @returns - The css string\n * @internal\n */\nexport function getFontCss(fontFamilies: string[]): Promise<string>;\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(text: string, style: HTMLTextStyle, resolution: number, fontCSS: string, htmlTextData: HTMLTextRenderData): string;\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: ImageLike, resolution: number): CanvasAndContext;\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport function loadFontAsBase64(url: string): Promise<string>;\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions {\n\t/**\n\t * The font family to use in the CSS\n\t * @example\n\t * 'Arial' or ['Arial', 'Helvetica']\n\t */\n\tfontFamily: string | string[];\n\t/**\n\t * The font weight to use in the CSS\n\t * @example\n\t * 'normal', 'bold', '100', '200', etc.\n\t */\n\tfontWeight: string;\n\t/**\n\t * The font style to use in the CSS\n\t * @example\n\t * 'normal', 'italic', 'oblique'\n\t */\n\tfontStyle: string;\n}\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>;\n/**\n * This function loads an SVG image into an IImage element.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: ImageLike, url: string, delay: boolean): Promise<void>;\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(text: string, style: HTMLTextStyle, fontStyleCSS?: string, htmlTextRenderData?: HTMLTextRenderData): Size;\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n * @internal\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string;\n/**\n * Configuration options for BitmapText splitting.\n * @category text\n * @standard\n * @interface\n */\nexport interface SplitBitmapOptions extends AbstractSplitOptions {\n}\n/**\n * Configuration options for SplitBitmapText, combining container properties with text splitting settings.\n * @example Basic Usage\n * ```ts\n * const options: SplitBitmapTextOptions = {\n *   text: 'Hello World',\n *   style: { fontSize: 32, fill: 0xffffff },\n *   // Transform origins\n *   lineAnchor: 0.5,                // Center each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center each char\n * };\n * ```\n * @example Advanced Configuration\n * ```ts\n * const options: SplitBitmapTextOptions = {\n *   // Text content and style\n *   text: 'Multi\\nLine Text',\n *   style: new TextStyle({\n *     fontSize: 24,\n *     fill: 'white',\n *     strokeThickness: 2,\n *   }),\n *\n *   // Container properties\n *   x: 100,\n *   y: 100,\n *   alpha: 0.8,\n *\n *   // Splitting settings\n *   autoSplit: true,\n *\n *   // Transform origins (normalized 0-1)\n *   lineAnchor: { x: 1, y: 0 },    // Top-right\n *   wordAnchor: 0.5,               // Center\n *   charAnchor: { x: 0, y: 1 },    // Bottom-left\n * };\n * ```\n *\n * Properties:\n * - Container options from {@link ContainerOptions}\n * - Text splitting options from {@link SplitBitmapOptions}\n * - Additional PixiJS-specific options from PixiMixins.SplitBitmapText\n * @see {@link SplitBitmapText} For the main implementation\n * @see {@link ContainerOptions} For base container properties\n * @see {@link SplitBitmapOptions} For text splitting options\n * @category text\n * @standard\n */\nexport interface SplitBitmapTextOptions extends PixiMixins.SplitBitmapText, ContainerOptions, SplitBitmapOptions {\n}\n/**\n * @experimental\n * A container that splits text into individually manipulatable segments (lines, words, and characters)\n * for advanced text effects and animations.\n * Converts each segment into a separate BitmapText object.\n * @example Basic Usage\n * ```ts\n * const text = new SplitBitmapText({\n *   text: \"Hello World\",\n *   style: { fontSize: 24 },\n *   // Origin points for transformations (0-1 range)\n *   lineAnchor: 0.5,  // Center of each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center of each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center of each character\n *   autoSplit: true  // Auto-update segments on text/style changes\n * });\n * ```\n *\n * Features:\n * - Hierarchical text segmentation (lines  words  characters)\n * - Independent transformation origins for each segment level\n * - Automatic or manual segment updates\n * @example Animation Example\n * ```ts\n * // Character fade-in sequence\n * text.chars.forEach((char, i) => {\n *   gsap.from(char, {\n *     alpha: 0,\n *     delay: i * 0.1\n *   });\n * });\n *\n * // Word scale animation\n * text.words.forEach((word, i) => {\n *   gsap.to(word.scale, {\n *     x: 1.2, y: 1.2,\n *     yoyo: true,\n *     repeat: -1,\n *     delay: i * 0.2\n *   });\n * });\n *\n * // Line slide-in effect\n * text.lines.forEach((line, i) => {\n *   gsap.from(line, {\n *     x: -200,\n *     delay: i * 0.3\n *   });\n * });\n * ```\n *\n * Configuration Options:\n * - `text`: The string to render and segment\n * - `style`: TextStyle instance or configuration object\n * - `autoSplit`: Automatically update segments on changes (default: true)\n * - `lineAnchor`: Transform origin for lines (default: 0)\n * - `wordAnchor`: Transform origin for words (default: 0)\n * - `charAnchor`: Transform origin for characters (default: 0)\n *\n * > [!NOTE] Anchor points are normalized (0-1):\n * > - 0,0: Top-left\n * > - 0.5,0.5: Center\n * > - 1,1: Bottom-right\n *\n * > [!WARNING] Limitations\n * > - Character spacing may differ slightly from standard text due to browser\n * >   kerning being lost when characters are separated\n * @category text\n * @standard\n */\nexport class SplitBitmapText extends AbstractSplitText<BitmapText> {\n\t/**\n\t * Default configuration options for SplitBitmapText instances.\n\t * @example\n\t * ```ts\n\t * // Override defaults globally\n\t * SplitBitmapText.defaultOptions = {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,  // Center alignment\n\t *   wordAnchor: { x: 0, y: 0.5 },  // Left-center\n\t *   charAnchor: { x: 0.5, y: 1 }   // Bottom-center\n\t * };\n\t * ```\n\t */\n\tstatic defaultOptions: Partial<SplitBitmapTextOptions>;\n\tconstructor(config: SplitBitmapTextOptions);\n\t/**\n\t * Creates a SplitBitmapText instance from an existing text object.\n\t * Useful for converting standard Text or BitmapText objects into segmented versions.\n\t * @param text - The source text object to convert\n\t * @param options - Additional splitting options\n\t * @returns A new SplitBitmapText instance\n\t * @example\n\t * ```ts\n\t * const bitmapText = new BitmapText({\n\t *   text: 'Bitmap Text',\n\t *   style: { fontFamily: 'Arial' }\n\t * });\n\t *\n\t * const segmented = SplitBitmapText.from(bitmapText);\n\t *\n\t * // with additional options\n\t * const segmentedWithOptions = SplitBitmapText.from(bitmapText, {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,\n\t *   wordAnchor: { x: 0, y: 0.5 },\n\t * })\n\t * ```\n\t */\n\tstatic from(text: BitmapText, options?: Omit<SplitBitmapTextOptions, \"text\" | \"style\">): SplitBitmapText;\n\tprotected splitFn(): TextSplitOutput<BitmapText>;\n}\ndeclare class CanvasTextGeneratorClass {\n\t/**\n\t * Creates a canvas with the specified text rendered to it.\n\t *\n\t * Generates a canvas of appropriate size, renders the text with the provided style,\n\t * and returns both the canvas/context and a Rectangle representing the text bounds.\n\t *\n\t * When trim is enabled in the style, the frame will represent the bounds of the\n\t * non-transparent pixels, which can be smaller than the full canvas.\n\t * @param options - The options for generating the text canvas\n\t * @param options.text - The text to render\n\t * @param options.style - The style to apply to the text\n\t * @param options.resolution - The resolution of the canvas (defaults to 1)\n\t * @param options.padding\n\t * @returns An object containing the canvas/context and the frame (bounds) of the text\n\t */\n\tgetCanvasAndContext(options: {\n\t\ttext: string;\n\t\tstyle: TextStyle;\n\t\tresolution?: number;\n\t\tpadding?: number;\n\t}): {\n\t\tcanvasAndContext: CanvasAndContext;\n\t\tframe: Rectangle;\n\t};\n\t/**\n\t * Returns a canvas and context to the pool.\n\t *\n\t * This should be called when you're done with the canvas to allow reuse\n\t * and prevent memory leaks.\n\t * @param canvasAndContext - The canvas and context to return to the pool\n\t */\n\treturnCanvasAndContext(canvasAndContext: CanvasAndContext): void;\n\t/**\n\t * Renders text to its canvas, and updates its texture.\n\t * @param text - The text to render\n\t * @param style - The style of the text\n\t * @param padding - The padding of the text\n\t * @param resolution - The resolution of the text\n\t * @param canvasAndContext - The canvas and context to render the text to\n\t */\n\tprivate _renderTextToCanvas;\n\t/**\n\t * Render the text with letter-spacing.\n\t *\n\t * This method handles rendering text with the correct letter spacing, using either:\n\t * 1. Native letter spacing if supported by the browser\n\t * 2. Manual letter spacing calculation if not natively supported\n\t *\n\t * For manual letter spacing, it calculates the position of each character\n\t * based on its width and the desired spacing.\n\t * @param text - The text to draw\n\t * @param style - The text style to apply\n\t * @param canvasAndContext - The canvas and context to draw to\n\t * @param x - Horizontal position to draw the text\n\t * @param y - Vertical position to draw the text\n\t * @param isStroke - Whether to render the stroke (true) or fill (false)\n\t * @private\n\t */\n\tprivate _drawLetterSpacing;\n}\n/** @internal */\nexport const CanvasTextGenerator: CanvasTextGeneratorClass;\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text$1> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"text\";\n\t};\n\tprivate _renderer;\n\tprivate readonly _managedTexts;\n\tconstructor(renderer: Renderer);\n\tprotected resolutionChange(): void;\n\tvalidateRenderable(text: Text$1): boolean;\n\taddRenderable(text: Text$1, instructionSet: InstructionSet): void;\n\tupdateRenderable(text: Text$1): void;\n\tprivate _updateGpuText;\n\tprivate _getGpuText;\n\tinitGpuText(text: Text$1): BatchableText;\n\tprotected onTextUnload(text: Text$1): void;\n\tdestroy(): void;\n}\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem,\n\t\t\tExtensionType.CanvasSystem\n\t\t];\n\t\treadonly name: \"canvasText\";\n\t};\n\tprivate readonly _renderer;\n\tprivate readonly _activeTextures;\n\tconstructor(_renderer: Renderer);\n\t/** @deprecated since 8.0.0 */\n\tgetTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n\t/**\n\t * This is a function that will create a texture from a text string, style and resolution.\n\t * Useful if you want to make a texture of your text and use if for various other pixi things!\n\t * @param options - The options of the text that will be used to generate the texture.\n\t * @param options.text - the text to render\n\t * @param options.style - the style of the text\n\t * @param options.resolution - the resolution of the texture\n\t * @returns the newly created texture\n\t */\n\tgetTexture(options: CanvasTextOptions): Texture;\n\t/**\n\t * Returns a texture that was created wit the above `getTexture` function.\n\t * Handy if you are done with a texture and want to return it to the pool.\n\t * @param texture - The texture to be returned.\n\t */\n\treturnTexture(texture: Texture): void;\n\t/**\n\t * Renders text to its canvas, and updates its texture.\n\t * @deprecated since 8.10.0\n\t */\n\trenderTextToCanvas(): void;\n\t/**\n\t * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n\t * @param text - The Text object that needs a texture\n\t * @returns A Texture instance that represents the rendered text\n\t * @remarks\n\t * This method performs the following:\n\t * 1. Sets the appropriate resolution based on auto-resolution settings\n\t * 2. Checks if a texture already exists for the text's style\n\t * 3. Creates a new texture if needed or returns an existing one\n\t * 4. Manages reference counting for texture reuse\n\t */\n\tgetManagedTexture(text: Text$1): Texture<TextureSource<any>>;\n\t/**\n\t * Decreases the reference count for a texture associated with a text key.\n\t * When the reference count reaches zero, the texture is returned to the pool.\n\t * @param textKey - The unique key identifying the text style configuration\n\t * @remarks\n\t * This method is crucial for memory management, ensuring textures are properly\n\t * cleaned up when they are no longer needed by any Text instances.\n\t */\n\tdecreaseReferenceCount(textKey: string): void;\n\t/**\n\t * Gets the current reference count for a texture associated with a text key.\n\t * @param textKey - The unique key identifying the text style configuration\n\t * @returns The number of Text instances currently using this texture\n\t */\n\tgetReferenceCount(textKey: string): number;\n\tprivate _increaseReferenceCount;\n\t/**\n\t * Applies the specified filters to the given texture.\n\t *\n\t * This method takes a texture and a list of filters, applies the filters to the texture,\n\t * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n\t * texture is set to 'premultiplied-alpha'.\n\t * @param {Texture} texture - The texture to which the filters will be applied.\n\t * @param {Filter[]} filters - The filters to apply to the texture.\n\t * @returns {Texture} The resulting texture after all filters have been applied.\n\t */\n\tprivate _applyFilters;\n\tdestroy(): void;\n}\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n * @internal\n */\nexport function fontStringFromTextStyle(style: TextStyle): string;\n/**\n * Converts a PixiJS fill style into a Canvas-compatible fill style.\n * Handles solid colors, textures, patterns, and gradients.\n * @param fillStyle - The PixiJS fill style to convert\n * @param context - The canvas rendering context\n * @param textMetrics - Metrics about the text being rendered\n * @param padding - Padding to add to the text metrics (used to ensure that the gradient accommodates the stroke width)\n * @returns Canvas-compatible fill style (string, CanvasGradient, or CanvasPattern)\n * @internal\n */\nexport function getCanvasFillStyle(fillStyle: ConvertedFillStyle, context: ICanvasRenderingContext2D, textMetrics?: CanvasTextMetrics, padding?: number): string | CanvasGradient | CanvasPattern;\n/** @internal */\nexport class SdfShader extends Shader {\n\tconstructor(maxTextures: number);\n}\n/** @internal */\nexport const localUniformMSDFBit: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t\tend: string;\n\t};\n\tfragment: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/** @internal */\nexport const localUniformMSDFBitGl: {\n\tname: string;\n\tvertex: {\n\t\theader: string;\n\t\tmain: string;\n\t\tend: string;\n\t};\n\tfragment: {\n\t\theader: string;\n\t\tmain: string;\n\t};\n};\n/** @internal */\nexport const mSDFBit: {\n\tname: string;\n\tfragment: {\n\t\theader: string;\n\t};\n};\n/** @internal */\nexport const mSDFBitGl: {\n\tname: string;\n\tfragment: {\n\t\theader: string;\n\t};\n};\n/**\n * Splits a Text object into segments based on the text's layout and style,\n * and adds these segments as individual Text objects to a specified container.\n *\n * This function handles word wrapping, alignment, and letter spacing,\n * ensuring that each segment is rendered correctly according to the original text's style.\n * It uses the CanvasTextMetrics to measure text dimensions and segment the text into lines.\n * @param options - Configuration options for the text split operation.\n * @returns An array of Text objects representing the split segments.\n * @internal\n */\nexport function canvasTextSplit(options: Pick<SplitOptions, \"text\" | \"style\"> & {\n\tchars: Text$1[];\n}): TextSplitOutput<Text$1>;\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n * @internal\n * @deprecated 8.12.0\n */\nexport function generateTextStyleKey(style: TextStyle): string;\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(image: ImageLike | HTMLCanvasElement | ICanvas, width: number, height: number, resolution: number): Texture;\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>): void;\n/**\n * Shader that uses a texture.\n * This is the default shader used by `Mesh` when no shader is provided.\n * It is a simple shader that samples a texture and applies it to the geometry.\n * @category scene\n * @advanced\n */\nexport interface TextureShader extends Shader {\n\t/** The texture that the shader uses. */\n\ttexture: Texture;\n}\n/**\n * Constructor options used for `Mesh` instances. Extends {@link MeshViewOptions}\n * ```js\n * const mesh = new Mesh({\n *    texture: Texture.from('assets/image.png'),\n *    geometry: new PlaneGeometry(),\n *    shader: Shader.from(VERTEX, FRAGMENT),\n * });\n * ```\n * @see {@link Mesh}\n * @see {@link MeshViewOptions}\n * @category scene\n */\n/**\n * Options for creating a Mesh instance.\n * @category scene\n * @advanced\n * @noInheritDoc\n */\nexport interface MeshOptions<GEOMETRY extends Geometry = MeshGeometry, SHADER extends Shader = TextureShader> extends PixiMixins.MeshOptions, ContainerOptions {\n\t/**\n\t * Includes vertex positions, face indices, colors, UVs, and\n\t * custom attributes within buffers, reducing the cost of passing all\n\t * this data to the GPU. Can be shared between multiple Mesh objects.\n\t */\n\tgeometry: GEOMETRY;\n\t/**\n\t * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n\t * Can be shared between multiple Mesh objects.\n\t */\n\tshader?: SHADER | null;\n\t/** The state of WebGL required to render the mesh. */\n\tstate?: State;\n\t/** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n\ttexture?: Texture;\n\t/** Whether or not to round the x/y position. */\n\troundPixels?: boolean;\n}\nexport interface Mesh extends PixiMixins.Mesh, ViewContainer<MeshGpuData> {\n}\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL/WebGPU visuals you can think of.\n * This class assumes a certain level of WebGL/WebGPU knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL/WebGPU can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @category scene\n * @advanced\n */\nexport class Mesh<GEOMETRY extends Geometry = MeshGeometry, SHADER extends Shader = TextureShader> extends ViewContainer<MeshGpuData> implements View, Instruction {\n\t/** @internal */\n\treadonly renderPipeId: string;\n\tstate: State;\n\t/** @internal */\n\t_texture: Texture;\n\t/** @internal */\n\t_geometry: GEOMETRY;\n\t/** @internal */\n\t_shader: SHADER | null;\n\t/**\n\t * @param {MeshOptions} options - options for the mesh instance\n\t */\n\tconstructor(options: MeshOptions<GEOMETRY, SHADER>);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(geometry: GEOMETRY, shader: SHADER, state?: State, drawMode?: Topology);\n\t/** Alias for {@link Mesh#shader}. */\n\tget material(): SHADER;\n\t/**\n\t * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n\t * Can be shared between multiple Mesh objects.\n\t */\n\tset shader(value: SHADER | null);\n\tget shader(): SHADER | null;\n\t/**\n\t * Includes vertex positions, face indices, colors, UVs, and\n\t * custom attributes within buffers, reducing the cost of passing all\n\t * this data to the GPU. Can be shared between multiple Mesh objects.\n\t */\n\tset geometry(value: GEOMETRY);\n\tget geometry(): GEOMETRY;\n\t/** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n\tset texture(value: Texture);\n\tget texture(): Texture;\n\tget batched(): boolean;\n\t/**\n\t * The local bounds of the mesh.\n\t * @type {Bounds}\n\t */\n\tget bounds(): Bounds;\n\t/**\n\t * Update local bounds of the mesh.\n\t * @private\n\t */\n\tprotected updateBounds(): void;\n\t/**\n\t * Checks if the object contains the given point.\n\t * @param point - The point to check\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * mesh.destroy();\n\t * mesh.destroy(true);\n\t * mesh.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData {\n\tmeshData?: MeshData;\n\tbatchableMesh?: BatchableMesh;\n\tdestroy(): void;\n}\ninterface MeshData {\n\t/** if the mesh is batched or not */\n\tbatched: boolean;\n\t/** the size of the index buffer */\n\tindexSize: number;\n\t/** the size of the vertex buffer */\n\tvertexSize: number;\n}\n/** @internal */\nexport interface MeshAdaptor {\n\tinit(): void;\n\texecute(meshPipe: MeshPipe, mesh: Mesh): void;\n\tdestroy(): void;\n}\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh> {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLPipes,\n\t\t\tExtensionType.WebGPUPipes,\n\t\t\tExtensionType.CanvasPipes\n\t\t];\n\t\treadonly name: \"mesh\";\n\t};\n\tlocalUniforms: UniformGroup<{\n\t\tuTransformMatrix: {\n\t\t\tvalue: Matrix;\n\t\t\ttype: \"mat3x3<f32>\";\n\t\t};\n\t\tuColor: {\n\t\t\tvalue: Float32Array;\n\t\t\ttype: \"vec4<f32>\";\n\t\t};\n\t\tuRound: {\n\t\t\tvalue: number;\n\t\t\ttype: \"f32\";\n\t\t};\n\t}>;\n\tlocalUniformsBindGroup: BindGroup;\n\trenderer: Renderer;\n\tprivate _adaptor;\n\tconstructor(renderer: Renderer, adaptor: MeshAdaptor);\n\tvalidateRenderable(mesh: Mesh): boolean;\n\taddRenderable(mesh: Mesh, instructionSet: InstructionSet): void;\n\tupdateRenderable(mesh: Mesh): void;\n\texecute(mesh: Mesh): void;\n\tprivate _getMeshData;\n\tprivate _initMeshData;\n\tprivate _getBatchableMesh;\n\tprivate _initBatchableMesh;\n\tdestroy(): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tmesh: MeshPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tparticle: ParticleContainerPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface Container<C extends ContainerChild = ContainerChild> extends ChildrenHelperMixin<C>, ToLocalGlobalMixin, OnRenderMixin, MeasureMixin, EffectsMixin, FindMixin, SortMixin, GetGlobalMixin, CollectRenderablesMixin, GetFastGlobalBoundsMixin, CacheAsTextureMixin {\n\t\t}\n\t\tinterface ContainerOptions extends OnRenderMixinConstructor, MeasureMixinConstructor, EffectsMixinConstructor, FindMixinConstructor, SortMixinConstructor, CacheAsTextureMixinConstructor {\n\t\t}\n\t\tinterface ViewContainer {\n\t\t}\n\t\tinterface ViewContainerOptions {\n\t\t}\n\t\tinterface Graphics {\n\t\t}\n\t\tinterface GraphicsOptions {\n\t\t}\n\t\tinterface Mesh {\n\t\t}\n\t\tinterface MeshOptions {\n\t\t}\n\t\tinterface ParticleContainer {\n\t\t}\n\t\tinterface ParticleContainerOptions {\n\t\t}\n\t\tinterface Sprite {\n\t\t}\n\t\tinterface SpriteOptions {\n\t\t}\n\t\tinterface AnimatedSprite {\n\t\t}\n\t\tinterface AnimatedSpriteOptions {\n\t\t}\n\t\tinterface NineSliceSprite {\n\t\t}\n\t\tinterface NineSliceSpriteOptions {\n\t\t}\n\t\tinterface TilingSprite {\n\t\t}\n\t\tinterface TilingSpriteOptions {\n\t\t}\n\t\tinterface Text {\n\t\t}\n\t\tinterface BitmapText {\n\t\t}\n\t\tinterface TextOptions {\n\t\t}\n\t\tinterface HTMLText {\n\t\t}\n\t\tinterface HTMLTextOptions {\n\t\t}\n\t\tinterface SplitText {\n\t\t}\n\t\tinterface SplitTextOptions {\n\t\t}\n\t\tinterface SplitBitmapText {\n\t\t}\n\t\tinterface SplitBitmapTextOptions {\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tnineSliceSprite: NineSliceSpritePipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\ttilingSprite: TilingSpritePipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tbitmapText: BitmapTextPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\thtmlText: HTMLTextSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\thtmlText: HTMLTextPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\tcanvasText: CanvasTextSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\ttext: CanvasTextPipe;\n\t\t}\n\t}\n}\n/** @internal */\nexport interface BlendModeFilterOptions {\n\tsource?: string;\n\tgpu?: {\n\t\tfunctions?: string;\n\t\tmain?: string;\n\t};\n\tgl?: {\n\t\tfunctions?: string;\n\t\tmain?: string;\n\t};\n}\n/** @internal */\nexport class BlendModeFilter extends Filter {\n\tconstructor(options: BlendModeFilterOptions);\n}\n/**\n * The final color has the hue and saturation of the top color, while using the luminosity of the bottom color.\n * The effect preserves gray levels and can be used to colorize the foreground.\n *\n * Available as `container.blendMode = 'color'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color'\n * @category filters\n * @noInheritDoc\n */\nexport class ColorBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is the result of inverting the bottom color, dividing the value by the top color,\n * and inverting that value. A white foreground leads to no change.\n * A foreground with the inverse color of the backdrop leads to a black final image.\n * This blend mode is similar to multiply, but the foreground need only be as dark as the inverse\n * of the backdrop to make the final image black.\n *\n * Available as `container.blendMode = 'color-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-burn'\n * @category filters\n * @noInheritDoc\n */\nexport class ColorBurnBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is the result of dividing the bottom color by the inverse of the top color.\n * A black foreground leads to no change.\n * A foreground with the inverse color of the backdrop leads to a fully lit color.\n * This blend mode is similar to screen, but the foreground need only be as light as the inverse of the backdrop to create a fully lit color.\n *\n * Available as `container.blendMode = 'color-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-dodge'\n * @category filters\n * @noInheritDoc\n */\nexport class ColorDodgeBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is composed of the darkest values of each color channel.\n *\n * Available as `container.blendMode = 'darken'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'darken'\n * @category filters\n * @noInheritDoc\n */\nexport class DarkenBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is the result of subtracting the darker of the two colors from the lighter one.\n * black layer has no effect, while a white layer inverts the other layer's color.\n *\n * Available as `container.blendMode = 'difference'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'difference'\n * @category filters\n * @noInheritDoc\n */\nexport class DifferenceBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The Divide blend mode divides the RGB channel values of the bottom layer by those of the top layer.\n * The darker the top layer, the brighter the bottom layer will appear.\n * Blending any color with black yields white, and blending with white has no effect\n *\n * Available as `container.blendMode = 'divide'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'divide'\n * @category filters\n * @noInheritDoc\n */\nexport class DivideBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is similar to difference, but with less contrast.\n * As with difference, a black layer has no effect, while a white layer inverts the other layer's color.\n *\n * Available as `container.blendMode = 'exclusion'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'exclusion'\n * @category filters\n * @noInheritDoc\n */\nexport class ExclusionBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is the result of multiply if the top color is darker, or screen if the top color is lighter.\n * This blend mode is equivalent to overlay but with the layers swapped.\n * The effect is similar to shining a harsh spotlight on the backdrop.\n *\n * Available as `container.blendMode = 'hard-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-light'\n * @category filters\n * @noInheritDoc\n */\nexport class HardLightBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Hard defines each of the color channel values of the blend color to the RGB values of the base color.\n * If the sum of a channel is 255, it receives a value of 255; if less than 255, a value of 0.\n *\n * Available as `container.blendMode = 'hard-mix'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-mix'\n * @category filters\n * @noInheritDoc\n */\nexport class HardMixBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is composed of the lightest values of each color channel.\n *\n * Available as `container.blendMode = 'lighten'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'lighten'\n * @category filters\n * @noInheritDoc\n */\nexport class LightenBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Looks at the color information in each channel and darkens the base color to\n * reflect the blend color by increasing the contrast between the two.\n *\n * Available as `container.blendMode = 'linear-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-burn'\n * @category filters\n * @noInheritDoc\n */\nexport class LinearBurnBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Looks at the color information in each channel and brightens the base color to reflect the blend color by decreasing contrast between the two.\n *\n * Available as `container.blendMode = 'linear-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-dodge'\n * @category filters\n * @noInheritDoc\n */\nexport class LinearDodgeBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Increase or decrease brightness by burning or dodging color values, based on the blend color\n *\n * Available as `container.blendMode = 'linear-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-light'\n * @category filters\n * @noInheritDoc\n */\nexport class LinearLightBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color has the luminosity of the top color, while using the hue and saturation of the bottom color.\n * This blend mode is equivalent to color, but with the layers swapped.\n *\n * Available as `container.blendMode = 'luminosity'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'luminosity'\n * @category filters\n * @noInheritDoc\n */\nexport class LuminosityBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Implements the Negation blend mode which creates an inverted effect based on the brightness values.\n *\n * Available as `container.blendMode = 'negation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'negation'\n * @category filters\n * @noInheritDoc\n */\nexport class NegationBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is the result of multiply if the bottom color is darker, or screen if the bottom color is lighter.\n * This blend mode is equivalent to hard-light but with the layers swapped.\n *\n * Available as `container.blendMode = 'overlay'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'overlay'\n * @category filters\n * @noInheritDoc\n */\nexport class OverlayBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Replaces colors based on the blend color.\n *\n * Available as `container.blendMode = 'pin-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'pin-light'\n * @category filters\n * @noInheritDoc\n */\nexport class PinLightBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color has the saturation of the top color, while using the hue and luminosity of the bottom color.\n * A pure gray backdrop, having no saturation, will have no effect.\n *\n * Available as `container.blendMode = 'saturation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'saturation'\n * @category filters\n * @noInheritDoc\n */\nexport class SaturationBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * The final color is similar to hard-light, but softer. This blend mode behaves similar to hard-light.\n * The effect is similar to shining a diffused spotlight on the backdrop.\n *\n * Available as `container.blendMode = 'soft-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'soft-light'\n * @category filters\n * @noInheritDoc\n */\nexport class SoftLightBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Subtracts the blend from the base color using each color channel\n *\n * Available as `container.blendMode = 'subtract'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'subtract'\n * @category filters\n * @noInheritDoc\n */\nexport class SubtractBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * Darkens values darker than 50% gray and lightens those brighter than 50% gray, creating a dramatic effect.\n * It's essentially an extreme version of the Overlay mode, with a significant impact on midtones\n *\n * Available as `container.blendMode = 'vivid-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'vivid-light'\n * @category filters\n * @noInheritDoc\n */\nexport class VividLightBlend extends BlendModeFilter {\n\t/** @ignore */\n\tstatic extension: ExtensionMetadata;\n\tconstructor();\n}\n/**\n * A more verbose version of the AssetExtension,\n * allowing you to set the cached, loaded, parsed, and unloaded asset separately\n * @category assets\n * @advanced\n */\nexport interface AssetExtensionAdvanced<ASSET = any, PARSED_ASSET = ASSET, UNLOAD_ASSET = ASSET, CACHE_ASSET = ASSET, META_DATA = any> {\n\t/** The type of extension */\n\textension: ExtensionType.Asset;\n\t/** the asset loader */\n\tloader?: LoaderParserAdvanced<ASSET, PARSED_ASSET, UNLOAD_ASSET, META_DATA>;\n\t/** the asset resolve parser */\n\tresolver?: Partial<ResolveURLParser>;\n\t/** the asset cache parser */\n\tcache?: Partial<CacheParser<CACHE_ASSET>>;\n\t/** the asset format detection parser */\n\tdetection?: Partial<FormatDetectionParser>;\n}\n/**\n * This developer convenience object allows developers to group\n * together the various asset parsers into a single object.\n * @example\n * import { AssetExtension, extensions } from 'pixi.js';\n *\n * // create the CacheParser\n * const cache = {\n *    test(asset: item): boolean {\n *       // Gets called by the cache when a dev caches an asset\n *    },\n *    getCacheableAssets(keys: string[], asset: item): Record<string, any> {\n *       // If the test passes, this function is called to get the cacheable assets\n *       // an example may be that a spritesheet object will return all the sub textures it has so they can\n *       // be cached.\n *    },\n * };\n *\n * // create the ResolveURLParser\n * const resolver = {\n *    test(value: string): boolean {\n *       // the test to perform on the url to determine if it should be parsed\n *    },\n *    parse(value: string): ResolvedAsset {\n *       // the function that will convert the url into an object\n *    },\n * };\n *\n * // create the LoaderParser\n * const loader = {\n *    name: 'itemLoader',\n *    extension: {\n *       type: ExtensionType.LoadParser,\n *    },\n *    async testParse(asset: any, options: ResolvedAsset) {\n *       // This function is used to test if the parse function should be run on the asset\n *    },\n *    async parse(asset: any, options: ResolvedAsset, loader: Loader) {\n *       // Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n *    },\n *    async load(url: string, options: ResolvedAsset, loader: Loader) {\n *       // This is the promise that loads the URL provided\n *    },\n *    unload(item: any) {\n *       // If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n *       // to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n *    },\n * };\n *\n * // put it all together and create the AssetExtension\n * extensions.add({\n *     extension: ExtensionType.Asset,\n *     cache,\n *     resolver,\n *     loader,\n * }\n * @category assets\n * @advanced\n */\nexport interface AssetExtension<ASSET = any, META_DATA = any> extends AssetExtensionAdvanced<ASSET, ASSET, ASSET, ASSET, META_DATA> {\n}\n/**\n * The BackgroundLoader handles loading assets passively in the background to prepare them for future use.\n * It loads one asset at a time to minimize impact on application performance.\n *\n * Key features:\n * - Sequential loading of assets\n * - Automatic pause when high-priority loads occur\n * - Configurable concurrency\n * @example\n * ```ts\n * import { Assets } from 'pixi.js';\n *\n * // Background load level assets while in menu\n * Assets.backgroundLoad([\n *     'level1/background.png',\n *     'level1/sprites.json',\n *     'level1/music.mp3'\n * ]);\n *\n * // Assets will be instantly available when needed\n * const assets = await Assets.load([\n *     'level1/background.png',\n *     'level1/sprites.json'\n * ]);\n *\n * // Background load bundles\n * Assets.backgroundLoadBundle('level2');\n *\n * // Later, instant access\n * const level2 = await Assets.loadBundle('level2');\n * ```\n * > [!NOTE] You typically do not need to use this class directly. Use the main {@link Assets.backgroundLoad} API instead.\n * @remarks\n * - Background loading is automatically paused when `Assets.load()` is called\n * - Assets are loaded sequentially to minimize performance impact\n * - Assets are cached as they complete loading\n * - No progress tracking is available for background loading\n * @see {@link Assets.backgroundLoad} For the main background loading API\n * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n * @category assets\n * @advanced\n */\nexport class BackgroundLoader {\n\t/** Whether or not the loader should continue loading. */\n\tprivate _isActive;\n\t/** Assets to load. */\n\tprivate readonly _assetList;\n\t/** Whether or not the loader is loading. */\n\tprivate _isLoading;\n\t/** Number of assets to load at a time. */\n\tprivate readonly _maxConcurrent;\n\t/**\n\t * Should the loader log to the console.\n\t * @advanced\n\t */\n\tverbose: boolean;\n\tprivate readonly _loader;\n\t/**\n\t * @param loader\n\t * @param verbose - should the loader log to the console\n\t */\n\tconstructor(loader: Loader, verbose?: boolean);\n\t/**\n\t * Adds assets to the background loading queue. Assets are loaded one at a time to minimize\n\t * performance impact.\n\t * @param assetUrls - Array of resolved assets to load in the background\n\t * @example\n\t * ```ts\n\t * // Add assets to background load queue\n\t * backgroundLoader.add([\n\t *     { src: 'images/level1/bg.png' },\n\t *     { src: 'images/level1/characters.json' }\n\t * ]);\n\t *\n\t * // Assets will load sequentially in the background\n\t * // The loader automatically pauses when high-priority loads occur\n\t * // e.g. Assets.load() is called\n\t * ```\n\t * @remarks\n\t * - Assets are loaded one at a time to minimize performance impact\n\t * - Loading automatically pauses when Assets.load() is called\n\t * - No progress tracking is available for background loading\n\t * - Assets are cached as they complete loading\n\t * @internal\n\t */\n\tadd(assetUrls: ResolvedAsset[]): void;\n\t/**\n\t * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n\t *\n\t * The max assets it will try to load at one time will be 4.\n\t */\n\tprivate _next;\n\t/**\n\t * Controls the active state of the background loader. When active, the loader will\n\t * continue processing its queue. When inactive, loading is paused.\n\t * @returns Whether the background loader is currently active\n\t * @example\n\t * ```ts\n\t * // Pause background loading\n\t * backgroundLoader.active = false;\n\t *\n\t * // Resume background loading\n\t * backgroundLoader.active = true;\n\t *\n\t * // Check current state\n\t * console.log(backgroundLoader.active); // true/false\n\t *\n\t * // Common use case: Pause during intensive operations\n\t * backgroundLoader.active = false;  // Pause background loading\n\t * ... // Perform high-priority tasks\n\t * backgroundLoader.active = true;   // Resume background loading\n\t * ```\n\t * @remarks\n\t * - Setting to true resumes loading immediately\n\t * - Setting to false pauses after current asset completes\n\t * - Background loading is automatically paused during `Assets.load()`\n\t * - Assets already being loaded will complete even when set to false\n\t */\n\tget active(): boolean;\n\tset active(value: boolean);\n}\n/**\n * Returns an object of textures from an array of textures to be cached\n * @category assets\n * @internal\n */\nexport const cacheTextureArray: CacheParser<Texture[]>;\n/**\n * Detects if the browser supports the AVIF image format.\n * @category assets\n * @internal\n */\nexport const detectAvif: FormatDetectionParser;\n/**\n * Adds some default image formats to the detection parser\n * @category assets\n * @internal\n */\nexport const detectDefaults: FormatDetectionParser;\n/**\n * Detects if the browser supports the MP4 video format.\n * @category assets\n * @internal\n */\nexport const detectMp4: FormatDetectionParser;\n/**\n * Detects if the browser supports the OGV video format.\n * @category assets\n * @internal\n */\nexport const detectOgv: FormatDetectionParser;\n/**\n * Detects if the browser supports the WebM video format.\n * @category assets\n * @internal\n */\nexport const detectWebm: FormatDetectionParser;\n/**\n * Detects if the browser supports the WebP image format.\n * @category assets\n * @internal\n */\nexport const detectWebp: FormatDetectionParser;\n/**\n * @param imageData\n * @internal\n */\nexport function testImageFormat(imageData: string): Promise<boolean>;\n/**\n * @param mimeType\n * @internal\n */\nexport function testVideoFormat(mimeType: string): boolean;\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadJson: {\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t};\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\ttest(url: string): boolean;\n\tload<T>(url: string): Promise<T>;\n};\n/**\n * A simple loader plugin for loading text data\n * @category assets\n * @advanced\n */\nexport const loadTxt: {\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t\tname: string;\n\t};\n\ttest(url: string): boolean;\n\tload<T>(url: string): Promise<string>;\n};\n/**\n * Cache for font faces\n * @internal\n */\nexport interface FontFaceCache {\n\tentries: {\n\t\turl: string;\n\t\tfaces: FontFace[];\n\t}[];\n}\n/**\n * Data for loading a font\n * @category assets\n * @advanced\n */\nexport type LoadFontData = {\n\t/** Font family name */\n\tfamily: string;\n\t/** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n\tdisplay: string;\n\t/**\n\t * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n\t * font features that are not available from a font's variant properties.\n\t */\n\tfeatureSettings: string;\n\t/** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n\tstretch: string;\n\t/** The style property of the FontFace interface retrieves or sets the font's style. */\n\tstyle: string;\n\t/**\n\t * The unicodeRange property of the FontFace interface retrieves or sets the range of\n\t * unicode code points encompassing the font.\n\t */\n\tunicodeRange: string;\n\t/** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n\tvariant: string;\n\t/** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n\tweights: string[];\n};\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @category assets\n * @internal\n */\nexport function getFontFamilyName(url: string): string;\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @category assets\n * @advanced\n */\nexport const loadWebFont: {\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t};\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\ttest(url: string): boolean;\n\tload<T>(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>;\n\tunload(font: FontFace | FontFace[]): void;\n};\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @category assets\n * @advanced\n */\nexport function crossOrigin(element: ImageLike | HTMLVideoElement, url: string, crossorigin?: boolean | string): void;\n/**\n * Preload a video element\n * @param element - Video element to preload\n * @internal\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>;\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @category assets\n */\nexport function determineCrossOrigin(url: string, loc?: Location): string;\ntype LoadVideoData = VideoSourceOptions & {\n\tmime?: string;\n};\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Assets.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @category assets\n * @advanced\n */\nexport const loadVideoTextures: {\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tname: string;\n\t};\n\ttest(url: string): boolean;\n\tload<T>(url: string, asset: ResolvedAsset<LoadVideoData>, loader: Loader): Promise<Texture>;\n\tunload(texture: Texture): void;\n};\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string): Texture<TextureSource<any>>;\ndeclare class WorkerManagerClass {\n\t/**\n\t * Hash map storing resolve/reject functions for pending worker requests.\n\t * Keyed by UUID to match responses with their corresponding promises.\n\t */\n\tprivate _resolveHash;\n\t/** Pool of available workers ready for use */\n\tprivate readonly _workerPool;\n\t/** Queue of pending work items waiting for available workers */\n\tprivate readonly _queue;\n\t/** Whether the worker manager has been initialized */\n\tprivate _initialized;\n\t/** Current number of created workers (used to enforce MAX_WORKERS limit) */\n\tprivate _createdWorkers;\n\t/** Cached promise for ImageBitmap support check */\n\tprivate _isImageBitmapSupported?;\n\tconstructor();\n\t/**\n\t * Checks if ImageBitmap is supported in the current environment.\n\t *\n\t * This method uses a dedicated worker to test ImageBitmap support\n\t * and caches the result for subsequent calls.\n\t * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise\n\t */\n\tisImageBitmapSupported(): Promise<boolean>;\n\t/**\n\t * Loads an image as an ImageBitmap using a web worker.\n\t * @param src - The source URL or path of the image to load\n\t * @param asset - Optional resolved asset containing additional texture source options\n\t * @returns Promise that resolves to the loaded ImageBitmap\n\t * @example\n\t * ```typescript\n\t * const bitmap = await WorkerManager.loadImageBitmap('image.png');\n\t * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);\n\t * ```\n\t */\n\tloadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>;\n\t/**\n\t * Initializes the worker pool if not already initialized.\n\t * Currently a no-op but reserved for future initialization logic.\n\t */\n\tprivate _initWorkers;\n\t/**\n\t * Gets an available worker from the pool or creates a new one if needed.\n\t *\n\t * Workers are created up to the MAX_WORKERS limit (based on navigator.hardwareConcurrency).\n\t * Each worker is configured with a message handler for processing results.\n\t * @returns Available worker or undefined if pool is at capacity and no workers are free\n\t */\n\tprivate _getWorker;\n\t/**\n\t * Returns a worker to the pool after completing a task.\n\t * @param worker - The worker to return to the pool\n\t */\n\tprivate _returnWorker;\n\t/**\n\t * Handles completion of a worker task by resolving or rejecting the corresponding promise.\n\t * @param data - Result data from the worker containing uuid, data, and optional error\n\t */\n\tprivate _complete;\n\t/**\n\t * Executes a task using the worker pool system.\n\t *\n\t * Queues the task and processes it when a worker becomes available.\n\t * @param id - Identifier for the type of task to run\n\t * @param args - Arguments to pass to the worker\n\t * @returns Promise that resolves with the worker's result\n\t */\n\tprivate _run;\n\t/**\n\t * Processes the next item in the queue if workers are available.\n\t *\n\t * This method is called after worker initialization and when workers\n\t * complete tasks to continue processing the queue.\n\t */\n\tprivate _next;\n\t/**\n\t * Resets the worker manager, terminating all workers and clearing the queue.\n\t *\n\t * This method:\n\t * - Terminates all active workers\n\t * - Rejects all pending promises with an error\n\t * - Clears all internal state\n\t * - Resets initialization flags\n\t *\n\t * This should be called when the worker manager is no longer needed\n\t * to prevent memory leaks and ensure proper cleanup.\n\t * @example\n\t * ```typescript\n\t * // Clean up when shutting down\n\t * WorkerManager.reset();\n\t * ```\n\t */\n\treset(): void;\n}\n/**\n * Manages a pool of web workers for loading ImageBitmap objects asynchronously.\n *\n * This class provides a thread-safe way to load images using web workers,\n * automatically managing worker creation, pooling, and cleanup. It supports\n * checking ImageBitmap support and queuing multiple load requests.\n *\n * > [!IMPORTANT] You should not need to use this class directly\n * > However, you can call `WorkerManager.reset()` to clean up all workers when they are no longer needed.\n * @category Assets\n * @advanced\n */\nexport const WorkerManager: WorkerManagerClass;\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @category assets\n * @internal\n */\nexport const resolveJsonUrl: {\n\textension: {\n\t\ttype: ExtensionType.ResolveParser;\n\t\tpriority: number;\n\t\tname: string;\n\t};\n\ttest: (value: string) => boolean;\n\tparse: (value: string) => {\n\t\tresolution: number;\n\t\tformat: string;\n\t\tsrc: string;\n\t};\n};\n/**\n * A parser that will resolve a texture url\n * @category assets\n * @internal\n */\nexport const resolveTextureUrl: {\n\textension: {\n\t\ttype: ExtensionType.ResolveParser;\n\t\tname: string;\n\t};\n\ttest: (url: string, resolvedAsset?: ResolvedAsset<TextureSourceOptions<any>>, loader?: Loader) => boolean;\n\tparse: (value: string) => {\n\t\tresolution: number;\n\t\tformat: string;\n\t\tsrc: string;\n\t};\n};\n/**\n * @param url\n * @param mimes\n * @internal\n */\nexport function checkDataUrl(url: string, mimes: string | string[]): boolean;\n/**\n * @param url\n * @param extension\n * @internal\n */\nexport function checkExtension(url: string, extension: string | string[]): boolean;\n/**\n * @param input\n * @param transform\n * @param forceTransform\n * @internal\n */\nexport const convertToList: <T>(input: string | T | (string | T)[], transform?: (input: string) => T, forceTransform?: boolean) => T[];\n/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n * @internal\n */\nexport const copySearchParams: (targetUrl: string, sourceUrl: string) => string;\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n * @internal\n */\nexport function createStringVariations(string: string): string[];\n/**\n * Checks if the given value is an array.\n * @param item - The item to test\n * @internal\n */\nexport const isSingleItem: (item: unknown) => boolean;\n/**\n * Detects if Basis textures are supported by the browser.\n * This is done by checking if WebGL or WebGPU is supported.\n * If either is supported, Basis textures can be used.\n * @category assets\n * @internal\n */\nexport const detectBasis: FormatDetectionParser;\n/**\n * Loads Basis textures using a web worker.\n * @category assets\n * @advanced\n */\nexport const loadBasis: {\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t\tname: string;\n\t};\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\ttest(url: string): boolean;\n\tload<T>(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>;\n\tunload(texture: Texture | Texture[]): void;\n};\n/** @internal */\nexport type BASISModuleCreator = (config: {\n\tlocateFile: (file: string) => string;\n}) => {\n\tthen: (result: (libktx: BASISModule) => void) => void;\n};\n/** @internal */\nexport type BasisTextureConstructor = new (data: Uint8Array) => BasisTexture;\n/** @internal */\nexport interface BASISModule {\n\tinitializeBasis(): void;\n\tBasisFile: BasisTextureConstructor;\n}\n/** @internal */\nexport interface BasisTexture {\n\tgetNumImages(): number;\n\tgetNumLevels(imageIndex: number): number;\n\tstartTranscoding(): boolean;\n\tgetImageWidth(imageIndex: number, levelIndex: number): number;\n\tgetImageHeight(imageIndex: number, levelIndex: number): number;\n\tgetImageTranscodedSizeInBytes(imageIndex: number, levelIndex: number, format: number): number;\n\ttranscodeImage(buffer: Uint8Array, imageIndex: number, levelIndex: number, format: number, unused: number, getAlphaForOpaqueFormats: number): boolean;\n}\n/**\n * @param basisTexture\n * @param basisTranscoderFormat\n * @internal\n */\nexport function createLevelBuffers(basisTexture: BasisTexture, basisTranscoderFormat: number): Uint8Array[];\n/**\n * @param transcoderFormat\n * @internal\n */\nexport function gpuFormatToBasisTranscoderFormat(transcoderFormat: string): number;\n/**\n * The urls for the Basis transcoder files.\n * These can be set to custom paths if needed.\n * @category assets\n * @advanced\n */\nexport const basisTranscoderUrls: {\n\tjsUrl: string;\n\twasmUrl: string;\n};\n/**\n * Sets the Basis transcoder paths.\n * This allows you to override the default paths for the Basis transcoder files.\n * @param config - The configuration object containing the new paths.\n * @category assets\n * @advanced\n */\nexport function setBasisTranscoderPath(config: Partial<typeof basisTranscoderUrls>): void;\n/**\n * @param url\n * @param supportedTextures\n * @internal\n */\nexport function loadBasisOnWorker(url: string, supportedTextures: TEXTURE_FORMATS[]): Promise<TextureSourceOptions>;\n/**\n * @see https://docs.microsoft.com/en-us/windows/win32/api/dxgiformat/ne-dxgiformat-dxgi_format\n * This is way over-blown for us! Lend us a hand, and remove the ones that aren't used (but set the remaining\n * ones to their correct value)\n * @ignore\n */\nexport enum DXGI_FORMAT {\n\tDXGI_FORMAT_UNKNOWN = 0,\n\tDXGI_FORMAT_R32G32B32A32_TYPELESS = 1,\n\tDXGI_FORMAT_R32G32B32A32_FLOAT = 2,\n\tDXGI_FORMAT_R32G32B32A32_UINT = 3,\n\tDXGI_FORMAT_R32G32B32A32_SINT = 4,\n\tDXGI_FORMAT_R32G32B32_TYPELESS = 5,\n\tDXGI_FORMAT_R32G32B32_FLOAT = 6,\n\tDXGI_FORMAT_R32G32B32_UINT = 7,\n\tDXGI_FORMAT_R32G32B32_SINT = 8,\n\tDXGI_FORMAT_R16G16B16A16_TYPELESS = 9,\n\tDXGI_FORMAT_R16G16B16A16_FLOAT = 10,\n\tDXGI_FORMAT_R16G16B16A16_UNORM = 11,\n\tDXGI_FORMAT_R16G16B16A16_UINT = 12,\n\tDXGI_FORMAT_R16G16B16A16_SNORM = 13,\n\tDXGI_FORMAT_R16G16B16A16_SINT = 14,\n\tDXGI_FORMAT_R32G32_TYPELESS = 15,\n\tDXGI_FORMAT_R32G32_FLOAT = 16,\n\tDXGI_FORMAT_R32G32_UINT = 17,\n\tDXGI_FORMAT_R32G32_SINT = 18,\n\tDXGI_FORMAT_R32G8X24_TYPELESS = 19,\n\tDXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20,\n\tDXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21,\n\tDXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22,\n\tDXGI_FORMAT_R10G10B10A2_TYPELESS = 23,\n\tDXGI_FORMAT_R10G10B10A2_UNORM = 24,\n\tDXGI_FORMAT_R10G10B10A2_UINT = 25,\n\tDXGI_FORMAT_R11G11B10_FLOAT = 26,\n\tDXGI_FORMAT_R8G8B8A8_TYPELESS = 27,\n\tDXGI_FORMAT_R8G8B8A8_UNORM = 28,\n\tDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29,\n\tDXGI_FORMAT_R8G8B8A8_UINT = 30,\n\tDXGI_FORMAT_R8G8B8A8_SNORM = 31,\n\tDXGI_FORMAT_R8G8B8A8_SINT = 32,\n\tDXGI_FORMAT_R16G16_TYPELESS = 33,\n\tDXGI_FORMAT_R16G16_FLOAT = 34,\n\tDXGI_FORMAT_R16G16_UNORM = 35,\n\tDXGI_FORMAT_R16G16_UINT = 36,\n\tDXGI_FORMAT_R16G16_SNORM = 37,\n\tDXGI_FORMAT_R16G16_SINT = 38,\n\tDXGI_FORMAT_R32_TYPELESS = 39,\n\tDXGI_FORMAT_D32_FLOAT = 40,\n\tDXGI_FORMAT_R32_FLOAT = 41,\n\tDXGI_FORMAT_R32_UINT = 42,\n\tDXGI_FORMAT_R32_SINT = 43,\n\tDXGI_FORMAT_R24G8_TYPELESS = 44,\n\tDXGI_FORMAT_D24_UNORM_S8_UINT = 45,\n\tDXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46,\n\tDXGI_FORMAT_X24_TYPELESS_G8_UINT = 47,\n\tDXGI_FORMAT_R8G8_TYPELESS = 48,\n\tDXGI_FORMAT_R8G8_UNORM = 49,\n\tDXGI_FORMAT_R8G8_UINT = 50,\n\tDXGI_FORMAT_R8G8_SNORM = 51,\n\tDXGI_FORMAT_R8G8_SINT = 52,\n\tDXGI_FORMAT_R16_TYPELESS = 53,\n\tDXGI_FORMAT_R16_FLOAT = 54,\n\tDXGI_FORMAT_D16_UNORM = 55,\n\tDXGI_FORMAT_R16_UNORM = 56,\n\tDXGI_FORMAT_R16_UINT = 57,\n\tDXGI_FORMAT_R16_SNORM = 58,\n\tDXGI_FORMAT_R16_SINT = 59,\n\tDXGI_FORMAT_R8_TYPELESS = 60,\n\tDXGI_FORMAT_R8_UNORM = 61,\n\tDXGI_FORMAT_R8_UINT = 62,\n\tDXGI_FORMAT_R8_SNORM = 63,\n\tDXGI_FORMAT_R8_SINT = 64,\n\tDXGI_FORMAT_A8_UNORM = 65,\n\tDXGI_FORMAT_R1_UNORM = 66,\n\tDXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67,\n\tDXGI_FORMAT_R8G8_B8G8_UNORM = 68,\n\tDXGI_FORMAT_G8R8_G8B8_UNORM = 69,\n\tDXGI_FORMAT_BC1_TYPELESS = 70,\n\tDXGI_FORMAT_BC1_UNORM = 71,\n\tDXGI_FORMAT_BC1_UNORM_SRGB = 72,\n\tDXGI_FORMAT_BC2_TYPELESS = 73,\n\tDXGI_FORMAT_BC2_UNORM = 74,\n\tDXGI_FORMAT_BC2_UNORM_SRGB = 75,\n\tDXGI_FORMAT_BC3_TYPELESS = 76,\n\tDXGI_FORMAT_BC3_UNORM = 77,\n\tDXGI_FORMAT_BC3_UNORM_SRGB = 78,\n\tDXGI_FORMAT_BC4_TYPELESS = 79,\n\tDXGI_FORMAT_BC4_UNORM = 80,\n\tDXGI_FORMAT_BC4_SNORM = 81,\n\tDXGI_FORMAT_BC5_TYPELESS = 82,\n\tDXGI_FORMAT_BC5_UNORM = 83,\n\tDXGI_FORMAT_BC5_SNORM = 84,\n\tDXGI_FORMAT_B5G6R5_UNORM = 85,\n\tDXGI_FORMAT_B5G5R5A1_UNORM = 86,\n\tDXGI_FORMAT_B8G8R8A8_UNORM = 87,\n\tDXGI_FORMAT_B8G8R8X8_UNORM = 88,\n\tDXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89,\n\tDXGI_FORMAT_B8G8R8A8_TYPELESS = 90,\n\tDXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91,\n\tDXGI_FORMAT_B8G8R8X8_TYPELESS = 92,\n\tDXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93,\n\tDXGI_FORMAT_BC6H_TYPELESS = 94,\n\tDXGI_FORMAT_BC6H_UF16 = 95,\n\tDXGI_FORMAT_BC6H_SF16 = 96,\n\tDXGI_FORMAT_BC7_TYPELESS = 97,\n\tDXGI_FORMAT_BC7_UNORM = 98,\n\tDXGI_FORMAT_BC7_UNORM_SRGB = 99,\n\tDXGI_FORMAT_AYUV = 100,\n\tDXGI_FORMAT_Y410 = 101,\n\tDXGI_FORMAT_Y416 = 102,\n\tDXGI_FORMAT_NV12 = 103,\n\tDXGI_FORMAT_P010 = 104,\n\tDXGI_FORMAT_P016 = 105,\n\tDXGI_FORMAT_420_OPAQUE = 106,\n\tDXGI_FORMAT_YUY2 = 107,\n\tDXGI_FORMAT_Y210 = 108,\n\tDXGI_FORMAT_Y216 = 109,\n\tDXGI_FORMAT_NV11 = 110,\n\tDXGI_FORMAT_AI44 = 111,\n\tDXGI_FORMAT_IA44 = 112,\n\tDXGI_FORMAT_P8 = 113,\n\tDXGI_FORMAT_A8P8 = 114,\n\tDXGI_FORMAT_B4G4R4A4_UNORM = 115,\n\tDXGI_FORMAT_P208 = 116,\n\tDXGI_FORMAT_V208 = 117,\n\tDXGI_FORMAT_V408 = 118,\n\tDXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119,\n\tDXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120,\n\tDXGI_FORMAT_FORCE_UINT = 121\n}\n/**\n * Possible values of the field {@link DDS_DX10_FIELDS.RESOURCE_DIMENSION}\n * @ignore\n */\nexport enum D3D10_RESOURCE_DIMENSION {\n\tDDS_DIMENSION_TEXTURE1D = 2,\n\tDDS_DIMENSION_TEXTURE2D = 3,\n\tDDS_DIMENSION_TEXTURE3D = 6\n}\n/**\n * Four character codes for DXTn formats\n * https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide\n * https://learn.microsoft.com/en-us/windows/win32/direct3d9/d3dformat\n * @internal\n */\nexport enum D3DFMT {\n\tUNKNOWN = 0,\n\tR8G8B8 = 20,\n\tA8R8G8B8 = 21,\n\tX8R8G8B8 = 22,\n\tR5G6B5 = 23,\n\tX1R5G5B5 = 24,\n\tA1R5G5B5 = 25,\n\tA4R4G4B4 = 26,\n\tR3G3B2 = 27,\n\tA8 = 28,\n\tA8R3G3B2 = 29,\n\tX4R4G4B4 = 30,\n\tA2B10G10R10 = 31,\n\tA8B8G8R8 = 32,\n\tX8B8G8R8 = 33,\n\tG16R16 = 34,\n\tA2R10G10B10 = 35,\n\tA16B16G16R16 = 36,\n\tA8P8 = 40,\n\tP8 = 41,\n\tL8 = 50,\n\tA8L8 = 51,\n\tA4L4 = 52,\n\tV8U8 = 60,\n\tL6V5U5 = 61,\n\tX8L8V8U8 = 62,\n\tQ8W8V8U8 = 63,\n\tV16U16 = 64,\n\tA2W10V10U10 = 67,\n\tQ16W16V16U16 = 110,\n\tR16F = 111,\n\tG16R16F = 112,\n\tA16B16G16R16F = 113,\n\tR32F = 114,\n\tG32R32F = 115,\n\tA32B32G32R32F = 116,\n\tUYVY,\n\tR8G8_B8G8,\n\tYUY2,\n\tD3DFMT_G8R8_G8B8,\n\tDXT1,\n\tDXT2,\n\tDXT3,\n\tDXT4,\n\tDXT5,\n\tATI1,\n\tAT1N,\n\tATI2,\n\tAT2N,\n\tBC4U,\n\tBC4S,\n\tBC5U,\n\tBC5S,\n\tDX10\n}\n/**\n * Maps `FOURCC_*` formats to {@link TEXTURE_FORMATS}.\n * https://en.wikipedia.org/wiki/S3_Texture_Compression#S3TC_format_comparison\n * https://github.com/microsoft/DirectXTex/blob/main/DDSTextureLoader/DDSTextureLoader11.cpp\n * @ignore\n */\nexport const FOURCC_TO_TEXTURE_FORMAT: {\n\t[id: number]: TEXTURE_FORMATS;\n};\n/**\n * Maps {@link DXGI_FORMAT} to {@link TEXTURE_FORMATS}\n * @ignore\n */\nexport const DXGI_TO_TEXTURE_FORMAT: {\n\t[id: number]: TEXTURE_FORMATS;\n};\n/**\n * Maps {@link DXGI_FORMAT} to {@link D3DFMT}\n * @internal\n */\nexport const DDS: {\n\tMAGIC_VALUE: number;\n\tMAGIC_SIZE: number;\n\tHEADER_SIZE: number;\n\tHEADER_DX10_SIZE: number;\n\tPIXEL_FORMAT_FLAGS: {\n\t\tALPHAPIXELS: number;\n\t\tALPHA: number;\n\t\tFOURCC: number;\n\t\tRGB: number;\n\t\tRGBA: number;\n\t\tYUV: number;\n\t\tLUMINANCE: number;\n\t\tLUMINANCEA: number;\n\t};\n\tRESOURCE_MISC_TEXTURECUBE: number;\n\tHEADER_FIELDS: {\n\t\tMAGIC: number;\n\t\tSIZE: number;\n\t\tFLAGS: number;\n\t\tHEIGHT: number;\n\t\tWIDTH: number;\n\t\tMIPMAP_COUNT: number;\n\t\tPIXEL_FORMAT: number;\n\t\tPF_FLAGS: number;\n\t\tFOURCC: number;\n\t\tRGB_BITCOUNT: number;\n\t\tR_BIT_MASK: number;\n\t\tG_BIT_MASK: number;\n\t\tB_BIT_MASK: number;\n\t\tA_BIT_MASK: number;\n\t};\n\tHEADER_DX10_FIELDS: {\n\t\tDXGI_FORMAT: number;\n\t\tRESOURCE_DIMENSION: number;\n\t\tMISC_FLAG: number;\n\t\tARRAY_SIZE: number;\n\t\tMISC_FLAGS2: number;\n\t};\n\tDXGI_FORMAT: typeof DXGI_FORMAT;\n\tD3D10_RESOURCE_DIMENSION: typeof D3D10_RESOURCE_DIMENSION;\n\tD3DFMT: typeof D3DFMT;\n};\n/** @internal */\nexport const TEXTURE_FORMAT_BLOCK_SIZE: Record<string, number>;\n/**\n * Loads DDS textures.\n * @category assets\n * @advanced\n */\nexport const loadDDS: {\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t\tname: string;\n\t};\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\ttest(url: string): boolean;\n\tload<T>(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>;\n\tunload(texture: Texture | Texture[]): void;\n};\n/**\n * @param arrayBuffer\n * @param supportedFormats\n * @internal\n */\nexport function parseDDS(arrayBuffer: ArrayBuffer, supportedFormats: TEXTURE_FORMATS[]): TextureSourceOptions<Uint8Array[]>;\n/**\n * Loads KTX textures.\n * @category assets\n * @advanced\n */\nexport const loadKTX: {\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t\tname: string;\n\t};\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\ttest(url: string): boolean;\n\tload<T>(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>;\n\tunload(texture: Texture | Texture[]): void;\n};\n/**\n * @param arrayBuffer\n * @param supportedFormats\n * @internal\n */\nexport function parseKTX(arrayBuffer: ArrayBuffer, supportedFormats: TEXTURE_FORMATS[]): TextureSourceOptions<Uint8Array[]>;\n/** @internal */\nexport enum GL_INTERNAL_FORMAT {\n\tRGBA8_SNORM = 36759,\n\tRGBA = 6408,\n\tRGBA8UI = 36220,\n\tSRGB8_ALPHA8 = 35907,\n\tRGBA8I = 36238,\n\tRGBA8 = 32856,\n\tCOMPRESSED_RGB_S3TC_DXT1_EXT = 33776,\n\tCOMPRESSED_RGBA_S3TC_DXT1_EXT = 33777,\n\tCOMPRESSED_RGBA_S3TC_DXT3_EXT = 33778,\n\tCOMPRESSED_RGBA_S3TC_DXT5_EXT = 33779,\n\tCOMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917,\n\tCOMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918,\n\tCOMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919,\n\tCOMPRESSED_SRGB_S3TC_DXT1_EXT = 35916,\n\tCOMPRESSED_RED_RGTC1_EXT = 36283,\n\tCOMPRESSED_SIGNED_RED_RGTC1_EXT = 36284,\n\tCOMPRESSED_RED_GREEN_RGTC2_EXT = 36285,\n\tCOMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286,\n\tCOMPRESSED_R11_EAC = 37488,\n\tCOMPRESSED_SIGNED_R11_EAC = 37489,\n\tCOMPRESSED_RG11_EAC = 37490,\n\tCOMPRESSED_SIGNED_RG11_EAC = 37491,\n\tCOMPRESSED_RGB8_ETC2 = 37492,\n\tCOMPRESSED_RGBA8_ETC2_EAC = 37496,\n\tCOMPRESSED_SRGB8_ETC2 = 37493,\n\tCOMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497,\n\tCOMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494,\n\tCOMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495,\n\tCOMPRESSED_RGBA_ASTC_4x4_KHR = 37808,\n\tCOMPRESSED_RGBA_ASTC_5x4_KHR = 37809,\n\tCOMPRESSED_RGBA_ASTC_5x5_KHR = 37810,\n\tCOMPRESSED_RGBA_ASTC_6x5_KHR = 37811,\n\tCOMPRESSED_RGBA_ASTC_6x6_KHR = 37812,\n\tCOMPRESSED_RGBA_ASTC_8x5_KHR = 37813,\n\tCOMPRESSED_RGBA_ASTC_8x6_KHR = 37814,\n\tCOMPRESSED_RGBA_ASTC_8x8_KHR = 37815,\n\tCOMPRESSED_RGBA_ASTC_10x5_KHR = 37816,\n\tCOMPRESSED_RGBA_ASTC_10x6_KHR = 37817,\n\tCOMPRESSED_RGBA_ASTC_10x8_KHR = 37818,\n\tCOMPRESSED_RGBA_ASTC_10x10_KHR = 37819,\n\tCOMPRESSED_RGBA_ASTC_12x10_KHR = 37820,\n\tCOMPRESSED_RGBA_ASTC_12x12_KHR = 37821,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852,\n\tCOMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853,\n\tCOMPRESSED_RGBA_BPTC_UNORM_EXT = 36492,\n\tCOMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493,\n\tCOMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494,\n\tCOMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495\n}\n/**\n * The KTX file format constants.\n * @internal\n */\nexport const KTX: {\n\tFILE_HEADER_SIZE: number;\n\tFILE_IDENTIFIER: number[];\n\tFORMATS_TO_COMPONENTS: {\n\t\t[id: number]: number;\n\t};\n\tINTERNAL_FORMAT_TO_BYTES_PER_PIXEL: {\n\t\t[id: number]: number;\n\t};\n\tINTERNAL_FORMAT_TO_TEXTURE_FORMATS: {\n\t\t[id: number]: TEXTURE_FORMATS;\n\t};\n\tFIELDS: {\n\t\tFILE_IDENTIFIER: number;\n\t\tENDIANNESS: number;\n\t\tGL_TYPE: number;\n\t\tGL_TYPE_SIZE: number;\n\t\tGL_FORMAT: number;\n\t\tGL_INTERNAL_FORMAT: number;\n\t\tGL_BASE_INTERNAL_FORMAT: number;\n\t\tPIXEL_WIDTH: number;\n\t\tPIXEL_HEIGHT: number;\n\t\tPIXEL_DEPTH: number;\n\t\tNUMBER_OF_ARRAY_ELEMENTS: number;\n\t\tNUMBER_OF_FACES: number;\n\t\tNUMBER_OF_MIPMAP_LEVELS: number;\n\t\tBYTES_OF_KEY_VALUE_DATA: number;\n\t};\n\tTYPES_TO_BYTES_PER_COMPONENT: {\n\t\t[id: number]: number;\n\t};\n\tTYPES_TO_BYTES_PER_PIXEL: {\n\t\t[id: number]: number;\n\t};\n\tENDIANNESS: number;\n};\n/**\n * Loader parser for KTX2 textures.\n * This parser loads KTX2 textures using a web worker for transcoding.\n * It supports both single and multiple textures.\n * @category assets\n * @advanced\n */\nexport const loadKTX2: {\n\textension: {\n\t\ttype: ExtensionType.LoadParser;\n\t\tpriority: LoaderParserPriority;\n\t\tname: string;\n\t};\n\t/** used for deprecation purposes */\n\tname: string;\n\tid: string;\n\ttest(url: string): boolean;\n\tload<T>(url: string, _asset: ResolvedAsset, loader: Loader): Promise<Texture | Texture[]>;\n\tunload(texture: Texture | Texture[]): Promise<void>;\n};\n/** @internal */\nexport type LIBKTXModuleCreator = (config: {\n\tlocateFile: (file: string) => string;\n}) => {\n\tthen: (result: (libktx: LIBKTXModule) => void) => void;\n};\n/** @internal */\nexport interface KTXTexture {\n\tgetImageData(level: number, layer: number, face: number): Uint8Array;\n\tglInternalformat: number;\n\tvkFormat: number;\n\tclassId: number;\n\tnumLevels: number;\n\tbaseHeight: number;\n\tbaseWidth: number;\n\ttranscodeBasis(transcodeFormat: any, arg1: number): unknown;\n\tneedsTranscoding: boolean;\n}\n/** @internal */\nexport interface LIBKTXModule {\n\tErrorCode: any;\n\tTranscodeTarget: any;\n\tktxTexture: new (data: Uint8Array) => KTXTexture;\n}\n/** @internal */\nexport type COMPRESSED_TEXTURE_FORMATS = TEXTURE_FORMATS | \"rgb8unorm\" | \"rgb8unorm-srgb\";\n/**\n * @param textureOptions\n * @internal\n */\nexport function convertFormatIfRequired(textureOptions: TextureSourceOptions): void;\n/**\n * @param ktxTexture\n * @internal\n */\nexport function createLevelBuffersFromKTX(ktxTexture: KTXTexture): Uint8Array[];\n/**\n * @param ktxTexture\n * @internal\n */\nexport function getTextureFormatFromKTXTexture(ktxTexture: KTXTexture): COMPRESSED_TEXTURE_FORMATS;\n/**\n * @param glInternalFormat\n * @internal\n */\nexport function glFormatToGPUFormat(glInternalFormat: number): COMPRESSED_TEXTURE_FORMATS;\n/**\n * @param transcoderFormat\n * @internal\n */\nexport function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat: string): string;\n/**\n * The urls for the KTX transcoder library.\n * These can be set to custom paths if needed.\n * @category assets\n * @advanced\n */\nexport const ktxTranscoderUrls: {\n\tjsUrl: string;\n\twasmUrl: string;\n};\n/**\n * Sets the paths for the KTX transcoder library.\n * @param config - Partial configuration object to set custom paths for the KTX transcoder.\n * This allows you to override the default URLs for the KTX transcoder library.\n * @category assets\n * @advanced\n */\nexport function setKTXTranscoderPath(config: Partial<typeof ktxTranscoderUrls>): void;\n/**\n * @param vkFormat\n * @internal\n */\nexport function vkFormatToGPUFormat(vkFormat: number): COMPRESSED_TEXTURE_FORMATS;\n/**\n * @param url\n * @param supportedTextures\n * @internal\n */\nexport function loadKTX2onWorker(url: string, supportedTextures: TEXTURE_FORMATS[]): Promise<TextureSourceOptions>;\n/**\n * Detects if the browser supports compressed texture formats.\n * @category assets\n * @internal\n */\nexport const detectCompressed: FormatDetectionParser;\n/** @internal */\nexport const validFormats: string[];\n/**\n * A parser that will resolve a compressed texture url\n * @category assets\n * @internal\n */\nexport const resolveCompressedTextureUrl: {\n\textension: ExtensionType.ResolveParser;\n\ttest: (value: string) => boolean;\n\tparse: (value: string) => {\n\t\tresolution: number;\n\t\tformat: string;\n\t\tsrc: string;\n\t};\n};\n/**\n * A rectangle-like object that contains x, y, width, and height properties.\n * @example\n * const rect = { x: 0, y: 0, width: 100, height: 100 };\n * @category utils\n * @advanced\n */\nexport type RectangleLike = {\n\tx: number;\n\ty: number;\n\twidth: number;\n\theight: number;\n};\n/**\n * The Culler class is responsible for managing and culling containers.\n * Culling optimizes rendering performance by skipping objects outside the visible area.\n *\n * > [!IMPORTANT] culling is not always a golden bullet, it can be more expensive than rendering\n * > objects that are not visible, so it is best used in scenarios where you have many objects\n * > that are not visible at the same time, such as in large scenes or games with many sprites.\n * @example\n * ```ts\n * import { Culler, Container, Rectangle } from 'pixi.js';\n *\n * // Create a culler and container\n * const culler = new Culler();\n * const stage = new Container();\n *\n * // Set up container with culling\n * stage.cullable = true;\n * stage.cullArea = new Rectangle(0, 0, 800, 600);\n *\n * // Add some sprites that will be culled\n * for (let i = 0; i < 1000; i++) {\n *     const sprite = Sprite.from('texture.png');\n *     sprite.x = Math.random() * 2000;\n *     sprite.y = Math.random() * 2000;\n *     sprite.cullable = true;\n *     stage.addChild(sprite);\n * }\n *\n * // Cull objects outside view\n * culler.cull(stage, {\n *     x: 0,\n *     y: 0,\n *     width: 800,\n *     height: 600\n * });\n *\n * // Only visible objects will be rendered\n * renderer.render(stage);\n * ```\n * @see {@link CullerPlugin} For automatic culling in applications\n * @see {@link CullingMixinConstructor} For culling properties\n * @category scene\n * @standard\n */\nexport class Culler {\n\t/**\n\t * Culls the children of a specific container based on the given view rectangle.\n\t * This determines which objects should be rendered and which can be skipped.\n\t * @param container - The container to cull. Must be a Container instance.\n\t * @param view - The view rectangle that defines the visible area\n\t * @param skipUpdateTransform - Whether to skip updating transforms for better performance\n\t * @example\n\t * ```ts\n\t * // Basic culling with view bounds\n\t * const culler = new Culler();\n\t * culler.cull(stage, {\n\t *     x: 0,\n\t *     y: 0,\n\t *     width: 800,\n\t *     height: 600\n\t * });\n\t *\n\t * // Culling to renderer screen\n\t * culler.cull(stage, renderer.screen, false);\n\t * ```\n\t * @remarks\n\t * - Recursively processes all cullable children\n\t * - Uses cullArea if defined, otherwise calculates bounds\n\t * - Performance depends on scene complexity\n\t * @see {@link CullingMixinConstructor.cullable} For enabling culling on objects\n\t * @see {@link CullingMixinConstructor.cullArea} For custom culling boundaries\n\t */\n\tcull(container: Container, view: RectangleLike, skipUpdateTransform?: boolean): void;\n\tprivate _cullRecursive;\n\t/**\n\t * A shared instance of the Culler class. Provides a global culler instance for convenience.\n\t * @example\n\t * ```ts\n\t * // Use the shared instance instead of creating a new one\n\t * Culler.shared.cull(stage, {\n\t *     x: 0,\n\t *     y: 0,\n\t *     width: 800,\n\t *     height: 600\n\t * });\n\t * ```\n\t * @see {@link CullerPlugin} For automatic culling using this instance\n\t */\n\tstatic shared: Culler;\n}\n/**\n * CanvasObserver class synchronizes the DOM element's transform with the canvas size and position.\n * It uses ResizeObserver for efficient updates and requestAnimationFrame for fallback.\n * This ensures that the DOM element is always correctly positioned and scaled relative to the canvas.\n * @internal\n */\nexport class CanvasObserver {\n\t/** A cached value of the last transform applied to the DOM element. */\n\tprivate _lastTransform;\n\t/** A ResizeObserver instance to observe changes in the canvas size. */\n\tprivate _observer;\n\t/** The canvas element that this observer is associated with. */\n\tprivate _canvas;\n\t/** The DOM element that will be transformed based on the canvas size and position. */\n\tprivate readonly _domElement;\n\t/** The renderer instance that this observer is associated with. */\n\tprivate readonly _renderer;\n\t/** The last scale values applied to the DOM element, used to avoid unnecessary updates. */\n\tprivate _lastScaleX;\n\t/** The last scale values applied to the DOM element, used to avoid unnecessary updates. */\n\tprivate _lastScaleY;\n\t/** A flag to indicate whether the observer is attached to the Ticker for continuous updates. */\n\tprivate _tickerAttached;\n\tconstructor(options: {\n\t\tdomElement: HTMLElement;\n\t\trenderer: Renderer;\n\t});\n\t/** The canvas element that this CanvasObserver is associated with. */\n\tget canvas(): HTMLCanvasElement;\n\t/** Attaches the DOM element to the canvas parent if it is not already attached. */\n\tensureAttached(): void;\n\t/**\n\t * Updates the transform of the DOM element based on the canvas size and position.\n\t * This method calculates the scale and translation needed to keep the DOM element in sync with the canvas.\n\t */\n\treadonly updateTranslation: () => void;\n\t/** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */\n\tprivate _attachObserver;\n\t/** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */\n\tdestroy(): void;\n}\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @category environment\n * @advanced\n */\nexport interface Adapter {\n\t/** Returns a canvas object that can be used to create a webgl context. */\n\tcreateCanvas: (width?: number, height?: number) => ICanvas;\n\t/** Returns an IImage (HTMLImageElement) that can be used to create a texture. */\n\tcreateImage: () => ImageLike;\n\t/** Returns a 2D rendering context. */\n\tgetCanvasRenderingContext2D: () => {\n\t\tprototype: ICanvasRenderingContext2D;\n\t};\n\t/** Returns a WebGL rendering context. */\n\tgetWebGLRenderingContext: () => typeof WebGLRenderingContext;\n\t/** Returns a partial implementation of the browsers window.navigator */\n\tgetNavigator: () => {\n\t\tuserAgent: string;\n\t\tgpu: GPU | null;\n\t};\n\t/** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n\tgetBaseUrl: () => string;\n\t/** Return the font face set if available */\n\tgetFontFaceSet: () => FontFaceSet | null;\n\t/** Returns a Response object that has been fetched from the given URL. */\n\tfetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n\t/** Returns Document object that has been parsed from the given XML string. */\n\tparseXML: (xml: string) => Document;\n}\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link Adapter} interface to abstract away the differences between these environments\n * and uses the {@link BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @category environment\n * @advanced\n */\nexport const DOMAdapter: {\n\t/**\n\t * Returns the current adapter.\n\t * @returns {environment.Adapter} The current adapter.\n\t */\n\tget(): Adapter;\n\t/**\n\t * Sets the current adapter.\n\t * @param adapter - The new adapter.\n\t */\n\tset(adapter: Adapter): void;\n};\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n * @category environment\n * @advanced\n */\nexport function loadEnvironmentExtensions(skip: boolean): Promise<void>;\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n * @category environment\n * @advanced\n */\nexport function autoDetectEnvironment(add: boolean): Promise<void>;\n/**\n * This is an implementation of the {@link Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @category environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n * @advanced\n */\nexport const BrowserAdapter: Adapter;\n/**\n * Extension for the browser environment.\n * @category environment\n * @internal\n */\nexport const browserExt: {\n\textension: {\n\t\ttype: ExtensionType;\n\t\tname: string;\n\t\tpriority: number;\n\t};\n\ttest: () => boolean;\n\tload: () => Promise<void>;\n};\n/**\n * This is an implementation of the {@link Adapter} interface.\n * It can be used to make Pixi work in a Web Worker.\n * @category environment\n * @property {Function} createCanvas - Creates a canvas element of the given size using the browser's native OffscreenCanvas.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL of the worker, which is globalThis.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n * @category environment\n * @advanced\n */\nexport const WebWorkerAdapter: Adapter;\n/**\n * Extension for the webworker environment.\n * @category environment\n * @internal\n */\nexport const webworkerExt: {\n\textension: {\n\t\ttype: ExtensionType;\n\t\tname: string;\n\t\tpriority: number;\n\t};\n\ttest: () => boolean;\n\tload: () => Promise<void>;\n};\n/**\n * A simplified shape of an interactive object for the `eventTarget` property of a {@link FederatedEvent}\n * @category events\n * @deprecated since 8.1.4\n * @internal\n */\nexport interface FederatedEventTarget extends EventEmitter, EventTarget, Required<FederatedOptions> {\n\t/** The parent of this event target. */\n\treadonly parent?: FederatedEventTarget;\n\t/** The children of this event target. */\n\treadonly children?: ReadonlyArray<FederatedEventTarget>;\n\t_internalEventMode: EventMode;\n\t/** Returns true if the Container has interactive 'static' or 'dynamic' */\n\tisInteractive: () => boolean;\n\t/** Remove all listeners, or those of the specified event. */\n\tremoveAllListeners(event?: string | symbol): this;\n}\ndeclare class EventsTickerClass {\n\t/** The event system. */\n\tevents: EventSystem;\n\t/** The DOM element to listen to events on. */\n\tdomElement: HTMLElement;\n\t/** The frequency that fake events will be fired. */\n\tinteractionFrequency: number;\n\tprivate _deltaTime;\n\tprivate _didMove;\n\tprivate _tickerAdded;\n\tprivate _pauseUpdate;\n\t/**\n\t * Initializes the event ticker.\n\t * @param events - The event system.\n\t */\n\tinit(events: EventSystem): void;\n\t/** Whether to pause the update checks or not. */\n\tget pauseUpdate(): boolean;\n\tset pauseUpdate(paused: boolean);\n\t/** Adds the ticker listener. */\n\taddTickerListener(): void;\n\t/** Removes the ticker listener. */\n\tremoveTickerListener(): void;\n\t/** Sets flag to not fire extra events when the user has already moved there mouse */\n\tpointerMoved(): void;\n\t/** Updates the state of interactive objects. */\n\tprivate _update;\n\t/**\n\t * Updates the state of interactive objects if at least {@link interactionFrequency}\n\t * milliseconds have passed since the last invocation.\n\t *\n\t * Invoked by a throttled ticker update from {@link Ticker.system}.\n\t * @param ticker - The throttled ticker.\n\t */\n\tprivate _tickerUpdate;\n\t/** Destroys the event ticker. */\n\tdestroy(): void;\n}\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @category events\n * @class\n * @advanced\n */\nexport const EventsTicker: EventsTickerClass;\n/**\n * A helper object containing the hsl shader code for both glsl\n * @internal\n */\nexport const hslgl = \"\\n\\tfloat getLuminosity(vec3 c) {\\n\\t\\treturn 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\\n\\t}\\n\\n\\tvec3 setLuminosity(vec3 c, float lum) {\\n\\t\\tfloat modLum = lum - getLuminosity(c);\\n\\t\\tvec3 color = c.rgb + vec3(modLum);\\n\\n\\t\\t// clip back into legal range\\n\\t\\tmodLum = getLuminosity(color);\\n\\t\\tvec3 modLumVec = vec3(modLum);\\n\\n\\t\\tfloat cMin = min(color.r, min(color.g, color.b));\\n\\t\\tfloat cMax = max(color.r, max(color.g, color.b));\\n\\n\\t\\tif(cMin < 0.0) {\\n\\t\\t\\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\\n\\t\\t}\\n\\n\\t\\tif(cMax > 1.0) {\\n\\t\\t\\tcolor = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));\\n\\t\\t}\\n\\n\\t\\treturn color;\\n\\t}\\n\\n\\tfloat getSaturation(vec3 c) {\\n\\t\\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\\n\\t}\\n\\n\\tvec3 setSaturationMinMidMax(vec3 cSorted, float s) {\\n\\t\\tvec3 colorSorted = cSorted;\\n\\n\\t\\tif(colorSorted.z > colorSorted.x) {\\n\\t\\t\\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\\n\\t\\t\\tcolorSorted.z = s;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcolorSorted.y = 0.0;\\n\\t\\t\\tcolorSorted.z = 0.0;\\n\\t\\t}\\n\\n\\t\\tcolorSorted.x = 0.0;\\n\\n\\t\\treturn colorSorted;\\n\\t}\\n\\n\\tvec3 setSaturation(vec3 c, float s) {\\n\\t\\tvec3 color = c;\\n\\n\\t\\tif(color.r <= color.g && color.r <= color.b) {\\n\\t\\t\\tif(color.g <= color.b) {\\n\\t\\t\\t\\tcolor = setSaturationMinMidMax(color.rgb, s).rgb;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcolor = setSaturationMinMidMax(color.rbg, s).rbg;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if(color.g <= color.r && color.g <= color.b) {\\n\\t\\t\\tif(color.r <= color.b) {\\n\\t\\t\\t\\tcolor = setSaturationMinMidMax(color.grb, s).grb;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcolor = setSaturationMinMidMax(color.gbr, s).gbr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// Using bgr for both fixes part of hue\\n\\t\\t\\tif(color.r <= color.g) {\\n\\t\\t\\t\\tcolor = setSaturationMinMidMax(color.brg, s).brg;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcolor = setSaturationMinMidMax(color.bgr, s).bgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn color;\\n\\t}\\n    \";\n/**\n * A helper object containing the hsl shader code for wgsl\n * @internal\n */\nexport const hslgpu = \"\\n\\tfn getLuminosity(c: vec3<f32>) -> f32\\n\\t{\\n\\t\\treturn 0.3*c.r + 0.59*c.g + 0.11*c.b;\\n\\t}\\n\\n\\tfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>\\n\\t{\\n\\t\\tvar modLum: f32 = lum - getLuminosity(c);\\n\\t\\tvar color: vec3<f32> = c.rgb + modLum;\\n\\n\\t\\t// clip back into legal range\\n\\t\\tmodLum = getLuminosity(color);\\n\\t\\tlet modLumVec = vec3<f32>(modLum);\\n\\n\\t\\tlet cMin: f32 = min(color.r, min(color.g, color.b));\\n\\t\\tlet cMax: f32 = max(color.r, max(color.g, color.b));\\n\\n\\t\\tif(cMin < 0.0)\\n\\t\\t{\\n\\t\\t\\tcolor = mix(modLumVec, color, modLum / (modLum - cMin));\\n\\t\\t}\\n\\n\\t\\tif(cMax > 1.0)\\n\\t\\t{\\n\\t\\t\\tcolor = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));\\n\\t\\t}\\n\\n\\t\\treturn color;\\n\\t}\\n\\n\\tfn getSaturation(c: vec3<f32>) -> f32\\n\\t{\\n\\t\\treturn max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\\n\\t}\\n\\n\\tfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>\\n\\t{\\n\\t\\tvar colorSorted = cSorted;\\n\\n\\t\\tif(colorSorted.z > colorSorted.x)\\n\\t\\t{\\n\\t\\t\\tcolorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));\\n\\t\\t\\tcolorSorted.z = s;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcolorSorted.y = 0;\\n\\t\\t\\tcolorSorted.z = 0;\\n\\t\\t}\\n\\n\\t\\tcolorSorted.x = 0;\\n\\n\\t\\treturn colorSorted;\\n\\t}\\n\\n\\tfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>\\n\\t{\\n\\t\\tvar color = c;\\n\\n\\t\\tif (color.r <= color.g && color.r <= color.b)\\n\\t\\t{\\n\\t\\t\\tif (color.g <= color.b)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolor = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolor = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (color.g <= color.r && color.g <= color.b)\\n\\t\\t{\\n\\t\\t\\tif (color.r <= color.b)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolor = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolor = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// Using bgr for both fixes part of hue\\n\\t\\t\\tif (color.r <= color.g)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolor = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolor  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn color;\\n\\t}\\n\\t\";\n/**\n * Options for AlphaFilter\n * @category filters\n * @standard\n */\nexport interface AlphaFilterOptions extends FilterOptions {\n\t/**\n\t * Amount of alpha from 0 to 1, where 0 is transparent\n\t * @default 1\n\t */\n\talpha: number;\n}\n/**\n * Simplest filter - applies alpha.\n *\n * Use this instead of Container's alpha property to avoid visual layering of individual elements.\n * AlphaFilter applies alpha evenly across the entire display object and any opaque elements it contains.\n * If elements are not opaque, they will blend with each other anyway.\n *\n * Very handy if you want to use common features of all filters:\n *\n * 1. Assign a blendMode to this filter, blend all elements inside display object with background.\n *\n * 2. To use clipping in display coordinates, assign a filterArea to the same container that has this filter.\n * @category filters\n * @standard\n * @noInheritDoc\n * @example\n * import { AlphaFilter } from 'pixi.js';\n *\n * const filter = new AlphaFilter({ alpha: 0.5 });\n * sprite.filters = filter;\n *\n * // update alpha\n * filter.alpha = 0.8;\n */\nexport class AlphaFilter extends Filter {\n\t/**\n\t * Default options for the AlphaFilter.\n\t * @example\n\t * ```ts\n\t * AlphaFilter.defaultOptions = {\n\t *     alpha: 0.5, // Default alpha value\n\t * };\n\t * // Use default options\n\t * const filter = new AlphaFilter(); // Uses default alpha of 0.5\n\t * ```\n\t */\n\tstatic defaultOptions: AlphaFilterOptions;\n\tconstructor(options?: AlphaFilterOptions);\n\t/**\n\t * The alpha value of the filter.\n\t * Controls the transparency of the filtered display object.\n\t * @example\n\t * ```ts\n\t * // Create filter with initial alpha\n\t * const filter = new AlphaFilter({ alpha: 0.5 });\n\t *\n\t * // Update alpha value dynamically\n\t * filter.alpha = 0.8;\n\t * ```\n\t * @default 1\n\t * @remarks\n\t * - 0 = fully transparent\n\t * - 1 = fully opaque\n\t * - Values are clamped between 0 and 1\n\t */\n\tget alpha(): number;\n\tset alpha(value: number);\n}\n/**\n * Options for BlurFilterPass\n * @category filters\n * @internal\n */\nexport interface BlurFilterPassOptions extends BlurFilterOptions {\n\t/** Do pass along the x-axis (`true`) or y-axis (`false`). */\n\thorizontal: boolean;\n}\n/**\n * The BlurFilterPass applies a horizontal or vertical Gaussian blur to an object.\n * @category filters\n * @advanced\n * @example\n * import { BlurFilterPass } from 'pixi.js';\n *\n * const filter = new BlurFilterPass({ horizontal: true, strength: 8 });\n * sprite.filters = filter;\n *\n * // update blur\n * filter.blur = 16;\n */\nexport class BlurFilterPass extends Filter {\n\t/** Default blur filter pass options */\n\tstatic defaultOptions: Partial<BlurFilterPassOptions>;\n\t/** Do pass along the x-axis (`true`) or y-axis (`false`). */\n\thorizontal: boolean;\n\t/** The number of passes to run the filter. */\n\tpasses: number;\n\t/** The strength of the blur filter. */\n\tstrength: number;\n\tprivate _quality;\n\tprivate readonly _uniforms;\n\t/**\n\t * @param options\n\t * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n\t * @param options.strength - The strength of the blur filter.\n\t * @param options.quality - The quality of the blur filter.\n\t * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n\t */\n\tconstructor(options: BlurFilterPassOptions);\n\t/**\n\t * Applies the filter.\n\t * @param filterManager - The manager.\n\t * @param input - The input target.\n\t * @param output - The output target.\n\t * @param clearMode - How to clear\n\t */\n\tapply(filterManager: FilterSystem, input: Texture, output: RenderSurface, clearMode: boolean): void;\n\t/**\n\t * Sets the strength of both the blur.\n\t * @default 16\n\t */\n\tget blur(): number;\n\tset blur(value: number);\n\t/**\n\t * Sets the quality of the blur by modifying the number of passes. More passes means higher\n\t * quality blurring but the lower the performance.\n\t * @default 4\n\t */\n\tget quality(): number;\n\tset quality(value: number);\n}\n/**\n * Configuration options for the BlurFilter.\n * Controls how the Gaussian blur effect is applied.\n * @example\n * ```ts\n * // Basic blur with default values\n * const filter = new BlurFilter();\n *\n * // Custom blur configuration\n * const filter = new BlurFilter({\n *     strength: 8,        // Overall blur strength\n *     quality: 4,         // Higher quality = better blur\n *     kernelSize: 5      // Size of blur kernel\n * });\n *\n * // Different horizontal/vertical blur\n * const filter = new BlurFilter({\n *     strengthX: 4,      // Horizontal blur only\n *     strengthY: 12,     // Stronger vertical blur\n *     quality: 2         // Lower quality for better performance\n * });\n * ```\n * @remarks\n * - Higher quality values produce better blur but impact performance\n * - KernelSize affects blur precision and performance\n * - Strength values determine blur intensity\n * @see {@link BlurFilter} The filter that uses these options\n * @see {@link FilterOptions} Base filter options\n * @category filters\n * @standard\n */\nexport interface BlurFilterOptions extends FilterOptions {\n\t/**\n\t * The strength of the blur filter.\n\t * Applied to both horizontal and vertical blur if strengthX/Y not set.\n\t * @default 8\n\t */\n\tstrength?: number;\n\t/**\n\t * The horizontal strength of the blur.\n\t * Overrides strength parameter for x-axis.\n\t * @default 8\n\t */\n\tstrengthX?: number;\n\t/**\n\t * The vertical strength of the blur.\n\t * Overrides strength parameter for y-axis.\n\t * @default 8\n\t */\n\tstrengthY?: number;\n\t/**\n\t * The quality of the blur filter.\n\t * Higher values mean better quality but slower performance.\n\t * @default 4\n\t */\n\tquality?: number;\n\t/**\n\t * The kernelSize of the blur filter.\n\t * Larger values create more precise blur but impact performance.\n\t * Options: 5, 7, 9, 11, 13, 15.\n\t * @default 5\n\t */\n\tkernelSize?: number;\n}\n/**\n * The BlurFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for the x-axis and y-axis separately.\n * @example\n * ```ts\n * import { BlurFilter } from 'pixi.js';\n *\n * // Create with default settings\n * const filter = new BlurFilter();\n *\n * // Create with custom settings\n * const filter = new BlurFilter({\n *     strength: 8,      // Overall blur strength\n *     quality: 4,       // Blur quality (higher = better but slower)\n *     kernelSize: 5     // Size of blur kernel matrix\n * });\n *\n * // Apply to a display object\n * sprite.filters = [filter];\n *\n * // Update properties\n * filter.strength = 10;          // Set both X and Y blur\n * filter.strengthX = 5;          // Set only horizontal blur\n * filter.strengthY = 15;         // Set only vertical blur\n * filter.quality = 2;            // Adjust quality\n *\n * // Enable edge pixel clamping\n * filter.repeatEdgePixels = true;\n * ```\n * @remarks\n * - Higher quality values produce better blur but impact performance\n * - Strength controls blur intensity independently for X and Y\n * - Can be optimized using quality and kernelSize settings\n * - Supports edge pixel clamping for special effects\n * @see {@link BlurFilterPass} For single-direction blur\n * @see {@link FilterOptions} For base filter options\n * @category filters\n * @standard\n * @noInheritDoc\n */\nexport class BlurFilter extends Filter {\n\t/**\n\t * Default blur filter options\n\t * @example\n\t * ```ts\n\t * // Set default options for all BlurFilters\n\t * BlurFilter.defaultOptions = {\n\t *     strength: 10,       // Default blur strength\n\t *     quality: 2,        // Default blur quality\n\t *     kernelSize: 7      // Default kernel size\n\t * };\n\t * // Create a filter with these defaults\n\t * const filter = new BlurFilter(); // Uses default options\n\t * ```\n\t * @remarks\n\t * - These options are used when creating a new BlurFilter without specific parameters\n\t * - Can be overridden by passing options to the constructor\n\t * - Useful for setting global defaults for all blur filters in your application\n\t * @see {@link BlurFilterOptions} For detailed options\n\t * @see {@link BlurFilter} The filter that uses these options\n\t */\n\tstatic defaultOptions: Partial<BlurFilterOptions>;\n\t/**\n\t * The horizontal blur filter\n\t * @advanced\n\t */\n\tblurXFilter: BlurFilterPass;\n\t/**\n\t * The vertical blur filter\n\t * @advanced\n\t */\n\tblurYFilter: BlurFilterPass;\n\tprivate _repeatEdgePixels;\n\t/**\n\t * @param {filters.BlurFilterOptions} options - The options of the blur filter.\n\t */\n\tconstructor(options?: BlurFilterOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(strength?: number, quality?: number, resolution?: number | null, kernelSize?: number);\n\t/**\n\t * Applies the filter.\n\t * @param filterManager - The manager.\n\t * @param input - The input target.\n\t * @param output - The output target.\n\t * @param clearMode - How to clear\n\t * @advanced\n\t */\n\tapply(filterManager: FilterSystem, input: Texture, output: RenderSurface, clearMode: boolean): void;\n\tprotected updatePadding(): void;\n\t/**\n\t * Sets the strength of both the blurX and blurY properties simultaneously.\n\t * Controls the overall intensity of the Gaussian blur effect.\n\t * @example\n\t * ```ts\n\t * // Set equal blur strength for both axes\n\t * filter.strength = 8;\n\t *\n\t * // Will throw error if X and Y are different\n\t * filter.strengthX = 4;\n\t * filter.strengthY = 8;\n\t * filter.strength; // Error: BlurFilter's strengthX and strengthY are different\n\t * ```\n\t * @default 8\n\t * @throws {Error} If strengthX and strengthY are different values\n\t */\n\tget strength(): number;\n\tset strength(value: number);\n\t/**\n\t * Sets the number of passes for blur. More passes means higher quality blurring.\n\t * Controls the precision and smoothness of the blur effect at the cost of performance.\n\t * @example\n\t * ```ts\n\t * // High quality blur (slower)\n\t * filter.quality = 8;\n\t *\n\t * // Low quality blur (faster)\n\t * filter.quality = 2;\n\t * ```\n\t * @default 4\n\t * @remarks Higher values produce better quality but impact performance\n\t */\n\tget quality(): number;\n\tset quality(value: number);\n\t/**\n\t * Sets the strength of horizontal blur.\n\t * Controls the blur intensity along the x-axis independently.\n\t * @example\n\t * ```ts\n\t * // Apply horizontal-only blur\n\t * filter.strengthX = 8;\n\t * filter.strengthY = 0;\n\t *\n\t * // Create motion blur effect\n\t * filter.strengthX = 16;\n\t * filter.strengthY = 2;\n\t * ```\n\t * @default 8\n\t */\n\tget strengthX(): number;\n\tset strengthX(value: number);\n\t/**\n\t * Sets the strength of the vertical blur.\n\t * Controls the blur intensity along the y-axis independently.\n\t * @example\n\t * ```ts\n\t * // Apply vertical-only blur\n\t * filter.strengthX = 0;\n\t * filter.strengthY = 8;\n\t *\n\t * // Create radial blur effect\n\t * filter.strengthX = 8;\n\t * filter.strengthY = 8;\n\t * ```\n\t * @default 8\n\t */\n\tget strengthY(): number;\n\tset strengthY(value: number);\n\t/**\n\t * Sets the strength of both the blurX and blurY properties simultaneously\n\t * @default 2\n\t * @deprecated since 8.3.0\n\t * @see BlurFilter.strength\n\t */\n\tget blur(): number;\n\tset blur(value: number);\n\t/**\n\t * Sets the strength of the blurX property\n\t * @default 2\n\t * @deprecated since 8.3.0\n\t * @see BlurFilter.strengthX\n\t */\n\tget blurX(): number;\n\tset blurX(value: number);\n\t/**\n\t * Sets the strength of the blurY property\n\t * @default 2\n\t * @deprecated since 8.3.0\n\t * @see BlurFilter.strengthY\n\t */\n\tget blurY(): number;\n\tset blurY(value: number);\n\t/**\n\t * If set to true the edge of the target will be clamped\n\t * @default false\n\t */\n\tget repeatEdgePixels(): boolean;\n\tset repeatEdgePixels(value: boolean);\n}\ninterface IGAUSSIAN_VALUES {\n\t[x: number]: number[];\n}\n/** @internal */\nexport const GAUSSIAN_VALUES: IGAUSSIAN_VALUES;\n/**\n * @internal\n * @param kernelSize - The size of the kernel.\n */\nexport function generateBlurFragSource(kernelSize: number): string;\n/**\n * @internal\n * @param horizontal - Whether to generate a horizontal or vertical blur program.\n * @param kernelSize - The size of the kernel.\n */\nexport function generateBlurGlProgram(horizontal: boolean, kernelSize: number): GlProgram;\n/**\n * @internal\n * @param kernelSize - The size of the kernel.\n * @param x - Whether to generate a horizontal or vertical blur program.\n */\nexport function generateBlurVertSource(kernelSize: number, x: boolean): string;\n/**\n * @internal\n * @param horizontal - Whether to generate a horizontal or vertical blur program.\n * @param kernelSize - The size of the kernel.\n */\nexport function generateBlurProgram(horizontal: boolean, kernelSize: number): GpuProgram;\n/**\n * 5x4 matrix for transforming RGBA color and alpha\n * @category filters\n * @standard\n */\nexport type ColorMatrix = ArrayFixed<number, 20>;\n/**\n * The ColorMatrixFilter class lets you apply color transformations to display objects using a 5x4 matrix.\n * The matrix transforms the RGBA color and alpha values of every pixel to produce a new set of values.\n *\n * The class provides convenient methods for common color adjustments like brightness, contrast, saturation,\n * and various photo filter effects.\n * @example\n * ```js\n * import { ColorMatrixFilter } from 'pixi.js';\n *\n * // Create a new color matrix filter\n * const colorMatrix = new ColorMatrixFilter();\n *\n * // Apply it to a container\n * container.filters = [colorMatrix];\n *\n * // Adjust contrast\n * colorMatrix.contrast(2);\n *\n * // Chain multiple effects\n * colorMatrix\n *     .saturate(0.5)     // 50% saturation\n *     .brightness(1.2)    // 20% brighter\n *     .hue(90);          // 90 degree hue rotation\n * ```\n *\n * Common use cases:\n * - Adjusting brightness, contrast, or saturation\n * - Applying color tints or color grading\n * - Creating photo filter effects (sepia, negative, etc.)\n * - Converting to grayscale\n * - Implementing dynamic day/night transitions\n * @author Clment Chenebault <clement@goodboydigital.com>\n * @category filters\n * @standard\n * @noInheritDoc\n */\nexport class ColorMatrixFilter extends Filter {\n\tconstructor(options?: FilterOptions);\n\t/**\n\t * Transforms current matrix and set the new one\n\t * @param {number[]} matrix - 5x4 matrix\n\t * @param multiply - if true, current matrix and matrix are multiplied. If false,\n\t *  just set the current matrix with matrix\n\t */\n\tprivate _loadMatrix;\n\t/**\n\t * Multiplies two mat5's\n\t * @private\n\t * @param out - 5x4 matrix the receiving matrix\n\t * @param a - 5x4 matrix the first operand\n\t * @param b - 5x4 matrix the second operand\n\t * @returns {number[]} 5x4 matrix\n\t */\n\tprivate _multiply;\n\t/**\n\t * Create a Float32 Array and normalize the offset component to 0-1\n\t * @param {number[]} matrix - 5x4 matrix\n\t * @returns {number[]} 5x4 matrix with all values between 0-1\n\t */\n\tprivate _colorMatrix;\n\t/**\n\t * Adjusts the brightness of a display object.\n\t *\n\t * The brightness adjustment works by multiplying the RGB channels by a scalar value while keeping\n\t * the alpha channel unchanged. Values below 1 darken the image, while values above 1 brighten it.\n\t * @param b - The brightness multiplier to apply. Values between 0-1 darken the image (0 being black),\n\t *           while values > 1 brighten it (2.0 would make it twice as bright)\n\t * @param multiply - When true, the new matrix is multiplied with the current one instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * // Create a new color matrix filter\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Darken the image to 50% brightness\n\t * colorMatrix.brightness(0.5, false);\n\t *\n\t * // Chain with other effects by using multiply\n\t * colorMatrix\n\t *     .brightness(1.2, true)  // Brighten by 20%\n\t *     .saturate(1.1, true);   // Increase saturation by 10%\n\t * ```\n\t */\n\tbrightness(b: number, multiply: boolean): void;\n\t/**\n\t * Sets each channel on the diagonal of the color matrix to apply a color tint.\n\t *\n\t * This method provides a way to tint display objects using the color matrix filter, similar to\n\t * the tint property available on Sprites and other display objects. The tint is applied by\n\t * scaling the RGB channels of each pixel.\n\t * @param color - The color to use for tinting, this can be any valid color source.\n\t * @param multiply - When true, the new tint matrix is multiplied with the current matrix instead\n\t *                  of replacing it. This allows for combining tints with other color effects.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply a red tint\n\t * colorMatrix.tint(0xff0000);\n\t *\n\t * // Layer a green tint on top of existing effects\n\t * colorMatrix.tint('green', true);\n\t *\n\t * // Chain with other color adjustments\n\t * colorMatrix\n\t *     .tint('blue')       // Blue tint\n\t *     .brightness(1.2, true) // Increase brightness\n\t * ```\n\t */\n\ttint(color: ColorSource, multiply?: boolean): void;\n\t/**\n\t * Converts the display object to greyscale by applying a weighted matrix transformation.\n\t *\n\t * The greyscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n\t * effectively removing color information while preserving luminance.\n\t * @param scale - The intensity of the greyscale effect. Value between 0-1, where:\n\t *               - 0 produces black\n\t *               - 0.5 produces 50% grey\n\t *               - 1 produces white\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert to 50% grey\n\t * colorMatrix.greyscale(0.5, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .greyscale(0.6, true)    // Add grey tint\n\t *     .brightness(1.2, true);   // Brighten the result\n\t * ```\n\t */\n\tgreyscale(scale: number, multiply: boolean): void;\n\t/**\n\t * Converts the display object to grayscale by applying a weighted matrix transformation.\n\t *\n\t * The grayscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n\t * effectively removing color information while preserving luminance.\n\t * @param scale - The intensity of the grayscale effect. Value between 0-1, where:\n\t *               - 0 produces black\n\t *               - 0.5 produces 50% grey\n\t *               - 1 produces white\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert to 50% grey\n\t * colorMatrix.grayscale(0.5, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .grayscale(0.6, true)    // Add grey tint\n\t *     .brightness(1.2, true);   // Brighten the result\n\t * ```\n\t */\n\tgrayscale(scale: number, multiply: boolean): void;\n\t/**\n\t * Converts the display object to pure black and white using a luminance-based threshold.\n\t *\n\t * This method applies a matrix transformation that removes all color information and reduces\n\t * the image to just black and white values based on the luminance of each pixel. The transformation\n\t * uses standard luminance weightings: 30% red, 60% green, and 10% blue.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert to black and white\n\t * colorMatrix.blackAndWhite(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .blackAndWhite(true)     // Apply B&W effect\n\t *     .brightness(1.2, true);   // Then increase brightness\n\t * ```\n\t */\n\tblackAndWhite(multiply: boolean): void;\n\t/**\n\t * Adjusts the hue of the display object by rotating the color values around the color wheel.\n\t *\n\t * This method uses an optimized matrix transformation that accurately rotates the RGB color space\n\t * around its luminance axis. The implementation is based on RGB cube rotation in 3D space, providing\n\t * better results than traditional matrices with magic luminance constants.\n\t * @param rotation - The angle of rotation in degrees around the color wheel:\n\t *                  - 0 = no change\n\t *                  - 90 = rotate colors 90 clockwise\n\t *                  - 180 = invert all colors\n\t *                  - 270 = rotate colors 90 counter-clockwise\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Rotate hue by 90 degrees\n\t * colorMatrix.hue(90, false);\n\t *\n\t * // Chain multiple color adjustments\n\t * colorMatrix\n\t *     .hue(45, true)          // Rotate colors by 45\n\t *     .saturate(1.2, true)    // Increase saturation\n\t *     .brightness(1.1, true); // Slightly brighten\n\t * ```\n\t */\n\thue(rotation: number, multiply: boolean): void;\n\t/**\n\t * Adjusts the contrast of the display object by modifying the separation between dark and bright values.\n\t *\n\t * This method applies a matrix transformation that affects the difference between dark and light areas\n\t * in the image. Increasing contrast makes shadows darker and highlights brighter, while decreasing\n\t * contrast brings shadows up and highlights down, reducing the overall dynamic range.\n\t * @param amount - The contrast adjustment value. Range is 0 to 1, where:\n\t *                - 0 represents minimum contrast (flat gray)\n\t *                - 0.5 represents normal contrast\n\t *                - 1 represents maximum contrast\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Increase contrast by 50%\n\t * colorMatrix.contrast(0.75, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .contrast(0.6, true)     // Boost contrast\n\t *     .brightness(1.1, true)   // Slightly brighten\n\t *     .saturate(1.2, true);    // Increase color intensity\n\t * ```\n\t */\n\tcontrast(amount: number, multiply: boolean): void;\n\t/**\n\t * Adjusts the saturation of the display object by modifying color separation.\n\t *\n\t * This method applies a matrix transformation that affects the intensity of colors.\n\t * Increasing saturation makes colors more vivid and intense, while decreasing saturation\n\t * moves colors toward grayscale.\n\t * @param amount - The saturation adjustment value. Range is -1 to 1, where:\n\t *                - -1 produces grayscale\n\t *                - 0 represents no change\n\t *                - 1 produces maximum saturation\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Double the saturation\n\t * colorMatrix.saturate(1, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .saturate(0.5, true)     // Increase saturation by 50%\n\t *     .brightness(1.1, true)    // Slightly brighten\n\t *     .contrast(0.8, true);     // Reduce contrast\n\t * ```\n\t */\n\tsaturate(amount?: number, multiply?: boolean): void;\n\t/**\n\t * Completely removes color information from the display object, creating a grayscale version.\n\t *\n\t * This is a convenience method that calls `saturate(-1)` internally. The transformation preserves\n\t * the luminance of the original image while removing all color information.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert image to grayscale\n\t * colorMatrix.desaturate();\n\t *\n\t * // Can be chained with other effects\n\t * colorMatrix\n\t *     .desaturate()         // Remove all color\n\t *     .brightness(1.2);     // Then increase brightness\n\t * ```\n\t */\n\tdesaturate(): void;\n\t/**\n\t * Creates a negative effect by inverting all colors in the display object.\n\t *\n\t * This method applies a matrix transformation that inverts the RGB values of each pixel\n\t * while preserving the alpha channel. The result is similar to a photographic negative.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Create negative effect\n\t * colorMatrix.negative(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .negative(true)       // Apply negative effect\n\t *     .brightness(1.2, true) // Increase brightness\n\t *     .contrast(0.8, true);  // Reduce contrast\n\t * ```\n\t */\n\tnegative(multiply: boolean): void;\n\t/**\n\t * Applies a sepia tone effect to the display object, creating a warm brown tint reminiscent of vintage photographs.\n\t *\n\t * This method applies a matrix transformation that converts colors to various shades of brown while\n\t * preserving the original luminance values.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply sepia effect\n\t * colorMatrix.sepia(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .sepia(true)           // Add sepia tone\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(0.9, true);   // Reduce contrast\n\t * ```\n\t */\n\tsepia(multiply: boolean): void;\n\t/**\n\t * Applies a Technicolor-style effect that simulates the early color motion picture process.\n\t *\n\t * This method applies a matrix transformation that recreates the distinctive look of the\n\t * Technicolor process. The effect produces highly\n\t * saturated colors with a particular emphasis on reds, greens, and blues.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply Technicolor effect\n\t * colorMatrix.technicolor(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .technicolor(true)      // Add Technicolor effect\n\t *     .contrast(1.1, true)    // Boost contrast\n\t *     .brightness(0.9, true); // Slightly darken\n\t * ```\n\t */\n\ttechnicolor(multiply: boolean): void;\n\t/**\n\t * Applies a vintage Polaroid camera effect to the display object.\n\t *\n\t * This method applies a matrix transformation that simulates the distinctive look of\n\t * Polaroid instant photographs, characterized by slightly enhanced contrast, subtle color shifts,\n\t * and a warm overall tone.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply Polaroid effect\n\t * colorMatrix.polaroid(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .polaroid(true)         // Add Polaroid effect\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(1.1, true);   // Boost contrast\n\t * ```\n\t */\n\tpolaroid(multiply: boolean): void;\n\t/**\n\t * Swaps the red and blue color channels in the display object.\n\t *\n\t * This method applies a matrix transformation that exchanges the red and blue color values\n\t * while keeping the green channel and alpha unchanged.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Swap red and blue channels\n\t * colorMatrix.toBGR(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .toBGR(true)           // Swap R and B channels\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(0.9, true);   // Reduce contrast\n\t * ```\n\t */\n\ttoBGR(multiply: boolean): void;\n\t/**\n\t * Applies a Kodachrome color effect that simulates the iconic film stock.\n\t *\n\t * This method applies a matrix transformation that recreates the distinctive look of Kodachrome film,\n\t * known for its rich, vibrant colors and excellent image preservation qualities. The effect emphasizes\n\t * reds and blues while producing deep, true blacks.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply Kodachrome effect\n\t * colorMatrix.kodachrome(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .kodachrome(true)       // Add Kodachrome effect\n\t *     .contrast(1.1, true)    // Boost contrast\n\t *     .brightness(0.9, true); // Slightly darken\n\t * ```\n\t */\n\tkodachrome(multiply: boolean): void;\n\t/**\n\t * Applies a stylized brown-tinted effect to the display object.\n\t *\n\t * This method applies a matrix transformation that creates a rich, warm brown tone\n\t * with enhanced contrast and subtle color shifts.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply browni effect\n\t * colorMatrix.browni(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .browni(true)          // Add brown tint\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(1.2, true);   // Boost contrast\n\t * ```\n\t */\n\tbrowni(multiply: boolean): void;\n\t/**\n\t * Applies a vintage photo effect that simulates old photography techniques.\n\t *\n\t * This method applies a matrix transformation that creates a nostalgic, aged look\n\t * with muted colors, enhanced warmth, and subtle vignetting.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply vintage effect\n\t * colorMatrix.vintage(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .vintage(true)          // Add vintage look\n\t *     .brightness(0.9, true)  // Slightly darken\n\t *     .contrast(1.1, true);   // Boost contrast\n\t * ```\n\t */\n\tvintage(multiply: boolean): void;\n\t/**\n\t * We don't know exactly what it does, kind of gradient map, but funny to play with!\n\t * @param desaturation - Tone values.\n\t * @param toned - Tone values.\n\t * @param lightColor - Tone values, example: `0xFFE580`\n\t * @param darkColor - Tone values, example: `0xFFE580`\n\t * @param multiply - if true, current matrix and matrix are multiplied. If false,\n\t *  just set the current matrix with matrix\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Create sepia-like effect with custom colors\n\t * colorMatrix.colorTone(\n\t *     0.3,        // Moderate desaturation\n\t *     0.2,        // Moderate toning\n\t *     0xFFE580,   // Warm highlight color\n\t *     0x338000,   // Dark green shadows\n\t *     false\n\t * );\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .colorTone(0.2, 0.15, 0xFFE580, 0x338000, true)\n\t *     .brightness(1.1, true);  // Slightly brighten\n\t * ```\n\t */\n\tcolorTone(desaturation: number, toned: number, lightColor: ColorSource, darkColor: ColorSource, multiply: boolean): void;\n\t/**\n\t * Applies a night vision effect to the display object.\n\t *\n\t * This method applies a matrix transformation that simulates night vision by enhancing\n\t * certain color channels while suppressing others, creating a green-tinted effect\n\t * similar to night vision goggles.\n\t * @param intensity - The intensity of the night effect (0-1):\n\t *                   - 0 produces no effect\n\t *                   - 0.1 produces a subtle night vision effect (default)\n\t *                   - 1 produces maximum night vision effect\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply night vision effect\n\t * colorMatrix.night(0.3, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .night(0.2, true)        // Add night vision\n\t *     .brightness(1.1, true)    // Slightly brighten\n\t *     .contrast(1.2, true);     // Boost contrast\n\t * ```\n\t */\n\tnight(intensity: number, multiply: boolean): void;\n\t/**\n\t * Predator effect\n\t *\n\t * Erase the current matrix by setting a new independent one\n\t * @param amount - how much the predator feels his future victim\n\t * @param multiply - if true, current matrix and matrix are multiplied. If false,\n\t *  just set the current matrix with matrix\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply thermal vision effect\n\t * colorMatrix.predator(0.5, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .predator(0.3, true)      // Add thermal effect\n\t *     .contrast(1.2, true)      // Boost contrast\n\t *     .brightness(1.1, true);   // Slightly brighten\n\t * ```\n\t */\n\tpredator(amount: number, multiply: boolean): void;\n\t/**\n\t * Applies a psychedelic color effect that creates dramatic color shifts.\n\t *\n\t * This method applies a matrix transformation that produces vibrant colors\n\t * through channel mixing and amplification. Creates an effect reminiscent of\n\t * color distortions in psychedelic art.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply psychedelic effect\n\t * colorMatrix.lsd(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .lsd(true)             // Add color distortion\n\t *     .brightness(0.9, true)  // Slightly darken\n\t *     .contrast(1.2, true);   // Boost contrast\n\t * ```\n\t */\n\tlsd(multiply: boolean): void;\n\t/**\n\t * Resets the color matrix filter to its default state.\n\t *\n\t * This method resets all color transformations by setting the matrix back to its identity state.\n\t * The identity matrix leaves colors unchanged, effectively removing all previously applied effects.\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply some effects\n\t * colorMatrix\n\t *     .sepia(true)\n\t *     .brightness(1.2, true);\n\t *\n\t * // Reset back to original colors\n\t * colorMatrix.reset();\n\t * ```\n\t */\n\treset(): void;\n\t/**\n\t * The current color transformation matrix of the filter.\n\t *\n\t * This 5x4 matrix transforms RGBA color and alpha values of each pixel. The matrix is stored\n\t * as a 20-element array in row-major order.\n\t * @type {ColorMatrix}\n\t * @default [\n\t *     1, 0, 0, 0, 0,  // Red channel\n\t *     0, 1, 0, 0, 0,  // Green channel\n\t *     0, 0, 1, 0, 0,  // Blue channel\n\t *     0, 0, 0, 1, 0   // Alpha channel\n\t * ]\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t * // Get the current color matrix\n\t * const currentMatrix = colorMatrix.matrix;\n\t * // Modify the matrix\n\t * colorMatrix.matrix = [\n\t *     1, 0, 0, 0, 0,\n\t *     0, 1, 0, 0, 0,\n\t *     0, 0, 1, 0, 0,\n\t *     0, 0, 0, 1, 0\n\t * ];\n\t */\n\tget matrix(): ColorMatrix;\n\tset matrix(value: ColorMatrix);\n\t/**\n\t * The opacity value used to blend between the original and transformed colors.\n\t *\n\t * This value controls how much of the color transformation is applied:\n\t * - 0 = Original color only (no effect)\n\t * - 0.5 = 50% blend of original and transformed colors\n\t * - 1 = Fully transformed color (default)\n\t * @default 1\n\t * @example\n\t * ```ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply sepia at 50% strength\n\t * colorMatrix.sepia(false);\n\t * colorMatrix.alpha = 0.5;\n\t *\n\t * // Fade between effects\n\t * colorMatrix\n\t *     .saturate(1.5)      // Increase saturation\n\t *     .contrast(1.2);     // Boost contrast\n\t * colorMatrix.alpha = 0.7; // Apply at 70% strength\n\t * ```\n\t */\n\tget alpha(): number;\n\tset alpha(value: number);\n}\n/**\n * Configuration options for the DisplacementFilter.\n *\n * A displacement filter uses a sprite's texture as a displacement map,\n * moving pixels of the target based on the color values of corresponding\n * pixels in the displacement sprite.\n * @example\n * ```ts\n * const options: DisplacementFilterOptions = {\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * };\n *\n * const filter = new DisplacementFilter(options);\n * ```\n * @category filters\n * @standard\n */\nexport interface DisplacementFilterOptions extends FilterOptions {\n\t/**\n\t * The sprite whose texture will be used as the displacement map.\n\t * Red channel = horizontal displacement\n\t * Green channel = vertical displacement\n\t * @example\n\t * ```ts\n\t * const displacementSprite = new Sprite(texture);\n\t * const filter = new DisplacementFilter({ sprite: displacementSprite });\n\t * ```\n\t */\n\tsprite: Sprite;\n\t/**\n\t * The scale of the displacement effect. Can be a single number for uniform\n\t * scaling or a point-like object for separate x/y scaling.\n\t * @default 20\n\t * @example\n\t * ```ts\n\t * // Uniform scaling\n\t * new DisplacementFilter({ sprite, scale: 20 });\n\t * // Separate scaling\n\t * new DisplacementFilter({ sprite, scale: { x: 10, y: 15 } });\n\t * ```\n\t */\n\tscale?: number | PointData;\n}\n/**\n * A filter that applies a displacement map effect using a sprite's texture.\n *\n * The DisplacementFilter uses another texture (from a sprite) as a displacement map,\n * where the red and green channels of each pixel in the map determine how the corresponding\n * pixel in the filtered object should be offset:\n * - Red channel controls horizontal displacement\n * - Green channel controls vertical displacement\n *\n * Common use cases:\n * - Creating ripple or wave effects\n * - Distorting images dynamically\n * - Implementing heat haze effects\n * - Creating transition effects\n * @example\n * ```ts\n * import { Sprite, DisplacementFilter } from 'pixi.js';\n *\n * // Create a sprite to use as the displacement map\n * const displacementSprite = Sprite.from('displacement-map.png');\n *\n * // Create and configure the filter\n * const displacementFilter = new DisplacementFilter({\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * });\n *\n * // Apply to any display object\n * container.filters = [displacementFilter];\n * ```\n * @category filters\n * @author Vico: vicocotea\n * @standard\n * @noInheritDoc\n */\nexport class DisplacementFilter extends Filter {\n\tprivate readonly _sprite;\n\t/**\n\t * @param {Sprite | DisplacementFilterOptions} options - The sprite or options object.\n\t * @param {Sprite} options.sprite - The texture used for the displacement map.\n\t * @param {number | PointData} options.scale - The scale of the displacement.\n\t */\n\tconstructor(options: Sprite | DisplacementFilterOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(sprite: Sprite, scale?: number | PointData);\n\t/**\n\t * Applies the filter.\n\t * @param filterManager - The manager.\n\t * @param input - The input target.\n\t * @param output - The output target.\n\t * @param clearMode - clearMode.\n\t * @advanced\n\t */\n\tapply(filterManager: FilterSystem, input: Texture, output: Texture, clearMode: boolean): void;\n\t/**\n\t * The scale of the displacement effect.\n\t *\n\t * Gets the current x and y scaling values used for the displacement mapping.\n\t * - x: Horizontal displacement scale\n\t * - y: Vertical displacement scale\n\t * @returns {Point} The current scale as a Point object\n\t * @example\n\t * ```ts\n\t * const filter = new DisplacementFilter({ sprite });\n\t *\n\t * // Get current scale\n\t * console.log(filter.scale.x, filter.scale.y);\n\t *\n\t * // Update scale\n\t * filter.scale.x = 100;\n\t * filter.scale.y = 50;\n\t * ```\n\t */\n\tget scale(): Point;\n}\n/**\n * Configuration options for the NoiseFilter.\n *\n * The NoiseFilter adds random noise to the rendered content. The noise effect can be\n * controlled through the noise intensity and an optional seed value for reproducible results.\n * @example\n * ```ts\n * // Basic noise effect\n * const options: NoiseFilterOptions = {\n *     noise: 0.5,\n *     seed: Math.random()\n * };\n *\n * // Create filter with options\n * const noiseFilter = new NoiseFilter(options);\n * ```\n * @category filters\n * @standard\n */\nexport interface NoiseFilterOptions extends FilterOptions {\n\t/**\n\t * The amount of noise to apply. Should be in range (0, 1]:\n\t * - 0.1 = subtle noise\n\t * - 0.5 = moderate noise (default)\n\t * - 1.0 = maximum noise\n\t * @default 0.5\n\t * @example\n\t * ```ts\n\t * // Moderate noise effect\n\t * const noiseFilter = new NoiseFilter({ noise: 0.5 });\n\t * ```\n\t */\n\tnoise?: number;\n\t/**\n\t * A seed value to apply to the random noise generation.\n\t * Using the same seed will generate the same noise pattern.\n\t * @default Math.random()\n\t * @example\n\t * ```ts\n\t * // Using a fixed seed for reproducible noise\n\t * const noiseFilter = new NoiseFilter({ seed: 12345 });\n\t * ```\n\t */\n\tseed?: number;\n}\n/**\n * A filter that adds configurable random noise to rendered content.\n *\n * This filter generates pixel noise based on a noise intensity value and an optional seed.\n * It can be used to create various effects like film grain, static, or texture variation.\n *\n * Based on: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\n * @example\n * ```ts\n * import { NoiseFilter } from 'pixi.js';\n *\n * // Create with options\n * const filter = new NoiseFilter({\n *     noise: 0.5,    // 50% noise intensity\n *     seed: 12345    // Fixed seed for consistent noise\n * });\n *\n * // Apply to a display object\n * sprite.filters = [filter];\n *\n * // Adjust noise dynamically\n * filter.noise = 0.8;    // Increase noise\n * filter.seed = Math.random(); // New random pattern\n * ```\n * @category filters\n * @author Vico: vicocotea\n * @standard\n * @noInheritDoc\n */\nexport class NoiseFilter extends Filter {\n\t/**\n\t * The default configuration options for the NoiseFilter.\n\t *\n\t * These values will be used when no specific options are provided to the constructor.\n\t * You can override any of these values by passing your own options object.\n\t * @example\n\t * ```ts\n\t * NoiseFilter.defaultOptions.noise = 0.7; // Change default noise to 0.7\n\t * const filter = new NoiseFilter(); // Will use noise 0.7 by default\n\t * ```\n\t */\n\tstatic defaultOptions: NoiseFilterOptions;\n\t/**\n\t * @param options - The options of the noise filter.\n\t */\n\tconstructor(options?: NoiseFilterOptions);\n\t/**\n\t * The amount of noise to apply to the filtered content.\n\t *\n\t * This value controls the intensity of the random noise effect:\n\t * - Values close to 0 produce subtle noise\n\t * - Values around 0.5 produce moderate noise\n\t * - Values close to 1 produce strong noise\n\t * @default 0.5\n\t * @example\n\t * ```ts\n\t * const noiseFilter = new NoiseFilter();\n\t *\n\t * // Set to subtle noise\n\t * noiseFilter.noise = 0.2;\n\t *\n\t * // Set to maximum noise\n\t * noiseFilter.noise = 1.0;\n\t * ```\n\t */\n\tget noise(): number;\n\tset noise(value: number);\n\t/**\n\t * The seed value used for random noise generation.\n\t *\n\t * This value determines the noise pattern:\n\t * - Using the same seed will generate identical noise patterns\n\t * - Different seeds produce different but consistent patterns\n\t * - `Math.random()` can be used for random patterns\n\t * @default Math.random()\n\t * @example\n\t * ```ts\n\t * const noiseFilter = new NoiseFilter();\n\t *\n\t * // Use a fixed seed for consistent noise\n\t * noiseFilter.seed = 12345;\n\t *\n\t * // Generate new random pattern\n\t * noiseFilter.seed = Math.random();\n\t * ```\n\t */\n\tget seed(): number;\n\tset seed(value: number);\n}\n/**\n * The PassthroughFilter passes the input data through without altering it.\n * It serves as a basic filter, performing no graphical alterations.\n * @category filters\n * @internal\n */\nexport class PassthroughFilter extends Filter {\n\tconstructor();\n}\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions {\n\tsprite: Sprite;\n\tinverse?: boolean;\n\tscale?: number | {\n\t\tx: number;\n\t\ty: number;\n\t};\n}\n/** @internal */\nexport class MaskFilter extends Filter {\n\tsprite: Sprite;\n\tprivate readonly _textureMatrix;\n\tconstructor(options: MaskFilterOptions);\n\tset inverse(value: boolean);\n\tget inverse(): boolean;\n\tapply(filterManager: FilterSystem, input: Texture, output: Texture, clearMode: boolean): void;\n}\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n * @author Ivan: ivanpopelyshev\n * @groupDescription groupD8\n * @category maths\n * @advanced\n */\nexport const groupD8: {\n\t/**\n\t * | Rotation | Direction |\n\t * |----------|-----------|\n\t * | 0       | East      |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tE: number;\n\t/**\n\t * | Rotation | Direction |\n\t * |----------|-----------|\n\t * | 45     | Southeast |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tSE: number;\n\t/**\n\t * | Rotation | Direction |\n\t * |----------|-----------|\n\t * | 90     | South     |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tS: number;\n\t/**\n\t * | Rotation | Direction |\n\t * |----------|-----------|\n\t * | 135    | Southwest |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tSW: number;\n\t/**\n\t * | Rotation | Direction |\n\t * |----------|-----------|\n\t * | 180     | West      |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tW: number;\n\t/**\n\t * | Rotation    | Direction    |\n\t * |-------------|--------------|\n\t * | -135/225 | Northwest    |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tNW: number;\n\t/**\n\t * | Rotation    | Direction    |\n\t * |-------------|--------------|\n\t * | -90/270  | North        |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tN: number;\n\t/**\n\t * | Rotation    | Direction    |\n\t * |-------------|--------------|\n\t * | -45/315  | Northeast    |\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tNE: number;\n\t/**\n\t * Reflection about Y-axis.\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tMIRROR_VERTICAL: number;\n\t/**\n\t * Reflection about the main diagonal.\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tMAIN_DIAGONAL: number;\n\t/**\n\t * Reflection about X-axis.\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tMIRROR_HORIZONTAL: number;\n\t/**\n\t * Reflection about reverse diagonal.\n\t * @group groupD8\n\t * @type {GD8Symmetry}\n\t */\n\tREVERSE_DIAGONAL: number;\n\t/**\n\t * @group groupD8\n\t * @param {GD8Symmetry} ind - sprite rotation angle.\n\t * @returns {GD8Symmetry} The X-component of the U-axis\n\t *    after rotating the axes.\n\t */\n\tuX: (ind: GD8Symmetry) => GD8Symmetry;\n\t/**\n\t * @group groupD8\n\t * @param {GD8Symmetry} ind - sprite rotation angle.\n\t * @returns {GD8Symmetry} The Y-component of the U-axis\n\t *    after rotating the axes.\n\t */\n\tuY: (ind: GD8Symmetry) => GD8Symmetry;\n\t/**\n\t * @group groupD8\n\t * @param {GD8Symmetry} ind - sprite rotation angle.\n\t * @returns {GD8Symmetry} The X-component of the V-axis\n\t *    after rotating the axes.\n\t */\n\tvX: (ind: GD8Symmetry) => GD8Symmetry;\n\t/**\n\t * @group groupD8\n\t * @param {GD8Symmetry} ind - sprite rotation angle.\n\t * @returns {GD8Symmetry} The Y-component of the V-axis\n\t *    after rotating the axes.\n\t */\n\tvY: (ind: GD8Symmetry) => GD8Symmetry;\n\t/**\n\t * @group groupD8\n\t * @param {GD8Symmetry} rotation - symmetry whose opposite\n\t *   is needed. Only rotations have opposite symmetries while\n\t *   reflections don't.\n\t * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n\t */\n\tinv: (rotation: GD8Symmetry) => GD8Symmetry;\n\t/**\n\t * Composes the two D8 operations.\n\t *\n\t * Taking `^` as reflection:\n\t *\n\t * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n\t * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n\t * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n\t * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n\t * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n\t * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n\t * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n\t * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n\t * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n\t * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n\t *\n\t * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n\t * @group groupD8\n\t * @param {GD8Symmetry} rotationSecond - Second operation, which\n\t *   is the row in the above cayley table.\n\t * @param {GD8Symmetry} rotationFirst - First operation, which\n\t *   is the column in the above cayley table.\n\t * @returns {GD8Symmetry} Composed operation\n\t */\n\tadd: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry) => GD8Symmetry;\n\t/**\n\t * Reverse of `add`.\n\t * @group groupD8\n\t * @param {GD8Symmetry} rotationSecond - Second operation\n\t * @param {GD8Symmetry} rotationFirst - First operation\n\t * @returns {GD8Symmetry} Result\n\t */\n\tsub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry) => GD8Symmetry;\n\t/**\n\t * Adds 180 degrees to rotation, which is a commutative\n\t * operation.\n\t * @group groupD8\n\t * @param {number} rotation - The number to rotate.\n\t * @returns {number} Rotated number\n\t */\n\trotate180: (rotation: number) => number;\n\t/**\n\t * Checks if the rotation angle is vertical, i.e. south\n\t * or north. It doesn't work for reflections.\n\t * @group groupD8\n\t * @param {GD8Symmetry} rotation - The number to check.\n\t * @returns {boolean} Whether or not the direction is vertical\n\t */\n\tisVertical: (rotation: GD8Symmetry) => boolean;\n\t/**\n\t * Approximates the vector `V(dx,dy)` into one of the\n\t * eight directions provided by `groupD8`.\n\t * @group groupD8\n\t * @param {number} dx - X-component of the vector\n\t * @param {number} dy - Y-component of the vector\n\t * @returns {GD8Symmetry} Approximation of the vector into\n\t *  one of the eight symmetries.\n\t */\n\tbyDirection: (dx: number, dy: number) => GD8Symmetry;\n\t/**\n\t * Helps sprite to compensate texture packer rotation.\n\t * @group groupD8\n\t * @param {Matrix} matrix - sprite world matrix\n\t * @param {GD8Symmetry} rotation - The rotation factor to use.\n\t * @param {number} tx - sprite anchoring\n\t * @param {number} ty - sprite anchoring\n\t */\n\tmatrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx?: number, ty?: number) => void;\n\t/**\n\t * Transforms rectangle coordinates based on texture packer rotation.\n\t * Used when texture atlas pages are rotated and coordinates need to be adjusted.\n\t * @group groupD8\n\t * @param {RectangleLike} rect - Rectangle with original coordinates to transform\n\t * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)\n\t * @param {GD8Symmetry} rotation - The groupD8 rotation value\n\t * @param {Rectangle} out - Rectangle to store the result\n\t * @returns {Rectangle} Transformed coordinates (includes source frame offset)\n\t */\n\ttransformRectCoords: (rect: RectangleLike, sourceFrame: RectangleLike, rotation: GD8Symmetry, out: Rectangle) => Rectangle;\n};\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @category maths\n * @advanced\n */\nexport function nextPow2(v: number): number;\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @category maths\n * @advanced\n */\nexport function isPow2(v: number): boolean;\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @category maths\n * @advanced\n */\nexport function log2(v: number): number;\n/**\n * Calculates the squared distance from a point to a line segment defined by two endpoints.\n * @param x - x coordinate of the point\n * @param y - y coordinate of the point\n * @param x1 - x coordinate of the first endpoint of the line segment\n * @param y1 - y coordinate of the first endpoint of the line segment\n * @param x2 - x coordinate of the second endpoint of the line segment\n * @param y2 - y coordinate of the second endpoint of the line segment\n * @returns The squared distance from the point to the line segment\n * @category maths\n * @internal\n */\nexport function squaredDistanceToLineSegment(x: number, y: number, x1: number, y1: number, x2: number, y2: number): number;\n/**\n * Check if a point is inside a triangle.\n * @param px - x coordinate of the point\n * @param py - y coordinate of the point\n * @param x1 - x coordinate of the first vertex of the triangle\n * @param y1 - y coordinate of the first vertex of the triangle\n * @param x2 - x coordinate of the second vertex of the triangle\n * @param y2 - y coordinate of the second vertex of the triangle\n * @param x3 - x coordinate of the third vertex of the triangle\n * @param y3 - y coordinate of the third vertex of the triangle\n * @returns `true` if the point is inside the triangle, `false` otherwise\n * @category maths\n * @internal\n */\nexport function pointInTriangle(px: number, py: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): boolean;\n/**\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class extends the base functionality and resolves given resource items ready for the queue.\n * @category rendering\n * @advanced\n */\nexport abstract class PrepareQueue extends PrepareBase {\n\t/**\n\t * Resolve the given resource type and return an item for the queue\n\t * @param source\n\t * @param queue\n\t */\n\tprotected resolveQueueItem(source: PrepareSourceItem, queue: PrepareQueueItem[]): void;\n\t/**\n\t * Resolve the given container and return an item for the queue\n\t * @param container\n\t * @param queue\n\t */\n\tprotected resolveContainerQueueItem(container: Container, queue: PrepareQueueItem[]): void;\n\t/**\n\t * Resolve the given graphics context and return an item for the queue\n\t * @param graphicsContext\n\t */\n\tprotected resolveGraphicsContextQueueItem(graphicsContext: GraphicsContext): PrepareQueueItem | null;\n}\n/**\n * @advanced\n * Part of the prepare system. Responsible for uploading all the items to the GPU.\n * This class extends the resolver functionality and uploads the given queue items.\n * @category rendering\n */\nexport abstract class PrepareUpload extends PrepareQueue {\n\t/**\n\t * Upload the given queue item\n\t * @param item\n\t */\n\tprotected uploadQueueItem(item: PrepareQueueItem): void;\n\tprotected uploadTextureSource(textureSource: TextureSource): void;\n\tprotected uploadText(_text: Text$1): void;\n\tprotected uploadBitmapText(_text: BitmapText): void;\n\tprotected uploadHTMLText(_text: HTMLText): void;\n\t/**\n\t * Resolve the given graphics context and return an item for the queue\n\t * @param graphicsContext\n\t */\n\tprotected uploadGraphicsContext(graphicsContext: GraphicsContext): void;\n}\n/**\n * The prepare system provides renderer-specific plugins for pre-rendering DisplayObjects. This is useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.prepare` property.\n * @example\n * import 'pixi.js/prepare';\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (prepare will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // Create a display object\n * const rect = new Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n * @category rendering\n * @advanced\n */\nexport class PrepareSystem extends PrepareUpload implements System {\n\t/** @ignore */\n\tstatic extension: {\n\t\treadonly type: readonly [\n\t\t\tExtensionType.WebGLSystem,\n\t\t\tExtensionType.WebGPUSystem\n\t\t];\n\t\treadonly name: \"prepare\";\n\t};\n\t/** Destroys the plugin, don't use after this. */\n\tdestroy(): void;\n}\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetFrameData {\n\t/** The frame rectangle of the texture. */\n\tframe: {\n\t\tx: number;\n\t\ty: number;\n\t\tw: number;\n\t\th: number;\n\t};\n\t/** Whether the texture is trimmed. */\n\ttrimmed?: boolean;\n\t/** Whether the texture is rotated. */\n\trotated?: boolean;\n\t/** The source size of the texture. */\n\tsourceSize?: {\n\t\tw: number;\n\t\th: number;\n\t};\n\t/** The sprite source size. */\n\tspriteSourceSize?: {\n\t\th?: number;\n\t\tw?: number;\n\t\tx: number;\n\t\ty: number;\n\t};\n\t/** The anchor point of the texture. */\n\tanchor?: PointData;\n\t/** The 9-slice borders of the texture. */\n\tborders?: TextureBorders;\n}\n/**\n * Atlas format.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetData {\n\t/** The frames of the atlas. */\n\tframes: Dict<SpritesheetFrameData>;\n\t/** The animations of the atlas. */\n\tanimations?: Dict<string[]>;\n\t/** The meta data of the atlas. */\n\tmeta: {\n\t\tapp?: string;\n\t\tformat?: string;\n\t\tframeTags?: {\n\t\t\tfrom: number;\n\t\t\tname: string;\n\t\t\tto: number;\n\t\t\tdirection: string;\n\t\t}[];\n\t\timage?: string;\n\t\tlayers?: {\n\t\t\tblendMode: string;\n\t\t\tname: string;\n\t\t\topacity: number;\n\t\t}[];\n\t\tscale: number | string;\n\t\tsize?: {\n\t\t\th: number;\n\t\t\tw: number;\n\t\t};\n\t\tslices?: {\n\t\t\tcolor: string;\n\t\t\tname: string;\n\t\t\tkeys: {\n\t\t\t\tframe: number;\n\t\t\t\tbounds: {\n\t\t\t\t\tx: number;\n\t\t\t\t\ty: number;\n\t\t\t\t\tw: number;\n\t\t\t\t\th: number;\n\t\t\t\t};\n\t\t\t}[];\n\t\t}[];\n\t\trelated_multi_packs?: string[];\n\t\tversion?: string;\n\t};\n}\n/**\n * Options for loading a spritesheet from an atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetOptions<S extends SpritesheetData = SpritesheetData> {\n\t/** Reference to Texture */\n\ttexture: BindableTexture;\n\t/** JSON data for the atlas. */\n\tdata: S;\n\t/** The filename to consider when determining the resolution of the spritesheet. */\n\tresolutionFilename?: string;\n\t/**\n\t * Prefix to add to texture names when adding to global TextureCache,\n\t * using this option can be helpful if you have multiple texture atlases\n\t * that share texture names and you need to disambiguate them.\n\t */\n\tcachePrefix?: string;\n}\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @category assets\n * @standard\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData> {\n\t/**\n\t * The maximum number of Textures to build per process.\n\t * @advanced\n\t */\n\tstatic readonly BATCH_SIZE = 1000;\n\t/** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n\tlinkedSheets: Spritesheet<S>[];\n\t/** Reference to the source texture. */\n\ttextureSource: TextureSource;\n\t/**\n\t * A map containing all textures of the sprite sheet.\n\t * Can be used to create a {@link Sprite}:\n\t * @example\n\t * import { Sprite } from 'pixi.js';\n\t *\n\t * new Sprite(sheet.textures['image.png']);\n\t */\n\ttextures: Record<keyof S[\"frames\"], Texture>;\n\t/**\n\t * A map containing the textures for each animation.\n\t * Can be used to create an {@link AnimatedSprite}:\n\t * @example\n\t * import { AnimatedSprite } from 'pixi.js';\n\t *\n\t * new AnimatedSprite(sheet.animations['anim_name']);\n\t */\n\tanimations: Record<keyof NonNullable<S[\"animations\"]>, Texture[]>;\n\t/**\n\t * Reference to the original JSON data.\n\t * @type {object}\n\t */\n\tdata: S;\n\t/** The resolution of the spritesheet. */\n\tresolution: number;\n\t/**\n\t * Reference to original source image from the Loader. This reference is retained so we\n\t * can destroy the Texture later on. It is never used internally.\n\t */\n\tprivate _texture;\n\t/**\n\t * Map of spritesheet frames.\n\t * @type {object}\n\t */\n\tprivate _frames;\n\t/** Collection of frame names. */\n\tprivate _frameKeys;\n\t/** Current batch index being processed. */\n\tprivate _batchIndex;\n\t/**\n\t * Callback when parse is completed.\n\t * @type {Function}\n\t */\n\tprivate _callback;\n\t/** Prefix string to add to global cache */\n\treadonly cachePrefix: string;\n\t/**\n\t * @class\n\t * @param options - Options to use when constructing a new Spritesheet.\n\t */\n\tconstructor(options: SpritesheetOptions<S>);\n\t/**\n\t * @param texture - Reference to the source BaseTexture object.\n\t * @param {object} data - Spritesheet image data.\n\t */\n\tconstructor(texture: BindableTexture, data: S);\n\t/**\n\t * Parser spritesheet from loaded data. This is done asynchronously\n\t * to prevent creating too many Texture within a single process.\n\t */\n\tparse(): Promise<Record<string, Texture>>;\n\t/**\n\t * Process a batch of frames\n\t * @param initialFrameIndex - The index of frame to start.\n\t */\n\tprivate _processFrames;\n\t/** Parse animations config. */\n\tprivate _processAnimations;\n\t/** The parse has completed. */\n\tprivate _parseComplete;\n\t/** Begin the next batch of textures. */\n\tprivate _nextBatch;\n\t/**\n\t * Destroy Spritesheet and don't use after this.\n\t * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n\t */\n\tdestroy(destroyBase?: boolean): void;\n}\n/**\n * Interface for the JSON data structure of a spritesheet.\n * This is used to define the structure of the JSON file that describes a spritesheet.\n * It includes metadata about the spritesheet and the frames it contains.\n * @see {@link Spritesheet}\n * @see {@link SpritesheetData}\n * @category assets\n * @advanced\n */\nexport interface SpriteSheetJson extends SpritesheetData {\n\tmeta: {\n\t\timage: string;\n\t\tscale: string;\n\t\trelated_multi_packs?: string[];\n\t};\n}\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *         textureOptions: {\n *             scaleMode: \"nearest\"\n *         }\n *     }\n * })\n * @type {AssetExtension}\n * @category assets\n * @advanced\n */\nexport const spritesheetAsset: {\n\textension: ExtensionType.Asset;\n\t/** Handle the caching of the related Spritesheet Textures */\n\tcache: {\n\t\ttest: (asset: Spritesheet) => boolean;\n\t\tgetCacheableAssets: (keys: string[], asset: Spritesheet) => Record<string, any>;\n\t};\n\t/** Resolve the resolution of the asset. */\n\tresolver: {\n\t\textension: {\n\t\t\ttype: ExtensionType.ResolveParser;\n\t\t\tname: string;\n\t\t};\n\t\ttest: (value: string) => boolean;\n\t\tparse: (value: string) => {\n\t\t\tresolution: number;\n\t\t\tformat: string;\n\t\t\tsrc: string;\n\t\t};\n\t};\n\t/**\n\t * Loader plugin that parses sprite sheets!\n\t * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n\t * If it is, we load the spritesheets image and parse the data into Spritesheet\n\t * All textures in the sprite sheet are then added to the cache\n\t */\n\tloader: {\n\t\t/** used for deprecation purposes */\n\t\tname: string;\n\t\tid: string;\n\t\textension: {\n\t\t\ttype: ExtensionType.LoadParser;\n\t\t\tpriority: LoaderParserPriority;\n\t\t\tname: string;\n\t\t};\n\t\ttestParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>;\n\t\tparse<T>(asset: SpriteSheetJson, options: ResolvedAsset<{\n\t\t\ttexture?: Texture;\n\t\t\timageFilename?: string;\n\t\t\tignoreMultiPack?: boolean;\n\t\t\ttextureOptions?: TextureSourceOptions;\n\t\t\tcachePrefix?: string;\n\t\t}>, loader?: Loader): Promise<Spritesheet>;\n\t\tunload(spritesheet: Spritesheet, _resolvedAsset: ResolvedAsset<any>, loader: Loader): Promise<void>;\n\t};\n};\n/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @enum {number}\n * @category ticker\n * @standard\n */\nexport enum UPDATE_PRIORITY {\n\t/**\n\t * Highest priority used for interaction events in {@link EventSystem}\n\t * @default 50\n\t */\n\tINTERACTION = 50,\n\t/**\n\t * High priority updating, used by {@link AnimatedSprite}\n\t * @default 25\n\t */\n\tHIGH = 25,\n\t/**\n\t * Default priority for ticker events, see {@link Ticker#add}.\n\t * @default 0\n\t */\n\tNORMAL = 0,\n\t/**\n\t * Low priority used for {@link Application} rendering.\n\t * @default -25\n\t */\n\tLOW = -25,\n\t/**\n\t * Lowest priority used for {@link PrepareBase} utility.\n\t * @default -50\n\t */\n\tUTILITY = -50\n}\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any> {\n\t/** The current priority. */\n\tpriority: number;\n\t/** The next item in chain. */\n\tnext: TickerListener;\n\t/** The previous item in chain. */\n\tprevious: TickerListener;\n\t/** The handler function to execute. */\n\tprivate _fn;\n\t/** The calling to execute. */\n\tprivate _context;\n\t/** If this should only execute once. */\n\tprivate readonly _once;\n\t/** `true` if this listener has been destroyed already. */\n\tprivate _destroyed;\n\t/**\n\t * Constructor\n\t * @private\n\t * @param fn - The listener function to be added for one update\n\t * @param context - The listener context\n\t * @param priority - The priority for emitting\n\t * @param once - If the handler should fire once\n\t */\n\tconstructor(fn: TickerCallback<T>, context?: T, priority?: number, once?: boolean);\n\t/**\n\t * Simple compare function to figure out if a function and context match.\n\t * @param fn - The listener function to be added for one update\n\t * @param context - The listener context\n\t * @returns `true` if the listener match the arguments\n\t */\n\tmatch(fn: TickerCallback<T>, context?: any): boolean;\n\t/**\n\t * Emit by calling the current function.\n\t * @param ticker - The ticker emitting.\n\t * @returns Next ticker\n\t */\n\temit(ticker: Ticker): TickerListener;\n\t/**\n\t * Connect to the list.\n\t * @param previous - Input node, previous listener\n\t */\n\tconnect(previous: TickerListener): void;\n\t/**\n\t * Destroy and don't use after this.\n\t * @param hard - `true` to remove the `next` reference, this\n\t *        is considered a hard destroy. Soft destroy maintains the next reference.\n\t * @returns The listener to redirect while emitting or removing.\n\t */\n\tdestroy(hard?: boolean): TickerListener;\n}\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @category utils\n * @internal\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport function detectVideoAlphaMode(): Promise<ALPHA_MODES>;\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean;\n/**\n * Helper for checking for WebGL support in the current environment.\n *\n * Results are cached after first call for better performance.\n * @example\n * ```ts\n * // Basic WebGL support check\n * if (isWebGLSupported()) {\n *     console.log('WebGL is available');\n * }\n * ```\n * @param failIfMajorPerformanceCaveat - Whether to fail if there is a major performance caveat\n * @returns True if WebGL is supported\n * @category utils\n * @standard\n */\nexport function isWebGLSupported(failIfMajorPerformanceCaveat?: boolean): boolean;\n/**\n * Helper for checking for WebGPU support in the current environment.\n * Results are cached after first call for better performance.\n * @example\n * ```ts\n * // Basic WebGPU support check\n * const hasWebGPU = await isWebGPUSupported();\n * console.log('WebGPU available:', hasWebGPU);\n * ```\n * @param options - The options for requesting a GPU adapter\n * @returns Promise that resolves to true if WebGPU is supported\n * @category utils\n * @standard\n */\nexport function isWebGPUSupported(options?: GPURequestAdapterOptions): Promise<boolean>;\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean;\n/** @internal */\nexport interface GetCanvasBoundingBoxOptions {\n\t/** The canvas to measure */\n\tcanvas: ICanvas;\n\t/** Optional. The width to analyze (defaults to canvas.width) */\n\twidth?: number;\n\t/** Optional. The height to analyze (defaults to canvas.height) */\n\theight?: number;\n\t/**\n\t * Optional. The resolution at which to analyze the canvas, between 0-1.\n\t * Lower values improve performance for large canvases but may be less precise.\n\t * Default is 1 (full resolution).\n\t */\n\tresolution?: number;\n\t/** Optional. The rectangle to store the result in. */\n\toutput?: Rectangle;\n}\n/**\n * Measures the bounding box of a canvas's visible (non-transparent) pixels.\n *\n * This function analyzes the alpha channel of the canvas pixels to find the smallest\n * rectangle containing all non-transparent pixels. It's useful for optimizing sprite\n * rendering by trimming transparent borders.\n *\n * Uses an internal canvas with `willReadFrequently: true` for efficient pixel data access.\n * This internal canvas is reused between calls for better performance.\n * @example\n * ```typescript\n * // Basic usage - get trim bounds at full resolution\n * const bounds = getCanvasBoundingBox({ canvas: myCanvas });\n * console.log(bounds); // Rectangle{x: 10, y: 5, width: 100, height: 200}\n * // Optimized for performance with lower resolution scanning\n * const fastBounds = getCanvasBoundingBox({\n *     canvas: largeCanvas,\n *     width: largeCanvas.width,\n *     height: largeCanvas.height,\n *     resolution: 0.5\n * });\n * // Resolution of 0.5 means scanning at half size, much faster for large canvases\n *\n * // Using custom dimensions - only analyze part of the canvas\n * const partialBounds = getCanvasBoundingBox({ canvas: myCanvas, width: 100, height: 100 });\n * // Only analyzes a 100x100 region starting from top-left\n * ```\n * @param options - The options for measuring the bounding box, including the canvas to measure.\n * @returns The bounding box as a Rectangle containing the visible content.\n *          Returns Rectangle.EMPTY if the canvas is completely transparent.\n * @internal\n */\nexport function getCanvasBoundingBox(options: GetCanvasBoundingBoxOptions): Rectangle;\n/**\n * @param canvas\n * @param resolution\n * @internal\n * @deprecated since 8.10.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution?: number): Rectangle;\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @type {RegExp}\n * @default /(?:^data:image\\/([\\w+]+);(?:[\\w=]+|charset=[\\w-]+)?(?:;base64)?,)/i\n * @example\n * import { DATA_URI } from 'pixi.js';\n *\n * DATA_URI.test('data:image/png;base64,foobar'); // => true\n * @category utils\n * @advanced\n */\nexport const DATA_URI: RegExp;\n/**\n * The current version of PixiJS. This is automatically replaced by the build process.\n * @internal\n */\nexport const VERSION = \"$_VERSION\";\n/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @category utils\n * @internal\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>;\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @category utils\n * @internal\n */\nexport function cleanArray<T>(arr: T[]): T[];\n/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @category utils\n * @internal\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void;\n/**\n * The names of the unique identifiers. These are used to create unique identifiers for different types of objects.\n * @category utils\n * @internal\n */\nexport type UIDNames = \"default\" | \"resource\" | \"texture\" | \"textureSource\" | \"textureResource\" | \"batcher\" | \"graphicsContext\" | \"graphicsView\" | \"graphicsPath\" | \"fillGradient\" | \"fillPattern\" | \"meshView\" | \"renderable\" | \"buffer\" | \"bufferResource\" | \"geometry\" | \"instructionSet\" | \"renderTarget\" | \"uniform\" | \"spriteView\" | \"textView\" | \"tilingSpriteView\" | \"shader\" | \"renderer\" | \"textStyle\" | (string & {});\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @returns {number} The next unique identifier to use.\n * @category utils\n * @internal\n */\nexport function uid(name?: UIDNames): number;\n/**\n * Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :)\n * @internal\n */\nexport function resetUids(): void;\n/**\n * Updates the bounds of a quad (a rectangular area) based on the provided texture and anchor point.\n *\n * This function calculates the minimum and maximum x and y coordinates of the bounds, taking into\n * account the texture's original dimensions and any trimming that may have been applied to it.\n * @param {BoundsData} bounds - The bounds object to be updated. It contains minX, maxX, minY, and maxY properties.\n * @param {ObservablePoint} anchor - The anchor point of the texture, which affects the positioning of the bounds.\n * @param {Texture} texture - The texture whose dimensions and trimming information are used to update the bounds.\n * @internal\n */\nexport function updateQuadBounds(bounds: BoundsData, anchor: ObservablePoint, texture: Texture): void;\n/**\n * deprecation name for version 8.0.0\n * @ignore\n * @internal\n */\nexport const v8_0_0 = \"8.0.0\";\n/**\n * deprecation name for version 8.1.0\n * @ignore\n * @internal\n */\nexport const v8_3_4 = \"8.3.4\";\ninterface DeprecationOptions {\n\t/**\n\t * When set to true, all deprecation warning messages will be hidden.\n\t * Use this if you want to silence deprecation notifications.\n\t * @default false\n\t * @standard\n\t */\n\tquiet: boolean;\n\t/**\n\t * When set to true, deprecation messages will be displayed as plain text without color formatting.\n\t * Use this if you want to disable colored console output for deprecation warnings.\n\t * @default false\n\t * @standard\n\t */\n\tnoColor: boolean;\n}\n/** @internal */\nexport type DeprecationFn = ((version: string, message: string, ignoreDepth?: number) => void) & DeprecationOptions;\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n *\n * Deprecation messages can be configured globally:\n * ```ts\n * // Suppress all deprecation messages\n * deprecation.quiet = true;\n *\n * // Put plain text to console instead of colorful messages\n * deprecation.noColor = true;\n * ```\n * @category utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport const deprecation: DeprecationFn;\n/**\n * Logs a texture to the console as a base64 image.\n * This can be very useful for debugging issues with rendering.\n * @param texture - The texture to log\n * @param renderer - The renderer to use\n * @param size - The size of the texture to log in the console\n * @ignore\n */\nexport function logDebugTexture(texture: Texture, renderer: Renderer, size?: number): Promise<void>;\n/**\n * @param container\n * @param depth\n * @param data\n * @param data.color\n * @internal\n */\nexport function logScene(container: Container, depth?: number, data?: {\n\tcolor?: string;\n}): void;\n/**\n * @param renderGroup\n * @param depth\n * @param data\n * @param data.index\n * @param data.color\n * @internal\n */\nexport function logRenderGroupScene(renderGroup: RenderGroup, depth?: number, data?: {\n\tindex: number;\n\tcolor?: string;\n}): void;\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @category utils\n * @ignore\n */\nexport function warn(...args: any[]): void;\n/** @internal */\nexport const NOOP: () => void;\n/**\n * get the resolution / device pixel ratio of an asset by looking for the prefix\n * used by spritesheets and image urls\n * @category utils\n * @internal\n * @param {string} url - the image path\n * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.\n * @returns {number} resolution / device pixel ratio of an asset\n */\nexport function getResolutionOfUrl(url: string, defaultValue?: number): number;\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @category utils\n * @advanced\n */\nexport interface Path {\n\t/**\n\t * Converts a path to posix format.\n\t * @param path - The path to convert to posix\n\t */\n\ttoPosix: (path: string) => string;\n\t/**\n\t * Checks if the path is a URL e.g. http://, https://\n\t * @param path - The path to check\n\t */\n\tisUrl: (path: string) => boolean;\n\t/**\n\t * Checks if the path is a data URL\n\t * @param path - The path to check\n\t */\n\tisDataUrl: (path: string) => boolean;\n\t/**\n\t * Checks if the path is a blob URL\n\t * @param path - The path to check\n\t */\n\tisBlobUrl: (path: string) => boolean;\n\t/**\n\t * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n\t * This will return true for windows file paths\n\t * @param path - The path to check\n\t */\n\thasProtocol: (path: string) => boolean;\n\t/**\n\t * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n\t * @param path - The path to get the protocol from\n\t */\n\tgetProtocol: (path: string) => string;\n\t/**\n\t * Converts URL to an absolute path.\n\t * When loading from a Web Worker, we must use absolute paths.\n\t * If the URL is already absolute we return it as is\n\t * If it's not, we convert it\n\t * @param url - The URL to test\n\t * @param baseUrl - The base URL to use\n\t * @param rootUrl - The root URL to use\n\t */\n\ttoAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n\t/**\n\t * Normalizes the given path, resolving '..' and '.' segments\n\t * @param path - The path to normalize\n\t */\n\tnormalize: (path: string) => string;\n\t/**\n\t * Determines if path is an absolute path.\n\t * Absolute paths can be urls, data urls, or paths on disk\n\t * @param path - The path to test\n\t */\n\tisAbsolute: (path: string) => boolean;\n\t/**\n\t * Joins all given path segments together using the platform-specific separator as a delimiter,\n\t * then normalizes the resulting path\n\t * @param paths - The segments of the path to join\n\t */\n\tjoin: (...paths: string[]) => string;\n\t/**\n\t * Returns the directory name of a path\n\t * @param path - The path to parse\n\t */\n\tdirname: (path: string) => string;\n\t/**\n\t * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n\t * @param path - The path to parse\n\t */\n\trootname: (path: string) => string;\n\t/**\n\t * Returns the last portion of a path\n\t * @param path - The path to test\n\t * @param ext - Optional extension to remove\n\t */\n\tbasename: (path: string, ext?: string) => string;\n\t/**\n\t * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n\t * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n\t * the first character of the basename of path, an empty string is returned.\n\t * @param path - The path to parse\n\t */\n\textname: (path: string) => string;\n\t/**\n\t * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n\t * @param path - The path to parse\n\t */\n\tparse: (path: string) => {\n\t\troot?: string;\n\t\tdir?: string;\n\t\tbase?: string;\n\t\text?: string;\n\t\tname?: string;\n\t};\n\tsep: string;\n\tdelimiter: string;\n\tjoinExtensions: string[];\n}\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * @example\n * ```ts\n * import { path } from 'pixi.js';\n *\n * // Basic path normalization\n * path.normalize('http://www.example.com/foo/bar/../baz');\n * // -> 'http://www.example.com/foo/baz'\n *\n * // Working with file paths\n * path.join('assets', 'images', 'sprite.png');\n * // -> 'assets/images/sprite.png'\n *\n * // URL handling\n * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n * // -> 'http://example.com/assets/images/texture.png'\n * ```\n * @remarks\n * - Normalizes to POSIX separators (forward slashes)\n * - Handles URLs, data URLs, and file paths\n * - Supports path composition and decomposition\n * - Common in asset loading and URL management\n * @category utils\n * @standard\n * @see {@link Path} For full API reference\n * @see {@link DOMAdapter} For platform-specific path handling\n */\nexport const path: Path;\ninterface Cleanable {\n\tclear(): void;\n}\n/**\n * A singleton collector that manages and provides cleanup for registered pools and caches.\n * Useful for cleaning up all pools/caches at once during application shutdown or reset.\n * @category utils\n * @internal\n */\nexport const GlobalResourceRegistry: {\n\t/**\n\t * Set of registered pools and cleanable objects.\n\t * @private\n\t */\n\t_registeredResources: Set<Cleanable>;\n\t/**\n\t * Registers a pool or cleanable object for cleanup.\n\t * @param {Cleanable} pool - The pool or object to register.\n\t */\n\tregister(pool: Cleanable): void;\n\t/**\n\t * Unregisters a pool or cleanable object from cleanup.\n\t * @param {Cleanable} pool - The pool or object to unregister.\n\t */\n\tunregister(pool: Cleanable): void;\n\t/** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */\n\trelease(): void;\n\t/**\n\t * Gets the number of registered pools and cleanable objects.\n\t * @returns {number} The count of registered items.\n\t */\n\treadonly registeredCount: number;\n\t/**\n\t * Checks if a specific pool or cleanable object is registered.\n\t * @param {Cleanable} pool - The pool or object to check.\n\t * @returns {boolean} True if the item is registered, false otherwise.\n\t */\n\tisRegistered(pool: Cleanable): boolean;\n\t/**\n\t * Removes all registrations without clearing the pools.\n\t * Useful if you want to reset the collector without affecting the pools.\n\t */\n\treset(): void;\n};\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @category utils\n * @advanced\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n/**\n * A group of pools that can be used to store objects of different types.\n * @category utils\n * @advanced\n */\nexport class PoolGroupClass {\n\t/**\n\t * A map to store the pools by their class type.\n\t * @private\n\t */\n\tprivate readonly _poolsByClass;\n\t/**\n\t * Prepopulates a specific pool with a given number of items.\n\t * @template T The type of items in the pool. Must extend PoolItem.\n\t * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n\t * @param {number} total - The number of items to add to the pool.\n\t */\n\tprepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void;\n\t/**\n\t * Gets an item from a specific pool.\n\t * @template T The type of items in the pool. Must extend PoolItem.\n\t * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n\t * @param {unknown} [data] - Optional data to pass to the item's constructor.\n\t * @returns {T} The item from the pool.\n\t */\n\tget<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T;\n\t/**\n\t * Returns an item to its respective pool.\n\t * @param {PoolItem} item - The item to return to the pool.\n\t */\n\treturn(item: PoolItem): void;\n\t/**\n\t * Gets a specific pool based on the class type.\n\t * @template T The type of items in the pool. Must extend PoolItem.\n\t * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n\t * @returns {Pool<T>} The pool of the given class type.\n\t */\n\tgetPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>;\n\t/** gets the usage stats of each pool in the system */\n\tstats(): Record<string, {\n\t\tfree: number;\n\t\tused: number;\n\t\tsize: number;\n\t}>;\n\t/** Clears all pools in the group. This will reset all pools and free their resources. */\n\tclear(): void;\n}\n/**\n * A singleton instance of the PoolGroupClass that can be used throughout the application.\n * @internal\n */\nexport const BigPool: PoolGroupClass;\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n * @category utils\n * @advanced\n */\nexport function sayHello(type: string): void;\n\nexport {\n\tBuffer$1 as Buffer,\n\tCache$1 as Cache,\n\tEXT_texture_compression_bptc$1 as EXT_texture_compression_bptc,\n\tEXT_texture_compression_rgtc$1 as EXT_texture_compression_rgtc,\n\tExtensionFormat as ExtensionFormatLoose,\n\tGPU$1 as GPU,\n\tPredefinedColorSpace$1 as PredefinedColorSpace,\n\tRenderingContext$1 as RenderingContext,\n\tStrictExtensionFormat as ExtensionFormat,\n\tText$1 as Text,\n\tWEBGL_compressed_texture_etc$1 as WEBGL_compressed_texture_etc,\n\tWEBGL_compressed_texture_etc1$1 as WEBGL_compressed_texture_etc1,\n\tWEBGL_compressed_texture_pvrtc$1 as WEBGL_compressed_texture_pvrtc,\n\tearcut$1 as earcut,\n};\n\n}\n\n\n// --- commands/InterpreterUtils.d.ts ---\ndeclare const InterpreterUtils: {\n    advanceToElseOrEnd(interpreter: ZEventInterpreter): void;\n    advanceToEnd(interpreter: ZEventInterpreter): void;\n    advanceToNextWhenOrEnd(interpreter: ZEventInterpreter): void;\n};\n\n\n// --- commands/audio/AudioCommands.d.ts ---\n\n/**\n * Command 241: Play BGM\n */\ndeclare const commandPlayBGM: ZCommandProcessor;\n/**\n * Command 242: Fadeout BGM\n */\ndeclare const commandFadeOutBGM: ZCommandProcessor;\n/**\n * Command 245: Play BGS\n */\ndeclare const commandPlayBGS: ZCommandProcessor;\n/**\n * Command 246: Fadeout BGS\n */\ndeclare const commandFadeOutBGS: ZCommandProcessor;\n/**\n * Command 250: Play SE\n */\ndeclare const commandPlaySE: ZCommandProcessor;\n/**\n * Command 251: Stop SE\n */\ndeclare const commandStopSE: ZCommandProcessor;\n\n\n// --- commands/flow/ConditionalBranch.d.ts ---\n\n/**\n * Command 111: Conditional Branch\n */\ndeclare const commandConditionalBranch: ZCommandProcessor;\n/**\n * Command 411: Else\n */\ndeclare const commandElse: ZCommandProcessor;\n\n\n// --- commands/flow/Wait.d.ts ---\n\n/**\n * Command 230: Wait\n */\ndeclare const commandWait: ZCommandProcessor;\n\n\n// --- commands/index.d.ts ---\n\n\n// --- commands/messages/ShowChoices.d.ts ---\n\n/**\n * Command 102: Show Choices\n */\ndeclare const commandShowChoices: ZCommandProcessor;\n/**\n * Command 402: When (Choice Branch)\n */\ndeclare const commandWhen: ZCommandProcessor;\n\n\n// --- commands/messages/ShowMessage.d.ts ---\n\n/**\n * Command 101: Show Message\n */\ndeclare const commandShowMessage: ZCommandProcessor;\n\n\n// --- commands/movement/SetEventDirection.d.ts ---\n\n/**\n * Command 213: Set Event Direction\n */\ndeclare const commandSetEventDirection: ZCommandProcessor;\n\n\n// --- commands/movement/SetMoveRoute.d.ts ---\n\n/**\n * Command 205: Set Move Route\n */\ndeclare const commandSetMoveRoute: ZCommandProcessor;\n\n\n// --- commands/movement/TransferPlayer.d.ts ---\n\n/**\n * Command 201: Transfer Player\n */\ndeclare const commandTransferPlayer: ZCommandProcessor;\n\n\n// --- commands/movement/move-route/BasicMovement.d.ts ---\ndeclare const moveDown: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveLeft: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveRight: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveUp: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveLowerLeft: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveLowerRight: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveUpperLeft: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveUpperRight: (sys: MovementProcessor, m: ZMoveable) => void;\n\n\n// --- commands/movement/move-route/ComplexMovement.d.ts ---\ndeclare const moveRandom: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const moveTowardPlayer: (sys: MovementProcessor, m: ZMoveable, _params: unknown[], playerPos?: {\n    x: number;\n    y: number;\n}) => void;\ndeclare const moveAwayPlayer: (sys: MovementProcessor, m: ZMoveable, _params: unknown[], playerPos?: {\n    x: number;\n    y: number;\n}) => void;\ndeclare const jump: (_sys: MovementProcessor, m: ZMoveable, params: unknown[]) => void;\ndeclare const stepForward: (sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const stepBackward: (sys: MovementProcessor, m: ZMoveable) => void;\n\n\n// --- commands/movement/move-route/StateChange.d.ts ---\ndeclare const wait: (_sys: MovementProcessor, m: ZMoveable, params: unknown[]) => void;\ndeclare const changeSpeed: (_sys: MovementProcessor, m: ZMoveable, params: unknown[]) => void;\ndeclare const throughOn: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const throughOff: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const walkAnimOn: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const walkAnimOff: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const stepAnimOn: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const stepAnimOff: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const dirFixOn: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const dirFixOff: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const transparentOn: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const transparentOff: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const changeOpacity: (_sys: MovementProcessor, m: ZMoveable, params: unknown[]) => void;\n\n\n// --- commands/movement/move-route/Turning.d.ts ---\ndeclare const turnDown: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turnLeft: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turnRight: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turnUp: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turn90Right: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turn90Left: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turn180: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turn90RightLeft: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turnRandom: (_sys: MovementProcessor, m: ZMoveable) => void;\ndeclare const turnTowardPlayer: (sys: MovementProcessor, m: ZMoveable, _p: unknown[], playerPos?: {\n    x: number;\n    y: number;\n}) => void;\ndeclare const turnAwayPlayer: (sys: MovementProcessor, m: ZMoveable, _p: unknown[], playerPos?: {\n    x: number;\n    y: number;\n}) => void;\n\n\n// --- commands/movement/move-route/registry.d.ts ---\n\n\ntype MoveCommandHandler = (processor: MovementProcessor, moveable: ZMoveable, params: unknown[], playerPos?: {\n    x: number;\n    y: number;\n}) => void;\ndeclare const MoveRouteRegistry: Record<string, MoveCommandHandler>;\n\n\n// --- commands/registry.d.ts ---\ndeclare const CommandRegistry: Record<number, ZCommandProcessor>;\n\n\n// --- commands/state/ControlSelfSwitch.d.ts ---\n\n/**\n * Command 123: Control Self Switch\n */\ndeclare const commandControlSelfSwitch: ZCommandProcessor;\n\n\n// --- commands/state/ControlSwitch.d.ts ---\n\n/**\n * Command 121: Control Switch\n */\ndeclare const commandControlSwitch: ZCommandProcessor;\n\n\n// --- commands/state/ControlVariable.d.ts ---\n\n/**\n * Command 122: Control Variable\n */\ndeclare const commandControlVariable: ZCommandProcessor;\n\n\n// --- commands/visuals/SetEventGraphic.d.ts ---\n\n/**\n * Command 214: Set Event Graphic\n */\ndeclare const commandSetEventGraphic: ZCommandProcessor;\n\n\n// --- constants.d.ts ---\ndeclare const DEFAULT_PLAYER_GRAPHIC: ZEventGraphic;\n\n\n// --- core/MovementProcessor.d.ts ---\ndeclare class MovementProcessor {\n    private physics;\n    constructor(physics: IPhysicsSystem);\n    processNextCommand(moveable: ZMoveable, playerPos?: {\n        x: number;\n        y: number;\n    }, delta?: number): void;\n    attemptMove(moveable: ZMoveable, dx: number, dy: number, isAutonomous?: boolean): boolean;\n    turnToward(moveable: ZMoveable, pos: {\n        x: number;\n        y: number;\n    }): void;\n    turnAway(moveable: ZMoveable, pos: {\n        x: number;\n        y: number;\n    }): void;\n}\n\n\n// --- core/ZEngine.d.ts ---\ndeclare class EngineConfig {\n    mode: 'edit' | 'play';\n}\n/**\n * ZEngine - Composition Root\n * Central point where all systems are wired together manually.\n */\ndeclare class ZEngine implements IEngineContext {\n    app: Application;\n    dataProvider: ZDataProvider | null;\n    systemData: ZSystemData | null;\n    config: EngineConfig;\n    eventBus: ZEventBus;\n    input: InputManager;\n    audio: AudioManager;\n    textures: TextureManager;\n    tilesets: TilesetManager;\n    map: MapManager;\n    gameState: GameStateManager;\n    history: HistoryManager;\n    tools: ToolManager;\n    scenes: SceneManager;\n    save: SaveManager;\n    physics: PhysicsSystem;\n    player: PlayerSystem;\n    events: EventSystem;\n    menus: MenuSystem;\n    renderer: RenderSystem;\n    entities: EntityRenderSystem;\n    ghost: GhostSystem;\n    grid: GridSystem;\n    transitions: TransitionSystem;\n    messages: MessageSystem;\n    errors: ErrorSystem;\n    private sceneLayer;\n    private globalLayer;\n    private isBooted;\n    constructor();\n    init(container: HTMLElement, tileSize: number): Promise<void>;\n    private tick;\n    setMode(mode: 'edit' | 'play'): Promise<void>;\n    /**\n     * Propagates tool changes to editor-mode systems (like GhostSystem).\n     */\n    setTool(tool: ZTool): void;\n    /**\n     * Sets the DataProvider and propagates it to managers that need explicit reference.\n     * Note: SceneManager accesses it directly via EngineContext, so strict propagation there isn't needed,\n     * but we do it for managers that might cache it.\n     */\n    setDataProvider(provider: ZDataProvider): void;\n    setSystemData(data: ZSystemData): void;\n    resize(width: number, height: number): void;\n    destroy(): void;\n    private setupCanvas;\n    private setupStage;\n}\n\n\n// --- core/ZEventBus.d.ts ---\n\ntype ZSignalCallback<T extends keyof ZSignalData> = (data: ZSignalData[T]) => void;\ndeclare class ZEventBus {\n    private handlers;\n    on<T extends keyof ZSignalData>(signal: T, callback: ZSignalCallback<T>): void;\n    off<T extends keyof ZSignalData>(signal: T, callback: ZSignalCallback<T>): void;\n    emit<T extends keyof ZSignalData>(signal: T, data: ZSignalData[T]): void;\n    once<T extends keyof ZSignalData>(signal: T, callback: ZSignalCallback<T>): void;\n}\n\n\n// --- core/ZScene.d.ts ---\n\n\n/**\n * ZScene is the base class for all game states (Title, Map, Battle, etc.)\n */\ndeclare abstract class ZScene {\n    container: Container;\n    protected engine: IEngineContext;\n    constructor(engine: IEngineContext);\n    /**\n     * Called when the scene is requested to load.\n     * Useful for async data fetching.\n     * @param _params Scene-specific initialization data.\n     */\n    init(_params?: unknown): Promise<void>;\n    /**\n     * Called when the scene becomes active.\n     */\n    abstract start(): void;\n    /**\n     * Called every frame.\n     * @param _delta Time since last frame in MS.\n     */\n    update(_delta: number): void;\n    /**\n     * Called when the scene is about to be replaced.\n     */\n    stop(): void;\n    /**\n     * Final cleanup.\n     */\n    destroy(): void;\n}\n\n\n// --- core/ZSystem.d.ts ---\ndeclare enum SystemMode {\n    ALWAYS = \"always\",\n    PLAY = \"play\",\n    EDIT = \"edit\"\n}\ndeclare abstract class ZSystem {\n    updateMode: SystemMode;\n    onBoot(): void;\n    onSetup(): void;\n    onPreUpdate(_delta: number): void;\n    onUpdate(_delta: number): void;\n    onPostUpdate(_delta: number): void;\n    onDestroy(): void;\n}\n\n\n// --- core/index.d.ts ---\n\n\n\n\n\n// --- index.d.ts ---\n\n\n\n\n\n\n// --- interfaces/IPhysicsSystem.d.ts ---\ndeclare interface IObstacleProvider {\n    isOccupied(x: number, y: number, options?: {\n        isThrough?: boolean;\n        skipPlayer?: boolean;\n        excludeId?: string;\n    }): boolean;\n}\ndeclare interface IPhysicsSystem {\n    registerProvider(provider: IObstacleProvider): void;\n    isPassable(x: number, y: number, options?: {\n        isThrough?: boolean;\n        skipPlayer?: boolean;\n    }): boolean;\n    checkPassage(x: number, y: number, targetX: number, targetY: number, options?: {\n        isThrough?: boolean;\n        skipPlayer?: boolean;\n    }): boolean;\n}\n\n\n// --- managers/AudioManager.d.ts ---\ndeclare class AudioManager {\n    private context;\n    private masterGain;\n    private bgmGain;\n    private bgmSource;\n    private currentBgm;\n    private bgsGain;\n    private bgsSource;\n    private currentBgs;\n    private seGain;\n    private buffers;\n    private _masterVolume;\n    private _bgmVolume;\n    private _seVolume;\n    constructor();\n    playBgm(config: ZAudioConfig, fadeOutPrevious?: number): Promise<void>;\n    fadeOutBgm(duration: number): void;\n    stopBgm(): void;\n    playBgs(config: ZAudioConfig, fadeOutPrevious?: number): Promise<void>;\n    stopBgs(): void;\n    fadeOutBgs(duration: number): void;\n    playSe(config: ZAudioConfig): Promise<void>;\n    private loadBuffer;\n}\n\n\n// --- managers/EventManager.d.ts ---\n\n\n\n\n\n/**\n * Manages the lifecycle, state, and movement of events on the map.\n * Extracts \"Physical\" and \"State\" logic from EventSystem.\n */\ndeclare class EventManager implements IObstacleProvider {\n    private physicsSystem;\n    private gameState;\n    private mapManager;\n    private bus;\n    private movementProcessor;\n    private tileSize;\n    private eventStates;\n    private _activePageCache;\n    private preInteractionDirections;\n    constructor(physics: IPhysicsSystem, gameState: GameStateManager, mapManager: MapManager, bus: ZEventBus);\n    init(tileSize: number): void;\n    onBoot(): void;\n    initializeEventStates(): void;\n    getEventState(eventId: string): ZEventRuntimeState | undefined;\n    getActivePage(event: ZEvent): ZEventPage | null;\n    private checkPageConditions;\n    private checkPageConditionsWithEvent;\n    refreshAllEvents(): void;\n    refreshEvent(event: ZEvent): void;\n    private onEventStateChanged;\n    update(delta: number, playerPos: {\n        x: number;\n        y: number;\n    }, isProcessing: boolean): void;\n    isOccupied(x: number, y: number, options?: {\n        isThrough?: boolean;\n        excludeId?: string;\n    }): boolean;\n    turnEventToward(eventId: string, targetPos: {\n        x: number;\n        y: number;\n    }): void;\n    setEventDirection(eventId: string, direction: 'down' | 'left' | 'right' | 'up'): void;\n    savePreInteractionDirection(eventId: string): void;\n    restorePreInteractionDirection(eventId: string, isTransitioning: boolean): void;\n    checkTrigger(x: number, y: number, trigger: ZEventTrigger): {\n        event: ZEvent;\n        page: ZEventPage;\n    } | null;\n}\n\n\n// --- managers/GameStateManager.d.ts ---\n\n\n\n/**\n * Interface representing the state of a saved game.\n */\ndeclare interface GameSaveData {\n    switches: Record<number, boolean>;\n    variables: Record<number, number>;\n    selfSwitches: Record<string, boolean>;\n    party: unknown;\n    actors: unknown[];\n}\n/**\n * Manages the global game state, including switches, variables, and the party.\n */\ndeclare class GameStateManager {\n    private bus;\n    private switches;\n    private variables;\n    private selfSwitches;\n    private _party;\n    private _actors;\n    constructor(bus: ZEventBus);\n    get party(): Game_Party;\n    get actors(): Game_Actors;\n    /**\n     * Initializes default data for a new game session.\n     */\n    private initDefaultData;\n    getSwitch(id: number): boolean;\n    setSwitch(id: number, value: boolean): void;\n    toggleSwitch(id: number): void;\n    getSelfSwitch(mapId: number, eventId: string | number, ch: string): boolean;\n    setSelfSwitch(mapId: number, eventId: string | number, ch: string, value: boolean): void;\n    getVariable(id: number): number;\n    setVariable(id: number, value: number): void;\n    addVariable(id: number, value: number): void;\n    /**\n     * Captures the current state for storage.\n     */\n    getSaveData(): GameSaveData;\n    /**\n     * Restores state from saved data.\n     */\n    loadSaveData(data: GameSaveData): void;\n    /**\n     * Resets all data for a new game.\n     */\n    newGame(): void;\n}\n\n\n// --- managers/HistoryManager.d.ts ---\n\n\n\n/**\n * Manages editor history using a delta-based approach.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class HistoryManager {\n    private undoStack;\n    private redoStack;\n    private currentEntry;\n    private maxHistory;\n    private mapManager;\n    private renderSystem;\n    private dataProvider;\n    constructor(mapManager: MapManager, maxHistory?: number);\n    /**\n     * Links the DataProvider (called by ZEngine).\n     */\n    setDataProvider(provider: ZDataProvider): void;\n    /**\n     * Links the RenderSystem (called by ZEngine.init).\n     * Needed because RenderSystem is created after HistoryManager.\n     */\n    registerRenderer(renderSystem: RenderSystem): void;\n    /**\n     * Starts grouping multiple changes into a single history entry.\n     */\n    beginEntry(label: string): void;\n    /**\n     * Records a single tile change in the active entry.\n     */\n    addDelta(delta: ZTileDelta): void;\n    /**\n     * Finishes grouping and pushes the entry to the undo stack.\n     */\n    commitEntry(): void;\n    undo(): void;\n    redo(): void;\n    private applyDelta;\n    private refreshNeighbors;\n    get canUndo(): boolean;\n    get canRedo(): boolean;\n    get undoCount(): number;\n    get redoCount(): number;\n    clear(): void;\n}\n\n\n// --- managers/InputManager.d.ts ---\ndeclare class InputManager {\n    private keys;\n    private lastKeys;\n    private actionState;\n    private lastActionState;\n    private mappings;\n    constructor();\n    private onKeyDown;\n    private onKeyUp;\n    isKeyDown(code: string): boolean;\n    isActionDown(action: ZInputAction): boolean;\n    isActionJustPressed(action: ZInputAction): boolean;\n    /**\n     * Synchronizes the input state. Should be called once per frame.\n     */\n    update(): void;\n    private storeLastStates;\n    private pollGamepads;\n    isKeyJustPressed(code: string): boolean;\n    isAnyKeyDown(codes: string[]): boolean;\n    clearKey(code: string): void;\n    clearAction(action: ZInputAction): void;\n    destroy(): void;\n}\n\n\n// --- managers/MapManager.d.ts ---\ndeclare class MapManager {\n    currentMap: ZMap | null;\n    setMap(map: ZMap): void;\n    getEventsAt(x: number, y: number): ZEvent[];\n}\n\n\n// --- managers/SaveManager.d.ts ---\ndeclare class SaveManager {\n    private bus;\n    private gameState;\n    private player;\n    private map;\n    private dataProvider;\n    constructor(bus: ZEventBus, gameState: GameStateManager);\n    registerSystems(player: PlayerSystem, map: MapManager): void;\n    setDataProvider(provider: ZDataProvider): void;\n    saveGame(slotId: number): Promise<boolean>;\n    loadGame(slotId: number): Promise<GameSaveFile | null>;\n    doesSaveExist(slotId: number): Promise<boolean>;\n}\n\n\n// --- managers/SceneManager.d.ts ---\ndeclare type SceneConstructor = new (engine: IEngineContext) => ZScene;\ndeclare class SceneManager {\n    private engine;\n    private _currentScene;\n    private _sceneLayer;\n    private _sceneStack;\n    private _skipNextUpdate;\n    private _isTransitioning;\n    private onMapChangeRequest;\n    constructor(engine: IEngineContext);\n    get isTransitioning(): boolean;\n    setSceneLayer(layer: Container): void;\n    get currentScene(): ZScene | null;\n    /**\n     * Helper: Sprawdza czy naley uruchomi tranzycj.\n     * Dostp bezporedni przez this.engine, bez ServiceLocatora.\n     */\n    private getTransitionSystem;\n    /**\n     * Transitions to a new scene.\n     */\n    goto(SceneClass: SceneConstructor, params?: unknown, options?: {\n        fade?: boolean;\n    }): Promise<void>;\n    /**\n     * Pushes a new scene onto the stack.\n     */\n    push(SceneClass: SceneConstructor, params?: unknown, options?: {\n        fade?: boolean;\n    }): Promise<void>;\n    /**\n     * Pops the current scene from the stack.\n     */\n    pop(options?: {\n        fade?: boolean;\n    }): Promise<void>;\n    /**\n     * Propagates frame updates to the current scene.\n     */\n    update(delta: number): void;\n    setMapChangeCallback(callback: (mapId: number, x: number, y: number) => Promise<void>): void;\n    requestMapChange(mapId: number, x: number, y: number): Promise<void>;\n}\n\n\n// --- managers/TextureManager.d.ts ---\ndeclare class TextureManager {\n    private textures;\n    private textureUrls;\n    private dataProvider;\n    setDataProvider(provider: ZDataProvider): void;\n    load(path: string): Promise<Texture>;\n    loadTileset(id: string, url: string): Promise<void>;\n    get(id: string): Texture | undefined;\n}\n\n\n// --- managers/TilesetManager.d.ts ---\n\n/**\n * Manages tileset metadata (collision, priorities, offsets).\n * Centralizes knowledge about how tiles should behave.\n */\ndeclare class TilesetManager {\n    private configs;\n    /**\n     * Updates or replaces the configuration for multiple tilesets.\n     * Typically called during map load.\n     */\n    setConfigs(configs: Record<string, TilesetConfig>): void;\n    /**\n     * Get the full config for a specific tileset URL.\n     */\n    getConfig(tilesetUrl: string): TilesetConfig | undefined;\n    /**\n     * Get specific tile configuration.\n     */\n    getTileConfig(tilesetUrl: string, tx: number, ty: number): TileConfig | undefined;\n    /**\n     * Helper to normalize URLs for consistent lookups.\n     * Ensures 'z-proj://path/to/img/...' matches 'img/...'\n     */\n    private normalizeUrl;\n}\n\n\n// --- managers/ToolManager.d.ts ---\n\n\n\n\n/**\n * Handles editor tool logic (painting, fill, etc.) inside the engine.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class ToolManager {\n    private mapManager;\n    private historyManager;\n    private renderSystem;\n    private dataProvider;\n    constructor(mapManager: MapManager, historyManager: HistoryManager);\n    /**\n     * Sets the Data Provider (called by ZEngine).\n     */\n    setDataProvider(provider: ZDataProvider): void;\n    /**\n     * Registers the RenderSystem (called by ZEngine.init).\n     * Required for visual updates after tool application.\n     */\n    registerRenderer(renderSystem: RenderSystem): void;\n    /**\n     * Main entry point for applying a tile at a specific coordinate.\n     */\n    applyTile(x: number, y: number, tile: TileSelection | null, isStacking: boolean, layer: ZLayer): void;\n    private areStacksEqual;\n    /**\n     * Brush tool: Applies a selection (possibly multi-tile/layer) at target.\n     */\n    brush(target: {\n        x: number;\n        y: number;\n    }, selection: TileSelection, layer: ZLayer, isStacking: boolean, isEraser?: boolean): void;\n    /**\n     * Bucket Fill tool: Standard flood fill.\n     */\n    bucketFill(target: {\n        x: number;\n        y: number;\n    }, selection: TileSelection, layer: ZLayer, isStacking: boolean): void;\n    /**\n     * Shape tool: Rectangle/Circle.\n     */\n    drawShape(start: {\n        x: number;\n        y: number;\n    }, end: {\n        x: number;\n        y: number;\n    }, type: ZTool.rectangle | ZTool.circle, selection: TileSelection, layer: ZLayer, isStacking: boolean): void;\n    private refreshNeighbors;\n}\n\n\n// --- managers/index.d.ts ---\n\n\n\n\n\n\n\n\n\n// --- objects/Game_Actor.d.ts ---\n\n/**\n * Represents a single actor (hero/party member) in the game.\n * Stores runtime state like HP, MP, Level, and Equipment.\n */\ndeclare class Game_Actor {\n    private _data;\n    private _level;\n    private _hp;\n    private _mp;\n    constructor(data: ZActor);\n    get id(): number;\n    get name(): string;\n    get level(): number;\n    get mhp(): number;\n    get mmp(): number;\n    get atk(): number;\n    get def(): number;\n    get hp(): number;\n    get mp(): number;\n    /**\n     * Returns the value of a parameter (0: MHP, 1: MMP, 2: ATK, 3: DEF, etc.)\n     * @param id The parameter index.\n     */\n    param(id: number): number;\n    recoverAll(): void;\n    setLevel(level: number): void;\n    get characterName(): string;\n    get characterIndex(): number;\n    get faceName(): string;\n    get faceIndex(): number;\n}\n\n\n// --- objects/Game_Actors.d.ts ---\n\n\n/**\n * A repository for all actor instances in the game.\n * Ensures that each actor has a unique, persistent instance.\n */\ndeclare class Game_Actors {\n    private _data;\n    /**\n     * Retrieves an actor by ID. If it doesn't exist and data is provided, creates it.\n     */\n    get(id: number, data?: ZActor): Game_Actor | null;\n    /**\n     * Serializes all runtime actor data for saving.\n     */\n    getSaveData(): Record<string, unknown>[];\n}\n\n\n// --- objects/Game_Party.d.ts ---\n\n/**\n * Manages the player's party members and global state like Gold.\n */\ndeclare class Game_Party {\n    private _actors;\n    private _gold;\n    get members(): Game_Actor[];\n    get gold(): number;\n    /**\n     * Adds an actor to the party if they are not already present.\n     */\n    addActor(actor: Game_Actor): void;\n    /**\n     * Removes an actor from the party by ID.\n     */\n    removeActor(actorId: number): void;\n    /**\n     * Returns the first member of the party.\n     */\n    leader(): Game_Actor | null;\n    /**\n     * Modifies the amount of gold held by the party.\n     */\n    gainGold(amount: number): void;\n    /**\n     * Serializes the party state for saving.\n     */\n    getSaveData(): Record<string, unknown>;\n}\n\n\n// --- scenes/SceneBoot.d.ts ---\ndeclare class SceneBoot extends ZScene {\n    constructor(engine: IEngineContext);\n    init(): Promise<void>;\n    start(): void;\n}\n\n\n// --- scenes/SceneIntro.d.ts ---\ndeclare class SceneIntro extends ZScene {\n    private introText;\n    private timer;\n    private phase;\n    private isFinished;\n    private readonly FADE_SPEED;\n    private readonly WAIT_TIME;\n    constructor(engine: IEngineContext);\n    init(): Promise<void>;\n    start(): void;\n    update(delta: number): void;\n    private finishIntro;\n}\n\n\n// --- scenes/SceneMap.d.ts ---\ndeclare class SceneMap extends ZScene {\n    currentMap: ZMap | null;\n    private zoomLevel;\n    constructor(engine: IEngineContext);\n    init(params: {\n        mapOrId: number | ZMap;\n        playerX?: number;\n        playerY?: number;\n        direction?: 'down' | 'left' | 'right' | 'up';\n    }): Promise<void>;\n    start(): void;\n    update(): void;\n    stop(): void;\n}\n\n\n// --- scenes/SceneMenu.d.ts ---\n\n\n/**\n * The main menu scene of the game.\n * Displays party status, gold, and command options.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class SceneMenu extends ZScene {\n    private commandWindow;\n    private statusWindow;\n    private goldWindow;\n    private _isClosing;\n    constructor(engine: IEngineContext);\n    init(params: ZMenuParams): Promise<void>;\n    start(): void;\n    update(delta: number): void;\n    private processCommand;\n    private onSave;\n    private closeMenu;\n}\n\n\n// --- scenes/SceneTitle.d.ts ---\ndeclare class SceneTitle extends ZScene {\n    private commandWindow;\n    private isStarting;\n    private hasSave;\n    constructor(engine: IEngineContext);\n    init(): Promise<void>;\n    start(): void;\n    update(): void;\n    private onCommandOk;\n    private continueGame;\n    private startGame;\n}\n\n\n// --- scenes/index.d.ts ---\n\n\n\n\n\n\n// --- sprites/CharacterSprite.d.ts ---\n\n\n\n\n/**\n * Encapsulates the visual representation and state of a character (Player or Event).\n * Implements ZMoveable for integration with MovementProcessor.\n */\ndeclare class CharacterSprite implements ZMoveable {\n    id: string;\n    x: number;\n    y: number;\n    direction: 'down' | 'left' | 'right' | 'up';\n    isMoving: boolean;\n    moveSpeed: number;\n    moveFrequency: number;\n    moveRoute: ZMoveCommand[];\n    moveRouteIndex: number;\n    moveRouteRepeat: boolean;\n    moveRouteSkip: boolean;\n    moveType: 'fixed' | 'random' | 'approach' | 'custom';\n    isThrough: boolean;\n    waitTimer: number;\n    walkAnim: boolean;\n    stepAnim: boolean;\n    directionFix: boolean;\n    transparent: boolean;\n    opacity: number;\n    targetX: number;\n    targetY: number;\n    realX: number;\n    realY: number;\n    container: Container;\n    private _mainSprite;\n    private _textureManager;\n    private _tileSize;\n    private _baseX;\n    private _baseY;\n    private _frameW;\n    private _frameH;\n    private _colsPerChar;\n    private _isDirectional;\n    private _animationFrame;\n    private _animationTimer;\n    preInteractionDirection: 'down' | 'left' | 'right' | 'up' | null;\n    isInteracting: boolean;\n    autoUpdateMovement: boolean;\n    private _boundState;\n    constructor(id: string, textureManager: TextureManager, tileSize: number);\n    bindState(state: ZMoveable): void;\n    private _currentGraphic;\n    /**\n     * Loads and sets the character's graphic.\n     */\n    setGraphic(graphic: ZEventGraphic | null): Promise<void>;\n    private areGraphicsEqual;\n    /**\n     * Updates movement interpolation and animation.\n     */\n    update(delta: number): void;\n    private syncFromState;\n    private _lastFrame;\n    private updateMovement;\n    /**\n     * Updates the container's screen position based on realX and realY.\n     */\n    updateVisualPosition(): void;\n    private updateAnimation;\n    /**\n     * Updates the sprite's texture frame based on direction and animation frame.\n     */\n    refreshTexture(): void;\n    private getDirectionRow;\n    /**\n     * Instantly snaps the character to a grid position.\n     */\n    setGridPosition(x: number, y: number): void;\n    destroy(): void;\n}\n\n\n// --- systems/EntityRenderSystem.d.ts ---\n\n\n\n\n\n\n\n\n/**\n * Manages the rendering of entities (Player and Events) on the map.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class EntityRenderSystem {\n    private playerSystem;\n    private eventSystem;\n    private renderSystem;\n    private textures;\n    private mapManager;\n    private eventBus;\n    container: Container;\n    private tileSize;\n    private playerCharacter;\n    private eventCharacters;\n    constructor(playerSystem: PlayerSystem, eventSystem: EventSystem, renderSystem: RenderSystem, textures: TextureManager, mapManager: MapManager, eventBus: ZEventBus, tileSize: number);\n    /**\n     * Initializes systems and triggers initial entity creation.\n     * Called explicitly by ZEngine.init()\n     */\n    onBoot(): Promise<void>;\n    /**\n     * Loads all events from the current map.\n     */\n    loadEvents(): Promise<void>;\n    forceSetEventPosition(eventId: string, x: number, y: number): void;\n    private onEventStateChanged;\n    private createPlayerCharacter;\n    setVisible(visible: boolean): void;\n    setPlayerGraphic(assetPath: string, x?: number, y?: number, srcW?: number, srcH?: number): Promise<void>;\n    onUpdate(delta: number): void;\n    getEntitySprite(eventId: string): CharacterSprite | null;\n    onDestroy(): void;\n}\n\n\n// --- systems/ErrorSystem.d.ts ---\n\n/**\n * Displays critical errors overlay.\n * Refactored to be a standalone system without dependencies.\n */\ndeclare class ErrorSystem {\n    container: PIXI.Container;\n    private background;\n    private titleText;\n    private messageText;\n    private isVisible;\n    constructor();\n    show(error: Error | string): void;\n    hide(): void;\n    resize(width: number, height: number): void;\n    private updateLayout;\n    onUpdate(): void;\n}\n\n\n// --- systems/EventSystem.d.ts ---\n\n\n\n\n\n\n\n/**\n * Orchestrator for Event Logic.\n * Delegates State to EventManager.\n * Delegates Execution to InterpreterSystem.\n */\ndeclare class EventSystem implements IObstacleProvider {\n    private bus;\n    private mapManager;\n    eventManager: EventManager;\n    interpreterSystem: InterpreterSystem;\n    private playerPos;\n    constructor(physics: IPhysicsSystem, gameState: GameStateManager, bus: ZEventBus, mapManager: MapManager);\n    init(tileSize: number): void;\n    setEngineContext(engine: IEngineContext): void;\n    onBoot(): void;\n    private isTransitioning;\n    onUpdate(delta: number): void;\n    startEvent(event: ZEvent, triggererPos?: {\n        x: number;\n        y: number;\n    }): void;\n    isOccupied(x: number, y: number, options?: {\n        isThrough?: boolean;\n        excludeId?: string;\n    }): boolean;\n    getEventState(eventId: string): ZEventRuntimeState | undefined;\n    getActivePage(event: ZEvent): ZEventPage | null;\n    resumeProcessing(): void;\n    finishMessage(): void;\n    requestMessageAdvance(): void;\n    submitChoice(index: number): void;\n    get isProcessing(): boolean;\n    refreshAllEvents(): void;\n    refreshEvent(event: ZEvent): void;\n    setEventDirection(eventId: string, direction: 'down' | 'left' | 'right' | 'up'): void;\n}\n\n\n// --- systems/GhostSystem.d.ts ---\n\n\n\n\n\n/**\n * Handles Editor visualization (Ghosting, Selection, Event placeholders).\n * Refactored for Manual Dependency Injection.\n */\ndeclare class GhostSystem {\n    private wrapper;\n    private textures;\n    private mapManager;\n    private eventBus;\n    private tileSize;\n    container: Container;\n    private active;\n    private dirty;\n    private position;\n    private selection;\n    private currentTool;\n    private shapeStart;\n    private shapeEnd;\n    private isShape;\n    private activeLayer;\n    private draggingEventId;\n    private selectionBox;\n    private selectedEventPos;\n    constructor(stage: Container, textures: TextureManager, mapManager: MapManager, eventBus: ZEventBus, tileSize: number);\n    private setupListeners;\n    setDirty(): void;\n    onDestroy(): void;\n    update(x: number, y: number, sel: TileSelection | null, tool: ZTool, layer: ZLayer): void;\n    setTool(tool: ZTool): void;\n    updateShape(start: {\n        x: number;\n        y: number;\n    }, end: {\n        x: number;\n        y: number;\n    }, tool: ZTool, sel?: TileSelection | null, layer?: ZLayer): void;\n    setVisible(visible: boolean): void;\n    hide(): void;\n    setSelectionBox(box: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    } | null): void;\n    setSelectedEventPos(pos: {\n        x: number;\n        y: number;\n    } | null): void;\n    private draggingPlayerStart;\n    setDraggingPlayerStart(info: {\n        graphic: string;\n        charX: number;\n        charY: number;\n        srcX?: number;\n        srcY?: number;\n        srcW?: number;\n        srcH?: number;\n    } | null): void;\n    onUpdate(): void;\n    private renderSingleGhost;\n    private renderShape;\n    private renderTileSelectionAt;\n    private renderTileGhostAt;\n    private renderAutotileGhostAt;\n    private renderSingleTileSource;\n    private renderSourceTile;\n    private renderSelectionBox;\n    setDraggingEventId(id: string | null): void;\n    private renderExistingEvents;\n    private renderSelectedEventHighlight;\n    private renderPlayerStartGhost;\n}\n\n\n// --- systems/GridSystem.d.ts ---\n\n/**\n * Renders a visual grid overlay for the editor.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class GridSystem {\n    container: Container;\n    private gridGraphics;\n    private wrapper;\n    private tileSize;\n    private width;\n    private height;\n    private dirty;\n    constructor(stage: Container, tileSize: number);\n    onUpdate(): void;\n    onDestroy(): void;\n    setSize(w: number, h: number): void;\n    getTileCoords(globalEvent: FederatedPointerEvent): {\n        x: number;\n        y: number;\n    };\n    setVisible(visible: boolean): void;\n}\n\n\n// --- systems/InterpreterSystem.d.ts ---\n\n\n/**\n * Manages the execution of event interpreters (active and parallel).\n * Extracts \"Logical Execution\" from EventSystem.\n */\ndeclare class InterpreterSystem {\n    private bus;\n    private engine;\n    isProcessing: boolean;\n    activeInterpreter: ZEventInterpreter | null;\n    parallelInterpreters: ZEventInterpreter[];\n    constructor(bus: ZEventBus);\n    setEngineContext(engine: IEngineContext): void;\n    startInterpreter(page: ZEventPage, eventId: string): void;\n    addParallelInterpreter(page: ZEventPage, eventId: string): void;\n    update(): void;\n    private executeInterpreterLoop;\n    resumeProcessing(): void;\n    finishMessage(): void;\n    submitChoice(index: number): void;\n    onMoveRouteFinished(eventId: string): void;\n    requestMessageAdvance(): void;\n    private terminateActiveInterpreter;\n    private executeCommand;\n}\n\n\n// --- systems/MenuSystem.d.ts ---\ndeclare class MenuSystem {\n    private eventBus;\n    private input;\n    private scenes;\n    constructor(eventBus: ZEventBus, input: InputManager, scenes: SceneManager);\n    onBoot(): void;\n    private callMenu;\n}\n\n\n// --- systems/MessageSystem.d.ts ---\n\n\n\n\n\n\n/**\n * Manages the dialogue and choice window UI.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class MessageSystem {\n    private inputManager;\n    private eventBus;\n    private textureManager;\n    private eventSystem;\n    private entityRenderSystem;\n    container: Container;\n    private windowMessage;\n    private windowChoice;\n    private isVisible;\n    private isClosing;\n    private isChoiceVisible;\n    private choices;\n    private selectedChoiceIndex;\n    private messageStyle;\n    private messageTargetId;\n    private boxWidth;\n    private boxHeight;\n    constructor(inputManager: InputManager, eventBus: ZEventBus, textureManager: TextureManager, eventSystem: EventSystem, entityRenderSystem: EntityRenderSystem);\n    /**\n     * Async initialization: Loads assets and builds UI windows.\n     */\n    init(): Promise<void>;\n    private setupListeners;\n    onUpdate(): void;\n    private updateChoiceSelection;\n    private show;\n    private showChoices;\n    private close;\n    private finalizeClose;\n    resize(width: number, height: number): void;\n    private updateBubblePosition;\n    onDestroy(): void;\n}\n\n\n// --- systems/PhysicsSystem.d.ts ---\n\n\n\n/**\n * Handles collision detection and movement logic.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class PhysicsSystem implements IPhysicsSystem {\n    private mapManager;\n    private tilesetManager;\n    private obstacleProviders;\n    constructor(mapManager: MapManager, tilesetManager: TilesetManager);\n    registerProvider(provider: IObstacleProvider): void;\n    isPassable(x: number, y: number, options?: {\n        isThrough?: boolean;\n        skipPlayer?: boolean;\n    }): boolean;\n    checkPassage(x: number, y: number, targetX: number, targetY: number, options?: {\n        isThrough?: boolean;\n        skipPlayer?: boolean;\n    }): boolean;\n    private isDirectionBlocked;\n}\n\n\n// --- systems/PlayerSystem.d.ts ---\n\n\n\n\n\n\n/**\n * Handles Player controls, movement, and interaction.\n * Refactored for Manual Dependency Injection.\n */\ndeclare class PlayerSystem implements ZMoveable, IObstacleProvider {\n    private input;\n    private physicsSystem;\n    private bus;\n    private mapManager;\n    private movementProcessor;\n    private tileSize;\n    readonly id = \"PLAYER\";\n    x: number;\n    y: number;\n    direction: 'down' | 'left' | 'right' | 'up';\n    isMoving: boolean;\n    moveSpeed: number;\n    moveFrequency: number;\n    moveRoute: ZMoveCommand[];\n    moveRouteIndex: number;\n    moveRouteRepeat: boolean;\n    moveRouteSkip: boolean;\n    moveType: 'fixed' | 'random' | 'approach' | 'custom';\n    isThrough: boolean;\n    waitTimer: number;\n    walkAnim: boolean;\n    stepAnim: boolean;\n    directionFix: boolean;\n    transparent: boolean;\n    opacity: number;\n    targetX: number;\n    targetY: number;\n    realX: number;\n    realY: number;\n    private isBooted;\n    private blockState;\n    private get isInputBlocked();\n    constructor(input: InputManager, physics: IPhysicsSystem, bus: ZEventBus, mapManager: MapManager);\n    /**\n     * Called by ZEngine during initialization phase.\n     */\n    init(tileSize: number): void;\n    private setupListeners;\n    resetPositionToStart(): void;\n    onUpdate(delta: number): void;\n    private updateMoveRoute;\n    private updateInput;\n    private updateMovement;\n    snapToGrid(): void;\n    isOccupied(x: number, y: number, options?: {\n        isThrough?: boolean;\n        skipPlayer?: boolean;\n        excludeId?: string;\n    }): boolean;\n    getSaveData(): any;\n    loadSaveData(data: any): void;\n}\n\n\n// --- systems/RenderSystem.d.ts ---\n\n\n\n\n\n/**\n * Handles the rendering of the static Tilemap (Ground, Walls, Decorations).\n * Refactored for Manual Dependency Injection.\n */\ndeclare class RenderSystem {\n    private wrapper;\n    private textures;\n    private mapManager;\n    private tilesetManager;\n    tileSize: number;\n    private layers;\n    private eventMarkersLayer;\n    private tileContainers;\n    private fullRenderDirty;\n    private tileUpdates;\n    private playerStartMarker;\n    private showPlayerStart;\n    private playerStartX;\n    private playerStartY;\n    private playerStartGraphic;\n    private playerStartCharX;\n    private playerStartCharY;\n    private playerStartSrcX?;\n    private playerStartSrcY?;\n    private playerStartSrcW?;\n    private playerStartSrcH?;\n    private eventMarkers;\n    private showEventMarkers;\n    constructor(stage: PIXI.Container, textures: TextureManager, mapManager: MapManager, tilesetManager: TilesetManager, tileSize: number);\n    private initLayers;\n    getLayerContainer(layer: ZLayer): PIXI.Container;\n    getEventMarkersContainer(): PIXI.Container;\n    refresh(): void;\n    onUpdate(): void;\n    onDestroy(): void;\n    requestTileUpdate(x: number, y: number, tiles: TileSelection[], layer: ZLayer): void;\n    setMap(mapData: ZMap): void;\n    private performDrawTile;\n    clearTileAt(x: number, y: number, layer: ZLayer): void;\n    private performFullRender;\n    setEventMarkersVisible(visible: boolean): void;\n    setPlayerStartMarker(x: number, y: number, graphicPath: string, charX?: number, charY?: number, srcX?: number, srcY?: number, srcW?: number, srcH?: number): void;\n    private drawPlayerStartMarker;\n    hidePlayerStartMarker(): void;\n    updateLayerDimming(activeLayer: ZLayer | null, focusOnly?: boolean): void;\n    IsMapLoaded(): boolean;\n    private renderAutotile;\n    private resetLayers;\n    private createEmptyContainerStructure;\n}\n\n\n// --- systems/TransitionSystem.d.ts ---\n\n/**\n * Handles global screen transitions (Fade In/Out).\n * Refactored to be a standalone system without dependencies.\n */\ndeclare class TransitionSystem {\n    container: Graphics;\n    private _isFading;\n    private fadeTarget;\n    private fadeDuration;\n    private fadeTimer;\n    private resolvePromise;\n    get isTransitioning(): boolean;\n    constructor();\n    fadeOut(duration?: number): Promise<void>;\n    fadeIn(duration?: number): Promise<void>;\n    private startFade;\n    resize(width: number, height: number): void;\n    onUpdate(delta: number): void;\n}\n\n\n// --- systems/index.d.ts ---\n\n\n\n\n\n\n\n\n\n\n\n// --- types/index.d.ts ---\ndeclare interface ZDatabaseEntry {\n    id: number;\n    name: string;\n    description?: string;\n    note?: string;\n}\ndeclare enum ZTraitCode {\n    ElementRate = 11,\n    DebuffRate = 12,\n    StateRate = 13,\n    StateResist = 14,\n    Param = 21,\n    XParam = 22,\n    SParam = 23,\n    AttackElement = 31,\n    AttackState = 32,\n    AttackSpeed = 33,\n    AttackTimes = 34,\n    AddSkillType = 41,\n    SealSkillType = 42,\n    AddSkill = 43,\n    SealSkill = 44,\n    EquipWeapon = 51,\n    EquipArmor = 52,\n    LockEquip = 53,\n    SealEquip = 54,\n    SlotType = 55,\n    ActionTimes = 61,\n    SpecialFlag = 62,\n    CollapseEffect = 63,\n    PartyAbility = 64\n}\ndeclare interface ZTrait {\n    code: ZTraitCode;\n    dataId: number;\n    value: number;\n}\ndeclare interface ZClassLearning {\n    level: number;\n    skillId: number;\n}\ndeclare interface ZClass extends ZDatabaseEntry {\n    nickname?: string;\n    params: number[];\n    traits: ZTrait[];\n    learnings: ZClassLearning[];\n    expCurve: number;\n    expParams?: {\n        base: number;\n        extra: number;\n        acceleration: number;\n    };\n}\ndeclare interface ZSkillEffect {\n    code: number;\n    dataId: number;\n    value1: number;\n    value2: number;\n}\ndeclare interface ZSkill extends ZDatabaseEntry {\n    icon?: string;\n    mpCost: number;\n    tpCost: number;\n    scope: number;\n    occasion: number;\n    hitType: number;\n    elementId?: number;\n    stypeId?: number;\n    effects: ZSkillEffect[];\n}\ndeclare interface ZItem extends ZDatabaseEntry {\n    icon?: string;\n    price: number;\n    consumable: boolean;\n    target: number;\n    itypeId?: number;\n    effects: ZSkillEffect[];\n}\ndeclare interface ZWeapon extends ZDatabaseEntry {\n    icon?: string;\n    price: number;\n    params: number[];\n    wtypeId?: number;\n    description?: string;\n    animationId?: number;\n}\ndeclare interface ZArmor extends ZDatabaseEntry {\n    icon?: string;\n    price: number;\n    params: number[];\n    etypeId?: number;\n    description?: string;\n}\ndeclare interface ZEnemyDropItem {\n    itemId: number;\n    kind: number;\n    denominator: number;\n}\ndeclare interface ZEnemyAction {\n    skillId: number;\n    conditionType: number;\n    conditionParam1: number;\n    conditionParam2: number;\n    rating: number;\n}\ndeclare interface ZEnemy extends ZDatabaseEntry {\n    mhp: number;\n    mmp: number;\n    atk: number;\n    def: number;\n    mat: number;\n    mdf: number;\n    agi: number;\n    luk: number;\n    exp: number;\n    gold: number;\n    battlerName?: string;\n    dropItems: ZEnemyDropItem[];\n    actions: ZEnemyAction[];\n}\ndeclare interface ZActor extends ZDatabaseEntry {\n    nickname: string;\n    classId: number;\n    initialLevel: number;\n    maxLevel: number;\n    profile: string;\n    face: string;\n    faceX: number;\n    faceY: number;\n    faceSrcX?: number;\n    faceSrcY?: number;\n    faceSrcW?: number;\n    faceSrcH?: number;\n    character: string;\n    characterX: number;\n    characterY: number;\n    characterSrcX?: number;\n    characterSrcY?: number;\n    characterSrcW?: number;\n    characterSrcH?: number;\n    baseParams: number[];\n    traits: ZTrait[];\n}\ndeclare interface ZTerm {\n    id: number;\n    name: string;\n}\ndeclare interface ZTerms {\n    elements: ZTerm[];\n    weaponTypes: ZTerm[];\n    armorTypes: ZTerm[];\n    skillTypes: ZTerm[];\n    itemTypes: ZTerm[];\n}\ndeclare interface ZCommonEvent extends ZDatabaseEntry {\n    trigger: number;\n    switchId: number;\n    list: ZEventCommand[];\n}\ndeclare interface ZAudioConfig {\n    name: string;\n    volume: number;\n    pitch: number;\n}\ndeclare interface ZSystemData {\n    switches: string[];\n    variables: string[];\n    startMapId: number;\n    startX: number;\n    startY: number;\n    screenWidth: number;\n    screenHeight: number;\n    screenZoom: number;\n    projectName: string;\n    version: string;\n    startingParty: number[];\n    sounds: {\n        cursor: ZAudioConfig;\n        ok: ZAudioConfig;\n        cancel: ZAudioConfig;\n        buzzer: ZAudioConfig;\n        save: ZAudioConfig;\n        load: ZAudioConfig;\n        titleBGM: ZAudioConfig;\n        battleBGM: ZAudioConfig;\n    };\n}\ndeclare interface TileSelection {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    tilesetId: string;\n    isAutotile: boolean;\n    isWall?: boolean;\n    pattern?: (TileSelection | null)[][];\n    structure?: Partial<Record<ZLayer, (TileSelection[] | null)[][]>>;\n    isMultiLayer?: boolean;\n    pixelX?: number;\n    pixelY?: number;\n    pixelW?: number;\n    pixelH?: number;\n}\ndeclare interface ZEventGraphic {\n    assetId: string;\n    group: 'tile' | 'character';\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    srcX?: number;\n    srcY?: number;\n    srcW?: number;\n    srcH?: number;\n    divW?: number;\n    divH?: number;\n}\ndeclare interface ZEvent {\n    id: string;\n    name: string;\n    x: number;\n    y: number;\n    isThrough?: boolean;\n    pages: ZEventPage[];\n}\ndeclare interface ZEventPage {\n    id: string;\n    conditions: ZEventCondition;\n    graphic: ZEventGraphic | null;\n    trigger: ZEventTrigger;\n    moveType: 'fixed' | 'random' | 'approach' | 'custom';\n    moveSpeed: number;\n    moveFrequency: number;\n    moveRoute: ZMoveCommand[];\n    moveRouteRepeat: boolean;\n    moveRouteSkip: boolean;\n    moveRouteIndex?: number;\n    isThrough?: boolean;\n    options: ZEventOptions;\n    list: ZEventCommand[];\n}\ndeclare interface ZEventCondition {\n    switch1Id?: string;\n    switch2Id?: string;\n    variableId?: string;\n    variableValue?: number;\n    variableOp?: number;\n    selfSwitchCh?: string;\n    item?: string;\n    actor?: string;\n}\ndeclare enum ZEventTrigger {\n    Action = 0,\n    PlayerTouch = 1,\n    EventTouch = 2,\n    Autorun = 3,\n    Parallel = 4\n}\ndeclare interface ZEventOptions {\n    walkAnim: boolean;\n    stepAnim: boolean;\n    directionFix: boolean;\n    through: boolean;\n}\ndeclare interface ZEventCommand {\n    code: number;\n    parameters: unknown[];\n    indent?: number;\n}\ndeclare enum ZMoveCode {\n    MOVE_DOWN = \"MOVE_DOWN\",\n    MOVE_LEFT = \"MOVE_LEFT\",\n    MOVE_RIGHT = \"MOVE_RIGHT\",\n    MOVE_UP = \"MOVE_UP\",\n    MOVE_LOWER_LEFT = \"MOVE_LOWER_LEFT\",\n    MOVE_LOWER_RIGHT = \"MOVE_LOWER_RIGHT\",\n    MOVE_UPPER_LEFT = \"MOVE_UPPER_LEFT\",\n    MOVE_UPPER_RIGHT = \"MOVE_UPPER_RIGHT\",\n    MOVE_RANDOM = \"MOVE_RANDOM\",\n    MOVE_TOWARD_PLAYER = \"MOVE_TOWARD_PLAYER\",\n    MOVE_AWAY_PLAYER = \"MOVE_AWAY_PLAYER\",\n    STEP_FORWARD = \"STEP_FORWARD\",\n    STEP_BACKWARD = \"STEP_BACKWARD\",\n    JUMP = \"JUMP\",\n    WAIT = \"WAIT\",\n    TURN_DOWN = \"TURN_DOWN\",\n    TURN_LEFT = \"TURN_LEFT\",\n    TURN_RIGHT = \"TURN_RIGHT\",\n    TURN_UP = \"TURN_UP\",\n    TURN_90_RIGHT = \"TURN_90_RIGHT\",\n    TURN_90_LEFT = \"TURN_90_LEFT\",\n    TURN_180 = \"TURN_180\",\n    TURN_90_RIGHT_LEFT = \"TURN_90_RIGHT_LEFT\",\n    TURN_RANDOM = \"TURN_RANDOM\",\n    TURN_TOWARD_PLAYER = \"TURN_TOWARD_PLAYER\",\n    TURN_AWAY_PLAYER = \"TURN_AWAY_PLAYER\",\n    SPEED = \"SPEED\",\n    FREQUENCY = \"FREQUENCY\",\n    WALK_ANIM_ON = \"WALK_ANIM_ON\",\n    WALK_ANIM_OFF = \"WALK_ANIM_OFF\",\n    STEP_ANIM_ON = \"STEP_ANIM_ON\",\n    STEP_ANIM_OFF = \"STEP_ANIM_OFF\",\n    DIR_FIX_ON = \"DIR_FIX_ON\",\n    DIR_FIX_OFF = \"DIR_FIX_OFF\",\n    THROUGH_ON = \"THROUGH_ON\",\n    THROUGH_OFF = \"THROUGH_OFF\",\n    TRANSPARENT_ON = \"TRANSPARENT_ON\",\n    TRANSPARENT_OFF = \"TRANSPARENT_OFF\",\n    CHANGE_GRAPHIC = \"CHANGE_GRAPHIC\",\n    CHANGE_OPACITY = \"CHANGE_OPACITY\",\n    CHANGE_BLEND = \"CHANGE_BLEND\",\n    PLAY_SE = \"PLAY_SE\",\n    SCRIPT = \"SCRIPT\"\n}\ndeclare interface ZMoveCommand {\n    code: ZMoveCode | string;\n    params?: unknown[];\n}\ndeclare interface ZMoveable {\n    id: string;\n    x: number;\n    y: number;\n    direction: 'down' | 'left' | 'right' | 'up';\n    isMoving: boolean;\n    moveSpeed: number;\n    moveFrequency: number;\n    moveRoute: ZMoveCommand[];\n    moveRouteIndex: number;\n    moveRouteRepeat: boolean;\n    moveRouteSkip: boolean;\n    moveType: 'fixed' | 'random' | 'approach' | 'custom';\n    isThrough: boolean;\n    waitTimer: number;\n    startX?: number;\n    startY?: number;\n    targetX?: number;\n    targetY?: number;\n    realX?: number;\n    realY?: number;\n    walkAnim?: boolean;\n    stepAnim?: boolean;\n    directionFix?: boolean;\n    opacity?: number;\n    transparent?: boolean;\n}\ndeclare interface ZEventRuntimeState extends ZMoveable {\n    eventId: string;\n    realX: number;\n    realY: number;\n}\ndeclare interface ZMap {\n    id: number;\n    name: string;\n    width: number;\n    height: number;\n    tileWidth?: number;\n    tileHeight?: number;\n    layers: Record<ZLayer, {\n        icon: string;\n        data: (TileSelection[] | null)[][];\n        index: number;\n    }>;\n    events: ZEvent[];\n    tilesetConfig: Record<string, string>;\n    displayName?: string;\n    bgm?: ZAudioConfig;\n    bgs?: ZAudioConfig;\n    parallax?: {\n        name: string;\n        loopX: boolean;\n        loopY: boolean;\n        scrollX: number;\n        scrollY: number;\n    };\n    note?: string;\n    disableAutoshadow?: boolean;\n}\ndeclare interface ZMapInfo {\n    id: number;\n    name: string;\n    parentId: number;\n    order: number;\n    expanded?: boolean;\n    isFolder?: boolean;\n}\ndeclare type TileCoords = {\n    x: number;\n    y: number;\n};\ndeclare enum ZTool {\n    brush = \"brush\",\n    eraser = \"eraser\",\n    bucket = \"bucket\",\n    event = \"event\",\n    circle = \"circle\",\n    rectangle = \"rectangle\",\n    select = \"select\"\n}\ndeclare enum ZLayer {\n    ground = \"ground\",\n    walls = \"walls\",\n    decoration = \"decoration\",\n    highest = \"highest\"\n}\ndeclare interface IconMap {\n    uiX: number;\n    uiY: number;\n    ox: number;\n    oy: number;\n    w: number;\n    h: number;\n    tilesetId: string;\n    url: string;\n    isAuto: boolean;\n}\ndeclare interface TileConfig {\n    isSolid: boolean;\n    isHighPriority: boolean;\n    dirBlock: number;\n    collisionMask?: boolean[];\n    sortYOffset?: number;\n}\ndeclare type TilesetConfig = Record<string, TileConfig>;\ndeclare enum ZCommandCode {\n    ShowMessage = 101,\n    ShowChoices = 102,\n    ConditionalBranch = 111,\n    Loop = 112,\n    BreakLoop = 113,\n    ControlSwitch = 121,\n    ControlVariable = 122,\n    ControlSelfSwitch = 123,\n    TransferPlayer = 201,\n    SetMoveRoute = 205,\n    ShowAnimation = 212,\n    Else = 411,\n    EndBranch = 412,\n    When = 402,\n    EndChoices = 404,\n    SetEventDirection = 213,\n    SetEventGraphic = 214,\n    Wait = 230,\n    PlayBGM = 241,\n    FadeOutBGM = 242,\n    PlayBGS = 245,\n    FadeOutBGS = 246,\n    PlayME = 249,\n    PlaySE = 250,\n    StopSE = 251,\n    ShowMakeText = 1011,\n    ShowScrollingText = 105,\n    ControlTimer = 124,\n    GetLocationInfo = 202,\n    ScrollMap = 204,\n    ShowBalloonIcon = 215,\n    EraseEvent = 216,\n    ShowPicture = 231,\n    MovePicture = 232,\n    RotatePicture = 233,\n    TintPicture = 234,\n    ErasePicture = 235\n}\ndeclare type ZCommandResult = 'continue' | 'wait' | 'stop';\ndeclare interface IEngineContext {\n    app: Application;\n    systemData: ZSystemData | null;\n    textures: TextureManager;\n    tilesets: TilesetManager;\n    renderer: RenderSystem;\n    player: PlayerSystem;\n    entities: EntityRenderSystem;\n    grid: GridSystem;\n    ghost: GhostSystem;\n    scenes: SceneManager;\n    audio: AudioManager;\n    input: InputManager;\n    gameState: GameStateManager;\n    eventBus: ZEventBus;\n    map: MapManager;\n    dataProvider: ZDataProvider | null;\n    transitions: TransitionSystem;\n    save: SaveManager;\n    config: {\n        mode: 'play' | 'edit';\n    };\n}\ndeclare interface ZEventInterpreter {\n    list: ZEventCommand[];\n    index: number;\n    eventId: string;\n    waitCount?: number;\n    waitingForMoveEventId?: string | null;\n    isWaitingForMessage?: boolean;\n    pendingChoice?: number;\n}\ndeclare interface ZCommandProcessor {\n    (params: unknown[], interpreter: ZEventInterpreter, services: IEngineContext): ZCommandResult;\n}\ndeclare interface ZTileDelta {\n    x: number;\n    y: number;\n    layer: ZLayer;\n    oldStack: TileSelection[] | null;\n    newStack: TileSelection[] | null;\n}\ndeclare interface ZHistoryEntry {\n    id: string;\n    label: string;\n    deltas: ZTileDelta[];\n}\ndeclare interface GameSaveFile {\n    header: {\n        timestamp: number;\n        playtime: number;\n        version: string;\n    };\n    player: {\n        x: number;\n        y: number;\n        direction: string;\n        mapId: number;\n        transparent: boolean;\n    };\n    system: {\n        switches: Record<number, boolean>;\n        variables: Record<number, number>;\n        selfSwitches: Record<string, boolean>;\n        party: any;\n        actors: any;\n    };\n}\ndeclare interface ZDataProvider {\n    getMap(id: number): Promise<ZMap | null>;\n    getTilesetConfigs(): Promise<Record<string, TilesetConfig>>;\n    getSystemData(): Promise<ZSystemData>;\n    getTilesetUrl(slotId: string): string;\n    setTileAt(x: number, y: number, tile: TileSelection | null, isStacking: boolean, layer: ZLayer): void;\n    resolveAssetUrl(path: string): string;\n    saveGame(slotId: number, data: GameSaveFile): Promise<void>;\n    loadGame(slotId: number): Promise<GameSaveFile | null>;\n    doesSaveExist(slotId: number): Promise<boolean>;\n}\ndeclare enum ZEngineSignal {\n    PlayerMoved = \"player:moved\",\n    MapWillLoad = \"map:will-load\",\n    MapLoaded = \"map:loaded\",\n    MapLoadFailed = \"map:load-failed\",\n    EventTriggered = \"event:triggered\",\n    InteractionRequested = \"interaction:requested\",\n    ShowMessage = \"ui:show-message\",\n    ShowChoices = \"ui:show-choices\",\n    ChoiceSelected = \"ui:choice-selected\",\n    MessageClosed = \"ui:message-closed\",\n    MessageCloseDirective = \"ui:message-close-directive\",\n    GameStateChanged = \"state:changed\",\n    EventInternalStateChanged = \"event:internal-state\",\n    EventExecutionStarted = \"event:execution-started\",\n    EventExecutionFinished = \"event:execution-finished\",\n    MoveRouteFinished = \"event:move-route-finished\",\n    MenuRequested = \"ui:menu-requested\",\n    MenuClosed = \"ui:menu-closed\",\n    SceneTransitionStarted = \"scene:transition-started\",\n    SceneTransitionFinished = \"scene:transition-finished\"\n}\ndeclare interface ZMenuParams {\n    mapOrId: ZMap | number;\n    playerX: number;\n    playerY: number;\n    direction: string;\n}\ndeclare interface ZSignalData {\n    [ZEngineSignal.PlayerMoved]: {\n        x: number;\n        y: number;\n        prevX: number;\n        prevY: number;\n    };\n    [ZEngineSignal.MapWillLoad]: {\n        mapId: number;\n        map: ZMap;\n    };\n    [ZEngineSignal.MapLoaded]: {\n        mapId: number;\n        map: ZMap;\n    };\n    [ZEngineSignal.MapLoadFailed]: {\n        mapId: number;\n        error: Error;\n    };\n    [ZEngineSignal.EventTriggered]: {\n        event: ZEvent;\n        trigger: ZEventTrigger;\n    };\n    [ZEngineSignal.InteractionRequested]: {\n        x: number;\n        y: number;\n    };\n    [ZEngineSignal.ShowMessage]: {\n        text: string;\n        style?: number;\n        target?: number | string;\n    };\n    [ZEngineSignal.ShowChoices]: {\n        choices: string[];\n        style?: number;\n        target?: number | string;\n    };\n    [ZEngineSignal.ChoiceSelected]: {\n        index: number;\n    };\n    [ZEngineSignal.MessageClosed]: Record<string, never>;\n    [ZEngineSignal.MessageCloseDirective]: Record<string, never>;\n    [ZEngineSignal.GameStateChanged]: {\n        type: 'switch' | 'variable' | 'load' | 'new';\n        id?: number;\n        value?: boolean | number;\n    };\n    [ZEngineSignal.EventInternalStateChanged]: {\n        eventId: string;\n        direction?: 'down' | 'left' | 'right' | 'up';\n        graphic?: ZEventGraphic | null;\n        moveType?: 'fixed' | 'random' | 'approach' | 'custom';\n        moveSpeed?: number;\n        moveFrequency?: number;\n        moveRoute?: ZMoveCommand[];\n        moveRouteRepeat?: boolean;\n        moveRouteSkip?: boolean;\n        isThrough?: boolean;\n        walkAnim?: boolean;\n        stepAnim?: boolean;\n        directionFix?: boolean;\n        trigger?: ZEventTrigger;\n        opacity?: number;\n        transparent?: boolean;\n    };\n    [ZEngineSignal.EventExecutionStarted]: {\n        eventId: string;\n        triggererPos?: {\n            x: number;\n            y: number;\n        };\n    };\n    [ZEngineSignal.EventExecutionFinished]: {\n        eventId: string;\n    };\n    [ZEngineSignal.MoveRouteFinished]: {\n        eventId: string;\n    };\n    [ZEngineSignal.MenuRequested]: ZMenuParams;\n    [ZEngineSignal.MenuClosed]: Record<string, never>;\n    [ZEngineSignal.SceneTransitionStarted]: Record<string, never>;\n    [ZEngineSignal.SceneTransitionFinished]: Record<string, never>;\n}\ndeclare enum ZInputAction {\n    OK = \"OK\",\n    CANCEL = \"CANCEL\",\n    MENU = \"MENU\",\n    UP = \"UP\",\n    DOWN = \"DOWN\",\n    LEFT = \"LEFT\",\n    RIGHT = \"RIGHT\",\n    RUN = \"RUN\",\n    DEBUG = \"DEBUG\",\n    NOCLIP = \"NOCLIP\"\n}\ndeclare interface ZInputMap {\n    keyboard: Record<string, ZInputAction>;\n    gamepad: Record<number, ZInputAction>;\n}\n\n\n// --- ui/Window_Base.d.ts ---\ndeclare class Window_Base extends Container {\n    protected _width: number;\n    protected _height: number;\n    protected _padding: number;\n    protected _backSprite: Sprite | TilingSprite | null;\n    protected _frameContainer: Container;\n    private _tl;\n    private _tr;\n    private _bl;\n    private _br;\n    private _top;\n    private _bottom;\n    private _left;\n    private _right;\n    protected _contents: Container;\n    protected _mask: Graphics;\n    private _openness;\n    private _opening;\n    private _closing;\n    private _cornerSize;\n    constructor(x: number, y: number, width: number, height: number);\n    set windowSkin(texture: Texture);\n    update(): void;\n    open(): void;\n    close(): void;\n    isOpen(): boolean;\n    isClosed(): boolean;\n    get contents(): Container;\n    get innerWidth(): number;\n    get innerHeight(): number;\n    refresh(): void;\n    resize(width: number, height: number): void;\n}\n\n\n// --- ui/Window_Choice.d.ts ---\ndeclare class Window_Choice extends Window_Base {\n    protected _choices: string[];\n    protected _index: number;\n    protected _itemHeight: number;\n    protected _cursor: Graphics;\n    protected _itemContainer: Container;\n    constructor(x: number, y: number, width: number, height: number);\n    setChoices(choices: string[]): void;\n    select(index: number): void;\n    get index(): number;\n    protected refreshItems(): void;\n    private _input;\n    setInput(input: InputManager): void;\n    update(): void;\n    private processCursorMove;\n    private updateCursor;\n}\n\n\n// --- ui/Window_Gold.d.ts ---\n\n/**\n * Displays the current amount of party gold.\n */\ndeclare class Window_Gold extends Window_Base {\n    private _gold;\n    constructor(x: number, y: number, width: number, height: number);\n    /**\n     * Updates the gold amount and refreshes the window content.\n     */\n    setGold(gold: number): void;\n    refresh(): void;\n}\n\n\n// --- ui/Window_MenuCommand.d.ts ---\ndeclare class Window_MenuCommand extends Window_Choice {\n    constructor(x: number, y: number, width: number, height: number);\n}\n\n\n// --- ui/Window_MenuStatus.d.ts ---\n\n\n/**\n * Displays the status of party members in the main menu.\n */\ndeclare class Window_MenuStatus extends Window_Base {\n    private _actors;\n    constructor(x: number, y: number, width: number, height: number);\n    /**\n     * Updates the list of actors and refreshes the window content.\n     */\n    setActors(actors: Game_Actor[]): void;\n    refresh(): void;\n    private drawActorStatus;\n}\n\n\n// --- ui/Window_Message.d.ts ---\ndeclare class Window_Message extends Window_Base {\n    private _textObject;\n    constructor(x: number, y: number, width: number, height: number);\n    setText(text: string): void;\n    refresh(): void;\n    setBubbleMode(enabled: boolean): void;\n}\n\n\n// --- ui/Window_TitleCommand.d.ts ---\ndeclare class Window_TitleCommand extends Window_Choice {\n    protected refreshItems(): void;\n}\n\n\n// --- utils/AutotileSolver.d.ts ---\ndeclare class AutotileSolver {\n    static isSameTile(x: number, y: number, mapWidth: number, mapHeight: number, layer: ZLayer, sel: TileSelection, mapData: ZMap | null, stackIndex?: number, customCheck?: (x: number, y: number) => boolean): boolean;\n    static getQuadrantOffset(x: number, y: number, qx: number, qy: number, tileSize: number, sel: TileSelection, layer: ZLayer, mapData: ZMap, mapWidth: number, mapHeight: number, stackIndex?: number, customCheck?: (x: number, y: number) => boolean): {\n        x: number;\n        y: number;\n    };\n}\n\n\n// --- utils/SpriteUtils.d.ts ---\ndeclare class SpriteUtils {\n    /**\n     * Creates a sprite for an Event or Player.\n     * Handles both Tile graphics and Character Sheet graphics.\n     */\n    static getFrameRect(graphic: ZEventGraphic, tex: {\n        width: number;\n        height: number;\n    }): {\n        frameW: number;\n        frameH: number;\n        divW: number;\n        divH: number;\n        fx: number;\n        fy: number;\n    };\n    static getIdleFrameIndex(divW: number): number;\n    static createEventSprite(graphic: ZEventGraphic, textureManager: TextureManager, tileSize: number, isEditor?: boolean): PIXI.Sprite | null;\n}\n\n\n// --- utils/ZLogger.d.ts ---\ndeclare class ZLogger {\n    private tag;\n    private isDebugging;\n    log: (...messages: unknown[]) => void;\n    error: (...messages: unknown[]) => void;\n    warn: (...messages: unknown[]) => void;\n    info: (...messages: unknown[]) => void;\n    debug: (...messages: unknown[]) => void;\n    constructor(tag: string);\n    with(tag: string): ZLogger;\n}\ndeclare const _default: ZLogger;\n\n\n// --- utils/index.d.ts ---\n\n\n\n\n\n// --- utils/pixi.d.ts ---\n\n\n\n// --- Global Aliases (Mock) ---\ndeclare const MONACO_TEST_V4: string;\ndeclare const Game_System: any;\ndeclare const Game_Map: any;\ndeclare const Game_Player: any;\ndeclare const Game_Actors: any;\ndeclare const Game_Party: any;\ndeclare const Game_Temp: any;\ndeclare const Game_Timer: any;\ndeclare const Game_Switches: any;\ndeclare const Game_Variables: any;\ndeclare const Game_SelfSwitches: any;\ndeclare const SceneManager: any;\ndeclare const AudioManager: any;\ndeclare const Input: any;\ndeclare const TouchInput: any;\ndeclare const Graphics: any;\ndeclare const Z_ENGINE: ZEngine;\n\n// --- PIXI Aliases (Linking global names to PIXI namespace) ---\ndeclare type Application = PIXI.Application;\ndeclare type Container = PIXI.Container;\ndeclare type Sprite = PIXI.Sprite;\ndeclare type Graphics = PIXI.Graphics;\ndeclare type Texture = PIXI.Texture;\ndeclare type TilingSprite = PIXI.TilingSprite;\ndeclare type AnimatedSprite = PIXI.AnimatedSprite;\ndeclare type Text = PIXI.Text;\ndeclare type Point = PIXI.Point;\ndeclare type Rectangle = PIXI.Rectangle;\ndeclare type FederatedPointerEvent = PIXI.FederatedPointerEvent;\n\n\n";
